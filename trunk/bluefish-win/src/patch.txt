1,252c1,248
< /* Bluefish HTML Editor
<  * about.c - the About dialog
<  *
<  * Copyright (C) 2004 Eugene Morenko(More) more@irpin.com
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< #include <gdk/gdk.h>
< #include <gtk/gtk.h>
< #include <stdio.h>
< #include <stdlib.h>
< #include <string.h>
< #include <unistd.h>   /* getopt() */
< 
< #include "config.h"
< 
< #include "bluefish.h"
< #include "about.h"
< #include "gtk_easy.h"
< 
< static GtkWidget *info;
< 
< static void add_page(GtkNotebook * notebook, const gchar * name, const gchar * buf,
< 					 gboolean hscrolling) {
< 	GtkWidget *textview, *label, *sw;
< 	label = gtk_label_new(name);
< 	sw = textview_buffer_in_scrolwin(&textview, -1, 200, buf, GTK_WRAP_WORD);
< 	gtk_text_view_set_editable(GTK_TEXT_VIEW(textview), FALSE);
< 	gtk_text_view_set_cursor_visible (GTK_TEXT_VIEW (textview), FALSE);
< 	gtk_notebook_append_page(notebook, sw, label);
< }
< 
< static void about_dialog_close_lcb(GtkObject *object,GtkWidget *win) {
< 	window_destroy(win);
< }
< 
< void about_dialog_create(gpointer * data, guint * callback_action, GtkWidget * widget) {
< 	GtkWidget *vbox, *vbox2, *hbox;
< 	GtkWidget *notebook;
< 	GtkWidget *info_ok_button;
< 	GdkColor color;
< 	gchar *I1, *config_options;
< 	const gchar *INFO = _("Bluefish is an editor for experienced web designers and programmers. It supports many programming and markup languages, but focuses on editing dynamic and interactive websites. Bluefish is an open source development project, released under the GPL license.\n\nFor more information, visit the Bluefish Website at http://bluefish.openoffice.nl/\n\nThis version of bluefish was compiled with the following options:\n");
< 	const gchar *AUTHORS = _("Project leader:\n\
< 	                         Olivier Sessink <olivier@bluefish.openoffice.nl>\n\
< 	                         \n\
< 	                         Developers for this release:\n\
< 	                         Olivier Sessink\n\
< 	                         <olivier@bluefish.openoffice.nl>\n\
< 	                         Jim Hayward\n\
< 	                         <jim@bluefish.openoffice.nl>\n\
< 	                         Daniel Leidert\n\
< 	                         <daniel.leidert@wgdd.de>\n\
< 	                         Oskar Świda\n\
< 	                         <swida@aragorn.pb.bialystok.pl>\n\
< 	                         David Marrs\n\
< 	                         <David.Marrs@myrealbox.com>\n\
< 	                         Michèle Garoche\n\
< 	                         <michele.garoche@easyconnect.fr>\n\
< 	                         \n\
< 	                         Developers for previous releases:\n\
< 	                         Oskar Świda\n\
< 	                         <swida@aragorn.pb.bialystok.pl>\n\
< 	                         Eugene Morenko(More)\n\
< 	                         <more@irpin.com>\n\
< 	                         Alastair Porter\n\
< 	                         <alastair@porter.net.nz>\n\
< 	                         Chris Mazuc\n\
< 	                         Neil Millar\n\
< 	                         Gero Takke\n\
< 	                         Bo Forslund\n\
< 	                         David Arno\n\
< 	                         Pablo De Napoli\n\
< 	                         Santiago Capel Torres\n\
< 	                         Rasmus Toftdahl Olesen\n\
< 	                         <rto@pohldata.dk>\n\
< 	                         Roland Steinbach\n\
< 	                         <roland@netzblick.de>\n\
< 	                         Christian Tellefsen\n\
< 	                         <chris@tellefsen.net>\n\
< 	                         Antti-Juhani Kaijanaho\n\
< 	                         \n\
< 	                         Documentation:\n\
< 	                         Michèle Garoche\n\
< 	                         <michele.garoche@easyconnect.fr>\n\
< 	                         Scott White\n\
< 	                         <wwsw3@earthlink.net>\n\
< 	                         Anita Lewis\n\
< 	                         <ajreiki@highstream.net>\n\
< 	                         Alastair Porter\n\
< 	                         <alastair@porter.net.nz>\n\
< 	                         Daniel Blair\n\
< 	                         <joecamel@realcoders.org>\n\
< 	                         Olivier Sessink\n\
< 	                         <olivier@bluefish.openoffice.nl>\n\
< 	                         Denny Reeh\n\
< 	                         \n\
< 	                         Package Maintainers:\n\
< 	                         Debian:   Daniel Leidert\n\
< 	                         <daniel.leidert@wgdd.de>\n\
< 	                         Redhat:   Matthias Haase\n\
< 	                         <matthias_haase@bennewitz.com>\n\
< 	                         Mandrake: Todd Lyons\n\
< 	                         <todd@mrball.net>\n\
< 	                         Fink: Michèle Garoche\n\
< 	                         <michele.garoche@easyconnect.fr>\n\
< 	                         \n\
< 	                         If you know of anyone missing from this list, please let us know\n\
< 	                         <bluefish@bluefish.openoffice.nl>\n\
< 	                         \n\
< 	                         Thanks to all who helped making this software available.\n\
< 	                         ");
< 	const gchar *TRANSLATORS = _("Current translators:\n\n\
< 	                             Basque: Hizkuntza Politikarako Sailburuordetza\n\
< 	                             <hizkpol@ej-gv.es>\n\n\
< 	                             Brazilian Portuguese: Anderson Rocha\n\
< 	                             <anderson@maxlinux.com.br>\n\n\
< 	                             Bulgarian: Peio Popov\n\
< 	                             <peio@peio.org>\n\n\
< 	                             Chinese: Ting Yang (Dormouse)\n\
< 	                             <mouselinux@163.com>\n\n\
< 	                             Chinese, Traditional: OLS3\n\
< 	                             <ols3@lxer.idv.tw>\n\n\
< 	                             Danish: Rasmus Toftdahl Olesen\n\
< 	                             <rto@pohldata.dk>\n\n\
< 	                             Finnish: Juho Roukala\n\
< 	                             <j.mr@luukku.com>\n\n\
< 	                             French: Michèle Garoche\n\
< 	                             <michele.garoche@easyconnect.fr>\n\n\
< 	                             German: Roland Steinbach\n\
< 	                             <roland@netzblick.de>\n\n\
< 	                             Hungarian: Péter Sáska\n\
< 	                             <sasek@ccsystem.hu>\n\n\
< 	                             Italian: Stefano Canepa\n\
< 	                             <sc@linux.it>\n\n\
< 	                             Japanese: Takeshi Hamasaki\n\
< 	                             <hma@syd.odn.ne.jp>\n\n\
< 	                             Norwegian: Christian Tellefsen\n\
< 	                             <chris@tellefsen.net>\n\n\
< 	                             Polish: Oskar Swida\n\
< 	                             <swida@aragorn.pb.bialystok.pl>\n\n\
< 	                             Portuguese: Lopo Pizarro\n\
< 	                             <lopopizarro@netcabo.pt>\n\n\
< 	                             Russian: Eugene Rupakov\n\
< 	                             <rupakov@jet.msk.su>\n\n\
< 	                             Serbian: Marko Milenović\n\
< 	                             <raven@sbb.co.yu>\n\n\
< 	                             Slovak: Vladimir VASIL\n\
< 	                             <vvasil@post.sk>\n\n\
< 	                             Spanish: Walter Oscar Echarri\n\
< 	                             <wecharri@gmail.com>\n\n\
< 	                             Swedish: David Smeringe\n\
< 	                             <david.smeringe@telia.com>\n\n\
< 	                             Tamil: Murugapandian Barathee\n\
< 	                             <barathee@yahoo.com>\n\n\
< 	                             Turkish: Oğuz Eren\n\
< 	                             <ogzeren@gmail.com>\n\n\
< 	                             ");
< 
< 	info = window_full2(_("About Bluefish"), GTK_WIN_POS_CENTER, 6
< 	                    ,G_CALLBACK(about_dialog_close_lcb),NULL, TRUE, NULL);
< 	gtk_window_set_resizable(GTK_WINDOW(info), FALSE);
< 	color.red = 65535;
< 	color.blue = 65535;
< 	color.green = 65535;
< 	gtk_widget_modify_bg(info, GTK_STATE_NORMAL,&color);
< 
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(info), vbox2);
< 	{
< 		GError *error=NULL;
< 		GtkWidget *image;
< #ifdef WIN32
< 		GdkPixbuf* pixbuf= gdk_pixbuf_new_from_file(BLUEFISH_PNG_PATH,&error);
< #else
< 		GdkPixbuf* pixbuf= gdk_pixbuf_new_from_file(BLUEFISH_SPLASH_FILENAME,&error);
< #endif	/* WIN32 */		
< 		if (error) {
< 			g_print("ERROR while loading splash screen: %s\n", error->message);
< 			g_error_free(error);
< 		} else if (pixbuf) {
< 			image = gtk_image_new_from_pixbuf(pixbuf);
< 			gtk_box_pack_start(GTK_BOX(vbox2), image, FALSE, FALSE, 0);
< 			g_object_unref(pixbuf);
< 		}
< 	}
< 
< 	vbox = gtk_vbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox2), vbox, TRUE, TRUE, 0);
< 
< 	/* the notebook */
< 	notebook = gtk_notebook_new();
< 
< 	config_options = g_strconcat (CONFIGURE_OPTIONS, _("\n\nResulting in the detection of:\n"),
< #ifdef HAVE_LIBASPELL
< 	                              "libaspell\n",
< #endif
< #ifdef DEVELOPMENT
< 	                              "Development request\n",
< #endif
< #ifdef ENABLE_NLS
< 	                              "i18n request\n",
< #endif
< #ifdef HAVE_ATLEAST_GTK_2_4
< 	                              "GTK+ 2.4 or newer\n",
< #endif
< #ifdef HAVE_ATLEAST_GNOMEVFS_2_6
< 	                              "GnomeVFS 2.6 or newer\n",
< #endif
< #ifdef HAVE_ATLEAST_GNOMEUI_2_6
< 	                              "libgnomeui 2.6 or newer\n",
< #endif
< #ifdef PLATFORM_DARWIN
< 	                              "Platform Darwin",
< #endif
< 	                              NULL);
< 
< 	/* add pages */
< 	I1 = g_strconcat(INFO, config_options, NULL);
< 	g_free (config_options);
< 	add_page(GTK_NOTEBOOK(notebook), _("Info"), I1, TRUE);
< 	g_free(I1);
< 	add_page(GTK_NOTEBOOK(notebook), _("Authors"), AUTHORS, TRUE);
< 	add_page(GTK_NOTEBOOK(notebook), _("Translators"), TRANSLATORS, TRUE);
< 
< 	gtk_box_pack_start(GTK_BOX(vbox), notebook, TRUE, TRUE, 0);
< 
< 	hbox = gtk_hbutton_box_new ();
< 	gtk_button_box_set_layout (GTK_BUTTON_BOX (hbox), GTK_BUTTONBOX_END);
< 	gtk_box_pack_start( GTK_BOX (vbox), hbox, FALSE, FALSE, 4);
< 	info_ok_button = gtk_button_new_from_stock(GTK_STOCK_CLOSE);
< 	GTK_WIDGET_SET_FLAGS(info_ok_button, GTK_CAN_DEFAULT);
< 	gtk_box_pack_start(GTK_BOX(hbox), info_ok_button, FALSE, FALSE, 0);
< 	gtk_widget_grab_default(info_ok_button);
< 
< 	g_signal_connect(info_ok_button, "clicked", G_CALLBACK(about_dialog_close_lcb), info);
< 
< 	gtk_widget_show_all(info);
< }
---
> /* Bluefish HTML Editor
>  * about.c - the About dialog
>  *
>  * Copyright (C) 2004 Eugene Morenko(More) more@irpin.com
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> #include <gdk/gdk.h>
> #include <gtk/gtk.h>
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> #include <unistd.h>   /* getopt() */
> 
> #include "config.h"
> 
> #include "bluefish.h"
> #include "about.h"
> #include "gtk_easy.h"
> 
> static GtkWidget *info;
> 
> static void add_page(GtkNotebook * notebook, const gchar * name, const gchar * buf,
> 					 gboolean hscrolling) {
> 	GtkWidget *textview, *label, *sw;
> 	label = gtk_label_new(name);
> 	sw = textview_buffer_in_scrolwin(&textview, -1, 200, buf, GTK_WRAP_WORD);
> 	gtk_text_view_set_editable(GTK_TEXT_VIEW(textview), FALSE);
> 	gtk_text_view_set_cursor_visible (GTK_TEXT_VIEW (textview), FALSE);
> 	gtk_notebook_append_page(notebook, sw, label);
> }
> 
> static void about_dialog_close_lcb(GtkObject *object,GtkWidget *win) {
> 	window_destroy(win);
> }
> 
> void about_dialog_create(gpointer * data, guint * callback_action, GtkWidget * widget) {
> 	GtkWidget *vbox, *vbox2, *hbox;
> 	GtkWidget *notebook;
> 	GtkWidget *info_ok_button;
> 	GdkColor color;
> 	gchar *I1, *config_options;
> 	const gchar *INFO = _("Bluefish is an editor for experienced web designers and programmers. It supports many programming and markup languages, but focuses on editing dynamic and interactive websites. Bluefish is an open source development project, released under the GPL license.\n\nFor more information, visit the Bluefish Website at http://bluefish.openoffice.nl/\n\nThis version of bluefish was compiled with the following options:\n");
> 	const gchar *AUTHORS = _("Project leader:\n\
>   Olivier Sessink <olivier@bluefish.openoffice.nl>\n\
> \n\
> Developers for this release:\n\
>   Olivier Sessink\n\
>    <olivier@bluefish.openoffice.nl>\n\
>   Jim Hayward\n\
>    <jim@bluefish.openoffice.nl>\n\
>   Daniel Leidert\n\
>    <daniel.leidert@wgdd.de>\n\
>   Oskar Świda\n\
>    <swida@aragorn.pb.bialystok.pl>\n\
>   David Marrs\n\
>    <David.Marrs@myrealbox.com>\n\
>   Michèle Garoche\n\
>    <michele.garoche@easyconnect.fr>\n\
> \n\
> Developers for previous releases:\n\
>   Oskar Świda\n\
>    <swida@aragorn.pb.bialystok.pl>\n\
>   Eugene Morenko(More)\n\
>    <more@irpin.com>\n\
>   Alastair Porter\n\
>    <alastair@porter.net.nz>\n\
>   Chris Mazuc\n\
>   Neil Millar\n\
>   Gero Takke\n\
>   Bo Forslund\n\
>   David Arno\n\
>   Pablo De Napoli\n\
>   Santiago Capel Torres\n\
>   Rasmus Toftdahl Olesen\n\
>    <rto@pohldata.dk>\n\
>   Roland Steinbach\n\
>    <roland@netzblick.de>\n\
>   Christian Tellefsen\n\
>    <chris@tellefsen.net>\n\
>   Antti-Juhani Kaijanaho\n\
> \n\
> Documentation:\n\
>   Michèle Garoche\n\
>    <michele.garoche@easyconnect.fr>\n\
>   Scott White\n\
>    <wwsw3@earthlink.net>\n\
>   Anita Lewis\n\
>    <ajreiki@highstream.net>\n\
>   Alastair Porter\n\
>    <alastair@porter.net.nz>\n\
>   Daniel Blair\n\
>    <joecamel@realcoders.org>\n\
>   Olivier Sessink\n\
>    <olivier@bluefish.openoffice.nl>\n\
>   Denny Reeh\n\
> \n\
> Package Maintainers:\n\
>   Debian:   Daniel Leidert\n\
>    <daniel.leidert@wgdd.de>\n\
>   Redhat:   Matthias Haase\n\
>    <matthias_haase@bennewitz.com>\n\
>   Mandrake: Todd Lyons\n\
>    <todd@mrball.net>\n\
>   Fink: Michèle Garoche\n\
>    <michele.garoche@easyconnect.fr>\n\
> \n\
> If you know of anyone missing from this list, please let us know\n\
> <bluefish@bluefish.openoffice.nl>\n\
> \n\
> Thanks to all who helped making this software available.\n\
> ");
> 	const gchar *TRANSLATORS = _("Current translators:\n\n\
>   Basque: Hizkuntza Politikarako Sailburuordetza\n\
>    <hizkpol@ej-gv.es>\n\n\
>   Brazilian Portuguese: Anderson Rocha\n\
>    <anderson@maxlinux.com.br>\n\n\
>   Bulgarian: Peio Popov\n\
>    <peio@peio.org>\n\n\
>   Chinese: Ting Yang (Dormouse)\n\
>    <mouselinux@163.com>\n\n\
>   Chinese, Traditional: OLS3\n\
>    <ols3@lxer.idv.tw>\n\n\
>   Danish: Rasmus Toftdahl Olesen\n\
>    <rto@pohldata.dk>\n\n\
>   Finnish: Juho Roukala\n\
>    <j.mr@luukku.com>\n\n\
>   French: Michèle Garoche\n\
>    <michele.garoche@easyconnect.fr>\n\n\
>   German: Roland Steinbach\n\
>    <roland@netzblick.de>\n\n\
>   Hungarian: Péter Sáska\n\
>    <sasek@ccsystem.hu>\n\n\
>   Italian: Stefano Canepa\n\
>    <sc@linux.it>\n\n\
>   Japanese: Takeshi Hamasaki\n\
>    <hma@syd.odn.ne.jp>\n\n\
>   Norwegian: Christian Tellefsen\n\
>    <chris@tellefsen.net>\n\n\
>   Polish: Oskar Swida\n\
>    <swida@aragorn.pb.bialystok.pl>\n\n\
>   Portuguese: Lopo Pizarro\n\
>    <lopopizarro@netcabo.pt>\n\n\
>   Russian: Eugene Rupakov\n\
>    <rupakov@jet.msk.su>\n\n\
>   Serbian: Marko Milenović\n\
>    <raven@sbb.co.yu>\n\n\
>   Slovak: Vladimir VASIL\n\
>    <vvasil@post.sk>\n\n\
>   Spanish: Walter Oscar Echarri\n\
>    <wecharri@gmail.com>\n\n\
>   Swedish: David Smeringe\n\
>    <david.smeringe@telia.com>\n\n\
>   Tamil: Murugapandian Barathee\n\
>    <barathee@yahoo.com>\n\n\
>   Turkish: Oğuz Eren\n\
>    <ogzeren@gmail.com>\n\n\
> ");
> 
> 	info = window_full2(_("About Bluefish"), GTK_WIN_POS_CENTER, 6
> 			,G_CALLBACK(about_dialog_close_lcb),NULL, TRUE, NULL);
> 	gtk_window_set_resizable(GTK_WINDOW(info), FALSE);
> 	color.red = 65535;
> 	color.blue = 65535;
> 	color.green = 65535;
> 	gtk_widget_modify_bg(info, GTK_STATE_NORMAL,&color);
> 
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(info), vbox2);
> 	{
> 		GError *error=NULL;
> 		GtkWidget *image;
> 		GdkPixbuf* pixbuf= gdk_pixbuf_new_from_file(BLUEFISH_SPLASH_FILENAME,&error);
> 		if (error) {
> 			g_print("ERROR while loading splash screen: %s\n", error->message);
> 			g_error_free(error);
> 		} else if (pixbuf) {
> 			image = gtk_image_new_from_pixbuf(pixbuf);
> 			gtk_box_pack_start(GTK_BOX(vbox2), image, FALSE, FALSE, 0);
> 			g_object_unref(pixbuf);
> 		}
> 	}
> 
> 	vbox = gtk_vbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox2), vbox, TRUE, TRUE, 0);
> 
> 	/* the notebook */
> 	notebook = gtk_notebook_new();
> 
> 	config_options = g_strconcat (CONFIGURE_OPTIONS, _("\n\nResulting in the detection of:\n"),
> #ifdef HAVE_LIBASPELL
> 			"libaspell\n",
> #endif
> #ifdef DEVELOPMENT
> 			"Development request\n",
> #endif
> #ifdef ENABLE_NLS
> 			"i18n request\n",
> #endif
> #ifdef HAVE_ATLEAST_GTK_2_4
> 			"GTK+ 2.4 or newer\n",
> #endif
> #ifdef HAVE_ATLEAST_GNOMEVFS_2_6
> 			"GnomeVFS 2.6 or newer\n",
> #endif
> #ifdef HAVE_ATLEAST_GNOMEUI_2_6
> 			"libgnomeui 2.6 or newer\n",
> #endif
> #ifdef PLATFORM_DARWIN
> 			"Platform Darwin",
> #endif
> 			NULL);
> 
> 	/* add pages */
> 	I1 = g_strconcat(INFO, config_options, NULL);
> 	g_free (config_options);
> 	add_page(GTK_NOTEBOOK(notebook), _("Info"), I1, TRUE);
> 	g_free(I1);
> 	add_page(GTK_NOTEBOOK(notebook), _("Authors"), AUTHORS, TRUE);
> 	add_page(GTK_NOTEBOOK(notebook), _("Translators"), TRANSLATORS, TRUE);
> 
> 	gtk_box_pack_start(GTK_BOX(vbox), notebook, TRUE, TRUE, 0);
> 
> 	hbox = gtk_hbutton_box_new ();
> 	gtk_button_box_set_layout (GTK_BUTTON_BOX (hbox), GTK_BUTTONBOX_END);
> 	gtk_box_pack_start( GTK_BOX (vbox), hbox, FALSE, FALSE, 4);
> 	info_ok_button = gtk_button_new_from_stock(GTK_STOCK_CLOSE);
> 	GTK_WIDGET_SET_FLAGS(info_ok_button, GTK_CAN_DEFAULT);
> 	gtk_box_pack_start(GTK_BOX(hbox), info_ok_button, FALSE, FALSE, 0);
> 	gtk_widget_grab_default(info_ok_button);
> 
> 	g_signal_connect(info_ok_button, "clicked", G_CALLBACK(about_dialog_close_lcb), info);
> 
> 	gtk_widget_show_all(info);
> }
1,1540c1,1453
< /* Bluefish HTML Editor
<  * bf_lib.c - non-GUI general functions
<  *
<  * Copyright (C) 2000-2004 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< /* #define DEBUG */
< 
< #include <gtk/gtk.h>
< #include <unistd.h> /* chdir() */
< #include <stdio.h> /* fopen() */
< #include <ctype.h> /* toupper */
< #include <string.h> /* strrchr strncmp memmove strncat*/
< #include <sys/stat.h> /* S_IFDIR */
< #include <errno.h> 	/* errno */
< 
< #include "bluefish.h"  /* for DEBUG_MSG and stuff like that */
< #include "bf_lib.h"  /* myself */
< #ifndef _WIN_32_DIRSTRCHR
< #ifdef WIN32
< #define DIRSTR "\\"
< #define DIRCHR 92
< #else
< #define DIRSTR "/"
< #define DIRCHR '/'
< #endif
< #endif
< /**
<  * get_filename_on_disk_encoding
<  *
<  * if gnome_vfs is defined, this function will also escape local paths
<  * to make sure we can open files with a # in their name
<  */
< gchar *get_filename_on_disk_encoding(const gchar *utf8filename) {
< 	if (utf8filename) {
< 		GError *gerror=NULL;
< 		gsize b_written;
< 		gchar *ondiskencoding = g_filename_from_utf8(utf8filename,-1, NULL,&b_written,&gerror);
< 		if (gerror) {
< 			g_print(_("Bluefish has trouble reading the filenames. Try to set the environment variable G_BROKEN_FILENAMES=1\n"));
< 			ondiskencoding = g_strdup(utf8filename);
< 		}
< #ifdef HAVE_GNOME_VFS
< 		/* convert local path's */
< 		if (ondiskencoding[0] == '/') {
< 			gchar *tmp = gnome_vfs_escape_path_string(ondiskencoding);
< 			g_free(ondiskencoding);
< 			ondiskencoding = tmp;
< 		}
< #endif /* HAVE_GNOME_VFS */
< 		return ondiskencoding;
< 	}
< 	return NULL;
< }
< 
< gchar *get_utf8filename_from_on_disk_encoding(const gchar *encodedname) {
< 	if (encodedname) {
< 		GError *gerror=NULL;
< 		gsize b_written;
< 		gchar *ondiskencoding = g_filename_to_utf8(encodedname,-1, NULL,&b_written,&gerror);
< 		if (gerror) {
< 			g_print(_("Bluefish has trouble reading the filenames. Try to set the environment variable G_BROKEN_FILENAMES=1\n"));
< 			ondiskencoding = g_strdup(encodedname);
< 		}
< 		DEBUG_MSG("get_utf8filename_from_on_disk_encoding, utf8filename=%s\n",ondiskencoding);
< 		return ondiskencoding;
< 	}
< 	return NULL;
< }
< 
< gboolean string_is_color(const gchar *color) {
< 	GdkColor gcolor;
< 	return gdk_color_parse(color, &gcolor);
< }
< 
< static void fill_rwx(short unsigned int bits, char *chars) {
< 	chars[0] = (bits & S_IRUSR) ? 'r' : '-';
< 	chars[1] = (bits & S_IWUSR) ? 'w' : '-';
< 	chars[2] = (bits & S_IXUSR) ? 'x' : '-';
< }
< static void fill_setid(short unsigned int bits, char *chars) {
< #ifdef S_ISUID
< 	if (bits & S_ISUID) {
< 		/* Set-uid, but not executable by owner.  */
< 		if (chars[3] != 'x') chars[3] = 'S';
< 		else chars[3] = 's';
< 	}
< #endif
< #ifdef S_ISGID
< 	if (bits & S_ISGID) {
< 		/* Set-gid, but not executable by group.  */
< 		if (chars[6] != 'x') chars[6] = 'S';
< 		else chars[6] = 's';
< 	}
< #endif
< #ifdef S_ISVTX
< 	if (bits & S_ISVTX) {
< 		/* Sticky, but not executable by others.  */
< 		if (chars[9] != 'x') chars[9] = 'T';
< 		else chars[9] = 't';
< 	}
< #endif
< }
< gchar *filemode_to_string(mode_t statmode) {
< 	gchar *str = g_malloc0(10);
<  	/* following code "adapted" from GNU filemode.c program */
< 	fill_rwx((statmode & 0700) << 0, &str[0]);
< 	fill_rwx((statmode & 0070) << 3, &str[3]);
< 	fill_rwx((statmode & 0007) << 6, &str[6]);
< 	fill_setid(statmode, str);
< 	return str;
< }
< 
< 
< /**
<  * return_root_with_protocol:
<  * @url: #const gchar* with the url 
<  *
<  * returns the root of the url, including its trailing slash
<  * this might be in the form
<  * - "protocol://server:port/"
<  * - "/"
<  * - NULL, if the url contains no url, nor does it start with a / character
<  *
<  * if there is no trailing slash, this function will return the root WITH a
<  * trailing slash appended!!
<  *
<  * Return value: #gchar* newly allocated, or NULL
<  */
< gchar *return_root_with_protocol(const gchar *url) {
< #ifdef WIN32
< 	 return win_return_root_with_protocol(url);
< #endif
< 	if (!url) return NULL;
< 	g_print("return_root_with_protocol:%s\n",url);
< 	gchar *q;
< 	gchar *tmpurl = g_strdup(url);
< 	q = strchr(tmpurl,':');
< 	if (q && *(q+1)=='/' && *(q+2)=='/' && *(q+3)!='\0') {
< 		/* we have a protocol */
< 		gchar *root = strchr(q+3, '/');
< 		if (root) return g_strndup(tmpurl, root - url + 1);
< 		/* if there is no third slash character, we probably
< 		have an url like http://someserver so we will append 
< 		the slash ourselves */
< 		return g_strconcat(tmpurl, "/",NULL);
< 	} else if (url[0] == '/') {
< 		/* no protocol, return / */
< 		return g_strdup("/");
< 	}
< 	/* no root known */
< 	g_free(tmpurl);
< 	return NULL;
< }
< 
< gchar *win_return_root_with_protocol(const gchar *url){
< #ifndef WIN32
< 	return return_root_with_protocol( url);
< #endif
< 	if (!url) return NULL;
< 	gchar *q;
< 	if (g_str_has_prefix(url,"http://") ||g_str_has_prefix(url,"https://")
< 		 ||g_str_has_prefix(url,"ftp://")||g_str_has_prefix(url,"sftp://")
< 	    ||g_str_has_prefix(url,"file://")){
< 			q =strchr(url,':');
< 			return (g_strndup(url,q -url+1));
< 	}else{
< 		q = strchr(url,':');
< 		if (q){
< 			 return g_strconcat("/",g_strndup(url,q - url+1),NULL);
< 		 }
< 	 }
< 	return NULL;
<  }
< 
< /**
<  * pointer_switch_addresses:
<  * a: #gpointer;
<  * b: #gpointer
<  *
<  * after this call, a will contain the address previously in a
<  * and b will contain the address previously in b
<  *
<  * Return value: void
<  */
< #ifdef __GNUC__
< __inline__ 
< #endif
< void pointer_switch_addresses(gpointer *a, gpointer *b) {
< 	gpointer c;
< 	DEBUG_MSG("pointer_switch_addresses, before, a=%p, b=%p\n",a,b);
< 	c = *a;
< 	*a = *b;
< 	*b = c;
< 	DEBUG_MSG("pointer_switch_addresses, after, a=%p, b=%p\n",a,b);
< }
< 
< /**
<  * list_switch_order:
<  * @first: a #GList * item
<  * @second: a #GList * item
<  * 
<  * this function will switch place of these two list items
<  * actually not the items themselves, but the data they are 
<  * pointer to is switched
<  * 
<  * Return value: void
<  **/
< void list_switch_order(GList *first, GList *second) {
< 	gpointer tmp;
< 	tmp = first->data;
< 	first->data = second->data;
< 	second->data = tmp;
< }
< /**
<  * file_copy:
<  * @source: a #gchar * containing the source filename
<  * @dest: a #gchar * containing the destination filename
<  * 
<  * copies the contents of the file source to dest
<  * this function is Gnome-VFS aware, so it will work on URI's
<  * 
<  * Return value: gboolean, TRUE if the function succeeds
<  **/
< #ifdef HAVE_GNOME_VFS
< #define BYTES_TO_PROCESS 8196
< gboolean file_copy(gchar *source, gchar *dest) {
< 	GnomeVFSHandle *read_handle, *write_handle;
< 	GnomeVFSFileSize bytes_read, bytes_written;
< 	guint buffer[BYTES_TO_PROCESS];
< 	GnomeVFSResult result;
< 	gchar *OnDiEn_source, *OnDiEn_dest;
< 	OnDiEn_source = get_filename_on_disk_encoding(source);
< 	OnDiEn_dest = get_filename_on_disk_encoding(dest);
< 	
< 	result = gnome_vfs_open(&read_handle, OnDiEn_source, GNOME_VFS_OPEN_READ);
< 	g_free(OnDiEn_source);
< 	if (result != GNOME_VFS_OK) return FALSE;
< 	result = gnome_vfs_create(&write_handle, OnDiEn_dest, GNOME_VFS_OPEN_WRITE, FALSE, 0644);
< 	g_free(OnDiEn_dest);
< 	if (result != GNOME_VFS_OK) {
< 		gnome_vfs_close(read_handle);
< 		return FALSE;
< 	}
< 	result = gnome_vfs_read (read_handle, buffer, BYTES_TO_PROCESS, &bytes_read);
< 	while (result == GNOME_VFS_OK) {
< 		result = gnome_vfs_write (write_handle, buffer, bytes_read, &bytes_written);
< 		if (result != GNOME_VFS_OK || bytes_written != bytes_read) {
< 			DEBUG_MSG("file_copy, return FALSE, write result=%d, written=%ld, read=%ld\n",result,(long)bytes_written,(long)bytes_read);
< 			gnome_vfs_close(write_handle);
< 			gnome_vfs_close(read_handle);
< 			return FALSE;
< 		}
< 		result = gnome_vfs_read(read_handle, buffer, BYTES_TO_PROCESS, &bytes_read);
< 	}
< 	gnome_vfs_close(write_handle);
< 	gnome_vfs_close(read_handle);
< 	return TRUE;
< }
< #else  /* HAVE_GNOME_VFS */
< gboolean file_copy(gchar *source, gchar *dest) {
< #ifdef DEVELOPMENT
< 	g_assert(source);
< 	g_assert(dest);
< #endif
< 	int c;
< 	FILE *in, *out;
< 	gchar *OnDiEn_source, *OnDiEn_dest;
< 	OnDiEn_source = get_filename_on_disk_encoding(source);
< 	OnDiEn_dest = get_filename_on_disk_encoding(dest);
< 
< 	in = fopen(OnDiEn_source, "r");
< 	g_free(OnDiEn_source);
< 	if (!in) {
< 		return FALSE;
< 	}
< 	out = fopen(OnDiEn_dest, "w");
< 	g_free(OnDiEn_dest);
< 	if (!out) {
< 		fclose(in);
< 		return FALSE;
< 	}
< 	while((c=fgetc(in)) != EOF) {
< 		fputc(c,out);
< 	}
< 	fclose(in);
< 	fclose(out);
< 	return TRUE;
< }
< #endif /* HAVE_GNOME_VFS */
< 
< static gint length_common_prefix(gchar *first, gchar *second) {
< 	gint i=0;
< 	while (first[i] == second[i] && first[i] != '\0') {
< 		i++;
< 	}
< 	return i;
< }
< /**
<  * find_common_prefix_in_stringlist:
<  * @stringlist: a #GList* with strings
<  * 
<  * tests every string in stringlist, and returns the length of the 
<  * common prefix all these strings have
<  *
<  * This is for example useful to find out if a list of filenames
<  * share the same base directory
<  * 
<  * Return value: #gint with number of common characters
<  **/
< gint find_common_prefixlen_in_stringlist(GList *stringlist) {
< 	gchar *firststring;
< 	gint commonlen;
< 	GList *tmplist;
< 	tmplist = g_list_first(stringlist);
< 	firststring = (gchar *)tmplist->data;
< 	commonlen = strlen(firststring);
< 	tmplist = g_list_next(tmplist);
< 	while(tmplist){
< 		gint testlen;
< 		gchar *secondstring = (gchar *)tmplist->data;
< 		testlen = length_common_prefix(firststring, secondstring);
< 		if (testlen < commonlen) {
< 			commonlen = testlen;
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return commonlen;
< }
< /**
<  * append_string_to_file:
<  * @filename: a #gchar * containing the destination filename
<  * @string: a #gchar * containing the string to append
<  * 
<  * opens the file filename in append mode, and appends the string
<  * no newline or anything else is appended, just the string
<  *
<  * DOES NOT YET SUPPORT GNOME_VFS !!!
<  * 
<  * Return value: gboolean, TRUE if the function succeeds
<  **/
< gboolean append_string_to_file(gchar *filename, gchar *string) {
< 	FILE *out;
< 	gchar *ondiskencoding = get_filename_on_disk_encoding(filename);
< 	out = fopen(ondiskencoding, "a");
< 	g_free(ondiskencoding);
< 	if (!out) {
< 		DEBUG_MSG("append_to_file, could not open file %s for append\n", filename);
< 		return FALSE;
< 	}
< 	fputs(string, out);
< 	fclose(out);
< 	return TRUE;
< }
< /**
<  * countchars:
<  * @string: a gchar * to count the chars in
<  * @chars: a gchar * with the characters you are interested in
<  *
<  * this function will count every character in string that is also in chars
<  * 
<  * Return value: guint with the number of characters found
<  **/
< guint countchars(const gchar *string, const gchar *chars) {
< 	guint count=0;
< 	gchar *newstr = strpbrk(string, chars);
< 	while(newstr) {
< 		count++;
< 		newstr = strpbrk(++newstr, chars);
< 	}
< 	DEBUG_MSG("countchars, returning %d\n",count);
< 	return count;
< }
< static gint table_convert_char2int_backend(Tconvert_table *table, const gchar *my_char
< 		, Ttcc2i_mode mode, int (*func)(const gchar *arg1, const gchar *arg2) ) {
< 	Tconvert_table *entry;
< 	entry = table;
< 	while (entry->my_char) {
< 		if (func(my_char,entry->my_char)==0) {
< 			return entry->my_int;
< 		}
< 		entry++;
< 	}
< 	return -1;
< }
< static int strfirstchar(const gchar *mychar, const gchar *tablechar) {
< 	return mychar[0] - tablechar[0];
< }
< static int strmycharlen(const gchar *mychar, const gchar *tablechar) {
< 	return strncmp(mychar,tablechar,strlen(mychar));
< }
< static int strfull_match_gettext(const gchar *mychar, const gchar *tablechar) {
< 	return strcmp(mychar,_(tablechar));
< }
< /**
<  * table_convert_char2int:
<  * @table: a #tconvert_table * with strings and integers
<  * @my_char: a #gchar * containing the string to convert
<  * @mode: #Ttcc2i_mode
<  * 
<  * this function can be used to translate a string from some set (in table)
<  * to an integer
<  * 
<  * Return value: gint, found in table, or -1 if not found
<  **/
< gint table_convert_char2int(Tconvert_table *table, const gchar *my_char, Ttcc2i_mode mode) {
< 	switch (mode) {
< 	case tcc2i_firstchar:
< 		return table_convert_char2int_backend(table,my_char,mode,strfirstchar);
< 	case tcc2i_mycharlen:
< 		return table_convert_char2int_backend(table,my_char,mode,strmycharlen);
< 	case tcc2i_full_match:
< 		return table_convert_char2int_backend(table,my_char,mode,strcmp);
< 	case tcc2i_full_match_gettext:
< 		return table_convert_char2int_backend(table,my_char,mode,strfull_match_gettext);
< 	default:
< 		DEBUG_MSG("bug in call to table_convert_char2int()\n");
< 		return -1;
< 	}
< }
< /**
<  * table_convert_int2char:
<  * @table: a #tconvert_table * with strings and integers
<  * @my_int: a #gint containing the integer to convert
<  * 
<  * this function can be used to translate an integer from some set (in table)
<  * to a string
<  * WARNING: This function will return a pointer into table, it will 
<  * NOT allocate new memory
<  * 
<  * Return value: gchar * found in table, else NULL
<  **/
< gchar *table_convert_int2char(Tconvert_table *table, gint my_int) {
< 	Tconvert_table *entry;
< 	entry = table;
< 	while (entry->my_char) {
< 		if (my_int == entry->my_int) {
< 			return entry->my_char;
< 		}
< 		entry++;
< 	}
< 	return NULL;
< }
< /**
<  * expand_string:
<  * @string: a formatstring #gchar * to convert
<  * @specialchar: a const char to use as 'delimited' or 'special character'
<  * @table: a #Tconvert_table * array to use for conversion
<  * 
<  * this function can convert a format string with %0, %1, or \n, \t 
<  * into the final string, where each %number or \char entry is replaced 
<  * with the string found in table
<  *
<  * so this function is the backend for unescape_string() and 
<  * for replace_string_printflike()
<  *
<  * table is an array with last entry {0, NULL}
<  * 
<  * Return value: a newly allocated gchar * with the resulting string
<  **/
< gchar *expand_string(const gchar *string, const char specialchar, Tconvert_table *table) {
< 	gchar *p, *prev, *stringdup;
< 	gchar *tmp, *dest = g_strdup("");
< 
< 	stringdup = g_strdup(string); /* we make a copy so we can set some \0 chars in the string */
< 	prev = stringdup;
< 	DEBUG_MSG("expand_string, string='%s'\n", string);
< 	p = strchr(prev, specialchar);
< 	while (p) {
< 		gchar *converted;
< 		tmp = dest;
< 		*p = '\0'; /* set a \0 at this point, the pointer prev now contains everything up to the current % */
< 		DEBUG_MSG("expand_string, prev='%s'\n", prev);
< 		p++;
< 		converted = table_convert_int2char(table, *p);
< 		DEBUG_MSG("expand_string, converted='%s'\n", converted);
< 		dest = g_strconcat(dest, prev, converted, NULL);
< 		g_free(tmp);
< 		prev = ++p;
< 		p = strchr(p, specialchar);
< 	}
< 	tmp = dest;
< 	dest = g_strconcat(dest, prev, NULL); /* append the end to the current string */
< 	g_free(tmp);
< 	
< 	g_free(stringdup);
< 	DEBUG_MSG("expand_string, dest='%s'\n", dest);
< 	return dest;
< }
< gchar *replace_string_printflike(const gchar *string, Tconvert_table *table) {
< 	return expand_string(string,'%',table);
< }
< 
< static gint tablesize(Tconvert_table *table) {
< 	Tconvert_table *tmpentry = table;
< 	while (tmpentry->my_char) tmpentry++;
< 	return (tmpentry - table);
< }
< /* for now this function can only unexpand strings with tables that contain only
< single character strings like "\n", "\t" etc. */
< gchar *unexpand_string(const gchar *original, const char specialchar, Tconvert_table *table) {
< 	gchar *tmp, *tosearchfor, *retval, *prev, *dest, *orig;
< 	Tconvert_table *tmpentry;
< 	
< 	orig = g_strdup(original);
< 	DEBUG_MSG("original='%s', strlen()=%d\n",original,strlen(original));
< 	tosearchfor = g_malloc(tablesize(table)+1);
< 	DEBUG_MSG("tablesize(table)=%d, alloc'ed %d bytes for tosearchfor\n",tablesize(table), tablesize(table)+1);
< 	tmp = tosearchfor;
< 	tmpentry = table;
< 	while(tmpentry->my_char != NULL) {
< 		*tmp = tmpentry->my_char[0]; /* we fill the search string with the first character */
< 		tmpentry++;
< 		tmp++;
< 	}
< 	*tmp = '\0';
< 	DEBUG_MSG("unexpand_string, tosearchfor='%s'\n",tosearchfor);
< 	DEBUG_MSG("alloc'ing %d bytes\n", (countchars(original, tosearchfor) + strlen(original) + 1));
< 	retval = g_malloc((countchars(original, tosearchfor) + strlen(original) + 1) * sizeof(gchar));
< 	dest = retval;
< 	prev = orig;
< 	/* now we go trough the original till we hit specialchar */
< 	tmp = strpbrk(prev, tosearchfor);
< 	while (tmp) {
< 		gint len = tmp - prev;
< 		gint mychar = table_convert_char2int(table, tmp, tcc2i_firstchar);
< 		DEBUG_MSG("unexpand_string, tmp='%s', prev='%s'\n",tmp, prev);
< 		if (mychar == -1) mychar = *tmp;
< 		DEBUG_MSG("unexpand_string, copy %d bytes and advancing dest\n",len);
< 		memcpy(dest, prev, len);
< 		dest += len;
< 		*dest = specialchar;
< 		dest++;
< 		*dest = mychar;
< 		dest++;
< 		prev=tmp+1;
< 		DEBUG_MSG("prev now is '%s'\n",prev);
< 		tmp = strpbrk(prev, tosearchfor);
< 	}
< 	DEBUG_MSG("unexpand_string, copy the rest (%s) to dest\n",prev);
< 	memcpy(dest,prev,strlen(prev)+1); /* this will also make sure there is a \0 at the end */
< 	DEBUG_MSG("unexpand_string, retval='%s'\n",retval);
< 	g_free(orig);
< 	g_free(tosearchfor);
< 	return retval;
< }
< /* if you change this table, please change escape_string() and unescape_string() and new_convert_table() in the same way */
< static Tconvert_table standardescapetable [] = {
< 	{'n', "\n"},
< 	{'t', "\t"},
< 	{'\\', "\\"},
< 	{'f', "\f"},
< 	{'r', "\r"},
< 	{'a', "\a"},
< 	{'b', "\b"},
< 	{'v', "\v"},
< 	{'n', "\n"},
< 	{':', ":"}, /* this double entry is there to make unescape_string and escape_string work efficient */
< 	{0, NULL}
< };
< gchar *unescape_string(const gchar *original, gboolean escape_colon) {
< 	gchar *string, *tmp=NULL;
< 	DEBUG_MSG("unescape_string, started\n");
< 	if (!escape_colon) {
< 		tmp = standardescapetable[9].my_char;
< 		standardescapetable[9].my_char = NULL;
< 	}
< 	string = expand_string(original,'\\',standardescapetable);
< 	if (!escape_colon) {
< 		standardescapetable[9].my_char = tmp;
< 	}
< 	return string;
< }
< gchar *escape_string(const gchar *original, gboolean escape_colon) {
< 	gchar *string, *tmp=NULL;
< 	DEBUG_MSG("escape_string, started\n");
< 	if (!escape_colon) {
< 		tmp = standardescapetable[9].my_char;
< 		standardescapetable[9].my_char = NULL;
< 	}
< 	string = unexpand_string(original,'\\',standardescapetable);
< 	if (!escape_colon) {
< 		standardescapetable[9].my_char = tmp;
< 	}
< 	return string;
< }
< Tconvert_table *new_convert_table(gint size, gboolean fill_standardescape) {
< 	gint realsize = (fill_standardescape) ? size + 10 : size;
< 	Tconvert_table * tct = g_new(Tconvert_table, realsize+1);
< 	DEBUG_MSG("new_convert_table, size=%d, realsize=%d,alloced=%d\n",size,realsize,realsize+1);
< 	if (fill_standardescape) {
< 		gint i;
< 		for (i=size;i<realsize;i++) {
< 			tct[i].my_int = standardescapetable[i-size].my_int;
< 			tct[i].my_char = g_strdup(standardescapetable[i-size].my_char);
< 		}
< 		DEBUG_MSG("new_convert_table, setting tct[%d] (i) to NULL\n",i);
< 		tct[i].my_char = NULL;
< 	} else {
< 		DEBUG_MSG("new_convert_table, setting tct[%d] (size) to NULL\n",size);
< 		tct[size].my_char = NULL;
< 	}
< 	return tct;
< }
< void free_convert_table(Tconvert_table *tct) {
< 	Tconvert_table *tmp = tct;
< 	while (tmp->my_char) {
< 		DEBUG_MSG("free_convert_table, my_char=%s\n",tmp->my_char);
< 		g_free(tmp->my_char);
< 		tmp++;
< 	}
< 	DEBUG_MSG("free_convert_table, free table %p\n",tct);
< 	g_free(tct);
< }
< /**************************************************/
< /* byte offset to UTF8 character offset functions */
< /**************************************************/
< 
< /*
< html files usually have enough cache at size 4
< large php files, a cache of 
< 	10 resulted in 160% of the buffer to be parsed
< 	12 resulted in 152% of the buffer to be parsed
< 	14 resulted in 152% of the buffer to be parsed
< 	16 resulted in 152% of the buffer to be parsed
< so we keep it at 10 for the moment
< */
< #define UTF8_OFFSET_CACHE_SIZE 10
< /* #define UTF8_BYTECHARDEBUG */
< 
< typedef struct {
< 	gchar *last_buf;
< 	/* the two arrays must be grouped and in this order, because they are moved back 
< 	one position in ONE memmove() call */
< 	guint  last_byteoffset[UTF8_OFFSET_CACHE_SIZE];
< 	guint  last_charoffset[UTF8_OFFSET_CACHE_SIZE];
< #ifdef UTF8_BYTECHARDEBUG
< 	guint numcalls_since_reset;
< 	unsigned long long int numbytes_parsed;
< 	guint numcalls_cached_since_reset;
< 	unsigned long long int numbytes_cached_parsed;
< #endif
< } Tutf8_offset_cache;
< 
< static Tutf8_offset_cache utf8_offset_cache;
< 
< /**
<  * utf8_offset_cache_reset:
<  * 
<  * this function will reset the utf8 offset cache used by 
<  * utf8_byteoffset_to_charsoffset_cached()
<  *
<  * normally this is done automatically if utf8_byteoffset_to_charsoffset_cached() 
<  * is called with a new buffer. But if you ever call that function for 
<  * the same buffer but the buffer is changed in the meantime you have 
<  * to reset it manually using utf8_offset_cache_reset()
<  * 
<  * Return value: void
<  **/
< #ifdef __GNUC__
< __inline__ 
< #endif
< void utf8_offset_cache_reset() {
< #ifdef UTF8_BYTECHARDEBUG
< 	g_print("UTF8_BYTECHARDEBUG: called %d times for total %llu bytes\n",utf8_offset_cache.numcalls_since_reset,utf8_offset_cache.numbytes_parsed);
< 	g_print("UTF8_BYTECHARDEBUG: cache HIT %d times, reduced to %llu bytes, cache size %d\n",utf8_offset_cache.numcalls_cached_since_reset,utf8_offset_cache.numbytes_cached_parsed,UTF8_OFFSET_CACHE_SIZE);
< #endif
< 	memset(&utf8_offset_cache, 0, sizeof(Tutf8_offset_cache));
< }
< /**
<  * utf8_byteoffset_to_charsoffset_cached:
<  * @string: the gchar * you want to count
<  * @byteoffset: glong with the byteoffset you want the charoffset for
<  * 
<  * this function calculates the UTF-8 character offset in a string for
<  * a given byte offset
<  * It uses caching to speedup multiple calls for the same buffer, the cache
<  * is emptied if you change to another buffer. If you use the same buffer but 
<  * change it inbetween calls, you have to reset it yourself using
<  * the utf8_offset_cache_reset() function
<  *
<  **** the result is undefined if the provided byteoffset is in the middle of a UTF8 character ***
<  * 
<  * Return value: guint with character offset
<  **/
< guint utf8_byteoffset_to_charsoffset_cached(gchar *string, glong byteoffset) {
< 	guint retval;
< 	gint i = UTF8_OFFSET_CACHE_SIZE-1;
< 	if (byteoffset ==0) return 0;
< 
< 	if (string != utf8_offset_cache.last_buf) {
< 		utf8_offset_cache_reset();
< 		utf8_offset_cache.last_buf = string;
< 	}
< #ifdef DEBUG
< 	DEBUG_MSG("utf8_byteoffset_to_charsoffset_cached, string %p has strlen %d, looking for byteoffset %ld, starting in cache at i=%d\n", string, strlen(string),byteoffset,i);
< #endif
< 
< 	while (i > 0 && utf8_offset_cache.last_byteoffset[i] > byteoffset) {
< 		i--;
< 	}
< 	
< 	if (i > 0) {
< 		if (utf8_offset_cache.last_byteoffset[i] == byteoffset) {
< #ifdef DEBUG
< 	DEBUG_MSG("byteoffset %ld is in the cache at i=%d, returning %d\n",byteoffset,i,utf8_offset_cache.last_charoffset[i]);
< #endif
< 			return utf8_offset_cache.last_charoffset[i];
<        }
<        /* if the byteoffset is in the middle of a multibyte character, this line will fail (but
< 	       we are not supposed to get called in the middle of a character)*/
< 		retval = g_utf8_pointer_to_offset(string+utf8_offset_cache.last_byteoffset[i], string+byteoffset)+utf8_offset_cache.last_charoffset[i];
< #ifdef UTF8_BYTECHARDEBUG
< 		utf8_offset_cache.numbytes_parsed += (byteoffset - utf8_offset_cache.last_byteoffset[i]);
< 		utf8_offset_cache.numbytes_cached_parsed += (byteoffset - utf8_offset_cache.last_byteoffset[i]);
< 		utf8_offset_cache.numcalls_cached_since_reset++;
< #endif
< 	} else {
< 		retval = g_utf8_pointer_to_offset(string, string+byteoffset);
< #ifdef UTF8_BYTECHARDEBUG
< 		utf8_offset_cache.numbytes_parsed += byteoffset;
< #endif
< 	}
< 	DEBUG_MSG(" and byteoffset %ld has charoffset %d\n",byteoffset,retval);
< 	if (i == (UTF8_OFFSET_CACHE_SIZE-1)) {
< 		/* add this new calculation to the cache */
< 		/* this is a nasty trick to move all guint entries one back in the array, so we can add the new one */
< 		memmove(&utf8_offset_cache.last_byteoffset[0], &utf8_offset_cache.last_byteoffset[1], (UTF8_OFFSET_CACHE_SIZE+UTF8_OFFSET_CACHE_SIZE-1)*sizeof(guint));
< 
< 		utf8_offset_cache.last_byteoffset[UTF8_OFFSET_CACHE_SIZE-1] = byteoffset;
< 		utf8_offset_cache.last_charoffset[UTF8_OFFSET_CACHE_SIZE-1] = retval;
< 	}
< #ifdef UTF8_BYTECHARDEBUG
< 	utf8_offset_cache.numcalls_since_reset++;
< #endif
< 	return retval;
< }
< 
< /**
<  * escapestring:
<  * @original: a gchar * to escape
<  * @delimiter: a gchar that needs escaping, use '\0' if you don't need one
<  *
<  * this function will backslash escape \n, \t, and \ characters, and if 
<  * there is a delimiter it will also be escaped
<  * 
<  * Return value: a newly allocated gchar * that is escaped
<  **/
< /*gchar *old_escapestring(gchar *original, gchar delimiter)
< {
< 	gchar *tmp, *newstring, *escapedchars;
< 	guint newsize, pos=0;
< 
< 	* count the size of the new string *
< 	escapedchars = g_strdup_printf("\n\t\\%c", delimiter);
< 	DEBUG_MSG("escapestring, escapedchars=%s, extra length=%d\n", escapedchars, countchars(original, escapedchars));
< 	newsize = countchars(original, escapedchars) + strlen(original) + 1;
< 	newstring = g_malloc0(newsize * sizeof(gchar));
< 	g_free(escapedchars);
< 	DEBUG_MSG("escapestring, original=%s, newsize=%d\n", original, newsize);
< 
< 	tmp = original;
< 	while (*tmp != '\0') {
< 		switch (*tmp) {
< 		case '\\':
< 			strcat(newstring, "\\\\");
< 			pos +=2;
< 		break;
< 		case '\n':
< 			strcat(newstring, "\\n");
< 			pos +=2;
< 		break;
< 		case '\t':
< 			strcat(newstring, "\\t");
< 			pos +=2;
< 		break;
< 		default:
< 			if (*tmp == delimiter) {
< 				newstring[pos] = '\\';
< 				newstring[pos+1] = delimiter;
< 				pos +=2;			
< 			} else {
< 				newstring[pos] = *tmp;
< 				pos++;
< 			}
< 		break;
< 		}
< 		newstring[pos] = '\0';
< 		tmp++;
< 	}
< 	DEBUG_MSG("escapestring, newstring = %s\n", newstring);
< 	return newstring;
< }*/
< 
< /**
<  * unescapestring:
<  * @original: a gchar * to unescape
<  *
<  * this function will backslash unescape \n, \t, and \\ sequences to 
<  * their characters, and if there is any other escaped character 
<  * it will be replaced without the backslash
<  * 
<  * Return value: a newly allocated gchar * that is unescaped
<  **/
< /*gchar *old_unescapestring(gchar *original)
< {
< 	gchar *tmp1, *tmp2, *newstring;
< 	guint newsize;
< 	gint escaped;
< 
< 	newsize = strlen(original) + 1;
< 	newstring = g_malloc0(newsize * sizeof(gchar));
< 	DEBUG_MSG("unescapestring, original=%s, newsize = %d\n", original, newsize);
< 
< 	tmp1 = original;
< 	tmp2 = newstring;
< 	escaped = 0;
< 	while (*tmp1 != '\0') {
< 		if (escaped) {
< 			switch (*tmp1) {
< 			case '\\':
< 				*tmp2++ = '\\';
< 			break;
< 			case 'n':
< 				*tmp2++ = '\n';
< 			break;
< 			case 't':
< 				*tmp2++ = '\t';
< 			break;
< 			default:
< 				*tmp2++ = *tmp1;
< 			break;
< 			}
< 
< 			escaped = 0;
< 		} else {
< 			if (*tmp1 == '\\')
< 				escaped = 1;
< 			else
< 				*tmp2++ = *tmp1;
< 		}
< 		tmp1++;
< 	}
< 	DEBUG_MSG("unescapestring, newstring = %s\n", newstring);
< 	return newstring;
< }*/
< 
< /**
<  * strip_any_whitespace:
<  * @string: a gchar * to strip
<  *
<  * strips any double chars defined by isspace() from the string, 
<  * only single spaces are returned
<  * the same string is returned, no memory is allocated in this function
<  * 
<  * Return value: the same gchar * as passed to the function
<  **/
< gchar *strip_any_whitespace(gchar *string) {
< 	gint count=0, len;
< 
< #ifdef DEVELOPMENT
< 	g_assert(string);
< #endif
< 
< 	DEBUG_MSG("strip_any_whitespace, starting string='%s'\n", string);
< 	len = strlen(string);
< 	while(string[count]) {
< 		if (isspace((char)string[count])) {
< 			string[count] = ' ';
< 			if (string[count+1] && isspace((char)string[count+1])) {
< 				gint fcount = count;
< 				while (string[fcount] && isspace((char)string[fcount])) {
< 					fcount++;
< 				}
< 				DEBUG_MSG("strip_any_whitespace, found %d spaces\n", fcount - count);
< 				memmove(&string[count+1], &string[fcount], len - (count+1));
< 				string[len- (fcount-count)+1] = '\0';
< 				DEBUG_MSG("strip_any_whitespace, after memmove, string='%s'\n", string);
< 			}
< 		}
< 		count++;
< 	}
< 	g_strstrip(string);
< 	DEBUG_MSG("strip_any_whitespace, returning string='%s'\n", string);
< 	return string;
< }
< /**
<  * trunc_on_char:
<  * @string: a #gchar * to truncate
<  * @which_char: a #gchar with the char to truncate on
<  *
<  * Returns a pointer to the same string which is truncated at the first
<  * occurence of which_char
<  * 
<  * Return value: the same gchar * as passed to the function
<  **/
< gchar *trunc_on_char(gchar * string, gchar which_char)
< {
< 	gchar *tmpchar = string;
< 	while(*tmpchar) {
< 		if (*tmpchar == which_char) {
< 			*tmpchar = '\0';
< 			return string;
< 		}
< 		tmpchar++;
< 	}
< 	return string;
< }
< /* gchar *strip_common_path(char *image_fn, char *html_fn)
<  * returns a newly allocated string containing the the to_filename
<  * but all the common path with from_filename is removed 
<  *
<  * IS THIS IN USE ?? OBVIOUSLY NOT BECAUSE I CAN REMOVE IT */ 
< /*gchar *strip_common_path(char *to_filename, char *from_filename)
< {
< 	gchar *tempstr;
< 	int count, count2, dir_length;
< 
< 	count = 0;
< 	tempstr = strrchr(to_filename, DIRCHR);
< 	dir_length = strlen(to_filename) - strlen(tempstr);
< 	dir_length += 1;
< 	DEBUG_MSG("strip_common_path, dir_lenght=%d\n", dir_length);
< 	while ((strncmp(to_filename, from_filename, count + 1)) == 0) {
< 		count++;
< 		if (count > dir_length) {
< 			count = dir_length;
< 			break;
< 		}
< 	}
< 	while (to_filename[count - 1] != DIRCHR)
< 		count--;
< 	DEBUG_MSG("strip_common_path, equal count = %d\n", count);
< 	count2 = strlen(to_filename);
< 	tempstr = g_malloc(count2 - count + 2);
< 	memcpy(tempstr, &to_filename[count], count2 - count + 2);
< 	DEBUG_MSG("strip_common_path, tempstr= %s, should be %d long\n", tempstr, count2 - count);
< 	return tempstr;
< } */
< 
< /**
<  * most_efficient_filename:
<  * @filename: a gchar * with a possibly inefficient filename like /hello/../tmp/../myfile
<  *
<  * tries to eliminate any dir/../ combinations in filename
<  * this function could do evern better, it should also remove /./ entries
<  * 
<  * Return value: the same gchar * as passed to the function
<  **/
< gchar *most_efficient_filename(gchar *filename) {
< 	gint i,j, len;
< #ifdef WIN32
< 	/* bf_chrrepl(filename,"\\","/"); */
< #endif
< 	DEBUG_MSG("most_efficient_filename, 1 filename=%s\n", filename);
< 	len = strlen(filename);
< 	for (i=0; i < len-4; i++) {
< /*		DEBUG_MSG("most_efficient_filename, i=%d\n", i); */
< 		if (strncmp(&filename[i], "/../", 4) == 0) {
< 			for (j=1; j < i; j++) {
< 				if ((filename[i - j] == DIRCHR) || (i==j)) {
< 					DEBUG_MSG("most_efficient_filename, &filename[%d-%d]=%s, &filename[%d+3]=%s, %d-%d-4=%d\n", i,j,&filename[i-j],i, &filename[i+3], len, j, len-j-4);
< 					memmove(&filename[i-j], &filename[i+3], len-i);
< 					j=i;
< 					i--;
< 				}
< 			}
< 		}
< 	}
< 	DEBUG_MSG("most_efficient_filename, 3 filename=%s\n", filename);
< 	return filename;
< }
< 
< /**
<  * create_relative_link_to:
<  * @current_filepath: a #gchar * with the current filename
<  * @link_to_filepath: a #gchar * with a file to link to
<  *
<  * creates a newly allocated relative link from current_filepath 
<  * to link_to_filepath
<  *
<  * if current_filepath == NULL it returns the most efficient filepath 
<  * for link_to_filepath
<  *
<  * if link_to_filepath == NULL it will return NULL
<  *
<  * Return value: a newly allocated gchar * with the relative link
<  **/
< gchar *create_relative_link_to(gchar * current_filepath, gchar * link_to_filepath)
< {
< 	gchar *returnstring = NULL;
< 	gchar *eff_current_filepath, *eff_link_to_filepath;
< 	gint common_lenght, maxcommonlen;
< 	gint current_filename_length, link_to_filename_length, current_dirname_length, link_to_dirname_length;
< 	gint count, deeper_dirs;
< 	gchar *temp, *temp2;
< 	if (!current_filepath){
< 		returnstring = most_efficient_filename(g_strdup(link_to_filepath));
< 		return returnstring;
< 	}
< 	if (!link_to_filepath) {
< 		return NULL;
< 	}
< 	eff_current_filepath = most_efficient_filename(g_strdup(current_filepath));
< 	eff_link_to_filepath = most_efficient_filename(g_strdup(link_to_filepath));
< 	DEBUG_MSG("eff_current: '%s'\n",eff_current_filepath);
< 	DEBUG_MSG("eff_link_to: '%s'\n",eff_link_to_filepath);
< 	/* get the size of the directory of the current_filename */
< #ifdef WIN32
< 	temp = strrchr(eff_current_filepath,DIRCHR);
< 	if (temp == NULL){temp = strrchr(eff_current_filepath,'/');}
< 	current_filename_length = (temp == NULL ? 0 : strlen(temp)-1);
< 	temp2 = strrchr(eff_link_to_filepath, DIRCHR);
< 	if (temp2 == NULL){temp2 = strrchr(eff_link_to_filepath, '/');}
< 	link_to_filename_length = (temp2 == NULL ? 0 : strlen(temp2)-1);
< #else	
< 	current_filename_length = strlen(strrchr(eff_current_filepath, DIRCHR))-1;
< 	link_to_filename_length = strlen(strrchr(eff_link_to_filepath, DIRCHR))-1;
< #endif
< 	DEBUG_MSG("create_relative_link_to, filenames: current: %d, link_to:%d\n", current_filename_length,link_to_filename_length); 
< 	current_dirname_length = strlen(eff_current_filepath) - current_filename_length;
< 	link_to_dirname_length = strlen(eff_link_to_filepath) - link_to_filename_length;
< 	DEBUG_MSG("create_relative_link_to, dir's: current: %d, link_to:%d\n", current_dirname_length, link_to_dirname_length); 
< 
< 	if (current_dirname_length < link_to_dirname_length) {
< 		maxcommonlen = current_dirname_length;
< 	} else {
< 		maxcommonlen = link_to_dirname_length;
< 	}
< 	
< 	/* first lets get the common basedir for both dir+file  by comparing the
< 	   common path in the directories */
< 	common_lenght = 0;
< 	while ((strncmp(eff_current_filepath, eff_link_to_filepath, common_lenght + 1)) == 0) {
< 		common_lenght++;
< 		if (common_lenght >= maxcommonlen) {
< 			common_lenght = maxcommonlen;
< 			break;
< 		}
< 	}
< 	DEBUG_MSG("create_relative_link_to, common_lenght=%d (not checked for directory)\n", common_lenght);
< 	/* this is the common length, but we need the common directories */
< 	if (eff_current_filepath[common_lenght] != DIRCHR) {
< 		gchar *ltmp = &eff_current_filepath[common_lenght];
< 		while ((*ltmp != DIRCHR) && (common_lenght > 0)) {
< 			common_lenght--;
< 			ltmp--;
< 		}
< 	}
< 	DEBUG_MSG("create_relative_link_to, common_lenght=%d (checked for directory)\n", common_lenght);
< 
< 	/* now we need to count how much deeper (in directories) the current_filename
< 	   is compared to the link_to_file, that is the amount of ../ we need to add */
< 	deeper_dirs = 0;
< 	for (count = common_lenght+1; count <= current_dirname_length; count++) {
< 		if (eff_current_filepath[count] == DIRCHR) {
< 			deeper_dirs++;
< 			DEBUG_MSG("create_relative_link_to, on count=%d, deeper_dirs=%d\n", count, deeper_dirs);
< 		}
< 	}
< 	DEBUG_MSG("create_relative_link_to, deeper_dirs=%d\n", deeper_dirs);
< 
< 	/* now we know everything we need to know we can create the relative link */
< 	returnstring = g_malloc0((strlen(link_to_filepath) - common_lenght + 3 * deeper_dirs + 1) * sizeof(gchar *));
< 	count = deeper_dirs;
< 	while (count) {
< 		strcat(returnstring, "../");
< 		count--;
< 	}
< 	strcat(returnstring, &eff_link_to_filepath[common_lenght+1]);
< 	DEBUG_MSG("create_relative_link_to, returnstring=%s\n", returnstring);
< 	g_free(temp);
< 	g_free(temp2);
< 	g_free(eff_current_filepath);
< 	g_free(eff_link_to_filepath);
< 	return returnstring;
< }
< #ifdef HAVE_GNOME_VFS
< #define STRIP_FILE_URI
< #endif
< #ifdef HAVE_ATLEAST_GTK_2_4
< #define STRIP_FILE_URI
< #endif
< /**
<  * create_full_path:
<  * @filename: a gchar * with the (relative or not) filename
<  * @basedir: a gchar * with a basedir or NULL for current dir
<  *
<  * if filename is already absolute, it returns it
<  * else it will use basedir if available, else the current dir
<  * to add to the filename to form the full path
<  *
<  * for URL's it will simply return a strdup(), except for file:// URL's, 
<  * there the file:// bit is stripped and 
<  * IF YOU HAVE GNOME_VFS any %XX sequenves are converted
<  * so if you DON'T have gnome_vfs, you should not feed file:// uri's!!
<  *
<  * it does use most_efficient_filename() to remote unwanted dir/../ entries
<  *
<  * Return value: a newly allocated gchar * with the full path
<  **/
< gchar *create_full_path(const gchar * filename, const gchar *basedir) {
< 	gchar *absolute_filename;
< 	gchar *tmpcdir;
< 
< 	if (!filename) return NULL;
< 	DEBUG_MSG("create_full_path, filename=%s, basedir=%s\n", filename, basedir);
< #ifdef STRIP_FILE_URI
< 	if (strchr(filename, ':') != NULL) { /* it is an URI!! */
< 		DEBUG_MSG("create_full_path, %s is an URI\n",filename);
< 		if (strncmp(filename, "file://", 7)==0) {
< #ifdef HAVE_GNOME_VFS
< 			return gnome_vfs_get_local_path_from_uri(filename);
< #else
< 			/* THIS IS A BUG, IF YOU DON'T HAVE GNOME_VFS BUT YOU DO HAVE 
< 			GTK-2.4 A %21 OR SOMETHING LIKE THAT IS NOW NOT CONVERTED !!!!!!!!! */
< 			return g_strdup(filename+7); /* file:// URI's are never relative paths */
< #endif
< 		}
< 		return g_strdup(filename); /* cannot do this on remote paths */
< 	}
< #endif /* HAVE_GNOME_VFS */
< 	if (g_path_is_absolute(filename)) {
< 		absolute_filename = g_strdup(filename);
< 	} else {
< 		if (basedir) {
< 			tmpcdir = ending_slash(basedir);
< 		} else {
< 			gchar *curdir = g_get_current_dir();
< 			tmpcdir = ending_slash(curdir);
< 			g_free(curdir);
< 		}
< 		absolute_filename = g_strconcat(tmpcdir, filename, NULL);
< 		g_free(tmpcdir);
< 	}
< 	absolute_filename = most_efficient_filename(absolute_filename);
< 	return absolute_filename;
< }
< 
< /**
<  * ending_slash:
<  * @dirname: a #const gchar * with a diretory name
<  *
<  * makes sure the last character of the newly allocated 
<  * string it returns is a '/'
<  *
<  * Return value: a newly allocated gchar * dirname that does end on a '/'
<  **/
< gchar *ending_slash(const gchar *dirname) {
< 	if (!dirname) {
< 		return g_strdup("");
< 	}
< #ifdef WIN32
< 		gchar * tmp = g_strdup(dirname);
< 	bf_chrrepl(tmp,"/","\\");
< 	if (tmp[strlen(tmp)-1] == DIRCHR) {
< 		g_free(tmp);
< 		return g_strdup(dirname);
< 	} else {
< 		g_free(tmp);
< 		return g_strconcat(dirname, "/", NULL);
< 	}
< #else
< 	if (dirname[strlen(dirname)-1] == DIRCHR) {
< 		return g_strdup(dirname);
< 	} else {
< 		return g_strconcat(dirname, DIRSTR, NULL);
< 	}
< #endif
< }
< /**
<  * path_get_dirname_with_ending_slash:
<  * @filename: a #const gchar * with a file path
<  *
<  * returns a newly allocated string, containing everything up to 
<  * the last '/' character, including that character itself.
<  *
<  * if no '/' character is found it returns NULL
<  *
<  * Return value: a newly allocated gchar * dirname that does end on a '/', or NULL on failure
<  **/
< gchar *path_get_dirname_with_ending_slash(const gchar *filename) {
< 	gchar *tmp = strrchr(filename, DIRCHR);
< #ifdef WIN32	
< 	if (!tmp) {tmp = strrchr(filename, 47);}
< #endif /* WIN32 */
< 	if (tmp) {
< 		return g_strndup(filename, (tmp - filename + 1));
< 	} else {
< 		return NULL;
< 	}
< }
< 
< /**
<  * file_exists_and_readable:
<  * @filename: a #const gchar * with a file path
<  *
<  * tests if the file exists, and  if it is readable, the last
<  * check is not reliable, it does not check all the groups you are
<  * in, so change this function before you rely on that check!
<  *
<  * this function is Gnome-VFS aware, so it will work on URI's
<  *
<  * Return value: gboolean, TRUE if readable, else FALSE
<  **/
< gboolean file_exists_and_readable(const gchar * filename) {
< 	gchar *ondiskencoding;
< 	/* not sure the purpose of returning true here by default so I changed it to false. */
< 	gboolean retval=FALSE;
< 
< #ifdef WIN32
< 	if (filename[0] == '/') { filename++;}
< #endif /* WIN32 */
< 
< #ifdef DEVELOPMENT
< 	g_assert(filename);
< #endif
< 	if (!filename || strlen(filename) < 2) {
< 		DEBUG_MSG("file_exists_and_readable, strlen(filename) < 2 or no filename!!!!\n");
< 		return FALSE;
< 	}
< 	DEBUG_MSG("file_exists_and_readable, filename(%p)=\"%s\", strlen(filename)=%d\n", filename, filename, strlen(filename));
< 	ondiskencoding = get_filename_on_disk_encoding(filename);
< 	DEBUG_MSG("file_exists_and_readable, ondiskencoding='%s'\n",ondiskencoding);
< /* #ifndef WIN32 */
< #ifdef HAVE_GNOME_VFS
< 	{
< 		GnomeVFSURI* uri;
< 		uri = gnome_vfs_uri_new(ondiskencoding);
< 		retval = gnome_vfs_uri_exists(uri);
< 		DEBUG_MSG("gnome_vfs_uri has path %s\n",gnome_vfs_uri_get_path(uri));
< 		gnome_vfs_uri_unref(uri);
< 		DEBUG_MSG("file_exists_and_readable, return %d for %s\n",retval,filename);
< 	}
< #else /* HAVE_GNOME_VFS */
< 	{
< 		struct stat naamstat;
< 		errno = 0;
< 		retval = ((stat(ondiskencoding, &naamstat) == 0) && (errno == 0));
< 		DEBUG_MSG("file_exists_and_readable, retval=%d (ernno=%d) for %s\n",retval,errno,ondiskencoding);
< 	}
< #endif /* HAVE_GNOME_VFS */
< 	g_free(ondiskencoding);
< /* #endif */ /* NOT WIN32 */
< 	return retval;
< }
< /**
<  * return_first_existing_filename:
<  * @filename: a #const gchar * with a filename
<  * @...: more filenames
<  *
<  * you can pass multiple filenames to this function, and it will return
<  * the first filename that really exists according to file_exists_and_readable()
<  *
<  * Return value: gchar * with the first filename found
<  **/
< gchar *return_first_existing_filename(const gchar *filename, ...) {
< 	va_list args;
< 	gchar *retval=NULL;
< 
< 	va_start(args, filename);
< 	while (filename) {
< 		if (file_exists_and_readable(filename)) {
< 			retval = g_strdup(filename);
< 			break;
< 		}
< 		filename = va_arg(args, gchar*);
< 	}
< 	va_end(args);
< 	return retval;
< }
< 
< /**
<  * filename_test_extensions:
<  * @extensions: a #gchar ** NULL terminated arrau of strings
<  * @filename: a #const gchar * with a filename
<  *
<  * tests if the filename matches one of the extensions passed in the NULL terminated array
<  * of strings
<  *
<  * Return value: gboolean, TRUE if the file has one of the extensions in the array
<  **/
< gboolean filename_test_extensions(gchar **extensions, gchar *filename) {
< 	if (!extensions) {
< 		return FALSE;
< 	}
< 	while (*extensions) {
< 		if (strncmp(&filename[strlen(filename)-strlen(*extensions)], *extensions, strlen(*extensions)) == 0 ) {
< 			return TRUE;
< 		}
< 		extensions++;
< 	}
< 	return FALSE;
< }
< 
< /**
<  * bf_str_repeat:
<  * @str: a #const gchar * 
<  * @number_of: a #gint
<  *
<  * returns a newly allocated string, 
<  * containing str repeated number_of times
<  *
<  * Return value: the newly allocated #gchar *
<  **/
< gchar *bf_str_repeat(const gchar * str, gint number_of) {
< 	gchar *retstr;
< 	gint len = strlen(str) * number_of;
< 	retstr = g_malloc(len + 1);
< 	retstr[0] = '\0';
< 	while (number_of) {
< 		strncat(retstr, str, len);
< 		number_of--;
< 	};
< 	return retstr;
< }
< 
< /**
<  * get_int_from_string:
<  * @string: a #const gchar * 
<  *
<  * tries to find a positive integer value in the string and returns it
<  * the string does not have to start or end with the integer
<  * it returns -1 if no integer was found somewhere in the string
<  *
<  * Return value: the found #gint, -1 on failure
<  **/
< gint get_int_from_string(gchar *string) {
< 	if (string) {
< 		gint faktor = 1, result=-1;
< 		gint i,len = strlen(string);
< 		for (i=len-1;i>=0;i--) {
< 			if ((string[i] < 58) && (string[i] > 47)) {
< 				if (result == -1) {
< 					result = 0;
< 				} else {
< 					faktor *= 10;
< 				}
< 				result += (((gint)string[i])-48)*faktor;
< 				DEBUG_MSG("get_int_from_string, set result to %d\n", result);
< 			} else {
< 				if (result !=-1) {
< 					return result;
< 				}
< 			}
< 		}
< 		return result;
< 	}
< 	return -1;
< }
< 
< /**
<  * create_secure_dir_return_filename:
<  *
<  * this function uses mkdir(name) to create a dir with permissions rwx------
<  * mkdir will fail if name already exists or is a symlink or something
<  * the name is chosen by tempnam() so the chance that mkdir() fails in
<  * a normal situation is minimal, it almost must be a hacking attempt
<  *
<  * the filename generated can safely be used for output of an external 
<  * script because the dir has rwx------ permissions
<  *
<  * Return value: a newly allocated #gchar * containing a temporary filename in a secure dir
<  **/
< gchar *create_secure_dir_return_filename() {
< 	gchar *name, *name2;
< 	DEBUG_MSG("create_secure_dir_return_filename,g_get_tmp_dir()=%s\n", g_get_tmp_dir());
< 	/* it is SAFE to use tempnam() here, because we don't open a file with that name,
< 	 * we create a directory with that name. mkdir() will FAIL if this name is a hardlink
< 	 * or a symlink, so we DO NOT overwrite any file the link is pointing to
< 	 */
< 	name = tempnam(g_get_tmp_dir(), NULL);
< 	DEBUG_MSG("create_secure_dir_return_filename, name=%s\n", name);
< 	if (!name) {
< 		return NULL;
< 	}
< #ifdef WIN32
< 	if (mkdir(name) != 0) {
< #else
< 	if (mkdir(name, 0700) !=0) {
< #endif
< 		g_free(name);
< 		return NULL;
< 	}
< 	name2 = tempnam(name, NULL);
< 	DEBUG_MSG("create_secure_dir_return_filename, name2=%s\n", name2);
< 	g_free(name);
< 	return name2;
< }
< /**
<  * remove_secure_dir_and_filename:
<  * @filename: the #gchar * filename to remove
<  *
<  * this function will remove a the filename created 
<  * by create_secure_dir_return_filename(), and the safe
<  * directory the file was created in
<  *
<  * Return value: void
<  **/
< void remove_secure_dir_and_filename(gchar *filename) {
< 	gchar *dirname = g_path_get_dirname(filename);
< 	unlink(filename);
< 	rmdir(dirname);
< 	g_free(dirname);
< }
< 
< /* gchar *buf_replace_char(gchar *buf, gint len, gchar srcchar, gchar destchar) {
< 	gint curlen=0;
< 	gchar *tmpbuf=buf;
< 	while(tmpbuf[curlen] != '\0' && curlen < len) {
< 		if (tmpbuf[curlen] == srcchar) {
< 			tmpbuf[curlen] = destchar;
< 		}
< 		curlen++;
< 	}
< 	return buf;
< }*/
< 
< /**
<  * wordcount:
<  * @text: A #gchar* to examine.
<  * @chars: #guint*, will contain no. chars in text.
<  * @lines: #guint*, will contain no. lines in text.
<  * @words: #guint*, will contain no. words in text.
<  *
<  * Returns number of characters, lines and words in the supplied #gchar*.
<  * Handles UTF-8 correctly. Input must be properly encoded UTF-8.
<  * Words are defined as any characters grouped, separated with spaces.
<  * I.e., this is a word: "12a42a,.". This is two words: ". ."
<  *
<  * This function contains a switch() with inspiration from the GNU wc utility.
<  * Rewritten for glib UTF-8 handling by Christian Tellefsen, chris@tellefsen.net.
<  *
<  * Note that gchar == char, so that gives us no problems here.
<  *
<  * Return value: void
<  **/
< void wordcount(gchar *text, guint *chars, guint *lines, guint *words)
< {
< 	guint in_word = 0;
< 	gunichar utext;
< 	
< 	if(!text) return; /* politely refuse to operate on NULL .. */
< 		
< 	*chars = *words = *lines = 0;
< 	while (*text != '\0') {
< 		(*chars)++;
< 		
< 		switch (*text) {
< 			case '\n':
< 				(*lines)++;
< 				/* Fall through. */
< 			case '\r':
< 			case '\f':
< 			case '\t':
< 			case ' ':
< 			case '\v':
< 				mb_word_separator:
< 				if (in_word) {
< 					in_word = 0;
< 					(*words)++;
< 				}
< 				break;
< 			default:
< 				utext = g_utf8_get_char_validated(text, 2); /* This might be an utf-8 char..*/
< 				if (g_unichar_isspace (utext)) /* Unicode encoded space? */
< 					goto mb_word_separator;
< 				if (g_unichar_isgraph (utext)) /* Is this something printable? */
< 					in_word = 1;
< 				break;
< 		} /* switch */
< 		
< 		text = g_utf8_next_char(text); /* Even if the current char is 2 bytes, this will iterate correctly. */
< 	}
< 	
< 	/* Capture last word, if there's no whitespace at the end of the file. */
< 	if(in_word) (*words)++;
< 	/* We start counting line numbers from 1 */
< 	if(*chars > 0) (*lines)++;
< }
< 
< GSList *gslist_from_glist(GList *src) {
< 	GSList *target=NULL;
< 	GList *tmplist = g_list_first(src);
< 	while (tmplist) {
< 		target = g_slist_append(target, tmplist->data);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return target;
< }
< 
< GList *glist_from_gslist(GSList *src) {
< 	GList *target=NULL;
< 	GSList *tmplist = src;
< 	while (tmplist) {
< 		target = g_list_append(target, tmplist->data);
< 		tmplist = g_slist_next(tmplist);
< 	}
< 	return target;
< }
< /* Inplace replacement of character find with character repl in source string */
< void bf_chrrepl(gchar *source,const gchar *find, const gchar *repl){
< 	if (source){
< 		gint i,len = strlen(source);
< 		for (i =0; i<len ;i++)
< 		{
< 			if (source[i] == (gint)find[0]){
< 				source[i]= (gint)repl[0];
< 			}
< 		}
< 	}
< }
< 
< /*
< void fixpath(gchar *source){
< 	if (source){
< 		gint i,len = strlen(source);
< 		for (i =0; i<len ;i++)
< 		{
< 			if (source[i]== 92){
< 				source[i]= 47;
< 			}
< 		}
< 	}
< }
< */
---
> /* Bluefish HTML Editor
>  * bf_lib.c - non-GUI general functions
>  *
>  * Copyright (C) 2000-2004 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> /* #define DEBUG */
> 
> #include <gtk/gtk.h>
> #include <unistd.h> /* chdir() */
> #include <stdio.h> /* fopen() */
> #include <ctype.h> /* toupper */
> #include <string.h> /* strrchr strncmp memmove strncat*/
> #include <sys/stat.h> /* S_IFDIR */
> #include <errno.h> 	/* errno */
> 
> #include "bluefish.h"  /* for DEBUG_MSG and stuff like that */
> #include "bf_lib.h"  /* myself */
> 
> #ifdef WIN32
> #define DIRSTR "\\"
> #define DIRCHR 92
> #else
> #define DIRSTR "/"
> #define DIRCHR '/'
> #endif
> /**
>  * get_filename_on_disk_encoding
>  *
>  * if gnome_vfs is defined, this function will also escape local paths
>  * to make sure we can open files with a # in their name
>  */
> gchar *get_filename_on_disk_encoding(const gchar *utf8filename) {
> 	if (utf8filename) {
> 		GError *gerror=NULL;
> 		gsize b_written;
> 		gchar *ondiskencoding = g_filename_from_utf8(utf8filename,-1, NULL,&b_written,&gerror);
> 		if (gerror) {
> 			g_print(_("Bluefish has trouble reading the filenames. Try to set the environment variable G_BROKEN_FILENAMES=1\n"));
> 			ondiskencoding = g_strdup(utf8filename);
> 		}
> #ifdef HAVE_GNOME_VFS
> 		/* convert local path's */
> 		if (ondiskencoding[0] == '/') {
> 			gchar *tmp = gnome_vfs_escape_path_string(ondiskencoding);
> 			g_free(ondiskencoding);
> 			ondiskencoding = tmp;
> 		}
> #endif /* HAVE_GNOME_VFS */
> 		return ondiskencoding;
> 	}
> 	return NULL;
> }
> 
> gchar *get_utf8filename_from_on_disk_encoding(const gchar *encodedname) {
> 	if (encodedname) {
> 		GError *gerror=NULL;
> 		gsize b_written;
> 		gchar *ondiskencoding = g_filename_to_utf8(encodedname,-1, NULL,&b_written,&gerror);
> 		if (gerror) {
> 			g_print(_("Bluefish has trouble reading the filenames. Try to set the environment variable G_BROKEN_FILENAMES=1\n"));
> 			ondiskencoding = g_strdup(encodedname);
> 		}
> 		DEBUG_MSG("get_utf8filename_from_on_disk_encoding, utf8filename=%s\n",ondiskencoding);
> 		return ondiskencoding;
> 	}
> 	return NULL;
> }
> 
> gboolean string_is_color(const gchar *color) {
> 	GdkColor gcolor;
> 	return gdk_color_parse(color, &gcolor);
> }
> 
> static void fill_rwx(short unsigned int bits, char *chars) {
> 	chars[0] = (bits & S_IRUSR) ? 'r' : '-';
> 	chars[1] = (bits & S_IWUSR) ? 'w' : '-';
> 	chars[2] = (bits & S_IXUSR) ? 'x' : '-';
> }
> static void fill_setid(short unsigned int bits, char *chars) {
> #ifdef S_ISUID
> 	if (bits & S_ISUID) {
> 		/* Set-uid, but not executable by owner.  */
> 		if (chars[3] != 'x') chars[3] = 'S';
> 		else chars[3] = 's';
> 	}
> #endif
> #ifdef S_ISGID
> 	if (bits & S_ISGID) {
> 		/* Set-gid, but not executable by group.  */
> 		if (chars[6] != 'x') chars[6] = 'S';
> 		else chars[6] = 's';
> 	}
> #endif
> #ifdef S_ISVTX
> 	if (bits & S_ISVTX) {
> 		/* Sticky, but not executable by others.  */
> 		if (chars[9] != 'x') chars[9] = 'T';
> 		else chars[9] = 't';
> 	}
> #endif
> }
> gchar *filemode_to_string(mode_t statmode) {
> 	gchar *str = g_malloc0(10);
>  	/* following code "adapted" from GNU filemode.c program */
> 	fill_rwx((statmode & 0700) << 0, &str[0]);
> 	fill_rwx((statmode & 0070) << 3, &str[3]);
> 	fill_rwx((statmode & 0007) << 6, &str[6]);
> 	fill_setid(statmode, str);
> 	return str;
> }
> 
> 
> /**
>  * return_root_with_protocol:
>  * @url: #const gchar* with the url 
>  *
>  * returns the root of the url, including its trailing slash
>  * this might be in the form
>  * - "protocol://server:port/"
>  * - "/"
>  * - NULL, if the url contains no url, nor does it start with a / character
>  *
>  * if there is no trailing slash, this function will return the root WITH a
>  * trailing slash appended!!
>  *
>  * Return value: #gchar* newly allocated, or NULL
>  */
> gchar *return_root_with_protocol(const gchar *url) {
> 	gchar *q;
> 	if (!url) return NULL;
> 	q = strchr(url,':');
> 	if (q && *(q+1)=='/' && *(q+2)=='/' && *(q+3)!='\0') {
> 		/* we have a protocol */
> 		gchar *root = strchr(q+3, '/');
> 		if (root) return g_strndup(url, root - url + 1);
> 		/* if there is no third slash character, we probably
> 		have an url like http://someserver so we will append 
> 		the slash ourselves */
> 		return g_strconcat(url, "/",NULL);
> 	} else if (url[0] == '/') {
> 		/* no protocol, return / */
> 		return g_strdup("/");
> 	}
> 	/* no root known */
> 	return NULL;
> }
> 
> /**
>  * pointer_switch_addresses:
>  * a: #gpointer;
>  * b: #gpointer
>  *
>  * after this call, a will contain the address previously in a
>  * and b will contain the address previously in b
>  *
>  * Return value: void
>  */
> #ifdef __GNUC__
> __inline__ 
> #endif
> void pointer_switch_addresses(gpointer *a, gpointer *b) {
> 	gpointer c;
> 	DEBUG_MSG("pointer_switch_addresses, before, a=%p, b=%p\n",a,b);
> 	c = *a;
> 	*a = *b;
> 	*b = c;
> 	DEBUG_MSG("pointer_switch_addresses, after, a=%p, b=%p\n",a,b);
> }
> 
> /**
>  * list_switch_order:
>  * @first: a #GList * item
>  * @second: a #GList * item
>  * 
>  * this function will switch place of these two list items
>  * actually not the items themselves, but the data they are 
>  * pointer to is switched
>  * 
>  * Return value: void
>  **/
> void list_switch_order(GList *first, GList *second) {
> 	gpointer tmp;
> 	tmp = first->data;
> 	first->data = second->data;
> 	second->data = tmp;
> }
> /**
>  * file_copy:
>  * @source: a #gchar * containing the source filename
>  * @dest: a #gchar * containing the destination filename
>  * 
>  * copies the contents of the file source to dest
>  * this function is Gnome-VFS aware, so it will work on URI's
>  * 
>  * Return value: gboolean, TRUE if the function succeeds
>  **/
> #ifdef HAVE_GNOME_VFS
> #define BYTES_TO_PROCESS 8196
> gboolean file_copy(gchar *source, gchar *dest) {
> 	GnomeVFSHandle *read_handle, *write_handle;
> 	GnomeVFSFileSize bytes_read, bytes_written;
> 	guint buffer[BYTES_TO_PROCESS];
> 	GnomeVFSResult result;
> 	gchar *OnDiEn_source, *OnDiEn_dest;
> 	OnDiEn_source = get_filename_on_disk_encoding(source);
> 	OnDiEn_dest = get_filename_on_disk_encoding(dest);
> 	
> 	result = gnome_vfs_open(&read_handle, OnDiEn_source, GNOME_VFS_OPEN_READ);
> 	g_free(OnDiEn_source);
> 	if (result != GNOME_VFS_OK) return FALSE;
> 	result = gnome_vfs_create(&write_handle, OnDiEn_dest, GNOME_VFS_OPEN_WRITE, FALSE, 0644);
> 	g_free(OnDiEn_dest);
> 	if (result != GNOME_VFS_OK) {
> 		gnome_vfs_close(read_handle);
> 		return FALSE;
> 	}
> 	result = gnome_vfs_read (read_handle, buffer, BYTES_TO_PROCESS, &bytes_read);
> 	while (result == GNOME_VFS_OK) {
> 		result = gnome_vfs_write (write_handle, buffer, bytes_read, &bytes_written);
> 		if (result != GNOME_VFS_OK || bytes_written != bytes_read) {
> 			DEBUG_MSG("file_copy, return FALSE, write result=%d, written=%ld, read=%ld\n",result,(long)bytes_written,(long)bytes_read);
> 			gnome_vfs_close(write_handle);
> 			gnome_vfs_close(read_handle);
> 			return FALSE;
> 		}
> 		result = gnome_vfs_read(read_handle, buffer, BYTES_TO_PROCESS, &bytes_read);
> 	}
> 	gnome_vfs_close(write_handle);
> 	gnome_vfs_close(read_handle);
> 	return TRUE;
> }
> #else  /* HAVE_GNOME_VFS */
> gboolean file_copy(gchar *source, gchar *dest) {
> #ifdef DEVELOPMENT
> 	g_assert(source);
> 	g_assert(dest);
> #endif
> 	int c;
> 	FILE *in, *out;
> 	gchar *OnDiEn_source, *OnDiEn_dest;
> 	OnDiEn_source = get_filename_on_disk_encoding(source);
> 	OnDiEn_dest = get_filename_on_disk_encoding(dest);
> 
> 	in = fopen(OnDiEn_source, "r");
> 	g_free(OnDiEn_source);
> 	if (!in) {
> 		return FALSE;
> 	}
> 	out = fopen(OnDiEn_dest, "w");
> 	g_free(OnDiEn_dest);
> 	if (!out) {
> 		fclose(in);
> 		return FALSE;
> 	}
> 	while((c=fgetc(in)) != EOF) {
> 		fputc(c,out);
> 	}
> 	fclose(in);
> 	fclose(out);
> 	return TRUE;
> }
> #endif /* HAVE_GNOME_VFS */
> 
> static gint length_common_prefix(gchar *first, gchar *second) {
> 	gint i=0;
> 	while (first[i] == second[i] && first[i] != '\0') {
> 		i++;
> 	}
> 	return i;
> }
> /**
>  * find_common_prefix_in_stringlist:
>  * @stringlist: a #GList* with strings
>  * 
>  * tests every string in stringlist, and returns the length of the 
>  * common prefix all these strings have
>  *
>  * This is for example useful to find out if a list of filenames
>  * share the same base directory
>  * 
>  * Return value: #gint with number of common characters
>  **/
> gint find_common_prefixlen_in_stringlist(GList *stringlist) {
> 	gchar *firststring;
> 	gint commonlen;
> 	GList *tmplist;
> 	tmplist = g_list_first(stringlist);
> 	firststring = (gchar *)tmplist->data;
> 	commonlen = strlen(firststring);
> 	tmplist = g_list_next(tmplist);
> 	while(tmplist){
> 		gint testlen;
> 		gchar *secondstring = (gchar *)tmplist->data;
> 		testlen = length_common_prefix(firststring, secondstring);
> 		if (testlen < commonlen) {
> 			commonlen = testlen;
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return commonlen;
> }
> /**
>  * append_string_to_file:
>  * @filename: a #gchar * containing the destination filename
>  * @string: a #gchar * containing the string to append
>  * 
>  * opens the file filename in append mode, and appends the string
>  * no newline or anything else is appended, just the string
>  *
>  * DOES NOT YET SUPPORT GNOME_VFS !!!
>  * 
>  * Return value: gboolean, TRUE if the function succeeds
>  **/
> gboolean append_string_to_file(gchar *filename, gchar *string) {
> 	FILE *out;
> 	gchar *ondiskencoding = get_filename_on_disk_encoding(filename);
> 	out = fopen(ondiskencoding, "a");
> 	g_free(ondiskencoding);
> 	if (!out) {
> 		DEBUG_MSG("append_to_file, could not open file %s for append\n", filename);
> 		return FALSE;
> 	}
> 	fputs(string, out);
> 	fclose(out);
> 	return TRUE;
> }
> /**
>  * countchars:
>  * @string: a gchar * to count the chars in
>  * @chars: a gchar * with the characters you are interested in
>  *
>  * this function will count every character in string that is also in chars
>  * 
>  * Return value: guint with the number of characters found
>  **/
> guint countchars(const gchar *string, const gchar *chars) {
> 	guint count=0;
> 	gchar *newstr = strpbrk(string, chars);
> 	while(newstr) {
> 		count++;
> 		newstr = strpbrk(++newstr, chars);
> 	}
> 	DEBUG_MSG("countchars, returning %d\n",count);
> 	return count;
> }
> static gint table_convert_char2int_backend(Tconvert_table *table, const gchar *my_char
> 		, Ttcc2i_mode mode, int (*func)(const gchar *arg1, const gchar *arg2) ) {
> 	Tconvert_table *entry;
> 	entry = table;
> 	while (entry->my_char) {
> 		if (func(my_char,entry->my_char)==0) {
> 			return entry->my_int;
> 		}
> 		entry++;
> 	}
> 	return -1;
> }
> static int strfirstchar(const gchar *mychar, const gchar *tablechar) {
> 	return mychar[0] - tablechar[0];
> }
> static int strmycharlen(const gchar *mychar, const gchar *tablechar) {
> 	return strncmp(mychar,tablechar,strlen(mychar));
> }
> static int strfull_match_gettext(const gchar *mychar, const gchar *tablechar) {
> 	return strcmp(mychar,_(tablechar));
> }
> /**
>  * table_convert_char2int:
>  * @table: a #tconvert_table * with strings and integers
>  * @my_char: a #gchar * containing the string to convert
>  * @mode: #Ttcc2i_mode
>  * 
>  * this function can be used to translate a string from some set (in table)
>  * to an integer
>  * 
>  * Return value: gint, found in table, or -1 if not found
>  **/
> gint table_convert_char2int(Tconvert_table *table, const gchar *my_char, Ttcc2i_mode mode) {
> 	switch (mode) {
> 	case tcc2i_firstchar:
> 		return table_convert_char2int_backend(table,my_char,mode,strfirstchar);
> 	case tcc2i_mycharlen:
> 		return table_convert_char2int_backend(table,my_char,mode,strmycharlen);
> 	case tcc2i_full_match:
> 		return table_convert_char2int_backend(table,my_char,mode,strcmp);
> 	case tcc2i_full_match_gettext:
> 		return table_convert_char2int_backend(table,my_char,mode,strfull_match_gettext);
> 	default:
> 		DEBUG_MSG("bug in call to table_convert_char2int()\n");
> 		return -1;
> 	}
> }
> /**
>  * table_convert_int2char:
>  * @table: a #tconvert_table * with strings and integers
>  * @my_int: a #gint containing the integer to convert
>  * 
>  * this function can be used to translate an integer from some set (in table)
>  * to a string
>  * WARNING: This function will return a pointer into table, it will 
>  * NOT allocate new memory
>  * 
>  * Return value: gchar * found in table, else NULL
>  **/
> gchar *table_convert_int2char(Tconvert_table *table, gint my_int) {
> 	Tconvert_table *entry;
> 	entry = table;
> 	while (entry->my_char) {
> 		if (my_int == entry->my_int) {
> 			return entry->my_char;
> 		}
> 		entry++;
> 	}
> 	return NULL;
> }
> /**
>  * expand_string:
>  * @string: a formatstring #gchar * to convert
>  * @specialchar: a const char to use as 'delimited' or 'special character'
>  * @table: a #Tconvert_table * array to use for conversion
>  * 
>  * this function can convert a format string with %0, %1, or \n, \t 
>  * into the final string, where each %number or \char entry is replaced 
>  * with the string found in table
>  *
>  * so this function is the backend for unescape_string() and 
>  * for replace_string_printflike()
>  *
>  * table is an array with last entry {0, NULL}
>  * 
>  * Return value: a newly allocated gchar * with the resulting string
>  **/
> gchar *expand_string(const gchar *string, const char specialchar, Tconvert_table *table) {
> 	gchar *p, *prev, *stringdup;
> 	gchar *tmp, *dest = g_strdup("");
> 
> 	stringdup = g_strdup(string); /* we make a copy so we can set some \0 chars in the string */
> 	prev = stringdup;
> 	DEBUG_MSG("expand_string, string='%s'\n", string);
> 	p = strchr(prev, specialchar);
> 	while (p) {
> 		gchar *converted;
> 		tmp = dest;
> 		*p = '\0'; /* set a \0 at this point, the pointer prev now contains everything up to the current % */
> 		DEBUG_MSG("expand_string, prev='%s'\n", prev);
> 		p++;
> 		converted = table_convert_int2char(table, *p);
> 		DEBUG_MSG("expand_string, converted='%s'\n", converted);
> 		dest = g_strconcat(dest, prev, converted, NULL);
> 		g_free(tmp);
> 		prev = ++p;
> 		p = strchr(p, specialchar);
> 	}
> 	tmp = dest;
> 	dest = g_strconcat(dest, prev, NULL); /* append the end to the current string */
> 	g_free(tmp);
> 	
> 	g_free(stringdup);
> 	DEBUG_MSG("expand_string, dest='%s'\n", dest);
> 	return dest;
> }
> gchar *replace_string_printflike(const gchar *string, Tconvert_table *table) {
> 	return expand_string(string,'%',table);
> }
> 
> static gint tablesize(Tconvert_table *table) {
> 	Tconvert_table *tmpentry = table;
> 	while (tmpentry->my_char) tmpentry++;
> 	return (tmpentry - table);
> }
> /* for now this function can only unexpand strings with tables that contain only
> single character strings like "\n", "\t" etc. */
> gchar *unexpand_string(const gchar *original, const char specialchar, Tconvert_table *table) {
> 	gchar *tmp, *tosearchfor, *retval, *prev, *dest, *orig;
> 	Tconvert_table *tmpentry;
> 	
> 	orig = g_strdup(original);
> 	DEBUG_MSG("original='%s', strlen()=%d\n",original,strlen(original));
> 	tosearchfor = g_malloc(tablesize(table)+1);
> 	DEBUG_MSG("tablesize(table)=%d, alloc'ed %d bytes for tosearchfor\n",tablesize(table), tablesize(table)+1);
> 	tmp = tosearchfor;
> 	tmpentry = table;
> 	while(tmpentry->my_char != NULL) {
> 		*tmp = tmpentry->my_char[0]; /* we fill the search string with the first character */
> 		tmpentry++;
> 		tmp++;
> 	}
> 	*tmp = '\0';
> 	DEBUG_MSG("unexpand_string, tosearchfor='%s'\n",tosearchfor);
> 	DEBUG_MSG("alloc'ing %d bytes\n", (countchars(original, tosearchfor) + strlen(original) + 1));
> 	retval = g_malloc((countchars(original, tosearchfor) + strlen(original) + 1) * sizeof(gchar));
> 	dest = retval;
> 	prev = orig;
> 	/* now we go trough the original till we hit specialchar */
> 	tmp = strpbrk(prev, tosearchfor);
> 	while (tmp) {
> 		gint len = tmp - prev;
> 		gint mychar = table_convert_char2int(table, tmp, tcc2i_firstchar);
> 		DEBUG_MSG("unexpand_string, tmp='%s', prev='%s'\n",tmp, prev);
> 		if (mychar == -1) mychar = *tmp;
> 		DEBUG_MSG("unexpand_string, copy %d bytes and advancing dest\n",len);
> 		memcpy(dest, prev, len);
> 		dest += len;
> 		*dest = specialchar;
> 		dest++;
> 		*dest = mychar;
> 		dest++;
> 		prev=tmp+1;
> 		DEBUG_MSG("prev now is '%s'\n",prev);
> 		tmp = strpbrk(prev, tosearchfor);
> 	}
> 	DEBUG_MSG("unexpand_string, copy the rest (%s) to dest\n",prev);
> 	memcpy(dest,prev,strlen(prev)+1); /* this will also make sure there is a \0 at the end */
> 	DEBUG_MSG("unexpand_string, retval='%s'\n",retval);
> 	g_free(orig);
> 	g_free(tosearchfor);
> 	return retval;
> }
> /* if you change this table, please change escape_string() and unescape_string() and new_convert_table() in the same way */
> static Tconvert_table standardescapetable [] = {
> 	{'n', "\n"},
> 	{'t', "\t"},
> 	{'\\', "\\"},
> 	{'f', "\f"},
> 	{'r', "\r"},
> 	{'a', "\a"},
> 	{'b', "\b"},
> 	{'v', "\v"},
> 	{'n', "\n"},
> 	{':', ":"}, /* this double entry is there to make unescape_string and escape_string work efficient */
> 	{0, NULL}
> };
> gchar *unescape_string(const gchar *original, gboolean escape_colon) {
> 	gchar *string, *tmp=NULL;
> 	DEBUG_MSG("unescape_string, started\n");
> 	if (!escape_colon) {
> 		tmp = standardescapetable[9].my_char;
> 		standardescapetable[9].my_char = NULL;
> 	}
> 	string = expand_string(original,'\\',standardescapetable);
> 	if (!escape_colon) {
> 		standardescapetable[9].my_char = tmp;
> 	}
> 	return string;
> }
> gchar *escape_string(const gchar *original, gboolean escape_colon) {
> 	gchar *string, *tmp=NULL;
> 	DEBUG_MSG("escape_string, started\n");
> 	if (!escape_colon) {
> 		tmp = standardescapetable[9].my_char;
> 		standardescapetable[9].my_char = NULL;
> 	}
> 	string = unexpand_string(original,'\\',standardescapetable);
> 	if (!escape_colon) {
> 		standardescapetable[9].my_char = tmp;
> 	}
> 	return string;
> }
> Tconvert_table *new_convert_table(gint size, gboolean fill_standardescape) {
> 	gint realsize = (fill_standardescape) ? size + 10 : size;
> 	Tconvert_table * tct = g_new(Tconvert_table, realsize+1);
> 	DEBUG_MSG("new_convert_table, size=%d, realsize=%d,alloced=%d\n",size,realsize,realsize+1);
> 	if (fill_standardescape) {
> 		gint i;
> 		for (i=size;i<realsize;i++) {
> 			tct[i].my_int = standardescapetable[i-size].my_int;
> 			tct[i].my_char = g_strdup(standardescapetable[i-size].my_char);
> 		}
> 		DEBUG_MSG("new_convert_table, setting tct[%d] (i) to NULL\n",i);
> 		tct[i].my_char = NULL;
> 	} else {
> 		DEBUG_MSG("new_convert_table, setting tct[%d] (size) to NULL\n",size);
> 		tct[size].my_char = NULL;
> 	}
> 	return tct;
> }
> void free_convert_table(Tconvert_table *tct) {
> 	Tconvert_table *tmp = tct;
> 	while (tmp->my_char) {
> 		DEBUG_MSG("free_convert_table, my_char=%s\n",tmp->my_char);
> 		g_free(tmp->my_char);
> 		tmp++;
> 	}
> 	DEBUG_MSG("free_convert_table, free table %p\n",tct);
> 	g_free(tct);
> }
> /**************************************************/
> /* byte offset to UTF8 character offset functions */
> /**************************************************/
> 
> /*
> html files usually have enough cache at size 4
> large php files, a cache of 
> 	10 resulted in 160% of the buffer to be parsed
> 	12 resulted in 152% of the buffer to be parsed
> 	14 resulted in 152% of the buffer to be parsed
> 	16 resulted in 152% of the buffer to be parsed
> so we keep it at 10 for the moment
> */
> #define UTF8_OFFSET_CACHE_SIZE 10
> /* #define UTF8_BYTECHARDEBUG */
> 
> typedef struct {
> 	gchar *last_buf;
> 	/* the two arrays must be grouped and in this order, because they are moved back 
> 	one position in ONE memmove() call */
> 	guint  last_byteoffset[UTF8_OFFSET_CACHE_SIZE];
> 	guint  last_charoffset[UTF8_OFFSET_CACHE_SIZE];
> #ifdef UTF8_BYTECHARDEBUG
> 	guint numcalls_since_reset;
> 	unsigned long long int numbytes_parsed;
> 	guint numcalls_cached_since_reset;
> 	unsigned long long int numbytes_cached_parsed;
> #endif
> } Tutf8_offset_cache;
> 
> static Tutf8_offset_cache utf8_offset_cache;
> 
> /**
>  * utf8_offset_cache_reset:
>  * 
>  * this function will reset the utf8 offset cache used by 
>  * utf8_byteoffset_to_charsoffset_cached()
>  *
>  * normally this is done automatically if utf8_byteoffset_to_charsoffset_cached() 
>  * is called with a new buffer. But if you ever call that function for 
>  * the same buffer but the buffer is changed in the meantime you have 
>  * to reset it manually using utf8_offset_cache_reset()
>  * 
>  * Return value: void
>  **/
> #ifdef __GNUC__
> __inline__ 
> #endif
> void utf8_offset_cache_reset() {
> #ifdef UTF8_BYTECHARDEBUG
> 	g_print("UTF8_BYTECHARDEBUG: called %d times for total %llu bytes\n",utf8_offset_cache.numcalls_since_reset,utf8_offset_cache.numbytes_parsed);
> 	g_print("UTF8_BYTECHARDEBUG: cache HIT %d times, reduced to %llu bytes, cache size %d\n",utf8_offset_cache.numcalls_cached_since_reset,utf8_offset_cache.numbytes_cached_parsed,UTF8_OFFSET_CACHE_SIZE);
> #endif
> 	memset(&utf8_offset_cache, 0, sizeof(Tutf8_offset_cache));
> }
> /**
>  * utf8_byteoffset_to_charsoffset_cached:
>  * @string: the gchar * you want to count
>  * @byteoffset: glong with the byteoffset you want the charoffset for
>  * 
>  * this function calculates the UTF-8 character offset in a string for
>  * a given byte offset
>  * It uses caching to speedup multiple calls for the same buffer, the cache
>  * is emptied if you change to another buffer. If you use the same buffer but 
>  * change it inbetween calls, you have to reset it yourself using
>  * the utf8_offset_cache_reset() function
>  *
>  **** the result is undefined if the provided byteoffset is in the middle of a UTF8 character ***
>  * 
>  * Return value: guint with character offset
>  **/
> guint utf8_byteoffset_to_charsoffset_cached(gchar *string, glong byteoffset) {
> 	guint retval;
> 	gint i = UTF8_OFFSET_CACHE_SIZE-1;
> 	if (byteoffset ==0) return 0;
> 
> 	if (string != utf8_offset_cache.last_buf) {
> 		utf8_offset_cache_reset();
> 		utf8_offset_cache.last_buf = string;
> 	}
> #ifdef DEBUG
> 	DEBUG_MSG("utf8_byteoffset_to_charsoffset_cached, string %p has strlen %d, looking for byteoffset %ld, starting in cache at i=%d\n", string, strlen(string),byteoffset,i);
> #endif
> 
> 	while (i > 0 && utf8_offset_cache.last_byteoffset[i] > byteoffset) {
> 		i--;
> 	}
> 	
> 	if (i > 0) {
> 		if (utf8_offset_cache.last_byteoffset[i] == byteoffset) {
> #ifdef DEBUG
> 	DEBUG_MSG("byteoffset %ld is in the cache at i=%d, returning %d\n",byteoffset,i,utf8_offset_cache.last_charoffset[i]);
> #endif
> 			return utf8_offset_cache.last_charoffset[i];
>        }
>        /* if the byteoffset is in the middle of a multibyte character, this line will fail (but
> 	       we are not supposed to get called in the middle of a character)*/
> 		retval = g_utf8_pointer_to_offset(string+utf8_offset_cache.last_byteoffset[i], string+byteoffset)+utf8_offset_cache.last_charoffset[i];
> #ifdef UTF8_BYTECHARDEBUG
> 		utf8_offset_cache.numbytes_parsed += (byteoffset - utf8_offset_cache.last_byteoffset[i]);
> 		utf8_offset_cache.numbytes_cached_parsed += (byteoffset - utf8_offset_cache.last_byteoffset[i]);
> 		utf8_offset_cache.numcalls_cached_since_reset++;
> #endif
> 	} else {
> 		retval = g_utf8_pointer_to_offset(string, string+byteoffset);
> #ifdef UTF8_BYTECHARDEBUG
> 		utf8_offset_cache.numbytes_parsed += byteoffset;
> #endif
> 	}
> 	DEBUG_MSG(" and byteoffset %ld has charoffset %d\n",byteoffset,retval);
> 	if (i == (UTF8_OFFSET_CACHE_SIZE-1)) {
> 		/* add this new calculation to the cache */
> 		/* this is a nasty trick to move all guint entries one back in the array, so we can add the new one */
> 		memmove(&utf8_offset_cache.last_byteoffset[0], &utf8_offset_cache.last_byteoffset[1], (UTF8_OFFSET_CACHE_SIZE+UTF8_OFFSET_CACHE_SIZE-1)*sizeof(guint));
> 
> 		utf8_offset_cache.last_byteoffset[UTF8_OFFSET_CACHE_SIZE-1] = byteoffset;
> 		utf8_offset_cache.last_charoffset[UTF8_OFFSET_CACHE_SIZE-1] = retval;
> 	}
> #ifdef UTF8_BYTECHARDEBUG
> 	utf8_offset_cache.numcalls_since_reset++;
> #endif
> 	return retval;
> }
> 
> /**
>  * escapestring:
>  * @original: a gchar * to escape
>  * @delimiter: a gchar that needs escaping, use '\0' if you don't need one
>  *
>  * this function will backslash escape \n, \t, and \ characters, and if 
>  * there is a delimiter it will also be escaped
>  * 
>  * Return value: a newly allocated gchar * that is escaped
>  **/
> /*gchar *old_escapestring(gchar *original, gchar delimiter)
> {
> 	gchar *tmp, *newstring, *escapedchars;
> 	guint newsize, pos=0;
> 
> 	* count the size of the new string *
> 	escapedchars = g_strdup_printf("\n\t\\%c", delimiter);
> 	DEBUG_MSG("escapestring, escapedchars=%s, extra length=%d\n", escapedchars, countchars(original, escapedchars));
> 	newsize = countchars(original, escapedchars) + strlen(original) + 1;
> 	newstring = g_malloc0(newsize * sizeof(gchar));
> 	g_free(escapedchars);
> 	DEBUG_MSG("escapestring, original=%s, newsize=%d\n", original, newsize);
> 
> 	tmp = original;
> 	while (*tmp != '\0') {
> 		switch (*tmp) {
> 		case '\\':
> 			strcat(newstring, "\\\\");
> 			pos +=2;
> 		break;
> 		case '\n':
> 			strcat(newstring, "\\n");
> 			pos +=2;
> 		break;
> 		case '\t':
> 			strcat(newstring, "\\t");
> 			pos +=2;
> 		break;
> 		default:
> 			if (*tmp == delimiter) {
> 				newstring[pos] = '\\';
> 				newstring[pos+1] = delimiter;
> 				pos +=2;			
> 			} else {
> 				newstring[pos] = *tmp;
> 				pos++;
> 			}
> 		break;
> 		}
> 		newstring[pos] = '\0';
> 		tmp++;
> 	}
> 	DEBUG_MSG("escapestring, newstring = %s\n", newstring);
> 	return newstring;
> }*/
> 
> /**
>  * unescapestring:
>  * @original: a gchar * to unescape
>  *
>  * this function will backslash unescape \n, \t, and \\ sequences to 
>  * their characters, and if there is any other escaped character 
>  * it will be replaced without the backslash
>  * 
>  * Return value: a newly allocated gchar * that is unescaped
>  **/
> /*gchar *old_unescapestring(gchar *original)
> {
> 	gchar *tmp1, *tmp2, *newstring;
> 	guint newsize;
> 	gint escaped;
> 
> 	newsize = strlen(original) + 1;
> 	newstring = g_malloc0(newsize * sizeof(gchar));
> 	DEBUG_MSG("unescapestring, original=%s, newsize = %d\n", original, newsize);
> 
> 	tmp1 = original;
> 	tmp2 = newstring;
> 	escaped = 0;
> 	while (*tmp1 != '\0') {
> 		if (escaped) {
> 			switch (*tmp1) {
> 			case '\\':
> 				*tmp2++ = '\\';
> 			break;
> 			case 'n':
> 				*tmp2++ = '\n';
> 			break;
> 			case 't':
> 				*tmp2++ = '\t';
> 			break;
> 			default:
> 				*tmp2++ = *tmp1;
> 			break;
> 			}
> 
> 			escaped = 0;
> 		} else {
> 			if (*tmp1 == '\\')
> 				escaped = 1;
> 			else
> 				*tmp2++ = *tmp1;
> 		}
> 		tmp1++;
> 	}
> 	DEBUG_MSG("unescapestring, newstring = %s\n", newstring);
> 	return newstring;
> }*/
> 
> /**
>  * strip_any_whitespace:
>  * @string: a gchar * to strip
>  *
>  * strips any double chars defined by isspace() from the string, 
>  * only single spaces are returned
>  * the same string is returned, no memory is allocated in this function
>  * 
>  * Return value: the same gchar * as passed to the function
>  **/
> gchar *strip_any_whitespace(gchar *string) {
> 	gint count=0, len;
> 
> #ifdef DEVELOPMENT
> 	g_assert(string);
> #endif
> 
> 	DEBUG_MSG("strip_any_whitespace, starting string='%s'\n", string);
> 	len = strlen(string);
> 	while(string[count]) {
> 		if (isspace((char)string[count])) {
> 			string[count] = ' ';
> 			if (string[count+1] && isspace((char)string[count+1])) {
> 				gint fcount = count;
> 				while (string[fcount] && isspace((char)string[fcount])) {
> 					fcount++;
> 				}
> 				DEBUG_MSG("strip_any_whitespace, found %d spaces\n", fcount - count);
> 				memmove(&string[count+1], &string[fcount], len - (count+1));
> 				string[len- (fcount-count)+1] = '\0';
> 				DEBUG_MSG("strip_any_whitespace, after memmove, string='%s'\n", string);
> 			}
> 		}
> 		count++;
> 	}
> 	g_strstrip(string);
> 	DEBUG_MSG("strip_any_whitespace, returning string='%s'\n", string);
> 	return string;
> }
> /**
>  * trunc_on_char:
>  * @string: a #gchar * to truncate
>  * @which_char: a #gchar with the char to truncate on
>  *
>  * Returns a pointer to the same string which is truncated at the first
>  * occurence of which_char
>  * 
>  * Return value: the same gchar * as passed to the function
>  **/
> gchar *trunc_on_char(gchar * string, gchar which_char)
> {
> 	gchar *tmpchar = string;
> 	while(*tmpchar) {
> 		if (*tmpchar == which_char) {
> 			*tmpchar = '\0';
> 			return string;
> 		}
> 		tmpchar++;
> 	}
> 	return string;
> }
> /* gchar *strip_common_path(char *image_fn, char *html_fn)
>  * returns a newly allocated string containing the the to_filename
>  * but all the common path with from_filename is removed 
>  *
>  * IS THIS IN USE ?? OBVIOUSLY NOT BECAUSE I CAN REMOVE IT */ 
> /*gchar *strip_common_path(char *to_filename, char *from_filename)
> {
> 	gchar *tempstr;
> 	int count, count2, dir_length;
> 
> 	count = 0;
> 	tempstr = strrchr(to_filename, DIRCHR);
> 	dir_length = strlen(to_filename) - strlen(tempstr);
> 	dir_length += 1;
> 	DEBUG_MSG("strip_common_path, dir_lenght=%d\n", dir_length);
> 	while ((strncmp(to_filename, from_filename, count + 1)) == 0) {
> 		count++;
> 		if (count > dir_length) {
> 			count = dir_length;
> 			break;
> 		}
> 	}
> 	while (to_filename[count - 1] != DIRCHR)
> 		count--;
> 	DEBUG_MSG("strip_common_path, equal count = %d\n", count);
> 	count2 = strlen(to_filename);
> 	tempstr = g_malloc(count2 - count + 2);
> 	memcpy(tempstr, &to_filename[count], count2 - count + 2);
> 	DEBUG_MSG("strip_common_path, tempstr= %s, should be %d long\n", tempstr, count2 - count);
> 	return tempstr;
> } */
> 
> /**
>  * most_efficient_filename:
>  * @filename: a gchar * with a possibly inefficient filename like /hello/../tmp/../myfile
>  *
>  * tries to eliminate any dir/../ combinations in filename
>  * this function could do evern better, it should also remove /./ entries
>  * 
>  * Return value: the same gchar * as passed to the function
>  **/
> gchar *most_efficient_filename(gchar *filename) {
> 	gint i,j, len;
> #ifdef WIN32
> 	//bf_chrrepl(filename,"\\","/");
> #endif
> 	DEBUG_MSG("most_efficient_filename, 1 filename=%s\n", filename);
> 	len = strlen(filename);
> 	for (i=0; i < len-4; i++) {
> /*		DEBUG_MSG("most_efficient_filename, i=%d\n", i); */
> 		if (strncmp(&filename[i], "/../", 4) == 0) {
> 			for (j=1; j < i; j++) {
> 				if ((filename[i - j] == DIRCHR) || (i==j)) {
> 					DEBUG_MSG("most_efficient_filename, &filename[%d-%d]=%s, &filename[%d+3]=%s, %d-%d-4=%d\n", i,j,&filename[i-j],i, &filename[i+3], len, j, len-j-4);
> 					memmove(&filename[i-j], &filename[i+3], len-i);
> 					j=i;
> 					i--;
> 				}
> 			}
> 		}
> 	}
> 	DEBUG_MSG("most_efficient_filename, 3 filename=%s\n", filename);
> 	return filename;
> }
> 
> /**
>  * create_relative_link_to:
>  * @current_filepath: a #gchar * with the current filename
>  * @link_to_filepath: a #gchar * with a file to link to
>  *
>  * creates a newly allocated relative link from current_filepath 
>  * to link_to_filepath
>  *
>  * if current_filepath == NULL it returns the most efficient filepath 
>  * for link_to_filepath
>  *
>  * if link_to_filepath == NULL it will return NULL
>  *
>  * Return value: a newly allocated gchar * with the relative link
>  **/
> gchar *create_relative_link_to(gchar * current_filepath, gchar * link_to_filepath)
> {
> 	gchar *returnstring = NULL;
> 	gchar *eff_current_filepath, *eff_link_to_filepath;
> 	gint common_lenght, maxcommonlen;
> 	gint current_filename_length, link_to_filename_length, current_dirname_length, link_to_dirname_length;
> 	gint count, deeper_dirs;
> 
> 	if (!current_filepath){
> 		returnstring = most_efficient_filename(g_strdup(link_to_filepath));
> 		return returnstring;
> 	}
> 	if (!link_to_filepath) {
> 		return NULL;
> 	}
> 	eff_current_filepath = most_efficient_filename(g_strdup(current_filepath));
> 	eff_link_to_filepath = most_efficient_filename(g_strdup(link_to_filepath));
> 	DEBUG_MSG("eff_current: '%s'\n",eff_current_filepath);
> 	DEBUG_MSG("eff_link_to: '%s'\n",eff_link_to_filepath);
> 	/* get the size of the directory of the current_filename */
> 	current_filename_length = strlen(strrchr(eff_current_filepath, DIRCHR))-1;
> 	link_to_filename_length = strlen(strrchr(eff_link_to_filepath, DIRCHR))-1;
> 	DEBUG_MSG("create_relative_link_to, filenames: current: %d, link_to:%d\n", current_filename_length,link_to_filename_length); 
> 	current_dirname_length = strlen(eff_current_filepath) - current_filename_length;
> 	link_to_dirname_length = strlen(eff_link_to_filepath) - link_to_filename_length;
> 	DEBUG_MSG("create_relative_link_to, dir's: current: %d, link_to:%d\n", current_dirname_length, link_to_dirname_length); 
> 
> 	if (current_dirname_length < link_to_dirname_length) {
> 		maxcommonlen = current_dirname_length;
> 	} else {
> 		maxcommonlen = link_to_dirname_length;
> 	}
> 	
> 	/* first lets get the common basedir for both dir+file  by comparing the
> 	   common path in the directories */
> 	common_lenght = 0;
> 	while ((strncmp(eff_current_filepath, eff_link_to_filepath, common_lenght + 1)) == 0) {
> 		common_lenght++;
> 		if (common_lenght >= maxcommonlen) {
> 			common_lenght = maxcommonlen;
> 			break;
> 		}
> 	}
> 	DEBUG_MSG("create_relative_link_to, common_lenght=%d (not checked for directory)\n", common_lenght);
> 	/* this is the common length, but we need the common directories */
> 	if (eff_current_filepath[common_lenght] != DIRCHR) {
> 		gchar *ltmp = &eff_current_filepath[common_lenght];
> 		while ((*ltmp != DIRCHR) && (common_lenght > 0)) {
> 			common_lenght--;
> 			ltmp--;
> 		}
> 	}
> 	DEBUG_MSG("create_relative_link_to, common_lenght=%d (checked for directory)\n", common_lenght);
> 
> 	/* now we need to count how much deeper (in directories) the current_filename
> 	   is compared to the link_to_file, that is the amount of ../ we need to add */
> 	deeper_dirs = 0;
> 	for (count = common_lenght+1; count <= current_dirname_length; count++) {
> 		if (eff_current_filepath[count] == DIRCHR) {
> 			deeper_dirs++;
> 			DEBUG_MSG("create_relative_link_to, on count=%d, deeper_dirs=%d\n", count, deeper_dirs);
> 		}
> 	}
> 	DEBUG_MSG("create_relative_link_to, deeper_dirs=%d\n", deeper_dirs);
> 
> 	/* now we know everything we need to know we can create the relative link */
> 	returnstring = g_malloc0((strlen(link_to_filepath) - common_lenght + 3 * deeper_dirs + 1) * sizeof(gchar *));
> 	count = deeper_dirs;
> 	while (count) {
> 		strcat(returnstring, "../");
> 		count--;
> 	}
> 	strcat(returnstring, &eff_link_to_filepath[common_lenght+1]);
> 	DEBUG_MSG("create_relative_link_to, returnstring=%s\n", returnstring);
> 	g_free(eff_current_filepath);
> 	g_free(eff_link_to_filepath);
> 	return returnstring;
> }
> #ifdef HAVE_GNOME_VFS
> #define STRIP_FILE_URI
> #endif
> #ifdef HAVE_ATLEAST_GTK_2_4
> #define STRIP_FILE_URI
> #endif
> /**
>  * create_full_path:
>  * @filename: a gchar * with the (relative or not) filename
>  * @basedir: a gchar * with a basedir or NULL for current dir
>  *
>  * if filename is already absolute, it returns it
>  * else it will use basedir if available, else the current dir
>  * to add to the filename to form the full path
>  *
>  * for URL's it will simply return a strdup(), except for file:// URL's, 
>  * there the file:// bit is stripped and 
>  * IF YOU HAVE GNOME_VFS any %XX sequenves are converted
>  * so if you DON'T have gnome_vfs, you should not feed file:// uri's!!
>  *
>  * it does use most_efficient_filename() to remote unwanted dir/../ entries
>  *
>  * Return value: a newly allocated gchar * with the full path
>  **/
> gchar *create_full_path(const gchar * filename, const gchar *basedir) {
> 	gchar *absolute_filename;
> 	gchar *tmpcdir;
> 
> 	if (!filename) return NULL;
> 	DEBUG_MSG("create_full_path, filename=%s, basedir=%s\n", filename, basedir);
> #ifdef STRIP_FILE_URI
> 	if (strchr(filename, ':') != NULL) { /* it is an URI!! */
> 		DEBUG_MSG("create_full_path, %s is an URI\n",filename);
> 		if (strncmp(filename, "file://", 7)==0) {
> #ifdef HAVE_GNOME_VFS
> 			return gnome_vfs_get_local_path_from_uri(filename);
> #else
> 			/* THIS IS A BUG, IF YOU DON'T HAVE GNOME_VFS BUT YOU DO HAVE 
> 			GTK-2.4 A %21 OR SOMETHING LIKE THAT IS NOW NOT CONVERTED !!!!!!!!! */
> 			return g_strdup(filename+7); /* file:// URI's are never relative paths */
> #endif
> 		}
> 		return g_strdup(filename); /* cannot do this on remote paths */
> 	}
> #endif /* HAVE_GNOME_VFS */
> 	if (g_path_is_absolute(filename)) {
> 		absolute_filename = g_strdup(filename);
> 	} else {
> 		if (basedir) {
> 			tmpcdir = ending_slash(basedir);
> 		} else {
> 			gchar *curdir = g_get_current_dir();
> 			tmpcdir = ending_slash(curdir);
> 			g_free(curdir);
> 		}
> 		absolute_filename = g_strconcat(tmpcdir, filename, NULL);
> 		g_free(tmpcdir);
> 	}
> 	absolute_filename = most_efficient_filename(absolute_filename);
> 	return absolute_filename;
> }
> 
> /**
>  * ending_slash:
>  * @dirname: a #const gchar * with a diretory name
>  *
>  * makes sure the last character of the newly allocated 
>  * string it returns is a '/'
>  *
>  * Return value: a newly allocated gchar * dirname that does end on a '/'
>  **/
> gchar *ending_slash(const gchar *dirname) {
> 	if (!dirname) {
> 		return g_strdup("");
> 	}
> 
> 	if (dirname[strlen(dirname)-1] == DIRCHR) {
> 		return g_strdup(dirname);
> 	} else {
> 		return g_strconcat(dirname, DIRSTR, NULL);
> 	}
> }
> /**
>  * path_get_dirname_with_ending_slash:
>  * @filename: a #const gchar * with a file path
>  *
>  * returns a newly allocated string, containing everything up to 
>  * the last '/' character, including that character itself.
>  *
>  * if no '/' character is found it returns NULL
>  *
>  * Return value: a newly allocated gchar * dirname that does end on a '/', or NULL on failure
>  **/
> gchar *path_get_dirname_with_ending_slash(const gchar *filename) {
> 	gchar *tmp = strrchr(filename, DIRCHR);
> 	if (tmp) {
> 		return g_strndup(filename, (tmp - filename + 1));
> 	} else {
> 		return NULL;
> 	}
> }
> 
> /**
>  * file_exists_and_readable:
>  * @filename: a #const gchar * with a file path
>  *
>  * tests if the file exists, and  if it is readable, the last
>  * check is not reliable, it does not check all the groups you are
>  * in, so change this function before you rely on that check!
>  *
>  * this function is Gnome-VFS aware, so it will work on URI's
>  *
>  * Return value: gboolean, TRUE if readable, else FALSE
>  **/
> gboolean file_exists_and_readable(const gchar * filename) {
> 	gchar *ondiskencoding;
> 	gboolean retval=TRUE;
> #ifdef DEVELOPMENT
> 	g_assert(filename);
> #endif
> 	if (!filename || strlen(filename) < 2) {
> 		DEBUG_MSG("file_exists_and_readable, strlen(filename) < 2 or no filename!!!!\n");
> 		return FALSE;
> 	}
> 	DEBUG_MSG("file_exists_and_readable, filename(%p)=\"%s\", strlen(filename)=%d\n", filename, filename, strlen(filename));
> 	ondiskencoding = get_filename_on_disk_encoding(filename);
> 	DEBUG_MSG("file_exists_and_readable, ondiskencoding='%s'\n",ondiskencoding);
> #ifndef WIN32
> #ifdef HAVE_GNOME_VFS
> 	{
> 		GnomeVFSURI* uri;
> 		uri = gnome_vfs_uri_new(ondiskencoding);
> 		retval = gnome_vfs_uri_exists(uri);
> 		DEBUG_MSG("gnome_vfs_uri has path %s\n",gnome_vfs_uri_get_path(uri));
> 		gnome_vfs_uri_unref(uri);
> 		DEBUG_MSG("file_exists_and_readable, return %d for %s\n",retval,filename);
> 	}
> #else /* HAVE_GNOME_VFS */
> 	{
> 		struct stat naamstat;
> 		errno = 0;
> 		retval = ((stat(ondiskencoding, &naamstat) == 0) && (errno == 0));
> 		DEBUG_MSG("file_exists_and_readable, retval=%d (ernno=%d) for %s\n",retval,errno,ondiskencoding);
> 	}
> #endif /* HAVE_GNOME_VFS */
> 	g_free(ondiskencoding);
> #endif /* WIN32 */
> 	return retval;
> }
> /**
>  * return_first_existing_filename:
>  * @filename: a #const gchar * with a filename
>  * @...: more filenames
>  *
>  * you can pass multiple filenames to this function, and it will return
>  * the first filename that really exists according to file_exists_and_readable()
>  *
>  * Return value: gchar * with the first filename found
>  **/
> gchar *return_first_existing_filename(const gchar *filename, ...) {
> 	va_list args;
> 	gchar *retval=NULL;
> 
> 	va_start(args, filename);
> 	while (filename) {
> 		if (file_exists_and_readable(filename)) {
> 			retval = g_strdup(filename);
> 			break;
> 		}
> 		filename = va_arg(args, gchar*);
> 	}
> 	va_end(args);
> 	return retval;
> }
> 
> /**
>  * filename_test_extensions:
>  * @extensions: a #gchar ** NULL terminated arrau of strings
>  * @filename: a #const gchar * with a filename
>  *
>  * tests if the filename matches one of the extensions passed in the NULL terminated array
>  * of strings
>  *
>  * Return value: gboolean, TRUE if the file has one of the extensions in the array
>  **/
> gboolean filename_test_extensions(gchar **extensions, gchar *filename) {
> 	if (!extensions) {
> 		return FALSE;
> 	}
> 	while (*extensions) {
> 		if (strncmp(&filename[strlen(filename)-strlen(*extensions)], *extensions, strlen(*extensions)) == 0 ) {
> 			return TRUE;
> 		}
> 		extensions++;
> 	}
> 	return FALSE;
> }
> 
> /**
>  * bf_str_repeat:
>  * @str: a #const gchar * 
>  * @number_of: a #gint
>  *
>  * returns a newly allocated string, 
>  * containing str repeated number_of times
>  *
>  * Return value: the newly allocated #gchar *
>  **/
> gchar *bf_str_repeat(const gchar * str, gint number_of) {
> 	gchar *retstr;
> 	gint len = strlen(str) * number_of;
> 	retstr = g_malloc(len + 1);
> 	retstr[0] = '\0';
> 	while (number_of) {
> 		strncat(retstr, str, len);
> 		number_of--;
> 	};
> 	return retstr;
> }
> 
> /**
>  * get_int_from_string:
>  * @string: a #const gchar * 
>  *
>  * tries to find a positive integer value in the string and returns it
>  * the string does not have to start or end with the integer
>  * it returns -1 if no integer was found somewhere in the string
>  *
>  * Return value: the found #gint, -1 on failure
>  **/
> gint get_int_from_string(gchar *string) {
> 	if (string) {
> 		gint faktor = 1, result=-1;
> 		gint i,len = strlen(string);
> 		for (i=len-1;i>=0;i--) {
> 			if ((string[i] < 58) && (string[i] > 47)) {
> 				if (result == -1) {
> 					result = 0;
> 				} else {
> 					faktor *= 10;
> 				}
> 				result += (((gint)string[i])-48)*faktor;
> 				DEBUG_MSG("get_int_from_string, set result to %d\n", result);
> 			} else {
> 				if (result !=-1) {
> 					return result;
> 				}
> 			}
> 		}
> 		return result;
> 	}
> 	return -1;
> }
> 
> /**
>  * create_secure_dir_return_filename:
>  *
>  * this function uses mkdir(name) to create a dir with permissions rwx------
>  * mkdir will fail if name already exists or is a symlink or something
>  * the name is chosen by tempnam() so the chance that mkdir() fails in
>  * a normal situation is minimal, it almost must be a hacking attempt
>  *
>  * the filename generated can safely be used for output of an external 
>  * script because the dir has rwx------ permissions
>  *
>  * Return value: a newly allocated #gchar * containing a temporary filename in a secure dir
>  **/
> gchar *create_secure_dir_return_filename() {
> 	gchar *name, *name2;
> 	DEBUG_MSG("create_secure_dir_return_filename,g_get_tmp_dir()=%s\n", g_get_tmp_dir());
> 	/* it is SAFE to use tempnam() here, because we don't open a file with that name,
> 	 * we create a directory with that name. mkdir() will FAIL if this name is a hardlink
> 	 * or a symlink, so we DO NOT overwrite any file the link is pointing to
> 	 */
> 	name = tempnam(g_get_tmp_dir(), NULL);
> 	DEBUG_MSG("create_secure_dir_return_filename, name=%s\n", name);
> 	if (!name) {
> 		return NULL;
> 	}
> 
> 	if (mkdir(name, 0700) != 0) {
> 		g_free(name);
> 		return NULL;
> 	}
> 	name2 = tempnam(name, NULL);
> 	DEBUG_MSG("create_secure_dir_return_filename, name2=%s\n", name2);
> 	g_free(name);
> 	return name2;
> }
> /**
>  * remove_secure_dir_and_filename:
>  * @filename: the #gchar * filename to remove
>  *
>  * this function will remove a the filename created 
>  * by create_secure_dir_return_filename(), and the safe
>  * directory the file was created in
>  *
>  * Return value: void
>  **/
> void remove_secure_dir_and_filename(gchar *filename) {
> 	gchar *dirname = g_path_get_dirname(filename);
> 	unlink(filename);
> 	rmdir(dirname);
> 	g_free(dirname);
> }
> 
> /* gchar *buf_replace_char(gchar *buf, gint len, gchar srcchar, gchar destchar) {
> 	gint curlen=0;
> 	gchar *tmpbuf=buf;
> 	while(tmpbuf[curlen] != '\0' && curlen < len) {
> 		if (tmpbuf[curlen] == srcchar) {
> 			tmpbuf[curlen] = destchar;
> 		}
> 		curlen++;
> 	}
> 	return buf;
> }*/
> 
> /**
>  * wordcount:
>  * @text: A #gchar* to examine.
>  * @chars: #guint*, will contain no. chars in text.
>  * @lines: #guint*, will contain no. lines in text.
>  * @words: #guint*, will contain no. words in text.
>  *
>  * Returns number of characters, lines and words in the supplied #gchar*.
>  * Handles UTF-8 correctly. Input must be properly encoded UTF-8.
>  * Words are defined as any characters grouped, separated with spaces.
>  * I.e., this is a word: "12a42a,.". This is two words: ". ."
>  *
>  * This function contains a switch() with inspiration from the GNU wc utility.
>  * Rewritten for glib UTF-8 handling by Christian Tellefsen, chris@tellefsen.net.
>  *
>  * Note that gchar == char, so that gives us no problems here.
>  *
>  * Return value: void
>  **/
> void wordcount(gchar *text, guint *chars, guint *lines, guint *words)
> {
> 	guint in_word = 0;
> 	gunichar utext;
> 	
> 	if(!text) return; /* politely refuse to operate on NULL .. */
> 		
> 	*chars = *words = *lines = 0;
> 	while (*text != '\0') {
> 		(*chars)++;
> 		
> 		switch (*text) {
> 			case '\n':
> 				(*lines)++;
> 				/* Fall through. */
> 			case '\r':
> 			case '\f':
> 			case '\t':
> 			case ' ':
> 			case '\v':
> 				mb_word_separator:
> 				if (in_word) {
> 					in_word = 0;
> 					(*words)++;
> 				}
> 				break;
> 			default:
> 				utext = g_utf8_get_char_validated(text, 2); /* This might be an utf-8 char..*/
> 				if (g_unichar_isspace (utext)) /* Unicode encoded space? */
> 					goto mb_word_separator;
> 				if (g_unichar_isgraph (utext)) /* Is this something printable? */
> 					in_word = 1;
> 				break;
> 		} /* switch */
> 		
> 		text = g_utf8_next_char(text); /* Even if the current char is 2 bytes, this will iterate correctly. */
> 	}
> 	
> 	/* Capture last word, if there's no whitespace at the end of the file. */
> 	if(in_word) (*words)++;
> 	/* We start counting line numbers from 1 */
> 	if(*chars > 0) (*lines)++;
> }
> 
> GSList *gslist_from_glist(GList *src) {
> 	GSList *target=NULL;
> 	GList *tmplist = g_list_first(src);
> 	while (tmplist) {
> 		target = g_slist_append(target, tmplist->data);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return target;
> }
> 
> GList *glist_from_gslist(GSList *src) {
> 	GList *target=NULL;
> 	GSList *tmplist = src;
> 	while (tmplist) {
> 		target = g_list_append(target, tmplist->data);
> 		tmplist = g_slist_next(tmplist);
> 	}
> 	return target;
> }
1,82c1,79
< /* Bluefish HTML Editor
<  * bf_lib.h - non-GUI general functions
<  *
<  * Copyright (C) 2000-2004 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< #ifndef __BF_LIB_H_
< #define __BF_LIB_H_
< 
< typedef struct {
< 	gint my_int;
< 	gchar *my_char;
< } Tconvert_table;
< 
< typedef enum { 
< 	tcc2i_full_match = 0,
< 	tcc2i_firstchar,
< 	tcc2i_mycharlen,
< 	tcc2i_full_match_gettext
< } Ttcc2i_mode;
< 
< gchar *get_filename_on_disk_encoding(const gchar *utf8filename);
< gchar *get_utf8filename_from_on_disk_encoding(const gchar *encodedname);
< gboolean string_is_color(const gchar *color);
< gchar *filemode_to_string(mode_t statmode);
< gchar *return_root_with_protocol(const gchar *url);
< void pointer_switch_addresses(gpointer *a, gpointer *b);
< void list_switch_order(GList *first, GList *second);
< gboolean file_copy(gchar *source, gchar *dest);
< gint find_common_prefixlen_in_stringlist(GList *stringlist);
< gboolean append_string_to_file(gchar *filename, gchar *string);
< gint table_convert_char2int(Tconvert_table *table, const gchar *my_char, Ttcc2i_mode mode);
< gchar *table_convert_int2char(Tconvert_table *table, gint my_int);
< gchar *expand_string(const gchar *string, const char specialchar, Tconvert_table *table);
< gchar *unexpand_string(const gchar *original, const char specialchar, Tconvert_table *table);
< gchar *replace_string_printflike(const gchar *string, Tconvert_table *table);
< gchar *unescape_string(const gchar *original, gboolean escape_colon);
< gchar *escape_string(const gchar *original, gboolean escape_colon);
< Tconvert_table *new_convert_table(gint size, gboolean fill_standardescape);
< void free_convert_table(Tconvert_table *tct);
< 
< #define utf8_byteoffset_to_charsoffset(string,byteoffset) g_utf8_pointer_to_offset(string, string+byteoffset)
< /*glong utf8_byteoffset_to_charsoffset(gchar *string, glong byteoffset);*/
< void utf8_offset_cache_reset();
< guint utf8_byteoffset_to_charsoffset_cached(gchar *string, glong byteoffset);
< 
< gchar *strip_any_whitespace(gchar *string);
< gchar *trunc_on_char(gchar * string, gchar which_char);
< gchar *strip_common_path(char *to_filename, char *from_filename);
< gchar *most_efficient_filename(gchar *filename);
< gchar *create_relative_link_to(gchar * current_filepath, gchar * link_to_filepath);
< gchar *create_full_path(const gchar * filename, const gchar *basedir);
< gchar *ending_slash(const gchar *dirname);
< gchar *path_get_dirname_with_ending_slash(const gchar *filename);
< gboolean file_exists_and_readable(const gchar * filename);
< gchar *return_first_existing_filename(const gchar * filename, ...);
< gboolean filename_test_extensions(gchar **extensions, gchar *filename);
< gchar *bf_str_repeat(const gchar * str, gint number_of);
< gint get_int_from_string(gchar *string);
< gchar *create_secure_dir_return_filename();
< void remove_secure_dir_and_filename(gchar *filename);
< /*gchar *buf_replace_char(gchar *buf, gint len, gchar srcchar, gchar destchar);*/
< void wordcount(gchar *text, guint *chars, guint *lines, guint *words);
< GList *glist_from_gslist(GSList *src);
< void bf_chrrepl(gchar *source,const gchar *find, const gchar *repl);
< /* void fixpath(gchar *source); */
< gchar *win_return_root_with_protocol(const gchar *url);
< #endif /* __BF_LIB_H_ */
---
> /* Bluefish HTML Editor
>  * bf_lib.h - non-GUI general functions
>  *
>  * Copyright (C) 2000-2004 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> #ifndef __BF_LIB_H_
> #define __BF_LIB_H_
> 
> typedef struct {
> 	gint my_int;
> 	gchar *my_char;
> } Tconvert_table;
> 
> typedef enum { 
> 	tcc2i_full_match = 0,
> 	tcc2i_firstchar,
> 	tcc2i_mycharlen,
> 	tcc2i_full_match_gettext
> } Ttcc2i_mode;
> 
> gchar *get_filename_on_disk_encoding(const gchar *utf8filename);
> gchar *get_utf8filename_from_on_disk_encoding(const gchar *encodedname);
> gboolean string_is_color(const gchar *color);
> gchar *filemode_to_string(mode_t statmode);
> gchar *return_root_with_protocol(const gchar *url);
> void pointer_switch_addresses(gpointer *a, gpointer *b);
> void list_switch_order(GList *first, GList *second);
> gboolean file_copy(gchar *source, gchar *dest);
> gint find_common_prefixlen_in_stringlist(GList *stringlist);
> gboolean append_string_to_file(gchar *filename, gchar *string);
> gint table_convert_char2int(Tconvert_table *table, const gchar *my_char, Ttcc2i_mode mode);
> gchar *table_convert_int2char(Tconvert_table *table, gint my_int);
> gchar *expand_string(const gchar *string, const char specialchar, Tconvert_table *table);
> gchar *unexpand_string(const gchar *original, const char specialchar, Tconvert_table *table);
> gchar *replace_string_printflike(const gchar *string, Tconvert_table *table);
> gchar *unescape_string(const gchar *original, gboolean escape_colon);
> gchar *escape_string(const gchar *original, gboolean escape_colon);
> Tconvert_table *new_convert_table(gint size, gboolean fill_standardescape);
> void free_convert_table(Tconvert_table *tct);
> 
> #define utf8_byteoffset_to_charsoffset(string,byteoffset) g_utf8_pointer_to_offset(string, string+byteoffset)
> /*glong utf8_byteoffset_to_charsoffset(gchar *string, glong byteoffset);*/
> void utf8_offset_cache_reset();
> guint utf8_byteoffset_to_charsoffset_cached(gchar *string, glong byteoffset);
> 
> gchar *strip_any_whitespace(gchar *string);
> gchar *trunc_on_char(gchar * string, gchar which_char);
> gchar *strip_common_path(char *to_filename, char *from_filename);
> gchar *most_efficient_filename(gchar *filename);
> gchar *create_relative_link_to(gchar * current_filepath, gchar * link_to_filepath);
> gchar *create_full_path(const gchar * filename, const gchar *basedir);
> gchar *ending_slash(const gchar *dirname);
> gchar *path_get_dirname_with_ending_slash(const gchar *filename);
> gboolean file_exists_and_readable(const gchar * filename);
> gchar *return_first_existing_filename(const gchar * filename, ...);
> gboolean filename_test_extensions(gchar **extensions, gchar *filename);
> gchar *bf_str_repeat(const gchar * str, gint number_of);
> gint get_int_from_string(gchar *string);
> gchar *create_secure_dir_return_filename();
> void remove_secure_dir_and_filename(gchar *filename);
> /*gchar *buf_replace_char(gchar *buf, gint len, gchar srcchar, gchar destchar);*/
> void wordcount(gchar *text, guint *chars, guint *lines, guint *words);
> GList *glist_from_gslist(GSList *src);
> #endif /* __BF_LIB_H_ */
1,428c1,376
< /* Bluefish HTML Editor
<  * bluefish.c - the main function
<  *
<  * Copyright (C) 1998 Olivier Sessink and Chris Mazuc
<  * Copyright (C) 1999-2006 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< /* #define DEBUG */
< 
< #include <gtk/gtk.h>
< #include <stdlib.h>    /* getopt() exit() and abort() on Solaris */
< #include <time.h>      /* nanosleep */
< #include <unistd.h>    /* getopt() */
< 
< #include "bluefish.h"
< 
< #define _GNU_SOURCE
< #ifdef HAVE_GNOME_VFS
< #include <libgnomevfs/gnome-vfs.h>
< #endif
< #ifdef HAVE_ATLEAST_GNOMEUI_2_6
< #include <libgnomeui/libgnomeui.h>
< #endif
< 
< #ifdef ENABLE_NLS
< #include <locale.h>
< #endif
< 
< #include "authen.h"        /* set_authen_callbacks() */
< #include "bf_lib.h"        /* create_full_path() */
< #include "bookmark.h"      /* bmark_init() */
< #include "document.h"
< #include "filebrowser.h"   /* filters_rebuild() */
< #include "fref.h"          /* fref_init() */
< #include "gtk_easy.h"      /* flush_queue() */
< #include "gui.h"           /* gui_create_main() */
< #include "highlight.h"     /* hl_init() */
< #include "msg_queue.h"     /* msg_queue_start()*/
< #include "pixmap.h"        /* default_icon_list() */
< #include "project.h"
< #include "rcfile.h"        /* rcfile_parse_main() */
< #include "stringlist.h"    /* put_stringlist(), get_stringlist() */
< 
< #ifdef WIN32
< #include <windows.h>
< #endif
< /*********************************************/
< /* this var is global for all bluefish files */
< /*********************************************/
< Tmain *main_v;
< 
< /********************************/
< /* functions used in bluefish.c */
< /********************************/
< #ifndef __GNUC__
< void g_none(gchar *first, ...) {
< 	return;
< }
< #endif
< 
< static gint parse_commandline(int argc, char **argv
< 		, gboolean *root_override
< 		, GList **load_filenames
< 		, GList **load_projects
< 		, gboolean *open_in_new_win) {
< 	int c;
< 	gchar *tmpname;
< 
< 	opterr = 0;
< 	DEBUG_MSG("parse_commandline, started\n");
< 	while ((c = getopt(argc, argv, "hsvnp:?")) != -1) {
< 		switch (c) {
< 		case 's':
< 			*root_override = 1;
< 			break;
< 		case 'v':
< 			g_print(CURRENT_VERSION_NAME);
< 			g_print("\n");
< 			exit(1);
< 			break;
< 		case 'p':
< 			tmpname = create_full_path(optarg, NULL);
< 			*load_projects = g_list_append(*load_projects, tmpname);
< 			break;
< 		case 'h':
< 		case '?':
< 			g_print(CURRENT_VERSION_NAME);
< 			g_print(_("\nUsage: %s [options] [filenames ...]\n"), argv[0]);
< 			g_print(_("\nCurrently accepted options are:\n"));
< 			g_print(_("-s           skip root check\n"));
< 			g_print(_("-v           current version\n"));
< 			g_print(_("-n           open new window\n"));
< 			g_print(_("-p filename  open project\n"));
< 			g_print(_("-h           this help screen\n"));
< 			exit(1);
< 			break;
< 		case 'n':
< 			*open_in_new_win = 1;
< 		break;
< 		default:
< 			DEBUG_MSG("parse_commandline, abort ?!?\n");
< 			abort();
< 		}
< 	}
< 	DEBUG_MSG("parse_commandline, optind=%d, argc=%d\n", optind, argc);
< 	while (optind < argc) {
< 		tmpname = create_full_path(argv[optind], NULL);
< 		DEBUG_MSG("parse_commandline, argv[%d]=%s, tmpname=%s\n", optind, argv[optind], tmpname);
< 		*load_filenames = g_list_append(*load_filenames, tmpname);
< 		optind++;
< 	}
< 	DEBUG_MSG("parse_commandline, finished, num files=%d, num projects=%d\n"
< 		, g_list_length(*load_filenames), g_list_length(*load_projects));
< 	return 0;
< }
< 
< 
< /*********************/
< /* the main function */
< /*********************/
< 
< int main(int argc, char *argv[])
< {
< /* Dynamically create paths for Win32 */	
< #ifdef WIN32
<  	gchar *path = g_malloc0(MAXPATH+1);
< 	gchar *ctmp = g_malloc0(MAXPATH+1);
< 	if (GetModuleFileName(NULL,path,MAXPATH) != 0) {
< 	DEBUG_MSG("GetModuleFileName=%s\n",path);
< 	ctmp = g_strdup(path_get_dirname_with_ending_slash(path));
< 	if (ctmp[strlen(ctmp)-1] == '\\'){
< 		ctmp[strlen(ctmp)-1]='\0';
< 		ctmp = g_strdup(path_get_dirname_with_ending_slash(ctmp));
< 		}
< 	PKG_DATA_DIR = g_strconcat(ctmp,"share\\bluefish\\",NULL);
< 	LOCALE_DIR = g_strconcat(ctmp,"share\\locale",NULL);
< 	BLUEFISH_PNG_PATH = g_strconcat(PKG_DATA_DIR,"bluefish_splash.png",NULL);
< 	} else {
< 	g_print("Configuration file(s) could not be found.\nExiting now.\n");
< 	g_free(path);
< 	g_free(ctmp);
< 	bluefish_exit_request();	
< 	}
< 	g_free(path);
< 	g_free(ctmp);
< #endif /* WIN32 */
< 	gboolean root_override=FALSE, open_in_new_window=FALSE;
< 	GList *filenames = NULL, *projectfiles=NULL;
< 	Tbfwin *firstbfwin;
< #ifndef NOSPLASH
< 	GtkWidget *splash_window = NULL;
< #endif /* #ifndef NOSPLASH */
< 
< #ifdef ENABLE_NLS                                                               
< 	setlocale(LC_ALL,""); 
< #ifndef WIN32	
< 	bindtextdomain(PACKAGE,LOCALEDIR);
< 	DEBUG_MSG("set bindtextdomain for %s to %s\n",PACKAGE,LOCALEDIR);
< #else
< 	bindtextdomain(PACKAGE,LOCALE_DIR);
< 	DEBUG_MSG("set bindtextdomain for %s to %s\n",PACKAGE,LOCALE_DIR);
< #endif
< 	bind_textdomain_codeset(PACKAGE, "UTF-8");
< 	textdomain(PACKAGE);                                                    
< #endif
< #ifdef HAVE_ATLEAST_GNOMEUI_2_6
< 	gnome_init(PACKAGE, VERSION, argc, argv);
< #else
< 	gtk_init(&argc, &argv);
< #endif /* HAVE_ATLEAST_GNOMEUI_2_6
<  */
< #ifdef HAVE_GNOME_VFS
< 	DEBUG_MSG("main, we have gnome_vfs, so we init it\n");
< 	gnome_vfs_init();
< #ifdef HAVE_ATLEAST_GNOMEUI_2_6
< #ifndef WIN32
< 	gnome_authentication_manager_init();
< #endif /* NOT WIN32 */
< #else
< #ifdef HAVE_ATLEAST_GNOMEVFS_2_6
< 	set_authen_callbacks();
< #endif /* HAVE_ATLEAST_GNOMEVFS_2_6 */
< #endif /* HAVE_ATLEAST_GNOME_2_6 */
< #endif /* HAVE_GNOME_VFS */
<     gtk_window_set_default_icon_list (default_icon_list());
< 	main_v = g_new0(Tmain, 1);
< 	main_v->session = g_new0(Tsessionvars,1);
< 	main_v->session->view_html_toolbar = main_v->session->view_main_toolbar = main_v->session->view_custom_menu = main_v->session->view_left_panel = 1;
< 	DEBUG_MSG("main, main_v is at %p\n", main_v);
< 
< 	rcfile_check_directory();
< 	rcfile_parse_main();
< 	
< 	parse_commandline(argc, argv, &root_override, &filenames, &projectfiles, &open_in_new_window);
< #ifdef WITH_MSG_QUEUE	
< 	if (((filenames || projectfiles) && main_v->props.open_in_running_bluefish) ||  open_in_new_window) {
< 		msg_queue_start(filenames, projectfiles, open_in_new_window);
< 	}
< #endif /* WITH_MSG_QUEUE */
< #ifndef NOSPLASH
< 	if (main_v->props.show_splash_screen) {
< 		/* start splash screen somewhere here */
< 		splash_window = start_splash_screen();
< 		splash_screen_set_label(_("parsing highlighting file..."));
< 	}
< #endif /* #ifndef NOSPLASH */
< 
< 	{
< 		gchar *filename = g_strconcat(g_get_home_dir(), "/.bluefish/dir_history", NULL);
< 		main_v->recent_directories = get_stringlist(filename, NULL);
< 		g_free(filename);
< 	}
< 	rcfile_parse_global_session();
< 	rcfile_parse_highlighting();
< #ifndef NOSPLASH
< 	if (main_v->props.show_splash_screen) splash_screen_set_label(_("compiling highlighting patterns..."));
< #endif /* #ifndef NOSPLASH */
< 	hl_init();
< 	filebrowserconfig_init();
< 	filebrowser_filters_rebuild();
< 	autoclosing_init();
< #ifndef NOSPLASH
< 	if (main_v->props.show_splash_screen) splash_screen_set_label(_("parsing custom menu file..."));
< #endif /* #ifndef NOSPLASH */
< 	rcfile_parse_custom_menu(FALSE,FALSE);
< 	main_v->tooltips = gtk_tooltips_new();
< 	fref_init();
< 	bmark_init();
< #ifdef WITH_MSG_QUEUE
< 	if (!filenames && !projectfiles && main_v->props.open_in_running_bluefish) {
< 		msg_queue_start(NULL, NULL, open_in_new_window);
< 	}
< #endif /* WITH_MSG_QUEUE */
< #ifndef NOSPLASH
< 	if (main_v->props.show_splash_screen) splash_screen_set_label(_("creating main gui..."));
< #endif /* #ifndef NOSPLASH */
< 
< 	/* create the first window */
< 	firstbfwin = g_new0(Tbfwin,1);
< 	firstbfwin->session = main_v->session;
< 	firstbfwin->bookmarkstore = main_v->bookmarkstore;
< 	main_v->bfwinlist = g_list_append(NULL, firstbfwin);
< 	gui_create_main(firstbfwin,filenames);
< 	bmark_reload(firstbfwin);
< #ifndef NOSPLASH
< 	if (main_v->props.show_splash_screen) splash_screen_set_label(_("showing main gui..."));
< #endif /* #ifndef NOSPLASH */
< 	/* set GTK settings, must be AFTER the menu is created */
< 	{
< 		gchar *shortcutfilename;
< 		GtkSettings* gtksettings = gtk_settings_get_default();
< 		g_object_set(G_OBJECT(gtksettings), "gtk-can-change-accels", TRUE, NULL); 
< 		shortcutfilename = g_strconcat(g_get_home_dir(), "/.bluefish/menudump_2", NULL);
< 		gtk_accel_map_load(shortcutfilename);
< 		g_free(shortcutfilename);
< 	}
< 
< 	gui_show_main(firstbfwin);
< #ifdef WIN32
< 	gtk_window_move ((GtkWindow *)firstbfwin->main_window,0,0);
< #endif
< 	if (firstbfwin->session->view_html_toolbar && 
<          main_v->globses.quickbar_items == NULL && 
<          main_v->props.show_quickbar_tip == TRUE) 
<    {	
< 	   GtkWidget *dialog, *hbox, *image, *vbox, *label, *button, *show_again;
< 	   
< 	   dialog = gtk_dialog_new_with_buttons ("", 
< 	                                         GTK_WINDOW (firstbfwin->main_window),
< 	                                         GTK_DIALOG_DESTROY_WITH_PARENT,
< 	                                         NULL);
< 		button = gtk_dialog_add_button (GTK_DIALOG (dialog), GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE);
< 		gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);
< 		gtk_dialog_set_has_separator (GTK_DIALOG (dialog), FALSE);
< 		
< 		hbox = gtk_hbox_new (FALSE, 12);
< 		gtk_container_set_border_width (GTK_CONTAINER (hbox), 12);
< 		gtk_box_pack_start_defaults (GTK_BOX (GTK_DIALOG (dialog)->vbox), hbox);
< 		image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_INFO, GTK_ICON_SIZE_DIALOG);
< 		gtk_misc_set_alignment (GTK_MISC (image), 0 ,0);
< 		gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 0);
< 		vbox = gtk_vbox_new (FALSE, 0);
< 		gtk_box_pack_start_defaults (GTK_BOX (hbox), vbox);
< 		label = gtk_label_new (NULL);
< 		gtk_label_set_markup (GTK_LABEL (label), 
< 									 _("<span weight=\"bold\" size=\"larger\">Bluefish Tip:</span>\n\nThis message is shown if you do not have any items in the Quickbar.\n\nTo add buttons to the Quickbar, right click on a button in the HTML toolbars.\n"));
< 		gtk_label_set_line_wrap (GTK_LABEL (label), TRUE);
< 		gtk_box_pack_start (GTK_BOX (vbox), label, FALSE, FALSE, 0);
< 
< 	   show_again = gtk_check_button_new_with_mnemonic (_("_Don't show this dialog again."));
< 	   gtk_box_pack_start (GTK_BOX (vbox), show_again, FALSE, FALSE, 12);
< 	   
< 	   gtk_widget_show_all (GTK_DIALOG (dialog)->vbox);
< 		gtk_widget_grab_focus (button);
< 	   gtk_dialog_run (GTK_DIALOG (dialog));
< 	   if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (show_again))) {
< 	      main_v->props.show_quickbar_tip = FALSE;
< 	   }
< 	   gtk_widget_destroy (dialog);
< 	}
< 	
< 	if (projectfiles) {
< 		GList *tmplist = g_list_first(projectfiles);
< 		while (tmplist) {
< 			project_open_from_file(firstbfwin, tmplist->data);
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	
< #ifndef NOSPLASH
< /* 	if (main_v->props.show_splash_screen) {
< 		static struct timespec const req = { 0, 10000000};
< 		flush_queue();
< 		nanosleep(&req, NULL);
< 		gtk_widget_destroy(splash_window); */
< 	if (main_v->props.show_splash_screen) {
< 		/*static struct timespec const req = { 0, 10000000};*/
< 		flush_queue();
< 		/*nanosleep(&req, NULL);*/
< 		gtk_widget_destroy(splash_window);
< 		DEBUG_MSG("splash destroyed.\n");
< 	}	
< 
< #endif /* #ifndef NOSPLASH */
< 	DEBUG_MSG("main, before gtk_main()\n");
< 	gtk_main();
< 	DEBUG_MSG("main, after gtk_main()\n");
< 	DEBUG_MSG("calling bluefish_exit_request()\n");
< 	bluefish_exit_request();
< #ifdef WITH_MSG_QUEUE	
< 	/* do the cleanup */
< 	msg_queue_cleanup();
< #endif /* WITH_MSG_QUEUE */
< 	 
< 	DEBUG_MSG("Bluefish: exiting cleanly\n");
< 	return 0;
< }
< 
< void bluefish_exit_request() {
< 	GList *tmplist;
< 	gboolean tmpb;
< 	DEBUG_MSG("bluefish_exit_request, started\n");
< 	/* if we have modified documents we have to do something, file_close_all_cb()
< 	does exactly want we want to do */
< 	tmplist = return_allwindows_documentlist();
< 	tmpb = (tmplist && test_docs_modified(tmplist));
< 	g_list_free(tmplist);
< 	tmplist = g_list_first(main_v->bfwinlist);
< 	while (tmplist) {
< 		/* if there is a project, we anyway want to save & close the project */
< 		if (BFWIN(tmplist->data)->project) {
< 			if (!project_save_and_close(BFWIN(tmplist->data))) {
< 				/* cancelled or error! */
< 				DEBUG_MSG("bluefish_exit_request, project_save_and_close returned FALSE\n");
< 				return;
< 			}
< 		}
< 		if (tmpb) {
< 			file_close_all_cb(NULL, BFWIN(tmplist->data));
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	/* if we still have modified documents we don't do a thing,
< 	 if we don't have them we can quit */
< 	if (tmpb) {
< 		tmplist = return_allwindows_documentlist();
< 		tmpb = (tmplist && test_docs_modified(tmplist));
< 		g_list_free(tmplist);
< 		if (tmpb) {
< 			return;
< 		}
< 	}
< /*	gtk_widget_hide(main_v->main_window);*/
< 	tmplist = g_list_first(gtk_window_list_toplevels());
< 	while (tmplist) {
< 		gtk_widget_hide(GTK_WIDGET(tmplist->data));
< 		tmplist = g_list_next(tmplist);
< 	}
< 	flush_queue();
< 	
< 	rcfile_save_all();
< 	{
< 		gchar *filename = g_strconcat(g_get_home_dir(), "/.bluefish/dir_history", NULL);
< 		put_stringlist_limited(filename, main_v->recent_directories, main_v->props.max_dir_history);
< 		g_free(filename);
< 	}
< 	
< /*	NEEDS TO BE PORTED FOR MULTIPLE-WINDOW SUPPORT
< 	tmplist = gtk_window_list_toplevels();
< 	g_list_foreach(tmplist, (GFunc)g_object_ref, NULL);
< 	tmplist = g_list_first(tmplist);
< 	while (tmplist) {
< 		if (tmplist->data != main_v->main_window) {
< 			gtk_widget_destroy(GTK_WIDGET(tmplist->data));
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	g_list_foreach (tmplist, (GFunc)g_object_unref, NULL); */
< 	
< 	/* I don't understand why, but if I call gtk_main_quit here, the main() function does not continue after gtk_main(), very weird, so I'll call exit() here */
< 	gtk_main_quit();
< 	DEBUG_MSG("bluefish_exit_request, after gtk_main_quit()\n");
< #ifdef WITH_MSG_QUEUE	
< 	/* do the cleanup */
< 	msg_queue_cleanup();
< #endif /* WITH_MSG_QUEUE */
< /* #ifdef WIN32
< 	g_free(PKG_DATA_DIR);
< 	g_free(LOCALE_DIR);
< 	g_free(BLUEFISH_PNG_PATH);
< #endif
<  */	DEBUG_MSG("Bluefish: exiting cleanly\n");
< 	exit(0);
< }
---
> /* Bluefish HTML Editor
>  * bluefish.c - the main function
>  *
>  * Copyright (C) 1998 Olivier Sessink and Chris Mazuc
>  * Copyright (C) 1999-2006 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> /* #define DEBUG */
> 
> #include <gtk/gtk.h>
> #include <stdlib.h>    /* getopt() exit() and abort() on Solaris */
> #include <time.h>      /* nanosleep */
> #include <unistd.h>    /* getopt() */
> 
> #include "bluefish.h"
> 
> #ifdef HAVE_GNOME_VFS
> #include <libgnomevfs/gnome-vfs.h>
> #endif
> #ifdef HAVE_ATLEAST_GNOMEUI_2_6
> #include <libgnomeui/libgnomeui.h>
> #endif
> 
> #ifdef ENABLE_NLS
> #include <locale.h>
> #endif
> 
> #include "authen.h"        /* set_authen_callbacks() */
> #include "bf_lib.h"        /* create_full_path() */
> #include "bookmark.h"      /* bmark_init() */
> #include "document.h"
> #include "filebrowser.h"   /* filters_rebuild() */
> #include "fref.h"          /* fref_init() */
> #include "gtk_easy.h"      /* flush_queue() */
> #include "gui.h"           /* gui_create_main() */
> #include "highlight.h"     /* hl_init() */
> #include "msg_queue.h"     /* msg_queue_start()*/
> #include "pixmap.h"        /* default_icon_list() */
> #include "project.h"
> #include "rcfile.h"        /* rcfile_parse_main() */
> #include "stringlist.h"    /* put_stringlist(), get_stringlist() */
> 
> /*********************************************/
> /* this var is global for all bluefish files */
> /*********************************************/
> Tmain *main_v;
> 
> /********************************/
> /* functions used in bluefish.c */
> /********************************/
> #ifndef __GNUC__
> void g_none(gchar *first, ...) {
> 	return;
> }
> #endif
> 
> static gint parse_commandline(int argc, char **argv
> 		, gboolean *root_override
> 		, GList **load_filenames
> 		, GList **load_projects
> 		, gboolean *open_in_new_win) {
> 	int c;
> 	gchar *tmpname;
> 
> 	opterr = 0;
> 	DEBUG_MSG("parse_commandline, started\n");
> 	while ((c = getopt(argc, argv, "hsvnp:?")) != -1) {
> 		switch (c) {
> 		case 's':
> 			*root_override = 1;
> 			break;
> 		case 'v':
> 			g_print(CURRENT_VERSION_NAME);
> 			g_print("\n");
> 			exit(1);
> 			break;
> 		case 'p':
> 			tmpname = create_full_path(optarg, NULL);
> 			*load_projects = g_list_append(*load_projects, tmpname);
> 			break;
> 		case 'h':
> 		case '?':
> 			g_print(CURRENT_VERSION_NAME);
> 			g_print(_("\nUsage: %s [options] [filenames ...]\n"), argv[0]);
> 			g_print(_("\nCurrently accepted options are:\n"));
> 			g_print(_("-s           skip root check\n"));
> 			g_print(_("-v           current version\n"));
> 			g_print(_("-n           open new window\n"));
> 			g_print(_("-p filename  open project\n"));
> 			g_print(_("-h           this help screen\n"));
> 			exit(1);
> 			break;
> 		case 'n':
> 			*open_in_new_win = 1;
> 		break;
> 		default:
> 			DEBUG_MSG("parse_commandline, abort ?!?\n");
> 			abort();
> 		}
> 	}
> 	DEBUG_MSG("parse_commandline, optind=%d, argc=%d\n", optind, argc);
> 	while (optind < argc) {
> 		tmpname = create_full_path(argv[optind], NULL);
> 		DEBUG_MSG("parse_commandline, argv[%d]=%s, tmpname=%s\n", optind, argv[optind], tmpname);
> 		*load_filenames = g_list_append(*load_filenames, tmpname);
> 		optind++;
> 	}
> 	DEBUG_MSG("parse_commandline, finished, num files=%d, num projects=%d\n"
> 		, g_list_length(*load_filenames), g_list_length(*load_projects));
> 	return 0;
> }
> 
> 
> /*********************/
> /* the main function */
> /*********************/
> 
> int main(int argc, char *argv[])
> {
> 	gboolean root_override=FALSE, open_in_new_window=FALSE;
> 	GList *filenames = NULL, *projectfiles=NULL;
> 	Tbfwin *firstbfwin;
> #ifndef NOSPLASH
> 	GtkWidget *splash_window = NULL;
> #endif /* #ifndef NOSPLASH */
> 
> #ifdef ENABLE_NLS                                                               
> 	setlocale(LC_ALL,"");                                                   
> 	bindtextdomain(PACKAGE,LOCALEDIR);
> 	DEBUG_MSG("set bindtextdomain for %s to %s\n",PACKAGE,LOCALEDIR);
> 	bind_textdomain_codeset(PACKAGE, "UTF-8");
> 	textdomain(PACKAGE);                                                    
> #endif
> #ifdef HAVE_ATLEAST_GNOMEUI_2_6
> 	gnome_init(PACKAGE, VERSION, argc, argv);
> #else
> 	gtk_init(&argc, &argv);
> #endif /* HAVE_ATLEAST_GNOMEUI_2_6
>  */
> #ifdef HAVE_GNOME_VFS
> 	DEBUG_MSG("main, we have gnome_vfs, so we init it\n");
> 	gnome_vfs_init();
> #ifdef HAVE_ATLEAST_GNOMEUI_2_6
> 	gnome_authentication_manager_init();
> #else
> #ifdef HAVE_ATLEAST_GNOMEVFS_2_6
> 	set_authen_callbacks();
> #endif /* HAVE_ATLEAST_GNOMEVFS_2_6 */
> #endif /* HAVE_ATLEAST_GNOME_2_6 */
> #endif /* HAVE_GNOME_VFS */
>     gtk_window_set_default_icon_list (default_icon_list());
> 	main_v = g_new0(Tmain, 1);
> 	main_v->session = g_new0(Tsessionvars,1);
> 	main_v->session->view_html_toolbar = main_v->session->view_main_toolbar = main_v->session->view_custom_menu = main_v->session->view_left_panel = 1;
> 	DEBUG_MSG("main, main_v is at %p\n", main_v);
> 
> 	rcfile_check_directory();
> 	rcfile_parse_main();
> 	
> 	parse_commandline(argc, argv, &root_override, &filenames, &projectfiles, &open_in_new_window);
> #ifdef WITH_MSG_QUEUE	
> 	if (((filenames || projectfiles) && main_v->props.open_in_running_bluefish) ||  open_in_new_window) {
> 		msg_queue_start(filenames, projectfiles, open_in_new_window);
> 	}
> #endif /* WITH_MSG_QUEUE */
> #ifndef NOSPLASH
> 	if (main_v->props.show_splash_screen) {
> 		/* start splash screen somewhere here */
> 		splash_window = start_splash_screen();
> 		splash_screen_set_label(_("parsing highlighting file..."));
> 	}
> #endif /* #ifndef NOSPLASH */
> 
> 	{
> 		gchar *filename = g_strconcat(g_get_home_dir(), "/.bluefish/dir_history", NULL);
> 		main_v->recent_directories = get_stringlist(filename, NULL);
> 		g_free(filename);
> 	}
> 	rcfile_parse_global_session();
> 	rcfile_parse_highlighting();
> #ifndef NOSPLASH
> 	if (main_v->props.show_splash_screen) splash_screen_set_label(_("compiling highlighting patterns..."));
> #endif /* #ifndef NOSPLASH */
> 	hl_init();
> 	filebrowserconfig_init();
> 	filebrowser_filters_rebuild();
> 	autoclosing_init();
> #ifndef NOSPLASH
> 	if (main_v->props.show_splash_screen) splash_screen_set_label(_("parsing custom menu file..."));
> #endif /* #ifndef NOSPLASH */
> 	rcfile_parse_custom_menu(FALSE,FALSE);
> 	main_v->tooltips = gtk_tooltips_new();
> 	fref_init();
> 	bmark_init();
> #ifdef WITH_MSG_QUEUE
> 	if (!filenames && !projectfiles && main_v->props.open_in_running_bluefish) {
> 		msg_queue_start(NULL, NULL, open_in_new_window);
> 	}
> #endif /* WITH_MSG_QUEUE */
> #ifndef NOSPLASH
> 	if (main_v->props.show_splash_screen) splash_screen_set_label(_("creating main gui..."));
> #endif /* #ifndef NOSPLASH */
> 
> 	/* create the first window */
> 	firstbfwin = g_new0(Tbfwin,1);
> 	firstbfwin->session = main_v->session;
> 	firstbfwin->bookmarkstore = main_v->bookmarkstore;
> 	main_v->bfwinlist = g_list_append(NULL, firstbfwin);
> 	gui_create_main(firstbfwin,filenames);
> 	bmark_reload(firstbfwin);
> #ifndef NOSPLASH
> 	if (main_v->props.show_splash_screen) splash_screen_set_label(_("showing main gui..."));
> #endif /* #ifndef NOSPLASH */
> 	/* set GTK settings, must be AFTER the menu is created */
> 	{
> 		gchar *shortcutfilename;
> 		GtkSettings* gtksettings = gtk_settings_get_default();
> 		g_object_set(G_OBJECT(gtksettings), "gtk-can-change-accels", TRUE, NULL); 
> 		shortcutfilename = g_strconcat(g_get_home_dir(), "/.bluefish/menudump_2", NULL);
> 		gtk_accel_map_load(shortcutfilename);
> 		g_free(shortcutfilename);
> 	}
> 
> 	gui_show_main(firstbfwin);
> 	if (firstbfwin->session->view_html_toolbar && 
>          main_v->globses.quickbar_items == NULL && 
>          main_v->props.show_quickbar_tip == TRUE) 
>    {	
> 	   GtkWidget *dialog, *hbox, *image, *vbox, *label, *button, *show_again;
> 	   
> 	   dialog = gtk_dialog_new_with_buttons ("", 
> 	                                         GTK_WINDOW (firstbfwin->main_window),
> 	                                         GTK_DIALOG_DESTROY_WITH_PARENT,
> 	                                         NULL);
> 		button = gtk_dialog_add_button (GTK_DIALOG (dialog), GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE);
> 		gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);
> 		gtk_dialog_set_has_separator (GTK_DIALOG (dialog), FALSE);
> 		
> 		hbox = gtk_hbox_new (FALSE, 12);
> 		gtk_container_set_border_width (GTK_CONTAINER (hbox), 12);
> 		gtk_box_pack_start_defaults (GTK_BOX (GTK_DIALOG (dialog)->vbox), hbox);
> 		image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_INFO, GTK_ICON_SIZE_DIALOG);
> 		gtk_misc_set_alignment (GTK_MISC (image), 0 ,0);
> 		gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 0);
> 		vbox = gtk_vbox_new (FALSE, 0);
> 		gtk_box_pack_start_defaults (GTK_BOX (hbox), vbox);
> 		label = gtk_label_new (NULL);
> 		gtk_label_set_markup (GTK_LABEL (label), 
> 									 _("<span weight=\"bold\" size=\"larger\">Bluefish Tip:</span>\n\nThis message is shown if you do not have any items in the Quickbar.\n\nTo add buttons to the Quickbar, right click on a button in the HTML toolbars.\n"));
> 		gtk_label_set_line_wrap (GTK_LABEL (label), TRUE);
> 		gtk_box_pack_start (GTK_BOX (vbox), label, FALSE, FALSE, 0);
> 
> 	   show_again = gtk_check_button_new_with_mnemonic (_("_Don't show this dialog again."));
> 	   gtk_box_pack_start (GTK_BOX (vbox), show_again, FALSE, FALSE, 12);
> 	   
> 	   gtk_widget_show_all (GTK_DIALOG (dialog)->vbox);
> 		gtk_widget_grab_focus (button);
> 	   gtk_dialog_run (GTK_DIALOG (dialog));
> 	   if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (show_again))) {
> 	      main_v->props.show_quickbar_tip = FALSE;
> 	   }
> 	   gtk_widget_destroy (dialog);
> 	}
> 	
> 	if (projectfiles) {
> 		GList *tmplist = g_list_first(projectfiles);
> 		while (tmplist) {
> 			project_open_from_file(firstbfwin, tmplist->data);
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	
> #ifndef NOSPLASH
> 	if (main_v->props.show_splash_screen) {
> 		static struct timespec const req = { 0, 10000000};
> 		flush_queue();
> 		nanosleep(&req, NULL);
> 		gtk_widget_destroy(splash_window);
> 	}
> #endif /* #ifndef NOSPLASH */
> 	DEBUG_MSG("main, before gtk_main()\n");
> 	gtk_main();
> 	DEBUG_MSG("main, after gtk_main()\n");
> #ifdef WITH_MSG_QUEUE	
> 	/* do the cleanup */
> 	msg_queue_cleanup();
> #endif /* WITH_MSG_QUEUE */
> 	DEBUG_MSG("Bluefish: exiting cleanly\n");
> 	return 0;
> }
> 
> void bluefish_exit_request() {
> 	GList *tmplist;
> 	gboolean tmpb;
> 	DEBUG_MSG("bluefish_exit_request, started\n");
> 	/* if we have modified documents we have to do something, file_close_all_cb()
> 	does exactly want we want to do */
> 	tmplist = return_allwindows_documentlist();
> 	tmpb = (tmplist && test_docs_modified(tmplist));
> 	g_list_free(tmplist);
> 	tmplist = g_list_first(main_v->bfwinlist);
> 	while (tmplist) {
> 		/* if there is a project, we anyway want to save & close the project */
> 		if (BFWIN(tmplist->data)->project) {
> 			if (!project_save_and_close(BFWIN(tmplist->data))) {
> 				/* cancelled or error! */
> 				DEBUG_MSG("bluefish_exit_request, project_save_and_close returned FALSE\n");
> 				return;
> 			}
> 		}
> 		if (tmpb) {
> 			file_close_all_cb(NULL, BFWIN(tmplist->data));
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	/* if we still have modified documents we don't do a thing,
> 	 if we don't have them we can quit */
> 	if (tmpb) {
> 		tmplist = return_allwindows_documentlist();
> 		tmpb = (tmplist && test_docs_modified(tmplist));
> 		g_list_free(tmplist);
> 		if (tmpb) {
> 			return;
> 		}
> 	}
> /*	gtk_widget_hide(main_v->main_window);*/
> 	tmplist = g_list_first(gtk_window_list_toplevels());
> 	while (tmplist) {
> 		gtk_widget_hide(GTK_WIDGET(tmplist->data));
> 		tmplist = g_list_next(tmplist);
> 	}
> 	flush_queue();
> 	
> 	rcfile_save_all();
> 	{
> 		gchar *filename = g_strconcat(g_get_home_dir(), "/.bluefish/dir_history", NULL);
> 		put_stringlist_limited(filename, main_v->recent_directories, main_v->props.max_dir_history);
> 		g_free(filename);
> 	}
> 	
> /*	NEEDS TO BE PORTED FOR MULTIPLE-WINDOW SUPPORT
> 	tmplist = gtk_window_list_toplevels();
> 	g_list_foreach(tmplist, (GFunc)g_object_ref, NULL);
> 	tmplist = g_list_first(tmplist);
> 	while (tmplist) {
> 		if (tmplist->data != main_v->main_window) {
> 			gtk_widget_destroy(GTK_WIDGET(tmplist->data));
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	g_list_foreach (tmplist, (GFunc)g_object_unref, NULL); */
> 	
> 	/* I don't understand why, but if I call gtk_main_quit here, the main() function does not continue after gtk_main(), very weird, so I'll call exit() here */
> 	gtk_main_quit();
> 	DEBUG_MSG("bluefish_exit_request, after gtk_main_quit()\n");
> #ifdef WITH_MSG_QUEUE	
> 	/* do the cleanup */
> 	msg_queue_cleanup();
> #endif /* WITH_MSG_QUEUE */
> 	DEBUG_MSG("Bluefish: exiting cleanly\n");
> 	exit(0);
> }
1,394c1,376
< /* Bluefish HTML Editor
<  * bluefish.h - global prototypes
<  *
<  * Copyright (C) 1998 Olivier Sessink and Chris Mazuc
<  * Copyright (C) 1999-2005 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< /* if you define DEBUG here you will get debug output from all Bluefish parts */
< /* #define DEBUG */
< 
< #ifndef __BLUEFISH_H_
< #define __BLUEFISH_H_
< 
< #include "config.h"
< #define BLUEFISH_SPLASH_FILENAME PKGDATADIR"bluefish_splash.png"
< #ifdef WIN32
< #ifndef MAXPATH
< #define MAXPATH 260
< #endif /* MAXPATH */
< gchar *PKG_DATA_DIR;
< gchar *LOCALE_DIR;
< gchar *BLUEFISH_PNG_PATH;
< #endif 
< 
< #ifdef HAVE_SYS_MSG_H
< #define WITH_MSG_QUEUE
< #endif
< 
< #ifdef DEBUG
< #ifdef WIN32
< #define DEBUG_MSG printf
< #else
< #define DEBUG_MSG g_print
< #endif /* WIN32 */
< #else /* not DEBUG */
< #ifdef __GNUC__
< #define DEBUG_MSG(args,...)
<  /**/
< #else/* notdef __GNUC__ */
< extern void g_none(gchar *first, ...);
< #define DEBUG_MSG g_none
< #endif /* __GNUC__ */
< #endif /* DEBUG */
< 
< #ifdef ENABLE_NLS
< 
< #include <libintl.h>
< #define _(String) gettext (String)
< #define N_(String) (String)
< 
< #else                                                                           
< 
< #define _(String)(String)
< #define N_(String)(String)
< 
< #endif    
< 
< 
< #ifdef WIN32
< #define DIRSTR "\\"
< #define DIRCHR 92
< #define _WIN_32_DIRSTRCHR
< #else
< #define DIRSTR "/"
< #define DIRCHR '/'
< #endif
< 
< #include <sys/types.h>
< #include <regex.h>
< #include <sys/types.h>
< #include <sys/stat.h>
< #include <unistd.h>
< #include <pcre.h>
< 
< #ifdef HAVE_GNOME_VFS
< #include <libgnomevfs/gnome-vfs.h>
< #endif
< 
< 
< /*********************/
< /* undo/redo structs */
< /*********************/
< typedef enum {
< 	UndoDelete = 1, UndoInsert
< } undo_op_t;
< 
< typedef struct {
< 	GList *entries;	/* the list of entries that should be undone in one action */
< 	gint changed;		/* doc changed status at this undo node */
< } unregroup_t;
< 
< typedef struct {
< 	GList *first;
< 	GList *last;
< 	unregroup_t *current;
< 	gint num_groups;
< 	GList *redofirst;
< } unre_t;
< 
< /************************/
< /* filetype struct      */
< /************************/
< 
< typedef struct {
< 	gchar *type;
< 	gchar **extensions;
< 	GdkPixbuf *icon;
< 	gchar *update_chars;
< 	GList *highlightlist;
< 	gboolean editable; /* this a type that can be edited by Bluefish */
< 	gint autoclosingtag; /* 0=off, 1=xml mode, 2=html mode */
< 	gchar *content_regex; /* a regex pattern to test the filetype using the content */
< } Tfiletype;
< 
< /*******************/
< /* document struct */
< /*******************/
< #define BFWIN(var) ((Tbfwin *)(var))
< #define DOCUMENT(var) ((Tdocument *)(var))
< 
< typedef struct {
< 	gchar *filename; /* this is the UTF-8 encoded filename, before you use it on disk you need convert to disk-encoding! */
< 	gchar *encoding;
< 	gint modified;
< /*	time_t mtime; */ /* from stat() */
< #ifdef HAVE_GNOME_VFS
< 	GnomeVFSFileInfo *fileinfo;
< #else /* HAVE_GNOME_VFS */
< 	struct stat statbuf;
< #endif /* HAVE_GNOME_VFS */
< 	gint is_symlink; /* file is a symbolic link */
< 	gulong del_txt_id; /* text delete signal */
< 	gulong ins_txt_id; /* text insert signal */
< 	gulong ins_aft_txt_id; /* text insert-after signal, for auto-indenting */
< 	unre_t unre;
< 	GtkWidget *view;
< 	GtkWidget *tab_label;
< 	GtkWidget *tab_eventbox;
< 	GtkWidget *tab_menu;
< 	GtkTextBuffer *buffer;
< 	gpointer paste_operation;
< 	gint last_rbutton_event; /* index of last 3rd button click */
< 	Tfiletype *hl; /* filetype & highlighting set to use for this document */
< 	gint need_highlighting; /* if you open 10+ documents you don't need immediate highlighting, just set this var, and notebook_switch() will trigger the actual highlighting when needed */
< 	gboolean highlightstate; /* does this document use highlighting ? */
< 	gboolean wrapstate; /* does this document use wrap?*/
< 	gboolean linenumberstate; /* does this document use linenumbers? */
< 	gboolean overwrite_mode; /* is document in overwrite mode */
< 	gboolean autoclosingtag; /* does the document use autoclosing of tags */
< 	gpointer floatingview; /* a 2nd textview widget that has its own window */
< 	gpointer bfwin;
< 	GtkTreeIter *bmark_parent; /* if NULL this document doesn't have bookmarks, if 
< 									it does have bookmarks they are children of this GtkTreeIter */
< } Tdocument;
< 
< typedef struct {
< #ifndef NOSPLASH
< 	gint show_splash_screen;  /* show splash screen at startup */
< #endif /* #ifndef NOSPLASH */
< 	gint show_quickbar_tip;
< 	gint view_line_numbers; /* view line numbers on the left side by default */
< 	gint filebrowser_show_hidden_files;
< 	gint filebrowser_show_backup_files;
< 	gint filebrowser_two_pane_view; /* have one or two panes in the filebrowser */
< 	gint filebrowser_focus_follow; /* have the directory of the current document in focus */
< 	gchar *filebrowser_unknown_icon;
< 	gchar *filebrowser_dir_icon;
< 	gchar *editor_font_string;		/* editor font */
< 	gint editor_tab_width;	/* editor tabwidth */
< 	gint editor_smart_cursor;
< 	gint editor_indent_wspaces; /* indent with spaces, not tabs */
< 	gchar *tab_font_string;		/* notebook tabs font */
< 	GList *browsers; /* browsers array */
< 	GList *external_commands;	/* external commands array */
< 	GList *cust_menu; 		/* DEPRECATED entries in the custom menu */
< 	GList *cmenu_insert; /* custom menu inserts */
< 	GList *cmenu_replace; /* custom menu replaces */
< 	gint highlight_num_lines_count; /* number of lines to highlight in continous highlighting */	
< 	gint defaulthighlight;		/* highlight documents by default */
< #ifdef HAVE_PCRE_UTF8
< 	gint highlight_utf8;    /* enable PCRE UTF-8 support */
< #endif /* HAVE_PCRE_UTF8 */
< 	GList *filetypes; /* filetypes for highlighting and filtering */
< 	gint numcharsforfiletype; /* maximum number of characters in the file to use to find the filetype */
< 	GList *filefilters; /* filebrowser.c filtering */
< 	gchar *last_filefilter;	/* last filelist filter type */
< 	GList *highlight_patterns; /* the highlight patterns */
< 	gint transient_htdialogs;  /* set html dialogs transient ro the main window */
< 	gint restore_dimensions; /* use the dimensions as used the previous run */
< 	gint left_panel_width; 	/* width of filelist */
< 	gint left_panel_left; /* 1 = left, 0 = right */
< 	gint max_recent_files;	/* length of Open Recent list */
< 	gint max_dir_history;	/* length of directory history */
< 	gint backup_file; 			/* wheather to use a backup file */
< 	gchar *backup_filestring;  /* the string to append to the backup file */
< 	gint backup_abort_action; /* if the backup fails, continue save, abort save, or ask the user */
< 	gint backup_cleanuponclose; /* remove the backupfile after close ? */
< 	gchar *image_thumbnailstring;	/* string to append to thumbnail filenames */
< 	gchar *image_thumbnailtype;	/* fileformat to use for thumbnails, "jpeg" or "png" can be handled by gdkpixbuf*/
< 	gint image_thumbnail_refresh_quality; /* 1=GDK_INTERP_BILINEAR, 0=GDK_INTERP_NEAREST*/
< 	gint image_thumbnailsizing_type;	/* scaling ratio=0, fixed width=1, height=2, width+height (discard aspect ratio)=3 */
< 	gint image_thumbnailsizing_val1;	/* the width, height or ratio, depending on the value above */
< 	gint image_thumbnailsizing_val2; /* height if the type=3 */
< 	gchar *image_thumnailformatstring; /* like <a href="%r"><img src="%t"></a> or more advanced */
< 	gint allow_multi_instances; /* allow multiple instances of the same file */
< 	gint modified_check_type; /* 0=no check, 1=by mtime and size, 2=by mtime, 3=by size, 4,5,...not implemented (md5sum?) */
< 	gint num_undo_levels; 	/* number of undo levels per document */
< 	gint clear_undo_on_save; 	/* clear all undo information on file save */
< 	gchar *newfile_default_encoding; /* if you open a new file, what encoding will it use */
< 	GList *encodings; /* all encodings you can choose from */
< 	gint auto_set_encoding_meta; /* auto set metatag for the encoding */
< 	gint auto_update_meta_author; /* auto update author meta tag on save */
< 	gint auto_update_meta_date; /* auto update date meta tag on save */
< 	gint auto_update_meta_generator; /* auto update generator meta tag on save */
< 	gint encoding_search_Nbytes; /* number of bytes to look for the encoding meta tag */
< 	GList *outputbox; /* all outputbox commands */
< 	gint ext_browsers_in_submenu;
< 	gint ext_commands_in_submenu;
< 	gint ext_outputbox_in_submenu;
< 	GList *reference_files; /* all reference files */
< 	gint bookmarks_default_store; /* 0= temporary by default, 1= permanent by default */
< 	gint bookmarks_filename_mode; /* 0=FULLPATH, 1=DIR FROM BASE 2=BASENAME */
< 	gint document_tabposition;
< 	gint leftpanel_tabposition;
< 	gchar *default_basedir;
< 	gchar *project_suffix;
< #ifdef HAVE_LIBASPELL
< 	gchar *spell_default_lang;
< #endif /* HAVE_LIBASPELL */
< 	/* not yet in use */
< 	gchar *image_editor_cline; 	/* image editor commandline */
< 	gint allow_dep;				/* allow <FONT>... */
< 	gint format_by_context; 	/* use <strong> instead of <b>, <emphasis instead of <i> etc. (W3C reccomendation) */
< 	gint xhtml;					/* write <br /> */
< 	gint allow_ruby;			/* allow <ruby> */
< 	gint force_dtd;				/* write <!DOCTYPE...> */
< 	gint dtd_url;				/* URL in DTD */
< 	gint xml_start;				/* <?XML...> */
< 	gint lowercase_tags;		/* use lowercase tags */
< 	gint word_wrap;				/* use wordwrap */
< 	gint autoindent;			/* autoindent code */
< 	gint drop_at_drop_pos; 	/* drop at drop position instead of cursor position */
< 	gint link_management; 	/* perform link management */
< 	gint cont_highlight_update;	/* update the syntax highlighting continuous */
< 	/* key conversion */
< 	gint open_in_running_bluefish; /* open commandline documents in already running session*/
< #ifdef HAVE_GNOME_VFS
< 	gint server_zope_compat;        /* add 'document_src' to uri when reading remote files */
< #endif
< } Tproperties;
< 
< /* the Tglobalsession contains all settings that can change 
< over every time you run Bluefish, so things that *need* to be
< saved after every run! */
< typedef struct {
< 	GList *quickbar_items; /* items in the quickbar toolbar */	
< 	gint main_window_h;			/* main window height */
< 	gint main_window_w;			/* main window width */
< 	gint two_pane_filebrowser_height; /* position of the pane separater on the two paned file browser */
< 	gint fref_ldoubleclick_action; /* left doubleclick in the function reference */
< 	gint fref_info_type; /* type of info shown in a small function reference window */
< 	gint lasttime_cust_menu; /* the last time the defaultfile was checked for new entries */
< 	gint lasttime_highlighting; /* see above */
< 	gint lasttime_filetypes; /* see above */
< 	gint lasttime_encodings; /* see above */
< 	GList *recent_projects;
< } Tglobalsession;
< 
< typedef struct {
< 	GList *classlist;
< 	GList *colorlist;
< 	GList *targetlist;
< 	GList *urllist;
< 	GList *fontlist;
< 	GList *dtd_cblist; /* is this used ?? */
< 	GList *headerlist; /* is this used ?? */
< 	GList *positionlist; /* is this used ?? */
< 	GList *searchlist; /* used in snr2 */
< 	GList *replacelist; /* used in snr2 */
< 	GList *bmarks;
< 	GList *recent_files;
< 	GList *recent_dirs;
< 	gchar *opendir;
< 	gchar *savedir;
<    gint view_html_toolbar;	/* view html toolbar */
<    gint view_custom_menu;  /* view custom menubar */
<    gint view_main_toolbar;	/* view main toolbar */
<    gint view_left_panel;	/* view filebrowser/functionbrowser etc. */
< } Tsessionvars;
< 
< typedef struct {
< 	gchar *filename;
< 	gchar *name;
< 	GList *files;
< 	gchar *basedir;
< 	gchar *webdir;
< 	gchar *template;
< 	gpointer editor;
< 	gint word_wrap;
< 	Tsessionvars *session;
< 	GtkTreeStore *bookmarkstore; /* project bookmarks */
< } Tproject;
< 
< typedef struct {
< 	Tsessionvars *session; /* points to the global session, or to the project session */
< 	Tdocument *current_document; /* one object out of the documentlist, the current visible document */
< 	GList *documentlist; /* document.c and others: all Tdocument objects */
< 	Tdocument *last_activated_doc;
< 	Tproject *project; /* might be NULL for a default project */
< 	GtkWidget *main_window;
< 	GtkWidget *menubar;
< 	gint last_notebook_page; /* a check to see if the notebook changed to a new page */
< 	gulong notebook_switch_signal;
< 	GtkWidget *notebook;
< 	GtkWidget *notebook_fake;
< 	GtkWidget *notebook_box; /* Container for notebook and notebook_fake */
< 	GtkWidget *middlebox; /* we need this to show/hide the filebrowser */
< 	GtkWidget *hpane; /* we need this to show/hide the filebrowser */
< 	GtkWidget *statusbar;
< 	GtkWidget *statusbar_lncol; /* where we have the line number */
< 	GtkWidget *statusbar_insovr; /* insert/overwrite indicator */
< 	GtkWidget *statusbar_editmode; /* editor mode and doc encoding */
< 	/* the following list contains toolbar widgets we like to reference later on */
< 	GtkWidget *toolbar_undo;
< 	GtkWidget *toolbar_redo;
< 	GtkWidget *toolbar_quickbar; /* the quickbar widget */
< 	GList *toolbar_quickbar_children; /* this list is needed to remove widgets from the quickbar */
< 	/* following widgets are used to show/hide stuff */
< 	GtkWidget *main_toolbar_hb;
< 	GtkWidget *html_toolbar_hb;
< 	GtkWidget *custom_menu_hb; /* handle box for custom menu */
< 	GtkWidget *output_box;
< 	GtkWidget *leftpanel_notebook;
< 	/* following are lists with dynamic menu entries */
< 	GList *menu_recent_files;
< 	GList *menu_recent_projects;
< 	GList *menu_external;
< 	GList *menu_encodings;
< 	GList *menu_outputbox;
< 	GList *menu_windows;
< 	GtkWidget *menu_cmenu;
< 	GList *menu_cmenu_entries;
< 	GList *menu_filetypes;
< 	/* following is a new approach, that we have only a gpointer here, whioh is typecasted 
< 	in the file where it is needed */
< 	gpointer outputbox;
< 	gpointer bfspell;
< 	gpointer filebrowser;
< 	gpointer snr2;
< 	gpointer fref;
< 	gpointer bmark;
< 	GtkTreeStore *bookmarkstore; /* this is a link to project->bookmarkstore OR main_v->bookmarkstore
< 											  and it is only here for convenience !!!! */
< 	GHashTable *bmark_files;     /* no way, I have to have list of file iters. Other way I 
< 	                                cannot properly load bmarks for closed files */
< } Tbfwin;
< 
< typedef struct {
< 	Tproperties props; /* preferences */
< 	Tglobalsession globses; /* global session */
< 	GList *filetypelist; /* highlighting.c: a list of all filetypes with their icons and highlighting sets */
< 	GList *bfwinlist;
< 	GList *recent_directories; /* a stringlist with the most recently used directories */
< 	Tsessionvars *session; /* holds all session variables for non-project windows */
< 	gpointer filebrowserconfig;
< 	gpointer frefdata;
< 	gpointer bmarkdata;
< 	GtkTreeStore *bookmarkstore; /* the global bookmarks from the global session */
< 	gint num_untitled_documents;
< 	GtkTooltips *tooltips;
< 	guint16 lastkp_hardware_keycode; /* for the autoclosing, we need to know the last pressed key, in the key release callback, */
< 	guint lastkp_keyval;             /* this is different if the modifier key is not pressed anymore during the key-release */
< 	pcre *autoclosingtag_regc; /* the regular expression to check for a valid tag in tag autoclosing*/
< } Tmain;
< 
< extern Tmain *main_v;
< 
< /* public functions from bluefish.c */
< void bluefish_exit_request(void);
< #endif /* __BLUEFISH_H_ */
---
> /* Bluefish HTML Editor
>  * bluefish.h - global prototypes
>  *
>  * Copyright (C) 1998 Olivier Sessink and Chris Mazuc
>  * Copyright (C) 1999-2005 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> /* if you define DEBUG here you will get debug output from all Bluefish parts */
> /* #define DEBUG */
> 
> #ifndef __BLUEFISH_H_
> #define __BLUEFISH_H_
> 
> #include "config.h"
> #define BLUEFISH_SPLASH_FILENAME PKGDATADIR"bluefish_splash.png"
> 
> #ifdef HAVE_SYS_MSG_H
> #define WITH_MSG_QUEUE
> #endif
> 
> #ifdef DEBUG
> #define DEBUG_MSG g_print
> #else /* not DEBUG */
> #ifdef __GNUC__
> #define DEBUG_MSG(args...)
>  /**/
> #else/* notdef __GNUC__ */
> extern void g_none(gchar *first, ...);
> #define DEBUG_MSG g_none
> #endif /* __GNUC__ */
> #endif /* DEBUG */
> 
> #ifdef ENABLE_NLS
> 
> #include <libintl.h>
> #define _(String) gettext (String)
> #define N_(String) (String)
> 
> #else                                                                           
> 
> #define _(String)(String)
> #define N_(String)(String)
> 
> #endif    
> 
> 
> #define DIRSTR "/"
> #define DIRCHR '/'
> 
> #include <sys/types.h>
> #include <regex.h>
> #include <sys/types.h>
> #include <sys/stat.h>
> #include <unistd.h>
> #include <pcre.h>
> 
> #ifdef HAVE_GNOME_VFS
> #include <libgnomevfs/gnome-vfs.h>
> #endif
> 
> 
> /*********************/
> /* undo/redo structs */
> /*********************/
> typedef enum {
> 	UndoDelete = 1, UndoInsert
> } undo_op_t;
> 
> typedef struct {
> 	GList *entries;	/* the list of entries that should be undone in one action */
> 	gint changed;		/* doc changed status at this undo node */
> } unregroup_t;
> 
> typedef struct {
> 	GList *first;
> 	GList *last;
> 	unregroup_t *current;
> 	gint num_groups;
> 	GList *redofirst;
> } unre_t;
> 
> /************************/
> /* filetype struct      */
> /************************/
> 
> typedef struct {
> 	gchar *type;
> 	gchar **extensions;
> 	GdkPixbuf *icon;
> 	gchar *update_chars;
> 	GList *highlightlist;
> 	gboolean editable; /* this a type that can be edited by Bluefish */
> 	gint autoclosingtag; /* 0=off, 1=xml mode, 2=html mode */
> 	gchar *content_regex; /* a regex pattern to test the filetype using the content */
> } Tfiletype;
> 
> /*******************/
> /* document struct */
> /*******************/
> #define BFWIN(var) ((Tbfwin *)(var))
> #define DOCUMENT(var) ((Tdocument *)(var))
> 
> typedef struct {
> 	gchar *filename; /* this is the UTF-8 encoded filename, before you use it on disk you need convert to disk-encoding! */
> 	gchar *encoding;
> 	gint modified;
> /*	time_t mtime; */ /* from stat() */
> #ifdef HAVE_GNOME_VFS
> 	GnomeVFSFileInfo *fileinfo;
> #else /* HAVE_GNOME_VFS */
> 	struct stat statbuf;
> #endif /* HAVE_GNOME_VFS */
> 	gint is_symlink; /* file is a symbolic link */
> 	gulong del_txt_id; /* text delete signal */
> 	gulong ins_txt_id; /* text insert signal */
> 	gulong ins_aft_txt_id; /* text insert-after signal, for auto-indenting */
> 	unre_t unre;
> 	GtkWidget *view;
> 	GtkWidget *tab_label;
> 	GtkWidget *tab_eventbox;
> 	GtkWidget *tab_menu;
> 	GtkTextBuffer *buffer;
> 	gpointer paste_operation;
> 	gint last_rbutton_event; /* index of last 3rd button click */
> 	Tfiletype *hl; /* filetype & highlighting set to use for this document */
> 	gint need_highlighting; /* if you open 10+ documents you don't need immediate highlighting, just set this var, and notebook_switch() will trigger the actual highlighting when needed */
> 	gboolean highlightstate; /* does this document use highlighting ? */
> 	gboolean wrapstate; /* does this document use wrap?*/
> 	gboolean linenumberstate; /* does this document use linenumbers? */
> 	gboolean overwrite_mode; /* is document in overwrite mode */
> 	gboolean autoclosingtag; /* does the document use autoclosing of tags */
> 	gpointer floatingview; /* a 2nd textview widget that has its own window */
> 	gpointer bfwin;
> 	GtkTreeIter *bmark_parent; /* if NULL this document doesn't have bookmarks, if 
> 									it does have bookmarks they are children of this GtkTreeIter */
> } Tdocument;
> 
> typedef struct {
> #ifndef NOSPLASH
> 	gint show_splash_screen;  /* show splash screen at startup */
> #endif /* #ifndef NOSPLASH */
> 	gint show_quickbar_tip;
> 	gint view_line_numbers; /* view line numbers on the left side by default */
> 	gint filebrowser_show_hidden_files;
> 	gint filebrowser_show_backup_files;
> 	gint filebrowser_two_pane_view; /* have one or two panes in the filebrowser */
> 	gint filebrowser_focus_follow; /* have the directory of the current document in focus */
> 	gchar *filebrowser_unknown_icon;
> 	gchar *filebrowser_dir_icon;
> 	gchar *editor_font_string;		/* editor font */
> 	gint editor_tab_width;	/* editor tabwidth */
> 	gint editor_smart_cursor;
> 	gint editor_indent_wspaces; /* indent with spaces, not tabs */
> 	gchar *tab_font_string;		/* notebook tabs font */
> 	GList *browsers; /* browsers array */
> 	GList *external_commands;	/* external commands array */
> 	GList *cust_menu; 		/* DEPRECATED entries in the custom menu */
> 	GList *cmenu_insert; /* custom menu inserts */
> 	GList *cmenu_replace; /* custom menu replaces */
> 	gint highlight_num_lines_count; /* number of lines to highlight in continous highlighting */	
> 	gint defaulthighlight;		/* highlight documents by default */
> #ifdef HAVE_PCRE_UTF8
> 	gint highlight_utf8;    /* enable PCRE UTF-8 support */
> #endif /* HAVE_PCRE_UTF8 */
> 	GList *filetypes; /* filetypes for highlighting and filtering */
> 	gint numcharsforfiletype; /* maximum number of characters in the file to use to find the filetype */
> 	GList *filefilters; /* filebrowser.c filtering */
> 	gchar *last_filefilter;	/* last filelist filter type */
> 	GList *highlight_patterns; /* the highlight patterns */
> 	gint transient_htdialogs;  /* set html dialogs transient ro the main window */
> 	gint restore_dimensions; /* use the dimensions as used the previous run */
> 	gint left_panel_width; 	/* width of filelist */
> 	gint left_panel_left; /* 1 = left, 0 = right */
> 	gint max_recent_files;	/* length of Open Recent list */
> 	gint max_dir_history;	/* length of directory history */
> 	gint backup_file; 			/* wheather to use a backup file */
> 	gchar *backup_filestring;  /* the string to append to the backup file */
> 	gint backup_abort_action; /* if the backup fails, continue save, abort save, or ask the user */
> 	gint backup_cleanuponclose; /* remove the backupfile after close ? */
> 	gchar *image_thumbnailstring;	/* string to append to thumbnail filenames */
> 	gchar *image_thumbnailtype;	/* fileformat to use for thumbnails, "jpeg" or "png" can be handled by gdkpixbuf*/
> 	gint image_thumbnail_refresh_quality; /* 1=GDK_INTERP_BILINEAR, 0=GDK_INTERP_NEAREST*/
> 	gint image_thumbnailsizing_type;	/* scaling ratio=0, fixed width=1, height=2, width+height (discard aspect ratio)=3 */
> 	gint image_thumbnailsizing_val1;	/* the width, height or ratio, depending on the value above */
> 	gint image_thumbnailsizing_val2; /* height if the type=3 */
> 	gchar *image_thumnailformatstring; /* like <a href="%r"><img src="%t"></a> or more advanced */
> 	gint allow_multi_instances; /* allow multiple instances of the same file */
> 	gint modified_check_type; /* 0=no check, 1=by mtime and size, 2=by mtime, 3=by size, 4,5,...not implemented (md5sum?) */
> 	gint num_undo_levels; 	/* number of undo levels per document */
> 	gint clear_undo_on_save; 	/* clear all undo information on file save */
> 	gchar *newfile_default_encoding; /* if you open a new file, what encoding will it use */
> 	GList *encodings; /* all encodings you can choose from */
> 	gint auto_set_encoding_meta; /* auto set metatag for the encoding */
> 	gint auto_update_meta_author; /* auto update author meta tag on save */
> 	gint auto_update_meta_date; /* auto update date meta tag on save */
> 	gint auto_update_meta_generator; /* auto update generator meta tag on save */
> 	gint encoding_search_Nbytes; /* number of bytes to look for the encoding meta tag */
> 	GList *outputbox; /* all outputbox commands */
> 	gint ext_browsers_in_submenu;
> 	gint ext_commands_in_submenu;
> 	gint ext_outputbox_in_submenu;
> 	GList *reference_files; /* all reference files */
> 	gint bookmarks_default_store; /* 0= temporary by default, 1= permanent by default */
> 	gint bookmarks_filename_mode; /* 0=FULLPATH, 1=DIR FROM BASE 2=BASENAME */
> 	gint document_tabposition;
> 	gint leftpanel_tabposition;
> 	gchar *default_basedir;
> 	gchar *project_suffix;
> #ifdef HAVE_LIBASPELL
> 	gchar *spell_default_lang;
> #endif /* HAVE_LIBASPELL */
> 	/* not yet in use */
> 	gchar *image_editor_cline; 	/* image editor commandline */
> 	gint allow_dep;				/* allow <FONT>... */
> 	gint format_by_context; 	/* use <strong> instead of <b>, <emphasis instead of <i> etc. (W3C reccomendation) */
> 	gint xhtml;					/* write <br /> */
> 	gint allow_ruby;			/* allow <ruby> */
> 	gint force_dtd;				/* write <!DOCTYPE...> */
> 	gint dtd_url;				/* URL in DTD */
> 	gint xml_start;				/* <?XML...> */
> 	gint lowercase_tags;		/* use lowercase tags */
> 	gint word_wrap;				/* use wordwrap */
> 	gint autoindent;			/* autoindent code */
> 	gint drop_at_drop_pos; 	/* drop at drop position instead of cursor position */
> 	gint link_management; 	/* perform link management */
> 	gint cont_highlight_update;	/* update the syntax highlighting continuous */
> 	/* key conversion */
> 	gint open_in_running_bluefish; /* open commandline documents in already running session*/
> #ifdef HAVE_GNOME_VFS
> 	gint server_zope_compat;        /* add 'document_src' to uri when reading remote files */
> #endif
> } Tproperties;
> 
> /* the Tglobalsession contains all settings that can change 
> over every time you run Bluefish, so things that *need* to be
> saved after every run! */
> typedef struct {
> 	GList *quickbar_items; /* items in the quickbar toolbar */	
> 	gint main_window_h;			/* main window height */
> 	gint main_window_w;			/* main window width */
> 	gint two_pane_filebrowser_height; /* position of the pane separater on the two paned file browser */
> 	gint fref_ldoubleclick_action; /* left doubleclick in the function reference */
> 	gint fref_info_type; /* type of info shown in a small function reference window */
> 	gint lasttime_cust_menu; /* the last time the defaultfile was checked for new entries */
> 	gint lasttime_highlighting; /* see above */
> 	gint lasttime_filetypes; /* see above */
> 	gint lasttime_encodings; /* see above */
> 	GList *recent_projects;
> } Tglobalsession;
> 
> typedef struct {
> 	GList *classlist;
> 	GList *colorlist;
> 	GList *targetlist;
> 	GList *urllist;
> 	GList *fontlist;
> 	GList *dtd_cblist; /* is this used ?? */
> 	GList *headerlist; /* is this used ?? */
> 	GList *positionlist; /* is this used ?? */
> 	GList *searchlist; /* used in snr2 */
> 	GList *replacelist; /* used in snr2 */
> 	GList *bmarks;
> 	GList *recent_files;
> 	GList *recent_dirs;
> 	gchar *opendir;
> 	gchar *savedir;
>    gint view_html_toolbar;	/* view html toolbar */
>    gint view_custom_menu;  /* view custom menubar */
>    gint view_main_toolbar;	/* view main toolbar */
>    gint view_left_panel;	/* view filebrowser/functionbrowser etc. */
> } Tsessionvars;
> 
> typedef struct {
> 	gchar *filename;
> 	gchar *name;
> 	GList *files;
> 	gchar *basedir;
> 	gchar *webdir;
> 	gchar *template;
> 	gpointer editor;
> 	gint word_wrap;
> 	Tsessionvars *session;
> 	GtkTreeStore *bookmarkstore; /* project bookmarks */
> } Tproject;
> 
> typedef struct {
> 	Tsessionvars *session; /* points to the global session, or to the project session */
> 	Tdocument *current_document; /* one object out of the documentlist, the current visible document */
> 	GList *documentlist; /* document.c and others: all Tdocument objects */
> 	Tdocument *last_activated_doc;
> 	Tproject *project; /* might be NULL for a default project */
> 	GtkWidget *main_window;
> 	GtkWidget *menubar;
> 	gint last_notebook_page; /* a check to see if the notebook changed to a new page */
> 	gulong notebook_switch_signal;
> 	GtkWidget *notebook;
> 	GtkWidget *notebook_fake;
> 	GtkWidget *notebook_box; /* Container for notebook and notebook_fake */
> 	GtkWidget *middlebox; /* we need this to show/hide the filebrowser */
> 	GtkWidget *hpane; /* we need this to show/hide the filebrowser */
> 	GtkWidget *statusbar;
> 	GtkWidget *statusbar_lncol; /* where we have the line number */
> 	GtkWidget *statusbar_insovr; /* insert/overwrite indicator */
> 	GtkWidget *statusbar_editmode; /* editor mode and doc encoding */
> 	/* the following list contains toolbar widgets we like to reference later on */
> 	GtkWidget *toolbar_undo;
> 	GtkWidget *toolbar_redo;
> 	GtkWidget *toolbar_quickbar; /* the quickbar widget */
> 	GList *toolbar_quickbar_children; /* this list is needed to remove widgets from the quickbar */
> 	/* following widgets are used to show/hide stuff */
> 	GtkWidget *main_toolbar_hb;
> 	GtkWidget *html_toolbar_hb;
> 	GtkWidget *custom_menu_hb; /* handle box for custom menu */
> 	GtkWidget *output_box;
> 	GtkWidget *leftpanel_notebook;
> 	/* following are lists with dynamic menu entries */
> 	GList *menu_recent_files;
> 	GList *menu_recent_projects;
> 	GList *menu_external;
> 	GList *menu_encodings;
> 	GList *menu_outputbox;
> 	GList *menu_windows;
> 	GtkWidget *menu_cmenu;
> 	GList *menu_cmenu_entries;
> 	GList *menu_filetypes;
> 	/* following is a new approach, that we have only a gpointer here, whioh is typecasted 
> 	in the file where it is needed */
> 	gpointer outputbox;
> 	gpointer bfspell;
> 	gpointer filebrowser;
> 	gpointer snr2;
> 	gpointer fref;
> 	gpointer bmark;
> 	GtkTreeStore *bookmarkstore; /* this is a link to project->bookmarkstore OR main_v->bookmarkstore
> 											  and it is only here for convenience !!!! */
> 	GHashTable *bmark_files;     /* no way, I have to have list of file iters. Other way I 
> 	                                cannot properly load bmarks for closed files */
> } Tbfwin;
> 
> typedef struct {
> 	Tproperties props; /* preferences */
> 	Tglobalsession globses; /* global session */
> 	GList *filetypelist; /* highlighting.c: a list of all filetypes with their icons and highlighting sets */
> 	GList *bfwinlist;
> 	GList *recent_directories; /* a stringlist with the most recently used directories */
> 	Tsessionvars *session; /* holds all session variables for non-project windows */
> 	gpointer filebrowserconfig;
> 	gpointer frefdata;
> 	gpointer bmarkdata;
> 	GtkTreeStore *bookmarkstore; /* the global bookmarks from the global session */
> 	gint num_untitled_documents;
> 	GtkTooltips *tooltips;
> 	guint16 lastkp_hardware_keycode; /* for the autoclosing, we need to know the last pressed key, in the key release callback, */
> 	guint lastkp_keyval;             /* this is different if the modifier key is not pressed anymore during the key-release */
> 	pcre *autoclosingtag_regc; /* the regular expression to check for a valid tag in tag autoclosing*/
> } Tmain;
> 
> extern Tmain *main_v;
> 
> /* public functions from bluefish.c */
> void bluefish_exit_request(void);
> #endif /* __BLUEFISH_H_ */
1,4303c1,4302
< /* Bluefish HTML Editor
<  * document.c - the document
<  *
<  * Copyright (C) 1998-2006 Olivier Sessink
<  * Copyright (C) 1998 Chris Mazuc
<  * some additions Copyright (C) 2004 Eugene Morenko(More)
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< #include "config.h"
< 
< /* this is needed for Solaris to comply with the latest POSIX standard 
<  * regarding the ctime_r() function
<  */
< #ifdef PLATFORM_SOLARIS
< #define _POSIX_C_SOURCE 200312L
< #endif
< 
< #include <gtk/gtk.h>
< #include <gdk/gdkkeysyms.h>    /* for the keyboard event codes */
< #include <sys/types.h>         /* stat() */
< #include <sys/stat.h>          /* stat() */
< #include <unistd.h>            /* stat() */
< #include <stdio.h>             /* fopen() */
< #include <string.h>            /* strchr() */
< #include <regex.h>             /* regcomp() */
< #include <stdlib.h>            /* system() */
< #include <time.h>              /* ctime_r() */
< #include <pcre.h>
< #ifdef MINGW32
< #include "ctime.c"
< #endif
< /* #define DEBUG */
< 
< #ifdef DEBUGPROFILING
< #include <sys/times.h>
< #endif
< #include "bluefish.h"
< #include "document.h"
< #include "bf_lib.h"
< #include "bookmark.h"
< #include "cap.h"
< #include "char_table.h"    /* convert_utf8...() */
< #include "filebrowser.h"
< #include "gtk_easy.h"      /* *_dialog() */
< #include "gui.h"           /* statusbar_message() */
< #include "highlight.h"     /* all highlight functions */
< #include "menu.h"          /* add_to_recent_list */
< #include "pixmap.h"
< #include "rpopup.h"        /* doc_bevent_in_html_tag(), rpopup_edit_tag_cb() */
< #include "snr2.h"          /* snr2_run_extern_replace */
< #include "stringlist.h"    /* free_stringlist() */
< #include "undo_redo.h"     /* doc_unre_init() */
< 
< typedef struct {
< 	GtkWidget *textview;
< 	GtkWidget *window;
< } Tfloatingview;
< #define FLOATINGVIEW(var) ((Tfloatingview *)(var))
< 
< typedef struct {
< 	gint so;
< 	gint eo;
< } Tpasteoperation;
< #define PASTEOPERATION(var) ((Tpasteoperation *)(var))
< 
< void autoclosing_init(void) {
< 	const char *error;
< 	int erroffset;
< 	main_v->autoclosingtag_regc = pcre_compile("^<([a-z][a-z0-9]*)([\n\t ][^<>]*)?>$", PCRE_CASELESS, &error,&erroffset,NULL);
< #ifdef DEBUG
< 	if (!main_v->autoclosingtag_regc) {
< 		DEBUG_MSG("autoclosing_init, ERROR, %s\n",error);
< 	}
< #endif
< }
< 
< /**
<  * return_allwindows_documentlist:
<  *
<  * returns a documentlist with all documents in all windows, the list should be freed, the Tdocuments obviously not
<  *
<  * Return value: #GList* with all documents
<  */
< GList *return_allwindows_documentlist() {
< 	GList *newdoclist=NULL, *bflist, *tmplist=NULL;
< 	bflist = g_list_first(main_v->bfwinlist);
< 	DEBUG_MSG("return_allwindows_documentlist, bfwinlist length=%d\n",g_list_length(main_v->bfwinlist));
< 	while (bflist) {
< 		DEBUG_MSG("return_allwindows_documentlist, current bfwin doclist length=%d\n",g_list_length(BFWIN(bflist->data)->documentlist));
< 		tmplist = g_list_first(BFWIN(bflist->data)->documentlist);
< 		while (tmplist) {
< 			newdoclist = g_list_append(newdoclist,tmplist->data);
< 			tmplist = g_list_next(tmplist);
< 		}
< 		bflist = g_list_next(bflist);
< 	}
< 	DEBUG_MSG("return_allwindows_documentlist, returning list length %d\n",g_list_length(newdoclist));
< 	return newdoclist;
< }
< 
< /**
<  * return_filenamestringlist_from_doclist:
<  * @doclist: #GList*
<  *
<  * Returns a stringlist with filenames given a 
<  * list with documents (#Tdocument*)
<  *
<  * Return value: #GList* stringlist with filenames
<  */
< GList *return_filenamestringlist_from_doclist(GList *doclist) {
< 	GList *newlist=NULL, *tmplist;
< 	DEBUG_MSG("return_filenamestringlist_from_doclist, started for doclist %p, len=%d\n",doclist,g_list_length(doclist));
< 	tmplist = g_list_first(doclist);
< 	while(tmplist){
< 		if (DOCUMENT(tmplist->data)->filename) {
< 			DEBUG_MSG("return_filenamestringlist_from_doclist, adding filename %s\n",DOCUMENT(tmplist->data)->filename);
< 			newlist = g_list_append(newlist, g_strdup(DOCUMENT(tmplist->data)->filename));
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return newlist;
< }
< 
< /*
<  * return_num_untitled_documents:
<  * @doclist: #GList* with documents
<  *
<  * returns the number of untitled documents 
<  * opened in Bluefish
<  *
<  * Return value: #gint with number
<  *
< gint return_num_untitled_documents(GList *doclist) {
< 	gint retval = 0;
< 	GList *tmplist = g_list_first(doclist);
< 	while (tmplist) {
< 		if (DOCUMENT(tmplist->data)->filename == NULL) retval++;
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return retval;
< }*/
< 
< /**
<  * add_filename_to_history:
<  * @bfwin: #Tbfwin* 
<  * @filename: a #gchar
<  * 
<  * adds a filename to the recently opened files list
<  * will not add it to the menu, only to the list and the file
<  **/
< void add_filename_to_history(Tbfwin *bfwin, gchar *filename) {
< 	gchar *dirname;
< 
< 	add_to_recent_list(bfwin, filename, 0, FALSE); /* the recent menu */
< 	dirname = g_path_get_dirname(filename);
< 	DEBUG_MSG("add_filename_to_history, adding %s\n",dirname);
< 	main_v->recent_directories = add_to_history_stringlist(main_v->recent_directories,dirname,FALSE,TRUE);
< 	g_free(dirname);
< }
< 
< /**
<  * documentlist_return_index_from_filename:
<  * @doclist: #GList* with the documents to search in
<  * @filename: a #gchar
<  * 
<  * if the file is open, it returns the index in the documentlist
<  * which is also the index in the notebook
<  * if the file is not open it returns -1
<  *
<  * Return value: the index number on success, -1 if the file is not open
<  **/
< gint documentlist_return_index_from_filename(GList *doclist, gchar *filename) {
< 	GList *tmplist;
< 	gint count=0;
< 
< 	if (!filename) {
< 		return -1;
< 	}
< 	
< 	tmplist = g_list_first(doclist);
< 	while (tmplist) {
< 		if (((Tdocument *)tmplist->data)->filename &&(strcmp(filename, ((Tdocument *)tmplist->data)->filename) ==0)) {
< 			return count;
< 		}
< 		count++;
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return -1;
< }
< /**
<  * documentlist_return_index_from_filename:
<  * @doclist: #GList* with the documents to search in
<  * @filename: a #gchar
<  * 
<  * if the file is open, it returns the Tdocument* in the documentlist
<  * if the file is not open it returns NULL
<  *
<  * Return value: #Tdocument* or NULL if not open
<  **/
< Tdocument *documentlist_return_document_from_filename(GList *doclist, gchar *filename) {
< 	GList *tmplist;
< 	if (!filename) {
< 		DEBUG_MSG("documentlist_return_document_from_filename, no filename! returning\n");
< 		return NULL;
< 	}
< 	DEBUG_MSG("documentlist_return_document_from_filename, filename=%s\n",filename);
< 	tmplist = g_list_first(doclist);
< 	while (tmplist) {
< 		DEBUG_MSG("documentlist_return_document_from_filename, comparing with %s\n",filename);
< 		if (DOCUMENT(tmplist->data)->filename &&(strcmp(filename, DOCUMENT(tmplist->data)->filename) ==0)) {
< 			DEBUG_MSG("documentlist_return_document_from_filename, found, returning %p\n", tmplist->data);
< 			return DOCUMENT(tmplist->data);
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	DEBUG_MSG("documentlist_return_document_from_filename, not found, returning NULL\n");
< 	return NULL;
< }
< 
< /**
<  * documentlist_return_document_from_index:
<  * @doclist: #GList* with the documents to search in
<  * @index: a #gint, index in the documentlist.
<  *
<  * If the index is valid, it returns the appropriate Tdocument.
<  *
<  * Return value: Pointer to Tdocument on success, NULL on invalid index.
<  **/
< Tdocument *documentlist_return_document_from_index(GList *doclist, gint index) {
< 	return (Tdocument *) g_list_nth_data(doclist, index);
< }
< 
< /**
<  * doc_update_highlighting:
<  * @bfwin: #Tbfwin* with the window
<  * @callback_action: #guint ignored
<  * @widget: a #GtkWidget* ignored
<  *
<  * this function works on the current document
<  * if highlighting is disabled, this enables the highlighting
<  * the highlighting is also refreshed for the full document
<  *
<  * Return value: void
<  **/
< void doc_update_highlighting(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
< 	if (!bfwin->current_document) return;
< 	DEBUG_MSG("doc_update_highlighting, curdoc=%p, highlightstate=%d\n", bfwin->current_document, bfwin->current_document->highlightstate);
< 	if (bfwin->current_document->highlightstate == 0) {
< 		setup_toggle_item(gtk_item_factory_from_widget(bfwin->menubar), "/Document/Highlight Syntax", TRUE);
< 		DEBUG_MSG("doc_update_highlighting, calling doc_toggle_highlighting_cb\n");
< 		doc_toggle_highlighting_cb(bfwin, 0, NULL);
< 	} else {
< 		doc_highlight_full(bfwin->current_document);
< 	}
< }
< 
< /**
<  * doc_set_wrap:
<  * @doc: a #Tdocument
<  *
<  * this function will synchronise doc->wrapstate with the textview widget
<  * if doc->wrapstate TRUE it will set the textview to GTK_WRAP_WORD
<  * else (FALSE) it will set the textview to GTK_WRAP_NONE
<  *
<  * Return value: void
<  **/
< void doc_set_wrap(Tdocument * doc) {
< 	if (doc->wrapstate) {
< 		gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(doc->view),GTK_WRAP_WORD);
< 	} else {
< 		gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(doc->view),GTK_WRAP_NONE);
< 	}
< }
< /**
<  * doc_set_filetype:
<  * @doc: a #Tdocument
<  * @ft: a #Tfiletype with the new filetype
<  *
<  * this function will compare the filetype from the document and the new filetype
<  * and if they are different it will remove the old highlighting, set the newfiletype
<  * and set the filetype widget, it will return TRUE if the type was changed
<  *
<  * Return value: #gboolean if the value was changed
<  **/
< gboolean doc_set_filetype(Tdocument *doc, Tfiletype *ft) {
< 	if (ft != doc->hl) {
< 		doc_remove_highlighting(doc);
< 		doc->hl = ft;
< 		doc->need_highlighting = TRUE;
< 		doc->autoclosingtag = (ft->autoclosingtag > 0);
< 		gui_set_document_widgets(doc);
< 		return TRUE;
< 	}
< 	return FALSE;
< }
< /**
<  * get_filetype_by_name:
<  * @name: a #gchar* with the filetype name
<  *
<  * returns the Tfiletype* for corresponding to name
<  *
<  * Return value: Tfiletype* 
<  **/
< Tfiletype *get_filetype_by_name(gchar * name) {
< 	GList *tmplist;
< 	tmplist = g_list_first(main_v->filetypelist);
< 	while (tmplist) {
< 		if (strcmp(((Tfiletype *) tmplist->data)->type, name) == 0) {
< 			return (Tfiletype *) tmplist->data;
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return NULL;
< }
< /**
<  * get_filetype_by_filename_and_content:
<  * @filename: a #gchar* with the filename or NULL
<  * @buf: a #gchar* with the contents to search for with the Tfiletype->content_regex or NULL
<  *
<  * returns the Tfiletype* for corresponding to filename, using the file extension. If
<  * nothing is found using the file extension or filename==NULL it will start matching 
<  * the contents in buf with Tfiletype->content_regex
<  *
<  * if no filetype is found it will return NULL
<  *
<  * Return value: #Tfiletype* or NULL
<  **/
< Tfiletype *get_filetype_by_filename_and_content(gchar *filename, gchar *buf) {
< 	GList *tmplist;
< 
< 	if (filename) {
< 		tmplist = g_list_first(main_v->filetypelist);
< 		while (tmplist) {
< 			if (filename_test_extensions(((Tfiletype *) tmplist->data)->extensions, filename)) {
< 				return (Tfiletype *) tmplist->data;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	if (buf) {
< 		tmplist = g_list_first(main_v->filetypelist);
< 		while (tmplist) {
< 			Tfiletype *ft = (Tfiletype *)tmplist->data;
< 			if (strlen(ft->content_regex)) {
< 				pcre *pcreg;
< 				const char *err=NULL;
< 				int erroffset=0;
< 				DEBUG_MSG("get_filetype_by_filename_and_content, compiling pattern %s\n",ft->content_regex);
< 				pcreg = pcre_compile(ft->content_regex, PCRE_DOTALL|PCRE_MULTILINE,&err, &erroffset,NULL);
< 				if (err) {
< 					g_print("while testing for filetype '%s', pattern '%s' resulted in error '%s' at position %d\n", ft->type, ft->content_regex, err, erroffset);
< 				}
< 				if (pcreg) {
< 					int ovector[30];
< 					int retval = pcre_exec(pcreg,NULL,buf,strlen(buf),0,0,ovector,30);
< 					DEBUG_MSG("get_filetype_by_filename_and_content, buf='%s'\n",buf);
< 					DEBUG_MSG("get_filetype_by_filename_and_content, pcre_exec retval=%d\n",retval);
< 					if (retval > 0) {
< 						/* we have a match!! */
< 						pcre_free(pcreg);
< 						return ft;
< 					}
< 					pcre_free(pcreg);
< 				}
< 			} else {
< 				DEBUG_MSG("get_filetype_by_filename_and_content, type %s does not have a pattern (%s)\n",ft->type,ft->content_regex);
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	return NULL;
< }
< /**
<  * doc_reset_filetype:
<  * @doc: #Tdocument to reset
<  * @newfilename: a #gchar* with the new filename
<  * @buf: a #gchar* with the contents of the file, or NULL if the function should get that from the TextBuffer
<  *
<  * sets the new filetype based on newfilename and content, updates the widgets and highlighting
<  * (using doc_set_filetype())
<  *
<  * Return value: void
<  **/
< void doc_reset_filetype(Tdocument * doc, gchar * newfilename, gchar *buf) {
< 	Tfiletype *ft;
< 	if (buf) {
< 		ft = get_filetype_by_filename_and_content(newfilename, buf);
< 	} else {
< 		gchar *tmp = doc_get_chars(doc, 0, main_v->props.numcharsforfiletype);
< 		ft = get_filetype_by_filename_and_content(newfilename, tmp);
< 		g_free(tmp);
< 	}
< 	if (!ft) {
< 		GList *tmplist;
< 		/* if none found return first set (is default set) */
< 		tmplist = g_list_first(main_v->filetypelist);
< 		if (!tmplist) {
< 			DEBUG_MSG("doc_reset_filetype, no default filetype? huh?\n");
< 			return;
< 		}
< 		ft = (Tfiletype *)tmplist->data;
< 	}
< 	doc_set_filetype(doc, ft);
< }	
< 
< /**
<  * doc_set_font:
<  * @doc: a #Tdocument
<  * @fontstring: a #gchar describing the font
<  *
<  * this function will set the textview from doc to use the font
<  * described by fontstring
<  *
<  * Return value: void
<  **/
< 
< #ifdef __GNUC__
< __inline__ 
< #endif
< void doc_set_font(Tdocument *doc, gchar *fontstring) {
< 	if (fontstring) {
< 		apply_font_style(doc->view, fontstring);
< 	} else {
< 		apply_font_style(doc->view, main_v->props.editor_font_string);
< 	}
< }
< 
< /**
<  * This function is taken from gtksourceview
<  * Copyright (C) 2001
<  * Mikael Hermansson <tyan@linux.se>
<  * Chris Phelps <chicane@reninet.com>
<  */
< static gint textview_calculate_real_tab_width(GtkWidget *textview, gint tab_size) {
< 	gchar *tab_string;
< 	gint counter = 0;
< 	gint tab_width = 0;
< 
< 	if (tab_size <= 0)
< 		return 0;
< 
< 	tab_string = g_malloc (tab_size + 1);
< 	while (counter < tab_size) {
< 		tab_string[counter] = ' ';
< 		counter++;
< 	}
< 	tab_string[tab_size] = '\0';
< 	tab_width =  widget_get_string_size(textview, tab_string);
< 	g_free(tab_string);
< /*	if (tab_width < 0) tab_width = 0;*/
< 	return tab_width;
< }
< 
< /**
<  * doc_set_tabsize:
<  * @doc: a #Tdocument
<  * @tabsize: a #gint with the tab size
<  *
<  * this function will set the textview from doc to use the tabsize
<  * described by tabsize
<  *
<  * Return value: void
<  **/
< void doc_set_tabsize(Tdocument *doc, gint tabsize) {
< 	PangoTabArray *tab_array;
< 	gint pixels = textview_calculate_real_tab_width(GTK_WIDGET(doc->view), tabsize);
< 	DEBUG_MSG("doc_set_tabsize, tabsize=%d, pixels=%d\n", tabsize, pixels);
< 	tab_array = pango_tab_array_new (1, TRUE);
< 	pango_tab_array_set_tab (tab_array, 0, PANGO_TAB_LEFT, pixels);
< 	gtk_text_view_set_tabs (GTK_TEXT_VIEW (doc->view), tab_array);
< 	pango_tab_array_free(tab_array);
< }
< 
< /**
<  * gui_change_tabsize:
<  * @bfwin: #Tbfwin* with the window
<  * @action: a #guint, if 1 increase the tabsize, if 0 decrease
<  * @widget: a #GtkWidget, ignored
<  *
<  * this function is the callback for the menu, based on action
<  * it will increase or decrease the tabsize by one 
<  * for ALL DOCUMENTS (BUG: currently only all documents in the same window)
<  *
<  * Return value: void
<  **/
< void gui_change_tabsize(Tbfwin *bfwin,guint action,GtkWidget *widget) {
< 	GList *tmplist;
< 	PangoTabArray *tab_array;
< 	gint pixels;
< 	if (action == 1) {
< 		main_v->props.editor_tab_width++;
< 	} else {
< 		main_v->props.editor_tab_width--;
< 	}
< 	{
< 		gchar *message = g_strdup_printf("Setting tabsize to %d", main_v->props.editor_tab_width);
< 		statusbar_message(bfwin,message, 2000);
< 		g_free(message);
< 	}
< 	/* this should eventually be the total documentlist, not only for this window */
< 	tmplist = g_list_first(bfwin->documentlist);
< 	pixels = textview_calculate_real_tab_width(GTK_WIDGET(((Tdocument *)tmplist->data)->view), main_v->props.editor_tab_width);
< 	tab_array = pango_tab_array_new (1, TRUE);
< 	pango_tab_array_set_tab (tab_array, 0, PANGO_TAB_LEFT, pixels);
< 	while (tmplist) {
< 		gtk_text_view_set_tabs (GTK_TEXT_VIEW(((Tdocument *)tmplist->data)->view), tab_array);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	pango_tab_array_free(tab_array);
< }
< /**
<  * doc_is_empty_non_modified_and_nameless:
<  * @doc: a #Tdocument
<  *
<  * this function returns TRUE if the document pointer to by doc
<  * is an empty, nameless and non-modified document
<  *
<  * Return value: gboolean, TRUE if doc is empty, non-modified and nameless
<  **/
< gboolean doc_is_empty_non_modified_and_nameless(Tdocument *doc) {
< 	if (!doc) {
< 		return FALSE;
< 	}
< 	if (doc->modified || doc->filename) {
< 		return FALSE;
< 	}
< 	if (gtk_text_buffer_get_char_count(doc->buffer) > 0) {
< 		return FALSE;
< 	}
< 	return TRUE;
< }
< 
< 
< /* gboolean test_docs_modified(GList *doclist)
<  * if doclist is NULL it will use main_v->documentlist as doclist
<  * returns TRUE if there are any modified documents in doclist
<  * returns FALSE if there are no modified documents in doclist
<  */
< 
< /**
<  * test_docs_modified:
<  * @doclist: a #GList with documents
<  *
<  * this function will test if any documents in doclist are modified
<  *
<  * Return value: gboolean
<  **/
<  
< gboolean test_docs_modified(GList *doclist) {
< 
< 	GList *tmplist;
< 	Tdocument *tmpdoc;
< 
< 	if (doclist) {
< 		tmplist = g_list_first(doclist);
< 	} else {
< 		g_print("test_docs_modified, calling without a doclist is deprecated, aborting\n");
< 		exit(144);
< 	}
< 	
< 	while (tmplist) {
< 		tmpdoc = (Tdocument *) tmplist->data;
< #ifdef DEBUG
< 		g_assert(tmpdoc);
< #endif
< 		if (tmpdoc->modified) {
< 			return TRUE;
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return FALSE;
< }
< /**
<  * test_only_empty_doc_left:
<  * @doclist: #GList* with all documents to test in
<  *
<  * returns TRUE if there is only 1 document open, and that document
<  * is not modified and 0 bytes long and without filename
<  * returns FALSE if there are multiple documents open, or 
<  * a modified document is open, or a > 0 bytes document is open
<  * or a document with filename is open
<  *
<  * Return value: void
<  **/
< gboolean test_only_empty_doc_left(GList *doclist) {
< 	if (g_list_length(doclist) > 1) {
< 		return FALSE;
< 	} else {
< 		Tdocument *tmpdoc;
< 		GList *tmplist = g_list_first(doclist);
< 		if (tmplist) {
< #ifdef DEBUG
< 			g_assert(tmplist->data);
< #endif
< 			tmpdoc = tmplist->data;
< 			if (!doc_is_empty_non_modified_and_nameless(tmpdoc)) {
< 				return FALSE;
< 			}
< 		}
< 	}
< 	return TRUE;
< }
< /**
<  * doc_move_to_window:
<  * @doc: #Tdocument*
<  * @newwin: #Tbfwin*
<  *
<  * detaches the document from it's old window (doc->bfwin) and attaches
<  * it to the window newwin
<  *
<  * Return value: void, ignored
<  */
< void doc_move_to_window(Tdocument *doc, Tbfwin *newwin) {
< 	Tbfwin *oldwin = BFWIN(doc->bfwin);
< 	GtkWidget *tab_widget, *scroll;
< 	DEBUG_MSG("doc_move_to_window, oldwin=%p, newwin=%p, doc=%p\n",oldwin,newwin,doc);
< 	tab_widget = doc->tab_eventbox->parent;
< 	scroll = doc->view->parent;
< 	gtk_widget_ref(scroll);
< 	gtk_widget_ref(tab_widget);
< 	gtk_widget_ref(doc->tab_menu);
< 	DEBUG_MSG("doc_move_to_window, tab_label=%p, tab_widget=%p\n",doc->tab_label, tab_widget);
< /*	gtk_container_remove(GTK_CONTAINER(oldwin->notebook), doc->view);*/
< 	gtk_notebook_remove_page(GTK_NOTEBOOK(oldwin->notebook), g_list_index(oldwin->documentlist, doc));
< 	oldwin->documentlist = g_list_remove(oldwin->documentlist, doc);
< 	DEBUG_MSG("doc_move_to_window, removed doc=%p from oldwin %p\n",doc,oldwin);
< 	doc->bfwin = newwin;
< 	newwin->documentlist = g_list_append(newwin->documentlist, doc);
< 	gtk_notebook_append_page_menu(GTK_NOTEBOOK(newwin->notebook), scroll, tab_widget, doc->tab_menu);
< 	DEBUG_MSG("doc_move_to_window, appended doc=%p to newwin %p\n",doc,newwin);
< 
< 	gtk_widget_unref(scroll);
< 	gtk_widget_unref(tab_widget);
< 	gtk_widget_unref(doc->tab_menu);
< 
< 	gtk_widget_show_all(scroll);
< 	gtk_widget_show_all(tab_widget);
< 	gtk_widget_show(doc->tab_menu);
< 	
< 	if (NULL == oldwin->documentlist) {
< 		file_new_cb(NULL, oldwin);
< 	}
< }
< /**
<  * doc_has_selection:
<  * @doc: a #Tdocument
<  *
<  * returns TRUE if the document has a selection
<  * returns FALSE if it does not
<  *
<  * Return value: gboolean
<  **/
< gboolean doc_has_selection(Tdocument *doc) {
< 	return gtk_text_buffer_get_selection_bounds(doc->buffer,NULL,NULL);
< }
< 
< /**
<  * doc_set_tooltip:
<  * @doc: #Tdocument*
<  *
<  * will set the tooltip on the notebook tab eventbox
<  *
<  * Return value: void
<  */
< static void doc_set_tooltip(Tdocument *doc) {
< 	gchar *text, *tmp;
< 	gchar mtimestr[128], *modestr=NULL, *sizestr=NULL;
< 	mtimestr[0] = '\0';
< #ifdef HAVE_GNOME_VFS
< 	DEBUG_MSG("doc_set_tooltip, fileinfo=%p\n", doc->fileinfo);
< 	if (doc->fileinfo) {
< 		if (doc->fileinfo->valid_fields & GNOME_VFS_FILE_INFO_FIELDS_PERMISSIONS) {
< 			modestr = filemode_to_string(doc->fileinfo->permissions);
< 		}
< 		if (doc->fileinfo->valid_fields & GNOME_VFS_FILE_INFO_FIELDS_MTIME) {
< 			ctime_r(&doc->fileinfo->mtime,mtimestr);
< 		}
< 		if (doc->fileinfo->valid_fields & GNOME_VFS_FILE_INFO_FIELDS_SIZE) {
< 			sizestr = gnome_vfs_format_file_size_for_display(doc->fileinfo->size);
< 		}
< 	}
< #else
< 	if (doc->statbuf.st_mode != 0 || doc->statbuf.st_size != 0) {
< 		modestr = filemode_to_string(doc->statbuf.st_mode);
< 		ctime_r(&doc->statbuf.st_mtime,mtimestr);
< 		/*sizestr = g_strdup_printf("%ld", doc->statbuf.st_size);*/
< 		if (sizeof(off_t) == sizeof(unsigned long long int)) {
< 			sizestr = g_strdup_printf("%llu", (unsigned long long int )doc->statbuf.st_size);
< 		} else {
< 			sizestr = g_strdup_printf("%lu", doc->statbuf.st_size);
<         }
< 	}
< #endif
< 	tmp = text = g_strconcat(_("Name: "),gtk_label_get_text(GTK_LABEL(doc->tab_menu))
< 							,_("\nType: "),doc->hl->type
< 							,_("\nEncoding: "), (doc->encoding != NULL) ? doc->encoding : main_v->props.newfile_default_encoding
< 							,NULL);
< 	if (sizestr) {
< 		text = g_strconcat(text, _("\nSize (on disk): "), sizestr, _(" bytes"), NULL);
< 		g_free(tmp);
< 		g_free(sizestr);
< 		tmp = text;
< 	}
< 	if (modestr) {
< 		text = g_strconcat(text, _("\nPermissions: "), modestr, NULL);
< 		g_free(tmp);
< 		g_free(modestr);
< 		tmp = text;
< 	}
< 	if (mtimestr[0] != '\0') {
< 		trunc_on_char(mtimestr, '\n');
< 		text = g_strconcat(text, _("\nLast modified: "), mtimestr, NULL);
< 		g_free(tmp);
< 		tmp = text;
< 	}
< 
< 	gtk_tooltips_set_tip(main_v->tooltips, doc->tab_eventbox, text, "");
< 	g_free(text);
< }
< /**
<  * doc_set_title:
<  * @doc: #Tdocument*
<  *
<  * will set the notebook tab label and the notebook tab menu label
<  * and if this document->bfwin == document->bfwin->current_document
<  * it will update the bfwin title
<  * it will also call doc_set_tooltip() to reflect the changes in the tooltip
<  *
<  * Return value: void
<  */
< static void doc_set_title(Tdocument *doc) {
< 	gchar *label_string, *tabmenu_string;
< 	if (doc->filename) {
< 		label_string = g_path_get_basename(doc->filename);
< 		tabmenu_string = g_strdup(doc->filename);
< 	} else {
< 		label_string = g_strdup_printf(_("Untitled %d"),main_v->num_untitled_documents);
< 		tabmenu_string =  g_strdup(label_string);
< 		main_v->num_untitled_documents++;
< 	}
< 	gtk_label_set(GTK_LABEL(doc->tab_menu),tabmenu_string);
< 	gtk_label_set(GTK_LABEL(doc->tab_label),label_string);
< 	doc_set_tooltip(doc);
< 	g_free(label_string);
< 	g_free(tabmenu_string);
< 	if (doc->bfwin == BFWIN(doc->bfwin)->current_document) {
< 		gui_set_title(doc->bfwin, doc);
< 	}
< }
< /**
<  * doc_set_modified:
<  * @doc: a #Tdocument
<  * @value: a gint TRUE or FALSE
<  *
<  * sets the doc->modified to value
<  * if it already has this value, do nothing
<  * if it does not have this value, it will do some action
<  *
<  * if the document pointed to by doc == the current document
<  * it will update the toolbar and menu undo/redo items
<  *
<  * if value is TRUE, it will make the notebook and notebook-menu
<  * label red, if value is FALSE it will set them to black
<  *
<  * Return value: void
<  **/
< void doc_set_modified(Tdocument *doc, gint value) {
< 	DEBUG_MSG("doc_set_modified, started, doc=%p, value=%d\n", doc, value);
< 	if (doc->modified != value) {
< 		GdkColor colorred = {0, 65535, 0, 0};
< 		GdkColor colorblack = {0, 0, 0, 0};
< 
< 		doc->modified = value;
< 		if (doc->modified) {
< 			gtk_widget_modify_fg(doc->tab_menu, GTK_STATE_NORMAL, &colorred);
< 			gtk_widget_modify_fg(doc->tab_menu, GTK_STATE_PRELIGHT, &colorred);
< 			gtk_widget_modify_fg(doc->tab_label, GTK_STATE_NORMAL, &colorred);
< 			gtk_widget_modify_fg(doc->tab_label, GTK_STATE_PRELIGHT, &colorred);
< 			gtk_widget_modify_fg(doc->tab_label, GTK_STATE_ACTIVE, &colorred);
< 		} else {
< 			gtk_widget_modify_fg(doc->tab_menu, GTK_STATE_NORMAL, &colorblack);
< 			gtk_widget_modify_fg(doc->tab_menu, GTK_STATE_PRELIGHT, &colorblack);
< 			gtk_widget_modify_fg(doc->tab_label, GTK_STATE_NORMAL, &colorblack);
< 			gtk_widget_modify_fg(doc->tab_label, GTK_STATE_PRELIGHT, &colorblack);
< 			gtk_widget_modify_fg(doc->tab_label, GTK_STATE_ACTIVE, &colorblack);
< 		}
< 	}
< #ifdef DEBUG
< 	else {
< 		DEBUG_MSG("doc_set_modified, doc %p did have value %d already\n", doc, value);
< 	}
< #endif
< 	/* only when this is the current document we have to change these */
< 	DEBUG_MSG("doc=%p, doc->bfwin=%p\n",doc,doc->bfwin);
< 	if (doc == BFWIN(doc->bfwin)->current_document) {
< 		gui_set_undo_redo_widgets(BFWIN(doc->bfwin),doc_has_undo_list(doc), doc_has_redo_list(doc));
< 	}
< #ifdef DEBUG
< 	else {
< 		DEBUG_MSG("doc_set_modified, doc != current_document, so we do not update the gui widgets\n");
< 	}
< #endif
< }
< 
< #ifdef HAVE_GNOME_VFS
< /* returns 1 if the file is modified on disk, returns 0 
< if the file is modified by another process, returns
< 0 if there was no previous mtime information available 
< if newstatbuf is not NULL, it will be filled with the new statbuf from the file IF IT WAS CHANGED!!!
< leave NULL if you do not need this information, if the file is not changed, this field will not be set!!
< */
< static gboolean doc_check_modified_on_disk(Tdocument *doc, GnomeVFSFileInfo **newfileinfo) {
< 	if (main_v->props.modified_check_type == 0 || !doc->filename || doc->fileinfo == NULL) {
< 		return FALSE;
< 	} else if (main_v->props.modified_check_type < 4) {
< 		GnomeVFSFileInfo *fileinfo;
< 		gboolean unref_fileinfo = FALSE;
< 		gchar *ondiskencoding = get_filename_on_disk_encoding(doc->filename);
< 		if (*newfileinfo == NULL) {
< 			fileinfo = gnome_vfs_file_info_new();
< 			unref_fileinfo = TRUE;
< 			DEBUG_MSG("doc_check_modified_on_disk, allocating new fileinfo at %p\n", fileinfo);
< 		} else {
< 			fileinfo = *newfileinfo;
< 			DEBUG_MSG("doc_check_modified_on_disk, using existing fileinfo at %p\n", fileinfo);
< 		}
< 		if (gnome_vfs_get_file_info(ondiskencoding, fileinfo
< 					, GNOME_VFS_FILE_INFO_DEFAULT|GNOME_VFS_FILE_INFO_FOLLOW_LINKS) == GNOME_VFS_OK) {
< 			g_free(ondiskencoding);
< 			if (main_v->props.modified_check_type == 1 || main_v->props.modified_check_type == 2) {
< 				if (doc->fileinfo->mtime < fileinfo->mtime) {
< 					if (unref_fileinfo) gnome_vfs_file_info_unref(fileinfo);
< 					return TRUE;
< 				}
< 			}
< 			if (main_v->props.modified_check_type == 1 || main_v->props.modified_check_type == 3) {
< 				if (doc->fileinfo->size != fileinfo->size) {
< 					if (unref_fileinfo) gnome_vfs_file_info_unref(fileinfo);
< 					return TRUE;
< 				}
< 			}
< 		} else g_free(ondiskencoding);
< 		if (unref_fileinfo) gnome_vfs_file_info_unref(fileinfo);
< 	} else {
< 		DEBUG_MSG("doc_check_mtime, type %d checking not yet implemented\n", main_v->props.modified_check_type);
< 	}
< 	return FALSE;
< }
< #else /* HAVE_GNOME_VFS */
< /* returns 1 if the file is modified on disk, returns 0 
< if the file is modified by another process, returns
< 0 if there was no previous mtime information available 
< if newstatbuf is not NULL, it will be filled with the new statbuf from the file IF IT WAS CHANGED!!!
< leave NULL if you do not need this information, if the file is not changed, this field will not be set!!
< */
< static gboolean doc_check_modified_on_disk(Tdocument *doc, struct stat *newstatbuf) {
< 	if (main_v->props.modified_check_type == 0 || !doc->filename || doc->statbuf.st_mtime == 0 || doc->statbuf.st_size == 0) {
< 		return FALSE;
< 	} else if (main_v->props.modified_check_type < 4) {
< 		struct stat statbuf;
< 		gchar *ondiskencoding = get_filename_on_disk_encoding(doc->filename);
< 		if (stat(ondiskencoding, &statbuf) == 0) {
< 			g_free(ondiskencoding);
< 			*newstatbuf = statbuf;
< 			if (main_v->props.modified_check_type == 1 || main_v->props.modified_check_type == 2) {
< 				if (doc->statbuf.st_mtime < statbuf.st_mtime) {
< 					return TRUE;
< 				}
< 			}
< 			if (main_v->props.modified_check_type == 1 || main_v->props.modified_check_type == 3) {
< 				if (doc->statbuf.st_size != statbuf.st_size) {
< 					return TRUE;
< 				}
< 			}
< 		} else g_free(ondiskencoding);
< 	} else {
< 		DEBUG_MSG("doc_check_mtime, type %d checking not yet implemented\n", main_v->props.modified_check_type);
< 	}
< 	return FALSE;
< }
< #endif /* HAVE_GNOME_VFS */
< 
< /* doc_set_stat_info() includes setting the mtime field, so there is no need
< to call doc_update_mtime() as well */
< static void doc_set_stat_info(Tdocument *doc) {
< 	if (doc->filename) {
< 		gchar *ondiskencoding = get_filename_on_disk_encoding(doc->filename);
< #ifdef HAVE_GNOME_VFS
< 		if (doc->fileinfo == NULL) {
< 			doc->fileinfo = gnome_vfs_file_info_new();
< 		}
< 		gnome_vfs_get_file_info(ondiskencoding, doc->fileinfo
< 				,GNOME_VFS_FILE_INFO_DEFAULT|GNOME_VFS_FILE_INFO_FOLLOW_LINKS);
< 		doc->is_symlink = GNOME_VFS_FILE_INFO_SYMLINK(doc->fileinfo);
< #else
< 		struct stat statbuf;
< 		if (lstat(ondiskencoding, &statbuf) == 0) {
< 			if (S_ISLNK(statbuf.st_mode)) {
< 				doc->is_symlink = 1;
< 				stat(ondiskencoding, &statbuf);
< 			} else {
< 				doc->is_symlink = 0;
< 			}
< 			doc->statbuf = statbuf;
< 		}
< #endif
< 		g_free(ondiskencoding);
< 		doc_set_tooltip(doc);
< 	}
< }
< 
< /**
<  * doc_scroll_to_cursor:
<  * @doc: a #Tdocument
<  * 
<  * scolls the document pointer to by doc to its cursor position, 
<  * making the cursor visible
<  * 
<  * Return value: void
<  **/
< void doc_scroll_to_cursor(Tdocument *doc) {
< 	GtkTextMark *mark = gtk_text_buffer_get_insert(doc->buffer);
< 	gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(doc->view),mark,0.25,FALSE,0.5,0.5);
< }
< 
< /**
<  * doc_get_chars:
<  * @doc: a #Tdocument
<  * @start: a #gint, the start position
<  * @end: a #gint, the end position
<  * 
<  * returns all characters (NOT BYTES!!) from start to end from the document 
<  * pointer to by doc. end may be -1 to point to the end of the document
<  * 
<  * Return value: gchar * with the requested characters
<  **/
< gchar *doc_get_chars(Tdocument *doc, gint start, gint end) {
< 	GtkTextIter itstart, itend;
< 	gchar *string;
< 
< 	gtk_text_buffer_get_iter_at_offset(doc->buffer, &itstart,start);
< 	if (end >= 0) {
< 		gtk_text_buffer_get_iter_at_offset(doc->buffer, &itend, end);
< 	} else if (end == -1) {
< 		gtk_text_buffer_get_end_iter(doc->buffer, &itend);
< 	} else {
< 		DEBUG_MSG("doc_get_chars, end < -1, returning NULL\n");
< 		return NULL;
< 	}
< 	DEBUG_MSG("doc_get_chars, retrieving string, start=%d, end=%d\n", start, end);
< 	string = gtk_text_buffer_get_text(doc->buffer, &itstart, &itend,FALSE);
< 	DEBUG_MSG("doc_get_chars, retrieved string (%p)\n", string);
< 	return string;
< }
< /**
<  * doc_get_max_offset:
<  * @doc: a #Tdocument
<  * 
<  * returns the number of characters (NOT BYTES!!) in this document
<  * 
<  * Return value: gint with the number of characters
<  **/
< gint doc_get_max_offset(Tdocument *doc) {
< 	return gtk_text_buffer_get_char_count(doc->buffer);
< }
< 
< /**
<  * doc_select_region:
<  * @doc: a #Tdocument
<  * @start: a #gint with the start of selection
<  * @end: a #gint with the end of the selection
<  * @do_scroll: a #gboolean, if we should scroll to the selection
<  * 
<  * selects from start to end in the doc, and if do_scroll is set it will make
<  * sure the selection is visible to the user
<  *
<  * Return value: void
<  **/
< void doc_select_region(Tdocument *doc, gint start, gint end, gboolean do_scroll) {
< 	GtkTextIter itstart, itend;
< 	gtk_text_buffer_get_iter_at_offset(doc->buffer, &itstart,start);
< 	gtk_text_buffer_get_iter_at_offset(doc->buffer, &itend,end);
< 	gtk_text_buffer_move_mark_by_name(doc->buffer, "insert", &itstart);
< 	gtk_text_buffer_move_mark_by_name(doc->buffer, "selection_bound", &itend);
< 	if (do_scroll) {
< 		gtk_text_view_scroll_to_iter(GTK_TEXT_VIEW(doc->view),&itstart,0.25,FALSE,0.5,0.5);
< 	}
< }
< 
< /**
<  * doc_select_line:
<  * @doc: a #Tdocument
<  * @line: a #gint with the line number to select
<  * @do_scroll: a #gboolean, if we should scroll to the selection
<  * 
<  * selects the line in doc, and if do_scroll is set it will make
<  * sure the selection is visible to the user
<  * the line number starts at line 1, not at line 0!!
<  *
<  * Return value: void
<  **/
< void doc_select_line(Tdocument *doc, gint line, gboolean do_scroll) {
< 	GtkTextIter itstart, itend;
< 	gtk_text_buffer_get_iter_at_line(doc->buffer,&itstart,line-1);
< 	itend = itstart;
< 	gtk_text_iter_forward_to_line_end(&itend);
< 	gtk_text_buffer_move_mark_by_name(doc->buffer, "insert", &itstart);
< 	gtk_text_buffer_move_mark_by_name(doc->buffer, "selection_bound", &itend);
< 	if (do_scroll) {
< 		gtk_text_view_scroll_to_iter(GTK_TEXT_VIEW(doc->view),&itstart,0.25,FALSE,0.5,0.5);	
< 	}
< }
< 
< /**
<  * doc_get_selection:
<  * @doc: a #Tdocument
<  * @start: a #gint * to store the start
<  * @end: a #gint * to store the end
<  * 
<  *  returns FALSE if there is no selection
<  *  returns TRUE if there is a selection, and start and end will be set
<  *  to the current selection
<  *
<  * Return value: gboolean if there is a selection
<  **/
< gboolean doc_get_selection(Tdocument *doc, gint *start, gint *end) {
< 	GtkTextIter itstart, itend;
< 	GtkTextMark *mark = gtk_text_buffer_get_insert(doc->buffer);
< 	gtk_text_buffer_get_iter_at_mark(doc->buffer,&itstart,mark);
< 	mark = gtk_text_buffer_get_selection_bound(doc->buffer);
< 	gtk_text_buffer_get_iter_at_mark(doc->buffer,&itend,mark);
< 	*start = gtk_text_iter_get_offset(&itstart);
< 	*end = gtk_text_iter_get_offset(&itend);
< 	DEBUG_MSG("doc_get_selection, start=%d, end=%d\n", *start, *end);
< 	if (*start == *end) {
< 		return FALSE;
< 	}
< 	if (*start > *end) {
< 		gint tmp = *start;
< 		*start = *end;
< 		*end = tmp;
< 	}
< 	return TRUE;
< }
< /**
<  * doc_get_cursor_position:
<  * @doc: a #Tdocument
<  * 
<  * returns the cursor position in doc as character offset
<  *
<  * Return value: gint with the character offset of the cursor
<  **/
< gint doc_get_cursor_position(Tdocument *doc) {
< 	GtkTextIter iter;
< 	GtkTextMark *mark = gtk_text_buffer_get_insert(doc->buffer);
< 	gtk_text_buffer_get_iter_at_mark(doc->buffer, &iter, mark);
< 	return gtk_text_iter_get_offset(&iter);
< }
< 
< /**
<  * doc_set_statusbar_lncol:
<  * @doc: a #Tdocument
<  * 
<  * Return value: void
<  **/
< static void doc_set_statusbar_lncol(Tdocument *doc) {
< 	gchar *msg;
< 	gint line;
< 	gint col = 0;
< 	GtkTextIter iter, start;
< 
< 	gtk_text_buffer_get_iter_at_mark(doc->buffer, &iter, gtk_text_buffer_get_insert(doc->buffer));
< 
< 	line = gtk_text_iter_get_line(&iter);
< 	
< 	start = iter;
< 	gtk_text_iter_set_line_offset(&start, 0);
< 
< 	while (!gtk_text_iter_equal(&start, &iter)) {
< 		if (gtk_text_iter_get_char(&start) == '\t') {
< 			col += (main_v->props.editor_tab_width - (col  % main_v->props.editor_tab_width));
< 		} else ++col;
< 		gtk_text_iter_forward_char(&start);
< 	}
< 
< 	msg = g_strdup_printf(_(" Ln: %d, Col: %d"), line + 1, col + 1);
< 
< 	gtk_statusbar_pop(GTK_STATUSBAR(BFWIN(doc->bfwin)->statusbar_lncol), 0);
< 	gtk_statusbar_push(GTK_STATUSBAR(BFWIN(doc->bfwin)->statusbar_lncol), 0, msg);
< 
< 	g_free(msg);
< }
< 
< /**
<  * doc_set_statusbar_insovr:
<  * @doc: a #Tdocument
<  * 
<  * 
<  *
<  * Return value: void
<  **/
< void doc_set_statusbar_insovr(Tdocument *doc)
< {
< 	gtk_statusbar_pop(GTK_STATUSBAR(BFWIN(doc->bfwin)->statusbar_insovr), 0);
< 	gtk_statusbar_push(GTK_STATUSBAR(BFWIN(doc->bfwin)->statusbar_insovr), 0, (doc->overwrite_mode ? " OVR" : " INS"));
< }
< /**
<  * doc_set_statusbar_editmode_encoding:
<  * @doc: a #Tdocument
<  * 
<  * 
<  * 
<  *
<  * Return value: void
<  **/
< void doc_set_statusbar_editmode_encoding(Tdocument *doc)
< {
< 	gchar *msg;
< 	if (doc->hl == NULL) msg = g_strdup_printf(_("  %s, %s"), "unknown", doc->encoding);
< 	else msg = g_strdup_printf(_("  %s, %s"), doc->hl->type, doc->encoding);
< 	gtk_statusbar_pop(GTK_STATUSBAR(BFWIN(doc->bfwin)->statusbar_editmode), 0);
< 	gtk_statusbar_push(GTK_STATUSBAR(BFWIN(doc->bfwin)->statusbar_editmode), 0, msg);
< 	g_free(msg);		
< }
< 
< /**
<  * doc_replace_text_backend:
<  * @doc: a #Tdocument
<  * @newstring: a #const char * with the new string
<  * @start: a gint with the start character position
<  * @end: a gint with the end character position
<  * 
<  * unbinds all signals so there will be no call to a highlighting 
<  * update or anything else
<  * deletes the text in the region between start and end
<  * registers that text to the undo/redo functionality
<  * inserts newstring at that same position
<  * registers this to the undo/redo functionality
<  * marks the document as modified and marks it as needing highlighting
<  * binds the signals again to their callbacks
<  *
<  * multiple calls to doc_replace_text_backend will all be in the same undo/redo group
<  *
<  * Return value: void
<  **/
< void doc_replace_text_backend(Tdocument *doc, const gchar * newstring, gint start, gint end) {
< 	doc_unbind_signals(doc);
< 	/* delete region, and add that to undo/redo list */
< 	{
< 		gchar *buf;
< 		GtkTextIter itstart, itend;
< 		DEBUG_MSG("doc_replace_text_backend, get iters at start %d and end %d\n", start, end);
< 		gtk_text_buffer_get_iter_at_offset(doc->buffer, &itstart,start);
< 		gtk_text_buffer_get_iter_at_offset(doc->buffer, &itend,end);
< 		buf = gtk_text_buffer_get_text(doc->buffer, &itstart, &itend,FALSE);
< 		gtk_text_buffer_delete(doc->buffer,&itstart,&itend);
< 		DEBUG_MSG("doc_replace_text_backend, calling doc_unre_add for buf=%s, start=%d and end=%d\n", buf, start, end);
< 		doc_unre_add(doc, buf, start, end, UndoDelete);
< 		g_free(buf);
< 		DEBUG_MSG("doc_replace_text_backend, text deleted from %d to %d\n", start, end);
< 	}
< 
< 	/* add new text to this region, the buffer is changed so re-calculate itstart */
< 	{
< 		GtkTextIter itstart;
< 		gint insert = (end > start) ? start : end;
< 		DEBUG_MSG("doc_replace_text_backend, set insert pos to %d\n", insert);
< 		gtk_text_buffer_get_iter_at_offset(doc->buffer, &itstart,insert);
< 		gtk_text_buffer_insert(doc->buffer,&itstart,newstring,-1);
< 		doc_unre_add(doc, newstring, insert, insert + g_utf8_strlen(newstring,-1), UndoInsert);
< 	}
< 	doc_bind_signals(doc);
< 	doc_set_modified(doc, 1);
< 	doc->need_highlighting=TRUE;
< }					  
< /**
<  * doc_replace_text:
<  * @doc: a #Tdocument
<  * @newstring: a #const char * with the new string
<  * @start: a gint with the start character position
<  * @end: a gint with the end character position
<  * 
<  * identical to doc_replace_text_backend, with one difference, multiple calls to
<  * doc_replace_text will be all be in a different undo/redo group
<  *
<  * Return value: void
<  **/
< void doc_replace_text(Tdocument * doc, const gchar * newstring, gint start, gint end) {
< 	doc_unre_new_group(doc);
< 	doc_replace_text_backend(doc, newstring, start, end);
< 	doc_unre_new_group(doc);
< }
< 
< static void doc_convert_chars_to_entities(Tdocument *doc, gint start, gint end, gboolean ascii, gboolean iso) {
< 	gchar *string;
< 	DEBUG_MSG("doc_convert_chars_to_entities, start=%d, end=%d\n", start,end);
< 	string = doc_get_chars(doc, start, end);
< 	if (string) {
< 		gchar *newstring = convert_string_utf8_to_html(string, ascii, iso);
< 		g_free(string);
< 		if (newstring) {
< 			doc_replace_text(doc, newstring, start, end);
< 			g_free(newstring);
< 		}
< #ifdef DEBUG
< 		 else {
< 		 	DEBUG_MSG("doc_convert_chars_to_entities, newstring=NULL\n");
< 		 }
< #endif
< 	}
< #ifdef DEBUG
< 		 else {
< 		 	DEBUG_MSG("doc_convert_chars_to_entities, string=NULL\n");
< 		 }
< #endif		 
< }
< 
< static void doc_convert_chars_to_entities_in_selection(Tdocument *doc, gboolean ascii, gboolean iso) {
< 	gint start, end;
< 	if (doc_get_selection(doc, &start, &end)) {
< 		DEBUG_MSG("doc_convert_chars_to_entities_in_selection, start=%d, end=%d\n", start, end);
< 		doc_convert_chars_to_entities(doc, start, end, ascii, iso);
< 	}
< }
< 
< static void doc_convert_case_in_selection(Tdocument *doc, gboolean toUpper) {
< 	gint start, end;
< 	if (doc_get_selection(doc, &start, &end)) {
< 		gchar *string = doc_get_chars(doc, start, end);
< 		if (string) {
< 			gchar *newstring = (toUpper) ? g_utf8_strup(string,-1) : g_utf8_strdown(string,-1);
< 			g_free(string);
< 			if (newstring) {
< 				doc_replace_text(doc, newstring, start, end);
< 				g_free(newstring);
< 			}
< 		}
< 	}
< }
< 
< 
< /**
<  * doc_insert_two_strings:
<  * @doc: a #Tdocument
<  * @before_str: a #const char * with the first string
<  * @after_str: a #const char * with the second string
<  * 
<  * if the marks 'diag_ins' and 'diag_sel' exist, they will be used
<  * as pos1 and pos2
<  * if a selection exists, the selection start and end will be pos1 and pos2
<  * if both not exist the cursor position will be both pos1 and pos2
<  *
<  * inserts the first string at pos1 and the second at pos2 in doc
<  * it does not unbind any signal, so the insert callback will have to do 
<  * do the undo/redo, modified and highlighting stuff
<  *
<  * multiple calls to this function will be in separate undo/redo groups
<  *
<  * Return value: void
<  **/
< void doc_insert_two_strings(Tdocument *doc, const gchar *before_str, const gchar *after_str) {
< 	GtkTextIter itinsert, itselect;
< 	GtkTextMark *insert, *select;
< 	gboolean have_diag_marks = FALSE;
< 	insert = gtk_text_buffer_get_mark(doc->buffer,"diag_ins");
< 	if (insert) {
< 		select = gtk_text_buffer_get_mark(doc->buffer,"diag_sel");
< 		have_diag_marks = TRUE;
< 	} else {
< 		insert = gtk_text_buffer_get_insert(doc->buffer);
< 		select = gtk_text_buffer_get_selection_bound(doc->buffer);
< 	}
< 	gtk_text_buffer_get_iter_at_mark(doc->buffer,&itinsert,insert);
< 	gtk_text_buffer_get_iter_at_mark(doc->buffer,&itselect,select);
< #ifdef DEBUG
< 	g_print("doc_insert_two_strings, current marks: itinsert=%d, itselect=%d\n",gtk_text_iter_get_offset(&itinsert),gtk_text_iter_get_offset(&itselect));
< #endif	
< 
< 	if (gtk_text_iter_equal(&itinsert, &itselect)) {
< 		/* no selection */
< 		gchar *double_str = g_strconcat(before_str, after_str, NULL);
< 		gtk_text_buffer_insert(doc->buffer,&itinsert,double_str,-1);
< 		g_free(double_str);
< 		if (after_str && strlen(after_str)) {
< 			/* the buffer has changed, but gtk_text_buffer_insert makes sure */
< 			/* that itinsert points to the end of the inserted text. */
< 			/* thus, no need to get a new one. */
< 			gtk_text_iter_backward_chars(&itinsert, g_utf8_strlen(after_str, -1));
< 			gtk_text_buffer_place_cursor(doc->buffer, &itinsert);
< 			gtk_widget_grab_focus(doc->view);
< 		}
< 	} else { /* there is a selection */
< 		GtkTextMark *marktoresetto;
< 		GtkTextIter firstiter;
< 		if (gtk_text_iter_compare(&itinsert,&itselect) < 0) {
< 			firstiter = itinsert;
< 			marktoresetto = (have_diag_marks) ? gtk_text_buffer_get_selection_bound(doc->buffer) : select;
< 		} else {
< 			firstiter = itselect;
< 			marktoresetto = (have_diag_marks) ? gtk_text_buffer_get_insert(doc->buffer) : insert;
< 		}
< 		/* there is a selection */
< 		gtk_text_buffer_insert(doc->buffer,&firstiter,before_str,-1);
< 		if (after_str && strlen(after_str)) {
< 			/* the buffer is changed, reset the select iterator */
< 			gtk_text_buffer_get_iter_at_mark(doc->buffer,&itselect,marktoresetto);
< 			gtk_text_buffer_insert(doc->buffer,&itselect,after_str,-1);
< 			/* now the only thing left is to move the selection and insert mark back to their correct places
< 			to preserve the users selection */
< 			gtk_text_buffer_get_iter_at_mark(doc->buffer,&itselect,marktoresetto);
< 			gtk_text_iter_backward_chars(&itselect, g_utf8_strlen(after_str, -1));
< 			gtk_text_buffer_move_mark(doc->buffer,marktoresetto,&itselect);
< 		}
< 		
< 	}
< 	doc_unre_new_group(doc);
< 	DEBUG_MSG("doc_insert_two_strings, finished\n");
< }
< 
< static void add_encoding_to_list(gchar *encoding) {
< 	gchar **enc = g_new0(gchar *,3);
< 	enc[0] = g_strdup(encoding);
< 	if (!arraylist_value_exists(main_v->props.encodings, enc, 1, FALSE)) {
< 		GList *tmplist;
< 		enc[1] = g_strdup(encoding);
< 		main_v->props.encodings = g_list_insert(main_v->props.encodings, enc, 1);
< 		tmplist = g_list_first(main_v->bfwinlist);
< 		while (tmplist) {
< 			encoding_menu_rebuild(BFWIN(tmplist->data));
< 			tmplist = g_list_next(tmplist);
< 		}
< 	} else {
< 		g_free(enc[0]);
< 		g_free(enc);
< 	}
< }
< 
< #ifdef HAVE_GNOME_VFS
< #define STARTING_BUFFER_SIZE 8192
< static gchar *get_buffer_from_filename(Tbfwin *bfwin, gchar *filename, int *returnsize) {
< 	GnomeVFSResult result= GNOME_VFS_NUM_ERRORS;
< /*	GnomeVFSHandle *handle;
< 	GnomeVFSFileSize bytes_read;
< 	gchar chunk[STARTING_BUFFER_SIZE];
< 	unsigned long long buffer_size = STARTING_BUFFER_SIZE;*/
< 	gchar *buffer=NULL;
< 
< 	DEBUG_MSG("get_buffer_from_filename, started for %s\n",filename);
< /*	result = gnome_vfs_open (&handle, filename, GNOME_VFS_OPEN_READ);
< 	if (result != GNOME_VFS_OK) {
< 		gchar *errmessage = g_strconcat(_("Could not read file:\n"), filename, NULL);
< 		warning_dialog(bfwin->main_window,errmessage, NULL);
< 		g_free(errmessage);
< 		DEBUG_MSG("get_buffer_from_filename, ERROR (result=%d), returning NULL\n",result);
< 		return NULL;
< 	}
< 	buffer = g_malloc(1+(buffer_size * sizeof(gchar)));
< 	while (result == GNOME_VFS_OK) {
< 		result = gnome_vfs_read(handle, chunk, STARTING_BUFFER_SIZE, &bytes_read);
< 		memcpy(&buffer[buffer_size-STARTING_BUFFER_SIZE], chunk, STARTING_BUFFER_SIZE);
< 		DEBUG_MSG("get_buffer_from_filename, copy %lld bytes to position %lld, size=%lld\n",(long long)STARTING_BUFFER_SIZE, (long long)buffer_size-STARTING_BUFFER_SIZE, (long long)bytes_read);
< 		if (bytes_read == STARTING_BUFFER_SIZE) {
< 			buffer_size += STARTING_BUFFER_SIZE;
< 			buffer = g_realloc(buffer, 1+(buffer_size * sizeof(gchar)));
< 		} else {
< 			DEBUG_MSG("get_buffer_from_filename, bytes_read was only %lld, result=%d\n",bytes_read,result);
< 			break;
< 		}
< 	}
< 	DEBUG_MSG("get_buffer_from_filename, size=%lld, terminating buffer at %lld\n",bytes_read,buffer_size-STARTING_BUFFER_SIZE+bytes_read);
< 	buffer[buffer_size-STARTING_BUFFER_SIZE+bytes_read] = '\0';
< 	*returnsize= buffer_size-STARTING_BUFFER_SIZE+bytes_read;
< 	gnome_vfs_close(handle);*/
< 	/* using gnome_vfs_read_entire_file results in a buffer without \0 at the end */
< 	
< 	/* a small hack to better support Zope. gnome-vfs metadata should be
< 	used to get the source-link for WebDAV request but unfortunatelly
< 	that functionality is yet not functional on gnome-vfs.*/
< 	if (main_v->props.server_zope_compat) {
< 		GnomeVFSURI* uri=gnome_vfs_uri_new(filename);
< 		if (uri) {
< 			gchar const *scheme=gnome_vfs_uri_get_scheme(uri);
< 			if (scheme && (strcmp(scheme, "http")==0 || strcmp(scheme, "https")==0)) {
< 				GnomeVFSURI* sourceuri;
< #ifdef HAVE_ATLEAST_GNOME_2_6
< 				/* TODO */
< 				/* use metadata to get source property */
< 				sourceuri=gnome_vfs_uri_append_file_name(uri, "document_src");
< #else
< 				sourceuri=gnome_vfs_uri_append_file_name(uri, "document_src");
< #endif
< 				if (sourceuri) {
< 					gchar *sourcefilename=gnome_vfs_uri_to_string(sourceuri, 0);
< 					if (sourcefilename) {
< 						result = gnome_vfs_read_entire_file(sourcefilename,returnsize,&buffer);
< 						DEBUG_MSG("get_buffer_from_filename, loading %s returns %d\n", sourcefilename, result);
< 						g_free(sourcefilename);
< 					}
< 					gnome_vfs_uri_unref(sourceuri);
< 				}
< 			}
< 			gnome_vfs_uri_unref(uri);
< 		}
< 	}
< 	if (GNOME_VFS_OK != result) {
< 		gchar *ondiskencoding = get_filename_on_disk_encoding(filename);
< 		DEBUG_MSG("get_buffer_from_filename, about to read entire file\n");
< 		result = gnome_vfs_read_entire_file(ondiskencoding,returnsize,&buffer);
< 		DEBUG_MSG("get_buffer_from_filename, read file, buffer len=%d!\n",strlen(buffer));
< 		g_free(ondiskencoding);
< 	}
< 	if (GNOME_VFS_OK != result) {
< 		gchar *errmessage = g_strconcat(_("Could not read file:\n"), filename, NULL);
< 		warning_dialog(bfwin->main_window,errmessage, NULL);
< 		g_free(errmessage);
< 		DEBUG_MSG("get_buffer_from_filename, GNOME_VFS ERROR (result=%d), returning NULL\n",result);
< 		DEBUG_MSG("get_buffer_from_filename, gnome_vfs error was: %s\n", gnome_vfs_result_to_string(result));
< 		return NULL;
< 	}
< 	buffer  = g_realloc(buffer, *returnsize+1);
< 	buffer[*returnsize] = '\0';
< 	return buffer;
< }
< #else /* no gnome-vfs */
< static gchar *get_buffer_from_filename(Tbfwin *bfwin, gchar *filename, int *returnsize) {
< 	gboolean result;
< 	gchar *buffer;
< 	GError *error=NULL;
< 	gsize length;
< 	gchar *ondiskencoding = get_filename_on_disk_encoding(filename);
< 	result = g_file_get_contents(ondiskencoding,&buffer,&length,&error);
< 	g_free(ondiskencoding);
< 	if (result == FALSE) {
< 		gchar *errmessage = g_strconcat(_("Could not read file:\n"), filename, NULL);
< 		warning_dialog(bfwin->main_window,errmessage, NULL);
< 		g_free(errmessage);
< 		return NULL;
< 	}
< 	*returnsize = length;
< 	return buffer;
< }
< #endif
< 
< /**
<  * doc_file_to_textbox:
<  * @doc: The #Tdocument target.
<  * @filename: Filename to read in.
<  * @enable_undo: #gboolean
<  * @delay: Whether to delay GUI-calls.
<  *
<  * Open and read in a file to the doc buffer.
<  * The data is inserted starting at the current cursor position.
<  * Charset is detected, and highlighting performed (if applicable).
<  *
<  * Return value: A #gboolean, TRUE if successful, FALSE on error.
<  **/ 
< gboolean doc_file_to_textbox(Tdocument * doc, gchar * filename, gboolean enable_undo, gboolean delay) {
< 	gchar *message;
< 	gint cursor_offset;
< 	int document_size=0;
< 
< 	if (!enable_undo) {
< 		doc_unbind_signals(doc);
< 	}
< 	message = g_strconcat(_("Opening file "), filename, NULL);
< 	statusbar_message(BFWIN(doc->bfwin),message, 1000);
< 	g_free(message);
< 
< 	/* now get the current cursor position */
< 	{
< 		GtkTextMark* insert;
< 		GtkTextIter iter;
< 		insert = gtk_text_buffer_get_insert(doc->buffer);
< 		gtk_text_buffer_get_iter_at_mark(doc->buffer, &iter, insert);
< 		cursor_offset = gtk_text_iter_get_offset(&iter);
< 	}
< 
< 	/* This opens the contents of a file to a textbox */
< 	{
< 		gchar *encoding=NULL;
< 		gchar *newbuf=NULL;
< 		gsize wsize;
< 		GError *error=NULL;
< 		gchar *buffer = get_buffer_from_filename(BFWIN(doc->bfwin), filename, &document_size);
< 		if (!buffer) {
< 			DEBUG_MSG("doc_file_to_textbox, buffer==NULL, returning\n");
< 			return FALSE;
< 		}
< 		/* the first try is if the encoding is set in the file */
< 		{
< 			regex_t preg;
< 			regmatch_t pmatch[10];
< 			gint retval;
< 			gchar *pattern = "<meta[ \t\n]http-equiv[ \t\n]*=[ \t\n]*\"content-type\"[ \t\n]+content[ \t\n]*=[ \t\n]*\"text/html;[ \t\n]*charset=([a-z0-9-]+)\"[ \t\n]*/?>";
< 			retval = regcomp(&preg,pattern,REG_EXTENDED|REG_ICASE);
< #ifdef DEBUG
< 			if (retval) {
< 				g_print("regcomp error!\n");
< 			}
< #endif
< 			/* we do a nasty trick to make regexec search only in the first N bytes */
< 			if (document_size > main_v->props.encoding_search_Nbytes) {
< 				gchar tmp = buffer[main_v->props.encoding_search_Nbytes];
< 				buffer[main_v->props.encoding_search_Nbytes] = '\0';
< 				retval = regexec(&preg,buffer,10,pmatch,0);
< 				buffer[main_v->props.encoding_search_Nbytes] = tmp;
< 			} else {
< 				retval = regexec(&preg,buffer,10,pmatch,0);
< 			}
< #ifdef DEBUG
< 			if (retval) {
< 				gchar errbuf[1024];
< 				regerror(retval, &preg, errbuf, 1024);
< 				g_print("regexec error! %s\n", errbuf);
< 			}
< #endif
< 			if (retval==0 && pmatch[0].rm_so != -1 && pmatch[1].rm_so != -1) {
< 				/* we have a match */
< 				DEBUG_MSG("doc_file_to_textbox, match so=%d,eo=%d\n", pmatch[1].rm_so,pmatch[1].rm_eo);
< 				encoding = g_strndup(&buffer[pmatch[1].rm_so], pmatch[1].rm_eo-pmatch[1].rm_so);
< 				DEBUG_MSG("doc_file_to_textbox, detected encoding %s\n", encoding);
< 			}
< 			regfree(&preg);
< #ifdef DEBUGPROFILING
< 			times(&locals.tms1);
< 			print_time_diff("encoding regex match", &locals.tms2, &locals.tms1);
< #endif		
< 		}
< 		if (encoding) {
< 			DEBUG_MSG("doc_file_to_textbox, try encoding %s from <meta>\n", encoding);
< 			newbuf = g_convert(buffer,-1,"UTF-8",encoding,NULL, &wsize, &error);
< 			if (!newbuf || error) {
< 				DEBUG_MSG("doc_file_to_textbox, cound not convert %s to UTF-8: \n", encoding);
< 				g_free(encoding);
< 				encoding=NULL;
< 			}
< 		}
< 		if (!newbuf) {
< 			DEBUG_MSG("doc_file_to_textbox, file does not have <meta> encoding, or could not convert, trying newfile default encoding %s\n", main_v->props.newfile_default_encoding);
< 			newbuf = g_convert(buffer,-1,"UTF-8",main_v->props.newfile_default_encoding,NULL, &wsize, NULL);
< 			if (newbuf) {
< 				DEBUG_MSG("doc_file_to_textbox, file is in default encoding: %s\n", main_v->props.newfile_default_encoding);
< 				encoding = g_strdup(main_v->props.newfile_default_encoding);
< 			}
< 		}
< 		if (!newbuf) {
< 			DEBUG_MSG("doc_file_to_textbox, file is not in UTF-8, trying encoding from locale\n");
< 			newbuf = g_locale_to_utf8(buffer,-1,NULL,&wsize,NULL);
< 			if (newbuf) {
< 				const gchar *tmpencoding=NULL;
< 				g_get_charset(&tmpencoding);
< 				DEBUG_MSG("doc_file_to_textbox, file is in locale encoding: %s\n", tmpencoding);
< 				encoding = g_strdup(tmpencoding);
< 			}
< 		}
< 		if (!newbuf) {
< 			DEBUG_MSG("doc_file_to_textbox, file NOT is converted yet, trying UTF-8 encoding\n");
< 			if(g_utf8_validate(buffer, -1, NULL)) {
< 				encoding = g_strdup("UTF-8");
< 			}
< 		}
< 		if (!newbuf) {
< 			GList *tmplist;
< 			DEBUG_MSG("doc_file_to_textbox, tried the most obvious encodings, nothing found.. go trough list\n");
< 			tmplist = g_list_first(main_v->props.encodings);
< 			while (tmplist) {
< 				gchar **enc = tmplist->data;
< 				DEBUG_MSG("doc_file_to_textbox, trying encoding %s\n", enc[1]);
< 				newbuf = g_convert(buffer,-1,"UTF-8",enc[1],NULL, &wsize, NULL);
< 				if (newbuf) {
< 					encoding = g_strdup(enc[1]);
< 					tmplist = NULL;
< 				} else {
< 					DEBUG_MSG("doc_file_to_textbox, no newbuf, next in list\n");
< 					tmplist = g_list_next(tmplist);
< 				}
< 			}
< 		}
< 		if (!newbuf) {
< 			error_dialog(BFWIN(doc->bfwin)->main_window,_("Cannot display file, unknown characters found."), NULL);
< 		} else {
< 			g_free(buffer);
< 			buffer = newbuf;
< 			if (doc->encoding) g_free(doc->encoding);
< 			doc->encoding = encoding;
< 			add_encoding_to_list(encoding);
< 		}
< 		if (buffer) {
< 			gtk_text_buffer_insert_at_cursor(doc->buffer,buffer,-1);
< 			g_free(buffer);
< 		}
< 	}
< 	if (doc->highlightstate) {
< 		doc->need_highlighting=TRUE;
< 		DEBUG_MSG("doc_file_to_textbox, highlightstate=%d, need_highlighting=%d, delay=%d\n",doc->highlightstate,doc->need_highlighting,delay);
< 		if (!delay) {
< #ifdef DEBUG
< 			g_print("doc_file_to_textbox, doc->hlset=%p\n", doc->hl);
< 			if (doc->hl) {
< 				g_print("doc_file_to_textbox, doc->hlset->highlightlist=%p\n", doc->hl->highlightlist);
< 			}
< #endif
< 			doc_highlight_full(doc);
< 		}
< 	}
< 	if (!enable_undo) {
< 		doc_bind_signals(doc);
< 	}
< 	
< 	{
< 		/* set the cursor position back */
< 		GtkTextIter iter;
< 		gtk_text_buffer_get_iter_at_offset(doc->buffer,&iter,cursor_offset);
< 		gtk_text_buffer_place_cursor(doc->buffer,&iter);
< 		if (!delay) {
< 			gtk_text_view_place_cursor_onscreen(GTK_TEXT_VIEW(doc->view));
< 		}
< /*		gtk_notebook_set_page(GTK_NOTEBOOK(main_v->notebook),g_list_length(main_v->documentlist) - 1);
< 		notebook_changed(-1);*/
< 	}
< 	return TRUE;
< }
< 
< /**
<  * doc_check_backup:
<  * @doc: #Tdocument*
<  *
<  * creates a backup, depending on the configuration
<  * returns 1 on success, 0 on failure
<  * if no backup is required, or no filename known, 1 is returned
<  *
<  * Return value: #gint 1 on success or 0 on failure
<  */
< static gint doc_check_backup(Tdocument *doc) {
< 	gint res = 1;
< 
< 	if (main_v->props.backup_file && doc->filename && file_exists_and_readable(doc->filename)) {
< 		gchar *backupfilename, *ondiskencoding;
< 		backupfilename = g_strconcat(doc->filename, main_v->props.backup_filestring, NULL);
< 		ondiskencoding = get_filename_on_disk_encoding(backupfilename);
< 		res = file_copy(doc->filename, backupfilename);
< #ifdef HAVE_GNOME_VFS
< 		if (doc->fileinfo) {
< 			gnome_vfs_set_file_info(ondiskencoding, doc->fileinfo, GNOME_VFS_SET_FILE_INFO_PERMISSIONS|GNOME_VFS_SET_FILE_INFO_OWNER);
< 		}
< #else
< 		if (doc->statbuf.st_uid != -1 && !doc->is_symlink) {
< 			chmod(ondiskencoding, doc->statbuf.st_mode);
< 			chown(ondiskencoding, doc->statbuf.st_uid, doc->statbuf.st_gid);
< 		}
< #endif
< 		g_free(ondiskencoding);
< 		g_free(backupfilename);
< 	}
< 	return res;
< }
< 
< static void doc_buffer_insert_text_lcb(GtkTextBuffer *textbuffer,GtkTextIter * iter,gchar * string,gint len, Tdocument * doc) {
< 	gint pos = gtk_text_iter_get_offset(iter);
< 	gint clen = g_utf8_strlen(string, len);
< 	DEBUG_MSG("doc_buffer_insert_text_lcb, started, string='%s', len=%d, clen=%d\n", string, len, clen);
< 	/* the 'len' seems to be the number of bytes and not the number of characters.. */
< 
< 	if (doc->paste_operation) {
< 		if ((pos + clen) > PASTEOPERATION(doc->paste_operation)->eo) PASTEOPERATION(doc->paste_operation)->eo = pos + clen;
< 		if (pos < PASTEOPERATION(doc->paste_operation)->so || PASTEOPERATION(doc->paste_operation)->so == -1) PASTEOPERATION(doc->paste_operation)->so = pos;
< 	} else if (len == 1) {
< 		/* undo_redo stuff */
< 		if (!doc_unre_test_last_entry(doc, UndoInsert, -1, pos)
< 				|| string[0] == ' ' 
< 				|| string[0] == '\n' 
< 				|| string[0] == '\t'
< 				|| string[0] == '\r') {
< 			DEBUG_MSG("doc_buffer_insert_text_lcb, need a new undogroup\n");
< 			doc_unre_new_group(doc);
< 		}
< 	}
< 	/* we do not call doc_unre_new_group() for multi character inserts, these are from paste, and edit_paste_cb groups them already */
< 	/*  else if (clen != 1) {
< 		doc_unre_new_group(doc);
< 	} */
< 	
< 	doc_unre_add(doc, string, pos, pos+clen, UndoInsert);
< 	doc_set_modified(doc, 1);	
< 	DEBUG_MSG("doc_buffer_insert_text_lcb, done\n");
< }
< static gboolean find_char(gunichar ch,gchar *data) {
< #ifdef DEBUG
< 	if (ch < 127) {
< 		DEBUG_MSG("find_char, looking at character %c, searching for '%s', returning %d\n",ch,data,(strchr(data, ch) != NULL));
< 	} else {
< 		DEBUG_MSG("find_char, looking at character code %d, searching for '%s', returning %d\n",ch,data,(strchr(data, ch) != NULL));
< 	}
< #endif
< 	return (strchr(data, ch) != NULL);
< }
< static gchar *noclosingtag [] = {"br","input","img","hr","meta","frame","map","base","link",NULL};
< 
< static gchar *closingtagtoinsert(Tdocument *doc, const gchar *tagname, GtkTextIter *iter) {
< 	/* only for XML all start tags have to end on < /> so we check for that, all other tags 
< 	 * will be treated like HTML tags */
< 	if (tagname[0] != '/') {
< 		if (main_v->props.xhtml || (doc->hl && doc->hl->autoclosingtag == 1) /* xml mode */) {
< 			gchar *tmp;
< 			GtkTextIter itstart = *iter, itend=*iter;
< 			gtk_text_iter_backward_chars(&itstart,2);
< 			tmp = gtk_text_buffer_get_text(doc->buffer,&itstart,&itend,FALSE);
< 			DEBUG_MSG("closingtagtoinsert, while testing for XML < />, tmp=%s\n",tmp);
< 			if (tmp[0] == '/') {
< 				g_free(tmp);
< 				return NULL;
< 			}
< 			g_free(tmp);
< 			return g_strconcat("</",tagname,">", NULL);
< 		} else /* should be doc->hl == 2, which is html mode */{
< 			/* HTML, test if this tag needs closing */
< 			gchar **tmp=noclosingtag;
< 			DEBUG_MSG("closingtagtoinsert, test if %s needs closing in HTML\n",tagname);
< 			while (*tmp) {
< 				if (strcmp(*tmp,tagname)==0) {
< 					return NULL;
< 				}
< 				tmp++;
< 			}
< 			return g_strconcat("</",cap(tagname),">", NULL);
< 		}
< 	}
< 	return NULL;
< }
< static void doc_buffer_insert_text_after_lcb(GtkTextBuffer *textbuffer,GtkTextIter * iter,gchar * string,gint len, Tdocument * doc) {
< 	DEBUG_MSG("doc_buffer_insert_text_after_lcb, started for string '%s'\n",string);
< 	if (!doc->paste_operation) {
< 		/* highlighting stuff */
< 		if (doc->highlightstate && string && doc->hl) {
< 			gboolean do_highlighting = FALSE;
< 			if (doc->hl->update_chars[0] == '\0' ) {
< 				do_highlighting = TRUE;
< 			} else {
< 				gint i=0;
< 				while (string[i] != '\0') {
< 					if (strchr(doc->hl->update_chars, string[i])) {
< 						do_highlighting = TRUE;
< 						break;
< 					}
< 					i++;
< 				}
< 			}
< 			if (do_highlighting) {
< 				doc_highlight_line(doc);
< 			}
< 		}
< 	}
< #ifdef DEBUG
< 	else {
< 		DEBUG_MSG("doc_buffer_insert_text_after_lcb, paste_operation, NOT DOING ANYTHING\n");
< 	}
< #endif
< }
< 
< static gboolean doc_view_key_press_lcb(GtkWidget *widget,GdkEventKey *kevent,Tdocument *doc) {
< 	DEBUG_MSG("doc_view_key_press_lcb, keyval=%d, hardware_keycode=%d\n",kevent->keyval, kevent->hardware_keycode);
< 	main_v->lastkp_keyval = kevent->keyval;
< 	main_v->lastkp_hardware_keycode = kevent->hardware_keycode;
< 
< 	if (!(kevent->state & GDK_CONTROL_MASK) && 
< 	       ((kevent->keyval == GDK_Home) || (kevent->keyval == GDK_KP_Home) || (kevent->keyval == GDK_End) || (kevent->keyval == GDK_KP_End)) && 
< 	       main_v->props.editor_smart_cursor) {
<                 GtkTextMark* imark;
<                 GtkTextIter  iter, currentpos, linestart;
<    
<         		imark = gtk_text_buffer_get_insert (doc->buffer);		
<         		gtk_text_buffer_get_iter_at_mark (doc->buffer, &currentpos, imark);
<         
<         		iter = currentpos;
<         		
<         		if ((kevent->keyval == GDK_Home) || (kevent->keyval == GDK_KP_Home)) {
<                     gtk_text_iter_backward_cursor_positions (&iter, gtk_text_iter_get_line_offset (&iter));
<                     linestart = iter;
<         
<                     while (g_unichar_isspace (gtk_text_iter_get_char (&iter)) && !gtk_text_iter_ends_line (&iter))
<                             gtk_text_iter_forward_char (&iter);
<                             
<                 } else { /* (kevent->keyval == GDK_End) || (kevent->keyval == GDK_KP_End) */
< 		            if (!gtk_text_iter_ends_line (&iter))
< 		                gtk_text_iter_forward_to_line_end (&iter);
< 
< 		            linestart = iter;
<                     
<                     if (gtk_text_iter_is_end (&iter) && !gtk_text_iter_starts_line (&iter))
<                         gtk_text_iter_backward_char (&iter);
<                         
< 		            while (g_unichar_isspace (gtk_text_iter_get_char (&iter)) && !gtk_text_iter_starts_line (&iter))
< 			                gtk_text_iter_backward_char (&iter);
< 
<                     if ((!gtk_text_iter_starts_line (&iter) || !gtk_text_iter_ends_line (&iter)) && !g_unichar_isspace (gtk_text_iter_get_char (&iter)))
<                         gtk_text_iter_forward_char (&iter);
<                 }
<                 
<         		if (gtk_text_iter_compare (&currentpos, &iter) == 0)
<         			iter = linestart;
<         
<         		if (kevent->state & GDK_SHIFT_MASK)
<         			gtk_text_buffer_move_mark (doc->buffer, imark, &iter);
<         		else {		
<         			gtk_text_buffer_place_cursor (doc->buffer, &iter);
<         		}
<         
<                 gtk_text_view_scroll_mark_onscreen (GTK_TEXT_VIEW (doc->view), gtk_text_buffer_get_insert (doc->buffer));
< 
<         		return TRUE;
< 	}
< 
< 	if (kevent->keyval == GDK_Tab && main_v->props.editor_indent_wspaces) {
<   		GtkTextMark* imark;
< 		GtkTextIter iter;
< 		gchar *string;
< 
<   	   /* replace the tab with spaces if the user wants that */
<   	   string = bf_str_repeat(" ", main_v->props.editor_tab_width);
<   	   imark = gtk_text_buffer_get_insert(doc->buffer);
<   	   gtk_text_buffer_get_iter_at_mark(doc->buffer,&iter,imark);
<   	   gtk_text_buffer_insert(doc->buffer,&iter,string,main_v->props.editor_tab_width);
<   	   g_free(string);
< 
<   	   return TRUE; /* we handled the event, stop the event from cascading further */
<   	}
<   	
< 	return FALSE; /* we didn't handle all of the event */
< }
< 
< static gboolean doc_view_key_release_lcb(GtkWidget *widget,GdkEventKey *kevent,Tdocument *doc) {
< #ifdef DEBUG
< 	guint32 character = gdk_keyval_to_unicode(kevent->keyval);
< 	DEBUG_MSG("doc_view_key_release_lcb, started for keyval=%d (or %X), character=%d, string=%s, state=%d, hw_keycode=%d\n",kevent->keyval,kevent->keyval, character,kevent->string,kevent->state, kevent->hardware_keycode);
< #endif
< 	/* if the shift key is released before the '>' key, we get a key release not for '>' but for '.'. We, therefore
< 	 have set that in the key_press event, and check if the same hardware keycode was released */
< 	if ((kevent->keyval == GDK_greater) || (kevent->hardware_keycode == main_v->lastkp_hardware_keycode && main_v->lastkp_keyval == GDK_greater)) {
< 		if (doc->autoclosingtag) {
< 			/* start the autoclosing! the code is modified from the patch sent by more <more@irpin.com> because that
< 			 * patch did not work with php code (the < and > characters can be inside a php block as well with a 
< 			 * different meaning then a tag), it could not do closing of XML tags and it was limited to a buffer 
< 			 * in Tdocument to hold the current tag name.
< 			 * This code will simply look back in the buffer once a '>' character is pressed, and look if that was
< 			 * the end of a tag. If so it will insert the closing tag for that same tag. Works for XML and HTML. For
< 			 * HTML we need an exception, since <br> and such don't need a closing tag */
< 			GtkTextMark* imark;
< 			GtkTextIter itstart,iter,maxsearch;
< 
< 			imark = gtk_text_buffer_get_insert(doc->buffer);
< 			gtk_text_buffer_get_iter_at_mark(doc->buffer,&iter,imark);
< 			itstart = iter;
< 			maxsearch = iter;
< 			DEBUG_MSG("doc_view_key_release_lcb, autoclosing, started at %d\n",gtk_text_iter_get_offset(&itstart));
< 			gtk_text_iter_backward_chars(&maxsearch,250);
< 			if (gtk_text_iter_backward_find_char(&itstart,(GtkTextCharPredicate)find_char,GINT_TO_POINTER("<"),&maxsearch)) {
< 				/* we use a regular expression to check if the tag is valid, AND to parse the tagname from the string */
< 				gchar *buf;
< 				int ovector[30], ret;
< 				DEBUG_MSG("doc_view_key_release_lcb, we found a '<'\n");
< 				maxsearch = iter; /* re-use maxsearch */
< 				buf = gtk_text_buffer_get_text(doc->buffer,&itstart,&maxsearch,FALSE);
< 				DEBUG_MSG("doc_view_key_release_lcb, buf='%s'\n",buf);
< 				ret = pcre_exec(main_v->autoclosingtag_regc, NULL, buf, strlen(buf), 0,PCRE_ANCHORED, ovector, 30);
< 				if (ret > 0) {
< 					gchar *tagname, *toinsert;
< 					DEBUG_MSG("doc_view_key_release_lcb, autoclosing, we have a tag, ret=%d, starts at ovector[2]=%d, ovector[3]=%d\n",ret, ovector[2], ovector[3]);
< 					tagname = g_strndup(&buf[ovector[2]], ovector[3]-ovector[2]);
< 					DEBUG_MSG("doc_view_key_release_lcb, autoclosing, tagname='%s'\n",tagname);
< 					toinsert = closingtagtoinsert(doc, tagname, &iter);
< 					if (toinsert) {
<  						/* we place this in a new undo/redo group */
< 						doc_unre_new_group(doc);
< 						/* we re-use the maxsearch iter now */
< 						gtk_text_buffer_insert(doc->buffer,&maxsearch,toinsert,-1);
< 						/* now we set the cursor back to its previous location, re-using itstart */
< 						gtk_text_buffer_get_iter_at_mark(doc->buffer,&itstart,gtk_text_buffer_get_insert(doc->buffer));
< 						gtk_text_iter_backward_chars(&itstart,strlen(toinsert));
< 						gtk_text_buffer_place_cursor(doc->buffer,&itstart);
< 						g_free(toinsert);
< 						doc_unre_new_group(doc);
< 					}
< #ifdef DEBUG
< 					 else {
< 						DEBUG_MSG("doc_view_key_release_lcb, no match!! '%s' is not a valid tag\n",buf);
< 					}
< #endif
< 					g_free(tagname);
< 				} else {
< 					DEBUG_MSG("doc_view_key_release_lcb, ret=%d\n",ret);
< 				}
< 				/* cleanup and return */
< 				g_free(buf);
< 			}
< #ifdef DEBUG
< 			 else {
< 				DEBUG_MSG("doc_view_key_release_lcb, did not find a '<' character\n");
< 			}
< #endif
< 		}
< 	} else if ((kevent->keyval == GDK_Return || kevent->keyval == GDK_KP_Enter) && !(kevent->state & GDK_SHIFT_MASK || kevent->state & GDK_CONTROL_MASK || kevent->state & GDK_MOD1_MASK)) {
< 		if (main_v->props.autoindent) {
< 			gchar *string, *indenting;
< 			GtkTextMark* imark;
< 			GtkTextIter itstart, itend;
< 			imark = gtk_text_buffer_get_insert(doc->buffer);
< 			gtk_text_buffer_get_iter_at_mark(doc->buffer,&itend,imark);
< 			itstart = itend;
< 			/* set to the beginning of the previous line */
< 			gtk_text_iter_backward_line(&itstart);
< 			gtk_text_iter_set_line_index(&itstart, 0);
< 			string = gtk_text_buffer_get_text(doc->buffer,&itstart,&itend,FALSE);
< 			if (string) {
< 				/* now count the indenting in this string */
< 				indenting = string;
< 				while (*indenting == '\t' || *indenting == ' ') {
< 					indenting++;
< 				}
< 				/* ending search, non-whitespace found, so terminate at this position */
< 				*indenting = '\0';
< 				if (strlen(string)) {
< 					DEBUG_MSG("doc_buffer_insert_text_lcb, inserting indenting\n");
< 					gtk_text_buffer_insert(doc->buffer,&itend,string,-1);
< 				}
< 				g_free(string);
< 			}
< 		}
< 	}
< 	return FALSE; /* we didn't handle all of the event */
< }
< 
< static void doc_buffer_delete_range_lcb(GtkTextBuffer *textbuffer,GtkTextIter * itstart,GtkTextIter * itend, Tdocument * doc) {
< 	gchar *string;
< 	gboolean do_highlighting=FALSE;
< 	string = gtk_text_buffer_get_text(doc->buffer, itstart, itend, FALSE);
< 	DEBUG_MSG("doc_buffer_delete_range_lcb, string='%s'\n",string);
< 	if (string) {
< 		/* highlighting stuff */
< 		if (doc->highlightstate && string && doc->hl) {
< 			if (strlen(doc->hl->update_chars)==0 ) {
< 				do_highlighting = TRUE;
< 			} else {
< 				gint i=0;
< 				while (string[i] != '\0') {
< 					if (strchr(doc->hl->update_chars, string[i])) {
< 						do_highlighting = TRUE;
< 						break;
< 					}
< 					i++;
< 				}
< 			}
< 			if (do_highlighting) {
< 				doc_highlight_line(doc);
< 			}
< 		}
< 		/* undo_redo stuff */
< 		{
< 			gint start, end, len;
< 			start = gtk_text_iter_get_offset(itstart);
< 			end = gtk_text_iter_get_offset(itend);	
< 			len = end - start;
< 			DEBUG_MSG("doc_buffer_delete_range_lcb, start=%d, end=%d, len=%d, string='%s'\n", start, end, len, string);
< 			if (len == 1) {
< 				if (		(!doc_unre_test_last_entry(doc, UndoDelete, start, -1) /* delete */
< 							&& !doc_unre_test_last_entry(doc, UndoDelete, end, -1)) /* backspace */
< 						|| string[0] == ' ' 
< 						|| string[0] == '\n' 
< 						|| string[0] == '\t'
< 						|| string[0] == '\r') {
< 					DEBUG_MSG("doc_buffer_delete_range_lcb, need a new undogroup\n");
< 					doc_unre_new_group(doc);
< 				}			
< 			} else if (!doc->paste_operation) {
< 				doc_unre_new_group(doc);
< 			}
< 			doc_unre_add(doc, string, start, end, UndoDelete);
< 		}
< 		g_free(string);
< 	}
< 	doc_set_modified(doc, 1);
< }
< 
< static gboolean doc_view_button_release_lcb(GtkWidget *widget,GdkEventButton *bevent, Tdocument *doc) {
< 	DEBUG_MSG("doc_view_button_release_lcb, button %d\n", bevent->button);
< 	if (bevent->button==2) {
< 		/* end of paste */
< 		if (doc->paste_operation) {
< 			if (PASTEOPERATION(doc->paste_operation)->eo > PASTEOPERATION(doc->paste_operation)->so) {
< 				DEBUG_MSG("doc_view_button_release_lcb, start doc-highlight_region for so=%d, eo=%d\n",PASTEOPERATION(doc->paste_operation)->so,PASTEOPERATION(doc->paste_operation)->eo);
< 				doc_highlight_region(doc, PASTEOPERATION(doc->paste_operation)->so, PASTEOPERATION(doc->paste_operation)->eo);
< 			}
< 			g_free(doc->paste_operation);
< 			doc->paste_operation = NULL;
< 		}
< 		/* now we should update the highlighting for the pasted text, but how long is the pasted text ?? */
< 	}
< /*	if (bevent->button == 3) {
< 		GtkWidget *menuitem;
< 		GtkWidget *submenu;
< 		GtkWidget *menu = gtk_menu_new ();
< 		gboolean tag_found;
< 		tag_found = doc_bevent_in_html_tag(doc, bevent);
< 		menuitem = gtk_menu_item_new_with_label(_("Edit tag"));
< 		g_signal_connect(G_OBJECT(menuitem), "activate", G_CALLBACK(rpopup_edit_tag_cb), doc);
< 		if (!tag_found) {
< 			gtk_widget_set_sensitive(menuitem, FALSE);
< 		}
<       gtk_widget_show (menuitem);
< 		gtk_menu_append(GTK_MENU(menu), menuitem);
< 		menuitem = gtk_menu_item_new();
<       gtk_widget_show (menuitem);
< 		gtk_menu_append(GTK_MENU(menu), menuitem);
< 
< 		menuitem = gtk_menu_item_new_with_mnemonic (_("Input _Methods"));
<       gtk_widget_show (menuitem);
< 		submenu = gtk_menu_new ();
<       gtk_menu_item_set_submenu (GTK_MENU_ITEM (menuitem), submenu);
<       gtk_menu_shell_append (GTK_MENU_SHELL (menu), menuitem);
<       gtk_im_multicontext_append_menuitems (GTK_IM_MULTICONTEXT (GTK_TEXT_VIEW(doc->view)->im_context),
< 					    GTK_MENU_SHELL (submenu));
< 		gtk_widget_show_all (menu);
< 		gtk_menu_popup (GTK_MENU (menu), NULL, NULL,
< 			  NULL, doc->view, 0, gtk_get_current_event_time ());
< 	} */
< 	return FALSE;
< }
< 
< static void doc_get_iter_at_bevent(Tdocument *doc, GdkEventButton *bevent, GtkTextIter *iter) {
< 	gint xpos, ypos;
< 	GtkTextWindowType wintype;
< 
< 	wintype = gtk_text_view_get_window_type(GTK_TEXT_VIEW(doc->view), doc->view->window);
< 	gtk_text_view_window_to_buffer_coords(GTK_TEXT_VIEW(doc->view), wintype,bevent->x, bevent->y,
< 					  &xpos, &ypos);
< 	xpos += gtk_text_view_get_border_window_size(GTK_TEXT_VIEW(doc->view),GTK_TEXT_WINDOW_LEFT);
< 	gtk_text_view_get_iter_at_location(GTK_TEXT_VIEW(doc->view), iter, xpos, ypos);
< }
< 
< static gboolean doc_view_button_press_lcb(GtkWidget *widget,GdkEventButton *bevent, Tdocument *doc) {
< 	DEBUG_MSG("doc_view_button_press_lcb, button %d\n", bevent->button);
< 	if (bevent->button==2 && !doc->paste_operation) {
< 		doc->paste_operation = g_new(Tpasteoperation,1);
< 		PASTEOPERATION(doc->paste_operation)->so = -1;
< 		PASTEOPERATION(doc->paste_operation)->eo = -1;
< 	}
< 	if (bevent->button == 3) {
< 		GtkTextIter iter;
< 		doc_get_iter_at_bevent(doc, bevent, &iter);
< 		rpopup_bevent_in_html_code(doc, &iter);
< 		bmark_store_bevent_location(doc, gtk_text_iter_get_offset(&iter));
< 	}
< 	return FALSE;
< }
< 
< static void rpopup_add_bookmark_lcb(GtkWidget *widget, Tdocument *doc) {
< 	bmark_add_at_bevent(doc);
< }
< static void rpopup_del_bookmark_lcb(GtkWidget *widget, Tdocument *doc) {
< 	bmark_del_at_bevent(doc);
< }
< 
< 
< static void doc_view_populate_popup_lcb(GtkTextView *textview,GtkMenu *menu,Tdocument *doc) {
< 	GtkWidget *menuitem;
< 	/* I found no way to connect an item-factory to this menu widget, so we have to do it in the manual way... */
< 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(gtk_menu_item_new()));
< 
< 	menuitem = gtk_image_menu_item_new_with_label(_("Replace"));
< 	g_signal_connect(menuitem, "activate", G_CALLBACK(replace_cb), doc->bfwin);
< 	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menuitem),gtk_image_new_from_stock(GTK_STOCK_FIND_AND_REPLACE, GTK_ICON_SIZE_MENU));
< 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(menuitem));
< 
< 	menuitem = gtk_image_menu_item_new_with_label(_("Find"));
< 	g_signal_connect(menuitem, "activate", G_CALLBACK(search_cb), doc->bfwin);
< 	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menuitem),gtk_image_new_from_stock(GTK_STOCK_FIND, GTK_ICON_SIZE_MENU));
< 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(menuitem));
< 
< 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(gtk_menu_item_new()));
< 
< 	if (bmark_have_bookmark_at_stored_bevent(doc)) {
< 		menuitem = gtk_menu_item_new_with_label(_("Delete bookmark"));
< 		g_signal_connect(menuitem, "activate", G_CALLBACK(rpopup_del_bookmark_lcb), doc);
< 		gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(menuitem));
< 	} else {
< 		menuitem = gtk_menu_item_new_with_label(_("Add bookmark"));
< 		g_signal_connect(menuitem, "activate", G_CALLBACK(rpopup_add_bookmark_lcb), doc);
< 		gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(menuitem));
< 	}
< 
< 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(gtk_menu_item_new()));
< 
< 	menuitem = gtk_image_menu_item_new_with_label(_("Edit color"));
< 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(menuitem));
< 	if (rpopup_doc_located_color(doc)) {
< 		g_signal_connect(G_OBJECT(menuitem), "activate", G_CALLBACK(rpopup_edit_color_cb), doc);
< 	} else {
< 		gtk_widget_set_sensitive(menuitem, FALSE);
< 	}
< 
< 	menuitem = gtk_image_menu_item_new_with_label(_("Edit tag"));
< 	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menuitem),new_pixmap(113));
< 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(menuitem));
< 	if (rpopup_doc_located_tag(doc)) {
< 		g_signal_connect(G_OBJECT(menuitem), "activate", G_CALLBACK(rpopup_edit_tag_cb), doc);
< 	} else {
< 		gtk_widget_set_sensitive(menuitem, FALSE);
< 	}
< 	
< 	gtk_widget_show_all(GTK_WIDGET(menu));
< }
< 
< static void doc_buffer_mark_set_lcb(GtkTextBuffer *buffer,GtkTextIter *iter,GtkTextMark *set_mark,Tdocument *doc) {
< 	doc_set_statusbar_lncol(doc);
< }
< static void doc_buffer_changed_lcb(GtkTextBuffer *textbuffer,Tdocument*doc) {
< 	doc_set_statusbar_lncol(doc);
< }
< 
< static void doc_view_toggle_overwrite_lcb(GtkTextView *view, Tdocument *doc)
< {	
< 	doc->overwrite_mode = (doc->overwrite_mode ? FALSE : TRUE);	
< 	doc_set_statusbar_insovr(doc);
< }
< 
< /**
<  * doc_bind_signals:
<  * @doc: a #Tdocument
<  *
<  * Bind signals related to the doc's buffer:
<  * "insert-text", "delete-range" and "insert-text" for autoindent
<  *
<  * Return value: void
<  **/
< void doc_bind_signals(Tdocument *doc) {
< 	doc->ins_txt_id = g_signal_connect(G_OBJECT(doc->buffer),
< 					 "insert-text",
< 					 G_CALLBACK(doc_buffer_insert_text_lcb), doc);
< 	doc->del_txt_id = g_signal_connect(G_OBJECT(doc->buffer),
< 					 "delete-range",
< 					 G_CALLBACK(doc_buffer_delete_range_lcb), doc);
< 	doc->ins_aft_txt_id = g_signal_connect_after(G_OBJECT(doc->buffer),
< 					 "insert-text",
< 					 G_CALLBACK(doc_buffer_insert_text_after_lcb), doc);
< }
< 
< /**
<  * doc_unbind_signals:
<  * @doc: a #Tdocument
<  *
<  * Unbind signals related to the doc's buffer:
<  * "insert-text", "delete-range" and "insert-text" for autoindent.
<  * This function checks if each individual signal has been bound before unbinding.
<  *
<  * Return value: void
<  **/
< void doc_unbind_signals(Tdocument *doc) {
< /*	g_print("doc_unbind_signals, before unbind ins=%lu, del=%lu\n", doc->ins_txt_id, doc->del_txt_id);*/
< 	if (doc->ins_txt_id != 0) {
< 		g_signal_handler_disconnect(G_OBJECT(doc->buffer),doc->ins_txt_id);
< 		doc->ins_txt_id = 0;
< 	}
< 	if (doc->del_txt_id != 0) {
< 		g_signal_handler_disconnect(G_OBJECT(doc->buffer),doc->del_txt_id);
< 		doc->del_txt_id = 0;
< 	}
< 	if (doc->ins_aft_txt_id != 0) {
< 		g_signal_handler_disconnect(G_OBJECT(doc->buffer),doc->ins_aft_txt_id);
< 		doc->ins_txt_id = 0;
< 	}
< }
< #ifdef HAVE_GNOME_VFS
< gboolean buffer_to_file(Tbfwin *bfwin, gchar *buffer, gchar *filename) {
< 	GnomeVFSHandle *handle;
< 	GnomeVFSFileSize bytes_written=0;
< 	GnomeVFSResult result;
< 	gchar *ondiskencoding = get_filename_on_disk_encoding(filename);
< 	/* we use create instead of open, because open will not create the file if it does
<       not already exist. The last argument is the permissions to use if the file is created,
<       the second to last tells GnomeVFS that its ok if the file already exists, and just open it */
< 	result = gnome_vfs_create(&handle, ondiskencoding, GNOME_VFS_OPEN_WRITE, FALSE, 0644);
< 	g_free(ondiskencoding);
< 	if (result != GNOME_VFS_OK) {
< 		DEBUG_MSG("buffer_to_file, opening, result=%d, error=%s\n",result, gnome_vfs_result_to_string(result));
< 		return FALSE;
< 	}
< 	/*	the gnome-sftp module does not truncate the file after create on an existing filename,
< 	but adding this truncate code results in an 'Unsupported operation' error */
< /* result = gnome_vfs_truncate_handle(handle, 0);
< 	if (result != GNOME_VFS_OK) {
< 		DEBUG_MSG("buffer_to_file, truncating: result=%d, error=%s\n", result, gnome_vfs_result_to_string(result));
< 	}*/
< 	result = gnome_vfs_write(handle, buffer, strlen(buffer), &bytes_written);
< 	if (bytes_written) {
< 		gnome_vfs_truncate_handle(handle, bytes_written);
< 	}
< 	gnome_vfs_close(handle);
< 	if (result != GNOME_VFS_OK) {
< 		DEBUG_MSG("buffer_to_file, writing: result=%d, error=%s\n", result, gnome_vfs_result_to_string(result));
< 		return FALSE;
< 	}
< 	return TRUE;
< }
< #else /* HAVE_GNOME_VFS */
< gboolean buffer_to_file(Tbfwin *bfwin, gchar *buffer, gchar *filename) {
< 	FILE *fd;
< 	gchar *ondiskencoding = get_filename_on_disk_encoding(filename);
< 	fd = fopen(ondiskencoding, "w");
< 	g_free(ondiskencoding);
< 	if (fd == NULL) {
< 		DEBUG_MSG("buffer_to_file, cannot open file %s\n", filename);
< 		return FALSE;
< 	}
< 	fputs(buffer, fd);
< 	fclose(fd);
< 	return TRUE;
< }
< #endif /* HAVE_GNOME_VFS */
< 
< /**
<  * gint doc_textbox_to_file
<  * @doc: a #Tdocument*
<  * @filename: a #gchar*
<  * @window_closing: a #gboolean if the window is closing, we should supress any statusbar messages then
<  *
<  * If applicable, backup existing file,
<  * possibly update meta-tags (HTML),
<  * and finally write the document to the specified file.
<  *
<  * Return value: #gint set to
<  * 1: on success
<  * 2: on success but the backup failed
<  * -1: if the backup failed and save was aborted
<  * -2: if the file could not be opened or written
<  * -3: if the backup failed and save was aborted by the user
<  * -4: if the charset encoding conversion failed and the save was aborted by the user
<  **/
< gint doc_textbox_to_file(Tdocument * doc, gchar * filename, gboolean window_closing) {
< 	gint backup_retval;
< 	gint write_retval;
< 	gchar *buffer;
< 	GtkTextIter itstart, itend;
< 
< 	if (!window_closing) statusbar_message(BFWIN(doc->bfwin),_("Saving file"), 1000);
< 
< 	/* update author meta tag */
< 	if (main_v->props.auto_update_meta_author) {
< 		const gchar *realname = g_get_real_name();
< 		if (realname && strlen(realname) > 0)  {
< 			gchar *author_tmp;
< 			author_tmp = g_strconcat("<meta name=\"author\" content=\"",realname,"\"",NULL);
< 			snr2_run_extern_replace(doc,"<meta[ \t\n]+name[ \t\n]*=[ \t\n]*\"author\"[ \t\n]+content[ \t\n]*=[ \t\n]*\"[^\"]*\"[ \t\n]*",0,1,0,author_tmp,FALSE);
< 			g_free(author_tmp);
< 		}
< 	}
< 
< 	/* update date meta tag */
< 	if (main_v->props.auto_update_meta_date) {
< 		time_t time_var;
< 		struct tm *time_struct;
< 		gchar isotime[60];
< 		gchar *date_tmp;
< 		
< 		time_var = time(NULL);
< 		time_struct = localtime(&time_var);
< 		strftime(isotime, 30, "%Y-%m-%dT%H:%M:%S%z", time_struct);
< 		
< 		date_tmp = g_strconcat("<meta name=\"date\" content=\"",isotime,"\"",NULL);
< 		snr2_run_extern_replace(doc,"<meta[ \t\n]+name[ \t\n]*=[ \t\n]*\"date\"[ \t\n]+content[ \t\n]*=[ \t\n]*\"[^\"]*\"[ \t\n]*",0,1,0,date_tmp,FALSE);
< 		g_free(date_tmp);
< 	}
< 	
< 	/* update generator meta tag */
< 	if (main_v->props.auto_update_meta_generator) {
< 		/* what is this good for? do we really need it? */
< 		/* Tsearch_result res = doc_search_run_extern(doc,"<meta[ \t\n]+name[ \t\n]*=[ \t\n]*\"generator\"[ \t\n]+content[ \t\n]*=[ \t\n]*\"[^\"]*[bB]luefish[^\"]*\"[ \t\n]*",1,0);
< 		 * if (res.end > 0) { */
< 		snr2_run_extern_replace(doc,"<meta[ \t\n]+name[ \t\n]*=[ \t\n]*\"generator\"[ \t\n]+content[ \t\n]*=[ \t\n]*\"[^\"]*\"[ \t\n]*",0,1,0,"<meta name=\"generator\" content=\"Bluefish "VERSION"\"", FALSE);
< 		/* } */
< 	}
< 
< 	/* This writes the contents of a textbox to a file */
< 	backup_retval = doc_check_backup(doc);
< 
< 	if (!backup_retval) {
< 		if (main_v->props.backup_abort_action == DOCUMENT_BACKUP_ABORT_ABORT) {
< 			DEBUG_MSG("doc_textbox_to_file, backup failure, abort!\n");
< 			return -1;
< 		} else if (main_v->props.backup_abort_action == DOCUMENT_BACKUP_ABORT_ASK) {
< 			gchar *options[] = {_("_Abort save"), _("_Continue save"), NULL};
< 			gint retval;
< 			gchar *tmpstr = g_strdup_printf(_("A backupfile for %s could not be created. If you continue, this file will be overwritten."), filename);
< 			retval = multi_warning_dialog(BFWIN(doc->bfwin)->main_window,_("File backup failure"), tmpstr, 1, 0, options);
< 			g_free(tmpstr);
< 			if (retval == 0) {
< 				DEBUG_MSG("doc_textbox_to_file, backup failure, user aborted!\n");
< 				return -3;
< 			}
< 		}
< 	}
< 	
< 	gtk_text_buffer_get_bounds(doc->buffer,&itstart,&itend);
< 	buffer = gtk_text_buffer_get_text(doc->buffer,&itstart,&itend,FALSE);
< 	
< 	if (doc->encoding) {
< 		gchar *newbuf;
< 		gsize bytes_written=0, bytes_read=0;
< 		DEBUG_MSG("doc_textbox_to_file, converting from UTF-8 to %s\n", doc->encoding);
< 		newbuf = g_convert(buffer,-1,doc->encoding,"UTF-8",&bytes_read,&bytes_written,NULL); 
< 		if (newbuf) {
< 			g_free(buffer);
< 			buffer = newbuf;
< 		} else {
< 			gchar *options[] = {_("_Abort save"), _("_Continue save in UTF-8"), NULL};
< 			gint retval, line, column;
< 			glong position;
< 			gchar *tmpstr, failed[6];
< 			GtkTextIter iter;
< 			position = g_utf8_pointer_to_offset(buffer,buffer+bytes_read);
< 			gtk_text_buffer_get_iter_at_offset(doc->buffer,&iter,position);
< 			line = gtk_text_iter_get_line(&iter);
< 			column = gtk_text_iter_get_line_offset(&iter);
< 			failed[0]='\0';
< 			g_utf8_strncpy(failed,buffer+bytes_read,1);
< 			tmpstr = g_strdup_printf(_("Failed to convert %s to character encoding %s. Encoding failed on character '%s' at line %d column %d\n\nContinue saving in UTF-8 encoding?"), filename, doc->encoding, failed, line+1, column+1);
< 			retval = multi_warning_dialog(BFWIN(doc->bfwin)->main_window,_("File encoding conversion failure"), tmpstr, 1, 0, options);
< 			g_free(tmpstr);
< 			if (retval == 0) {
< 				DEBUG_MSG("doc_textbox_to_file, character set conversion failed, user aborted!\n");
< 				return -4;
< 			} else {
< 				/* continue in UTF-8 */
< 				update_encoding_meta_in_file(doc, "UTF-8");
< 				g_free(buffer);
< 				gtk_text_buffer_get_bounds(doc->buffer,&itstart,&itend);
< 				buffer = gtk_text_buffer_get_text(doc->buffer,&itstart,&itend,FALSE);
< 			}
< 		}
< 	}
< 	
< 	write_retval = buffer_to_file(BFWIN(doc->bfwin), buffer, filename);
< 	DEBUG_MSG("doc_textbox_to_file, write_retval=%d\n",write_retval);
< 	g_free(buffer);
< 	if (!write_retval) {
< 		return -2;
< 	}
< 
< 	if (main_v->props.clear_undo_on_save) {
< 		doc_unre_clear_all(doc);
< 	}
< 	DEBUG_MSG("doc_textbox_to_file, calling doc_set_modified(doc, 0)\n");
< 	doc_set_modified(doc, 0);
< 	if (!backup_retval) {
< 		return 2;
< 	} else {
< 		return 1;
< 	}
< 
< }
< 
< /**
<  * doc_destroy:
<  * @doc: a #Tdocument
<  * @delay_activation: #gboolean whether to delay gui-updates.
<  *
<  * Performs all actions neccessary to remove an open document from the fish:
<  * Adds filename to recent-list,
<  * removes the document from the documentlist and notebook,
<  * change notebook-focus (if !delay_activation),
<  * delete backupfile if required by pref,
<  * free all related memory.
<  *
<  * Return value: void
<  **/
< void doc_destroy(Tdocument * doc, gboolean delay_activation) {
< 	Tbfwin *bfwin = BFWIN(doc->bfwin);
< 
< 	DEBUG_MSG("doc_destroy, calling bmark_clean_for_doc(%p)\n",doc);
< 	bmark_clean_for_doc(doc);
< /*        bmark_adjust_visible(bfwin);   */
< 
< 	if (doc->filename) {
< 		add_to_recent_list(doc->bfwin,doc->filename, 1, FALSE);
< 	}
< 	gui_notebook_unbind_signals(BFWIN(doc->bfwin));
< 	/* to make this go really quick, we first only destroy the notebook page and run flush_queue(), 
< 	after the document is gone from the GUI we complete the destroy, to destroy only the notebook
< 	page we ref+ the scrolthingie, remove the page, and unref it again */
< 	g_object_ref(doc->view->parent);
< 	if (doc->floatingview) {
< 		gtk_widget_destroy(FLOATINGVIEW(doc->floatingview)->window);
< 		doc->floatingview = NULL;
< 	}
< 	/* now we remove the document from the document list */
< 	bfwin->documentlist = g_list_remove(bfwin->documentlist, doc);
< 	DEBUG_MSG("removed %p from documentlist, list %p length=%d\n",doc
< 			, bfwin->documentlist
< 			, g_list_length(bfwin->documentlist));
< 	if (bfwin->current_document == doc) {
< 		bfwin->current_document = NULL;
< 	}
< 	/* then we remove the page from the notebook */
< 	DEBUG_MSG("about to remove widget from notebook (doc=%p, current_document=%p)\n",doc,bfwin->current_document);
< 	gtk_notebook_remove_page(GTK_NOTEBOOK(bfwin->notebook),
< 							 gtk_notebook_page_num(GTK_NOTEBOOK(bfwin->notebook),doc->view->parent));
< 	DEBUG_MSG("doc_destroy, removed widget from notebook (doc=%p), delay_activation=%d\n",doc,delay_activation);
< 	DEBUG_MSG("doc_destroy, (doc=%p) about to bind notebook signals...\n",doc);
< 	gui_notebook_bind_signals(BFWIN(doc->bfwin));
< 	if (!delay_activation) {
< 		notebook_changed(BFWIN(doc->bfwin),-1);
< 	}
< 	DEBUG_MSG("doc_destroy, (doc=%p) after calling notebook_changed()\n",doc);
< 	/* now we really start to destroy the document */
< 	g_object_unref(doc->view->parent);
< 
< 	if (doc->filename) {
< 		if (main_v->props.backup_cleanuponclose) {
< 			gchar *backupfile = g_strconcat(doc->filename, main_v->props.backup_filestring, NULL);
< 			DEBUG_MSG("unlinking %s, doc->filename=%s\n", backupfile,doc->filename);
< 			unlink(backupfile);
< 			g_free(backupfile);
< 		}
< 		g_free(doc->filename);
< 	}
< 	
< 	if (doc->encoding)
< 		g_free(doc->encoding);
< 
< #ifdef HAVE_GNOME_VFS
< 	if (doc->fileinfo) {
< 		gnome_vfs_file_info_unref (doc->fileinfo);
< 	}
< #endif	/* HAVE_GNOME_VFS */
< 
< 	g_object_unref(doc->buffer);
< 	doc_unre_destroy(doc);
< 	DEBUG_MSG("doc_destroy, finished for %p\n", doc);
< 	g_free(doc);
< }
< 
< /**
<  * document_unset_filename:
<  * @document: #Tdocument*
<  *
<  * this function is called if some other document is saved with a filename
<  * equal to this files filename, or when this file is deleted in the filebrowser
<  *
<  * return value: void, ignored
<  */
< void document_unset_filename(Tdocument *doc) {
< 	if (doc->filename) {
< 		gchar *tmpstr2, *tmpstr3;
< 		gchar *tmpstr, *oldfilename = doc->filename;
< 		doc->filename = NULL;
< 		doc_set_title(doc);
< 		tmpstr2 = g_path_get_basename(oldfilename);
< 		tmpstr3 = get_utf8filename_from_on_disk_encoding(tmpstr2);
< 		tmpstr = g_strconcat(_("Previously: "), tmpstr3, NULL);
< 		g_free(tmpstr2);
< 		g_free(tmpstr3);
< 		gtk_label_set(GTK_LABEL(doc->tab_label),tmpstr);
< 		g_free(tmpstr);
< 		g_free(oldfilename);
< 	}
< }
< 
< /**
<  * ask_new_filename:
<  * @bfwin: #Tbfwin* mainly used to set the dialog transient
<  * @oldfilename: #gchar* with the old filename
<  * @gui_name: #const gchar* with the name of the file used in the GUI
<  * @is_move: #gboolean if the title should be move or save as
<  *
<  * returns a newly allocated string with a new filename
<  *
<  * if a file with the selected name name was
<  * open already it will ask the user what to do, return NULL if
<  * the user wants to abort, or will remove the name of the other file if the user wants
<  * to continue
<  *
<  * Return value: gchar* with newly allocated string, or NULL on failure or abort
<  **/
< gchar *ask_new_filename(Tbfwin *bfwin,gchar *oldfilename, const gchar *gui_name, gboolean is_move) {
< 	Tdocument *exdoc;
< 	GList *alldocs;
< 	gchar *ondisk = get_filename_on_disk_encoding(oldfilename);
< 	gchar *newfilename = NULL;
< 	gchar *dialogtext;
< 	
< 	dialogtext = g_strdup_printf((is_move) ? _("Move/rename %s to"): _("Save %s as"), gui_name);
< #ifdef HAVE_ATLEAST_GTK_2_4
< 	{
< 		GtkWidget *dialog;
< 		dialog = file_chooser_dialog(bfwin, dialogtext, GTK_FILE_CHOOSER_ACTION_SAVE, oldfilename, FALSE, FALSE, NULL);
< 		if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT) {
< 			newfilename = gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(dialog));
< 		}
< 		gtk_widget_destroy(dialog);
< 	}
< #else
< 	newfilename = return_file_w_title(ondisk,dialogtext);
< #endif
< 	g_free(ondisk);
< 	g_free(dialogtext);
< 	
< 	if (!newfilename || (oldfilename && strcmp(oldfilename,newfilename)==0)) {
< 		if (newfilename) g_free(newfilename);
< 		return NULL;
< 	}
< 	
< 	/* make a full path, re-use the ondisk variable */
< 	ondisk = newfilename;
< 	newfilename = create_full_path(ondisk, NULL);
< 	g_free(ondisk);
< 
< 	
< 	alldocs = return_allwindows_documentlist();
< 	exdoc = documentlist_return_document_from_filename(alldocs, newfilename);
< 	g_list_free(alldocs);
< 	DEBUG_MSG("ask_new_filename, exdoc=%p, newfilename=%s\n", exdoc, newfilename);
< 	if (exdoc) {
< 		gchar *tmpstr;
< 		gint retval;
< 		gchar *options[] = {_("_Cancel"), _("_Overwrite"), NULL};
< 
< 		tmpstr = g_strdup_printf(_("File %s exists and is opened, overwrite?"), newfilename);
< 		retval = multi_warning_dialog(bfwin->main_window, tmpstr, 
< 		                              _("The file you have selected is being edited in Bluefish."), 1, 0, options);
< 		g_free(tmpstr);
< 		if (retval == 0) {
< 			g_free(newfilename);
< 			return NULL;
< 		} else {
< 			document_unset_filename(exdoc);
< 		}
< 	} else {
<       if (file_exists_and_readable(newfilename)) {      
< 			gchar *tmpstr;
< 			gint retval;
< 			gchar *options[] = {_("_Cancel"), _("_Overwrite"), NULL};
< 			
< 			tmpstr = g_strdup_printf(_("A file named \"%s\" already exists."), newfilename);
< 			retval = multi_warning_dialog(bfwin->main_window, tmpstr, 
<                                        _("Do you want to replace the existing file?"), 1, 0, options);
< 			g_free (tmpstr);
< 			if (retval == 0) {
< 				g_free (newfilename);
< 				return NULL;
< 			}
< 		}
< 	}
< 	return newfilename;
< }
< 
< /**
<  * doc_save:
<  * @doc: the #Tdocument to save
<  * @do_save_as: #gboolean set to 1 if "save as"
<  * @do_move: #gboolean set to 1 if moving the file.
<  * @window_closing: #gboolean if the window is closing, should suppress statusbar messages then
<  *
<  * Performs all neccessary actions to save an open document.
<  * Warns the user of problems, and asks for a filename if neccessary.
<  * 
<  * Return value: #gint set to
<  * 1: on success
<  * 2: on success but the backup failed
<  * 3: on user abort
<  * -1: if the backup failed and save was aborted
<  * -2: if the file pointer could not be opened 
<  * -3: if the backup failed and save was aborted by the user
<  * -4: if there is no filename, after asking one from the user
<  * -5: if another process modified the file, and the user chose cancel
<  **/
< gint doc_save(Tdocument * doc, gboolean do_save_as, gboolean do_move, gboolean window_closing) {
< 	gint retval;
< 	gchar *ondiskencoding = NULL, *ondiskencodingbckup = NULL;
< #ifdef DEBUG
< 	g_assert(doc);
< #endif
< 
< 	DEBUG_MSG("doc_save, doc=%p, save_as=%d, do_move=%d\n", doc, do_save_as, do_move);
< 	if (doc->filename == NULL) {
< 		do_save_as = 1;
< 	}
< 	if (do_move) {
< 		do_save_as = 1;
< 	}
< 
< 	if (do_save_as) {
< 		gchar *newfilename = NULL;
< 		if (!window_closing) statusbar_message(BFWIN(doc->bfwin),_("Save as..."), 1);
< 		newfilename = ask_new_filename(BFWIN(doc->bfwin), doc->filename, gtk_label_get_text(GTK_LABEL(doc->tab_label)), do_move);
< 		if (!newfilename) {
< 			return 3;
< 		}
< 		if (doc->filename) {
< 			if (do_move) {
<                 gchar *backupfilename = NULL;
<                 ondiskencoding = get_filename_on_disk_encoding(doc->filename);
<                 /* Check for a backup file */
<                 backupfilename = g_strconcat (doc->filename, main_v->props.backup_filestring, NULL);
<                 if (file_exists_and_readable(backupfilename)) {
<                     ondiskencodingbckup = get_filename_on_disk_encoding(backupfilename);
<                     DEBUG_MSG("doc_save, do_move, backup file exists, backupfilename = %s\n", ondiskencodingbckup);
<                 }
<                 g_free (backupfilename);
< 			}
< 			g_free(doc->filename);
< 		}
< 		doc->filename = newfilename;
< 		/* TODO: should feed the contents to the function too !! */
< 		doc_reset_filetype(doc, doc->filename, NULL);
< 		doc_set_title(doc);
< 		if (doc == BFWIN(doc->bfwin)->current_document) {
< 			gui_set_title(BFWIN(doc->bfwin), doc);
< 		}
< 	} else /* (!do_save_as) */ {
< 		gboolean modified;
< 		time_t oldmtime, newmtime;
< #ifdef HAVE_GNOME_VFS
< 		GnomeVFSFileInfo *fileinfo;
< 		fileinfo = gnome_vfs_file_info_new();
< 		modified = doc_check_modified_on_disk(doc,&fileinfo);
< 		if (doc->fileinfo && modified) {
< 			newmtime = fileinfo->mtime;
< 			oldmtime = doc->fileinfo->mtime;
< 		}
< 		gnome_vfs_file_info_unref(fileinfo);
< #else
< 		struct stat statbuf;
< 		modified = doc_check_modified_on_disk(doc,&statbuf);
< 		newmtime = statbuf.st_mtime;
< 		oldmtime = doc->statbuf.st_mtime;
< #endif
< 		if (modified) {
< 			gchar *tmpstr, oldtimestr[128], newtimestr[128];/* according to 'man ctime_r' this should be at least 26, so 128 should do ;-)*/
< 			gint retval;
< 			gchar *options[] = {_("_Cancel"), _("_Overwrite"), NULL};
< 	
< 			ctime_r(&newmtime,newtimestr);
< 			ctime_r(&oldmtime,oldtimestr);
< 			tmpstr = g_strdup_printf(_("File: %s\n\nNew modification time: %s\nOld modification time: %s"), doc->filename, newtimestr, oldtimestr);
< 			retval = multi_warning_dialog(BFWIN(doc->bfwin)->main_window,_("File has been modified by another process."), tmpstr, 1, 0, options);
< 			g_free(tmpstr);
< 			if (retval == 0) {
< 				return -5;
< 			}
< 		}
< 	}
< 	
< 	DEBUG_MSG("doc_save, returned file %s\n", doc->filename);
< /*	if (do_save_as && oldfilename && main_v->props.link_management) {
< 		update_filenames_in_file(doc, oldfilename, doc->filename, 1);
< 	}*/
< 	{
< 		gchar *tmp = g_strdup_printf(_("Saving %s"), doc->filename);
< 		if (!window_closing) statusbar_message(BFWIN(doc->bfwin),tmp, 1);
< 		g_free(tmp);
< 		/* re-use tmp */
< 		tmp = g_path_get_dirname(doc->filename);
< 		if (BFWIN(doc->bfwin)->session->savedir) g_free(BFWIN(doc->bfwin)->session->savedir);
< 		BFWIN(doc->bfwin)->session->savedir = tmp;
< 	}
< 	retval = doc_textbox_to_file(doc, doc->filename, window_closing);
< 
< 	switch (retval) {
< 		gchar *errmessage;
< 		case -1:
< 			/* backup failed and aborted */
< 			errmessage = g_strconcat(_("Could not backup file:\n\""), doc->filename, "\"", NULL);
< 			error_dialog(BFWIN(doc->bfwin)->main_window,_("File save aborted.\n"), errmessage);
< 			g_free(errmessage);
< 		break;
< 		case -2:
< 			/* could not open the file pointer */
< 			errmessage = g_strconcat(_("Could not write file:\n\""), doc->filename, "\"", NULL);
< 			error_dialog(BFWIN(doc->bfwin)->main_window,_("File save error"), errmessage);
< 			g_free(errmessage);
< 		break;
< 		case -3:
< 		case -4:
< 			/* do nothing, the save is aborted by the user */
< 		break;
< 		default:
< 			doc_set_stat_info(doc);
< 			{ 
< 				gchar *tmp = path_get_dirname_with_ending_slash(doc->filename);
< 				bfwin_filebrowser_refresh_dir(BFWIN(doc->bfwin),tmp);
< 				g_free(tmp);
< 			}
<             doc_unregroup_reset_changed(doc);
<             if (do_move) {
< #ifdef HAVE_GNOME_VFS
< 				gnome_vfs_unlink(ondiskencoding);
< 				if (ondiskencodingbckup) {
< 				    gnome_vfs_unlink(ondiskencodingbckup);
< 				}
< #else
< 				unlink(ondiskencoding);
< 				if (ondiskencodingbckup) {
< 				    unlink(ondiskencodingbckup);
< 				}				
< #endif
< 				g_free(ondiskencoding);
< 				if (ondiskencodingbckup)    g_free(ondiskencodingbckup);
<             }
< 			DEBUG_MSG("doc_save, received return value %d from doc_textbox_to_file\n", retval);
< 		break;
< 	}
< 	return retval;
< }
< 
< /**
<  * doc_close:
<  * @doc: The #Tdocument to clase.
<  * @warn_only: a #gint set to 1 if the document shouldn't actually be destroyed.
<  *
<  * Get confirmation when closing an unsaved file, save it if neccessary,
<  * and destroy the file unless aborted by user.
<  *
<  * Return value: #gint set to 0 (when cancelled/aborted) or 1 (when closed or saved&closed)
<  **/
< gint doc_close(Tdocument * doc, gint warn_only)
< {
< 	gchar *text;
< 	gint retval;
< #ifdef DEBUG
< 	if (!doc) {
< 		DEBUG_MSG("doc_close, returning because doc=NULL\n");
< 		return 0;
< 	}
< #endif
< 
< 	if (doc_is_empty_non_modified_and_nameless(doc) && g_list_length(BFWIN(doc->bfwin)->documentlist) ==1) {
< 		/* no need to close this doc, it's an Untitled empty document */
< 		DEBUG_MSG("doc_close, 1 untitled empty non-modified document, returning\n");
< 		return 0;
< 	}
< 
< 	if (doc->modified) {
< 		/*if (doc->tab_label) {*/
< 			text = g_strdup_printf(_("Save changes to \"%s\" before closing?."),
< 									gtk_label_get_text (GTK_LABEL (doc->tab_label)));
< 		/*} else {
< 			text = g_strdup(_("Save changes to this untitled file before closing?"));
< 		}*/
< 	
< 		{
< 			gchar *buttons[] = {_("Do_n't save"), GTK_STOCK_CANCEL, GTK_STOCK_SAVE, NULL};
< 			retval = multi_query_dialog(BFWIN(doc->bfwin)->main_window, text, 
< 						_("If you don't save your changes they will be lost."), 2, 1, buttons);
< 		}
< 		g_free(text);
< 
< 		switch (retval) {
< 		case 1:
< 			DEBUG_MSG("doc_close, retval=2 (cancel) , returning\n");
< 			return 2;
< 			break;
< 		case 2:
< 			doc_save(doc, FALSE, FALSE, FALSE);
< 			if (doc->modified == 1) {
< 				/* something went wrong it's still not saved */
< 				return 0;
< 			}
< 			if (!warn_only) {
< 				doc_destroy(doc, FALSE);
< 			}
< 			break;
< 		case 0:
< 			if (!warn_only) {
< 				doc_destroy(doc, FALSE);
< 			}
< 			break;
< 		default:
< 			return 0;			/* something went wrong */
< 			break;
< 		}
< 	} else {
< 		if (!warn_only) {
< 			DEBUG_MSG("doc_close, starting doc_destroy for doc=%p\n", doc);
< 			doc_destroy(doc, FALSE);
< 		}
< 	}
< 	DEBUG_MSG("doc_close, finished\n");
< /*	notebook_changed();*/
< 	return 1;
< }
< 
< static void doc_close_but_clicked_lcb(GtkWidget *wid, gpointer data) {
< 
< 	doc_close(data, 0);
< }
< 
< /* contributed by Oskar Swida <swida@aragorn.pb.bialystok.pl>, with help from the gedit source */
< static gboolean doc_textview_expose_event_lcb(GtkWidget * widget, GdkEventExpose * event, gpointer doc) {
< 	GtkTextView *view = (GtkTextView*)widget;
< 	GdkRectangle rect;
< 	GdkWindow *win;
< 	GtkTextIter l_start,l_end, it;
< 	gint l_top1,l_top2;
< 	PangoLayout *l;
< 	gchar *pomstr;
< 	gint numlines,w,i;
< 	GHashTable *temp_tab;
< 
< 	win = gtk_text_view_get_window(view,GTK_TEXT_WINDOW_LEFT);
< 	if (win!=event->window) return FALSE;
< 
< 	gtk_text_view_get_visible_rect(view,&rect);
< 	gtk_text_view_get_line_at_y(view,&l_start,rect.y,&l_top1);
< 	gtk_text_view_get_line_at_y(view,&l_end,rect.y+rect.height,&l_top2);
< 	l = gtk_widget_create_pango_layout(widget,"");
< 
< 	numlines = gtk_text_buffer_get_line_count(gtk_text_view_get_buffer(view));
< 	pomstr = g_strdup_printf("%d",MAX(99,numlines));
< 	pango_layout_set_text(l,pomstr,-1);
< 	g_free(pomstr);
< 	pango_layout_get_pixel_size(l,&w,NULL);
< 	gtk_text_view_set_border_window_size(view,GTK_TEXT_WINDOW_LEFT,w+4);   
< 	it = l_start;
< 	temp_tab = bmark_get_bookmarked_lines(DOCUMENT(doc),&l_start,&l_end);
< 	for(i=gtk_text_iter_get_line(&l_start);i<=gtk_text_iter_get_line(&l_end);i++) {
< 		gchar* val;
< 		gtk_text_iter_set_line(&it,i);
< 		gtk_text_view_get_line_yrange(view,&it,&w,NULL);      
< 		gtk_text_view_buffer_to_window_coords(view,GTK_TEXT_WINDOW_LEFT,0,w,NULL,&w);
< 		pomstr = NULL;
< 		if (temp_tab) {
< 			val = g_hash_table_lookup(temp_tab,&i);      		
< 			if (val) {
< 				pomstr = g_strdup_printf("<span background=\"%s\" >%d</span>",val[0] == '0' ? "#768BEA" : "#62CB7F",i+1);
< 			}
< 		}
< 		if (pomstr == NULL) {
< 			pomstr = g_strdup_printf("<span>%d</span>",i+1);
< 		} 
< 		pango_layout_set_markup(l,pomstr,-1);
< 		gtk_paint_layout(widget->style,win,GTK_WIDGET_STATE(widget),FALSE,NULL,widget,NULL,2,w,l);
< 		g_free(pomstr);
< 	}
< 	g_object_unref(G_OBJECT(l));
< 	if (temp_tab) g_hash_table_destroy(temp_tab);
< 	return TRUE;
< }
< 
< /**
<  * document_set_line_numbers:
<  * @doc: a #Tdocument*
<  * @value: a #gboolean
<  *
<  * Show or hide linenumbers (at the left of the main GtkTextView).
<  *
<  * Return value: void
<  **/ 
< void document_set_line_numbers(Tdocument *doc, gboolean value) {
< 	if (value) {
< 		gtk_text_view_set_left_margin(GTK_TEXT_VIEW(doc->view),2);
< 		gtk_text_view_set_border_window_size(GTK_TEXT_VIEW(doc->view),GTK_TEXT_WINDOW_LEFT,20);
< 		g_signal_connect(G_OBJECT(doc->view),"expose-event",G_CALLBACK(doc_textview_expose_event_lcb),doc);
< 	} else {
< 		gtk_text_view_set_left_margin(GTK_TEXT_VIEW(doc->view),0);
< 		gtk_text_view_set_border_window_size(GTK_TEXT_VIEW(doc->view),GTK_TEXT_WINDOW_LEFT,0);
< 	}
< }
< 
< static void doc_view_drag_end_lcb(GtkWidget *widget,GdkDragContext *drag_context,Tdocument *doc) {
< 	if (doc->paste_operation) {
< 		if (PASTEOPERATION(doc->paste_operation)->eo > PASTEOPERATION(doc->paste_operation)->so) {
< 			doc_highlight_region(doc, PASTEOPERATION(doc->paste_operation)->so, PASTEOPERATION(doc->paste_operation)->eo);
< 		}
< 		g_free(doc->paste_operation);
< 		doc->paste_operation = NULL;
< 	}
< }
< static void doc_view_drag_begin_lcb(GtkWidget *widget,GdkDragContext *drag_context,Tdocument *doc) {
< 	if (!doc->paste_operation) {
< 		doc->paste_operation = g_new(Tpasteoperation,1);
< 		PASTEOPERATION(doc->paste_operation)->so = -1;
< 		PASTEOPERATION(doc->paste_operation)->eo = -1;
< 	}
< }
< 
< /**
<  * doc_new:
<  * @bfwin: #Tbfwin* with the window to open the document in
<  * @delay_activate: Whether to perform GUI-calls and flush_queue(). Set to TRUE when loading several documents at once.
<  *
<  * Create a new document, related structures and a nice little textview to display the document in.
<  * Finally, add a new tab to the notebook.
<  * The GtkTextView is not actually gtk_widget_shown() if delay_activate == TRUE. This is done by doc_activate() instead.
<  *
<  * Return value: a #Tdocument* pointer to the just created document.
<  **/
< Tdocument *doc_new(Tbfwin* bfwin, gboolean delay_activate) {
< 	GtkWidget *scroll;
< 	Tdocument *newdoc = g_new0(Tdocument, 1);
< 	DEBUG_MSG("doc_new, main_v is at %p, bfwin at %p, newdoc at %p\n", main_v, bfwin, newdoc);
< 	newdoc->bfwin = (gpointer)bfwin;
< 	newdoc->hl = (Tfiletype *)((GList *)g_list_first(main_v->filetypelist))->data;
< 	newdoc->autoclosingtag = (newdoc->hl->autoclosingtag > 0);
< 	newdoc->buffer = gtk_text_buffer_new(highlight_return_tagtable());
< 	newdoc->view = gtk_text_view_new_with_buffer(newdoc->buffer);
< 	scroll = gtk_scrolled_window_new(NULL, NULL);
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll),
< 									   GTK_POLICY_AUTOMATIC,
< 									   GTK_POLICY_AUTOMATIC);
< 	gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW
< 											(scroll), GTK_SHADOW_IN);
< 	gtk_container_add(GTK_CONTAINER(scroll), newdoc->view);
< 
< 	newdoc->linenumberstate = main_v->props.view_line_numbers;
< 	document_set_line_numbers(newdoc, newdoc->linenumberstate);
< 
< 	newdoc->tab_label = gtk_label_new(NULL);
< 	GTK_WIDGET_UNSET_FLAGS(newdoc->tab_label, GTK_CAN_FOCUS);
< 	if (strlen(main_v->props.tab_font_string)) {
< 		apply_font_style(newdoc->tab_label, main_v->props.tab_font_string);
< 	}
< 	newdoc->tab_menu = gtk_label_new(NULL);
< 	newdoc->tab_eventbox = gtk_event_box_new();
< 	gtk_misc_set_alignment(GTK_MISC(newdoc->tab_menu), 0,0);
< 
< 	doc_unre_init(newdoc);
< 	doc_set_font(newdoc, NULL);
< 	newdoc->wrapstate = (bfwin->project) ? bfwin->project->word_wrap : main_v->props.word_wrap;
< 	doc_set_wrap(newdoc);
< 	/* newdoc->modified = 0; */
< 	doc_set_title(newdoc);
< 	/*newdoc->filename = NULL;*/
< 	newdoc->need_highlighting = 0;
< #ifdef HAVE_GNOME_VFS
< 	/*newdoc->fileinfo = NULL;*/
< #else
< 	newdoc->statbuf.st_mtime = 0;
< 	newdoc->statbuf.st_size = 0;
< 	newdoc->statbuf.st_uid = -1;
< 	newdoc->statbuf.st_gid = -1;
< #endif
< 	newdoc->is_symlink = 0;
< 	newdoc->encoding = g_strdup(main_v->props.newfile_default_encoding);
< 	newdoc->overwrite_mode = FALSE;
< 	doc_bind_signals(newdoc);
< 
< 	g_signal_connect(G_OBJECT(newdoc->view), "button-release-event", 
< 		G_CALLBACK(doc_view_button_release_lcb), newdoc);
< 	g_signal_connect(G_OBJECT(newdoc->view), "button-press-event", 
< 		G_CALLBACK(doc_view_button_press_lcb), newdoc);
< 	g_signal_connect(G_OBJECT(newdoc->buffer), "changed",
< 		G_CALLBACK(doc_buffer_changed_lcb), newdoc);
< 	g_signal_connect(G_OBJECT(newdoc->buffer), "mark-set", 
< 		G_CALLBACK(doc_buffer_mark_set_lcb), newdoc);
< 	g_signal_connect(G_OBJECT(newdoc->view), "toggle-overwrite",
< 		G_CALLBACK(doc_view_toggle_overwrite_lcb), newdoc);
< /*	g_signal_connect(G_OBJECT(newdoc->view), "paste-clipboard",
< 		G_CALLBACK(doc_paste_clipboard_lcb), newdoc);
< 	g_signal_connect_after(G_OBJECT(newdoc->view), "button-release-event", 
< 		G_CALLBACK(doc_view_button_release_after_lcb), newdoc);*/
< 	g_signal_connect_after(G_OBJECT(newdoc->view), "drag-end", 
< 		G_CALLBACK(doc_view_drag_end_lcb), newdoc);
< 	g_signal_connect_after(G_OBJECT(newdoc->view), "drag-begin", 
< 		G_CALLBACK(doc_view_drag_begin_lcb), newdoc);
< 	g_signal_connect_after(G_OBJECT(newdoc->view), "key-release-event", 
< 		G_CALLBACK(doc_view_key_release_lcb), newdoc);
< 	g_signal_connect(G_OBJECT(newdoc->view), "key-press-event", 
< 		G_CALLBACK(doc_view_key_press_lcb), newdoc);
< 	g_signal_connect_after(G_OBJECT(newdoc->view), "populate-popup", 
< 		G_CALLBACK(doc_view_populate_popup_lcb), newdoc);
< 
< 	bfwin->documentlist = g_list_append(bfwin->documentlist, newdoc);
< 
< 	if(!delay_activate) gtk_widget_show(newdoc->view); /* Delay _show() if neccessary */
< 
< 	gtk_widget_show(newdoc->tab_label);
< 	gtk_widget_show(scroll);
< 
< 	DEBUG_MSG("doc_new, appending doc to notebook\n");
< 	{
< 		GtkWidget *hbox, *but, *image;
< 		hbox = gtk_hbox_new(FALSE,0);
< 		but = gtk_button_new();
< 		image = new_pixmap(101);
< 		gtk_container_add(GTK_CONTAINER(but), image);
< 		gtk_container_set_border_width(GTK_CONTAINER(but),0);
< #ifndef HAVE_ATLEAST_GTK_2_4
< 		gtk_widget_set_size_request(but, 12,12);
< #endif
< 		gtk_button_set_relief(GTK_BUTTON(but), GTK_RELIEF_NONE);
< 		g_signal_connect(G_OBJECT(but), "clicked", G_CALLBACK(doc_close_but_clicked_lcb), newdoc);
< 		gtk_container_add(GTK_CONTAINER(newdoc->tab_eventbox), newdoc->tab_label);
< 		gtk_box_pack_start(GTK_BOX(hbox), newdoc->tab_eventbox, FALSE, FALSE, 0);
< 		gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, FALSE, 0);
< 		gtk_widget_show_all(hbox);
< 		gtk_notebook_append_page_menu(GTK_NOTEBOOK(bfwin->notebook), scroll ,hbox, newdoc->tab_menu);
< 	}
< 	/* for some reason it only works after the document is appended to the notebook */
< 	doc_set_tabsize(newdoc, main_v->props.editor_tab_width);
< 	
< 	newdoc->highlightstate = main_v->props.defaulthighlight;
< 	DEBUG_MSG("doc_new, need_highlighting=%d, highlightstate=%d\n", newdoc->need_highlighting, newdoc->highlightstate);
< /*	
< 	these lines should not be here since notebook_changed() calls flush_queue()
< 	that means that this document can be closed during notebook_changed(), and functions like open_file 
< 	rely on the fact that this function returns an existing document (and not a closed one!!)
< if (!delay_activate) {
< 		DEBUG_MSG("doc_new, notebook current page=%d, newdoc is on page %d\n",gtk_notebook_get_current_page(GTK_NOTEBOOK(main_v->notebook)),gtk_notebook_page_num(GTK_NOTEBOOK(main_v->notebook),scroll));
< 		DEBUG_MSG("doc_new, setting notebook page to %d\n", g_list_length(main_v->documentlist) - 1);
< 		gtk_notebook_set_current_page(GTK_NOTEBOOK(main_v->notebook),g_list_length(main_v->documentlist) - 1);
< 		if (bfwin->current_document != newdoc) {
< 			notebook_changed(-1);
< 		}*/
< /*		doc_activate() will be called by notebook_changed() and it will grab the focus
< 		gtk_widget_grab_focus(newdoc->view);	*/
< /*	}*/
< 	return newdoc;
< }
< 
< /**
<  * doc_new_with_new_file:
<  * @bfwin: #Tbfwin*
<  * @new_filename: #gchar* filename to give document.
<  *
<  * Create a new document, name it by new_filename, and create the file.
<  *
<  * Return value: void
<  **/
< void doc_new_with_new_file(Tbfwin *bfwin, gchar * new_filename) {
< 	Tdocument *doc;
< 	Tfiletype *ft;
< 	if (new_filename == NULL) {
< 		statusbar_message(bfwin,_("No filename"), 2);
< 		return;
< 	}
< 	if (!main_v->props.allow_multi_instances) {
< 		gboolean res;
< 		res = switch_to_document_by_filename(bfwin,new_filename);
< 		if (res){
< 			return;
< 		}
< 	} 
< 	DEBUG_MSG("doc_new_with_new_file, new_filename=%s\n", new_filename);
< 	add_filename_to_history(bfwin,new_filename);
< 	doc = doc_new(bfwin, FALSE);
< 	doc->filename = g_strdup(new_filename);
< 	if (bfwin->project && bfwin->project->template && strlen(bfwin->project->template) > 2) {
< 		doc_file_to_textbox(doc, bfwin->project->template, FALSE, FALSE);
<  	}
< 	ft = get_filetype_by_filename_and_content(doc->filename, NULL);
< 	if (ft) doc->hl = ft;
< /*	doc->modified = 1;*/
< 	doc_set_title(doc);
< 	doc_save(doc, FALSE, FALSE, FALSE);
< 	doc_set_stat_info(doc); /* also sets mtime field */
< 	switch_to_document_by_pointer(bfwin,doc);
< 	doc_activate(doc);
< }
< 
< /**
<  * doc_new_with_file:
<  * @bfwin: #Tbfwin* with the window to open the document in
<  * @filename: #gchar* with filename to load.
<  * @delay_activate: #gboolean if GUI calls are wanted.
<  * @move_to_this_win: #gboolean if the file should be moved to this window if already open
<  *
<  * Create a new document and read in a file.
<  * Errors are not propagated to user in any other way than returning a pointer or NULL
<  *
<  * Return value: #Tdocument*, or NULL on error
<  **/
< Tdocument * doc_new_with_file(Tbfwin *bfwin, gchar * filename, gboolean delay_activate, gboolean move_to_this_win) {
< 	Tdocument *doc;
< 	gboolean opening_in_existing_doc = FALSE;
< 	gchar *fullfilename;
< 	DEBUG_MSG("doc_new_with_file, called for %s\n",filename);
< 	if ((filename == NULL) || (!file_exists_and_readable(filename))) {
< 		DEBUG_MSG("doc_new_with_file, file %s !file_exists or readable\n", filename);
< 		return NULL;
< 	}
< 	fullfilename = create_full_path(filename, NULL);
< 	if (bfwin) {
< 		gchar *tmpstring = g_path_get_dirname(fullfilename);
< 		if (bfwin->session->opendir) g_free(bfwin->session->opendir);
< 		bfwin->session->opendir = tmpstring;
< 	}
< 	
< 	if (!main_v->props.allow_multi_instances) {
< 		GList *alldocs = return_allwindows_documentlist();
< 		Tdocument *tmpdoc = documentlist_return_document_from_filename(alldocs, fullfilename);
< 		DEBUG_MSG("doc_new_with_file, fullfilename=%s, tmpdoc=%p\n",fullfilename,tmpdoc);
< 		g_list_free(alldocs);
< 		if (tmpdoc) {
< 			DEBUG_MSG("doc_new_with_file, %s is already open %p\n",filename,tmpdoc);
< 			if (move_to_this_win && documentlist_return_document_from_filename(bfwin->documentlist, fullfilename) == NULL) {
< 				doc_move_to_window(tmpdoc, bfwin);
< 			} else {
< 				if (!delay_activate) {
< 					switch_to_document_by_pointer(BFWIN(tmpdoc->bfwin),tmpdoc);
< 					if (bfwin != tmpdoc->bfwin) {
< 						gtk_window_present(GTK_WINDOW(BFWIN(tmpdoc->bfwin)->main_window));
< 					}
< 				}
< 			}
< 			g_free(fullfilename);
< 			return tmpdoc;
< 		}
< 	}
< 	DEBUG_MSG("doc_new_with_file, fullfilename=%s, filename=%s\n", fullfilename, filename);
< 	add_filename_to_history(bfwin,fullfilename);
< 
< 	if (g_list_length(bfwin->documentlist)==1 && doc_is_empty_non_modified_and_nameless(bfwin->current_document)) {
< 		doc = bfwin->current_document;
< 		opening_in_existing_doc = TRUE;
< 		bfwin->last_activated_doc = NULL;
< 	} else {
< 		doc = doc_new(bfwin, delay_activate);
< 	}
< 	/* we do not need to free fullfilename anymore now */
< 	doc->filename = fullfilename;
< 	DEBUG_MSG("doc_new_with_file, hl is resetted to filename, about to load file\n");
< 	doc_file_to_textbox(doc, doc->filename, FALSE, delay_activate);
< 	/* after the textbuffer is filled the filetype can be found */
< 	doc_reset_filetype(doc, doc->filename, NULL);
< 
< 	/* hey, this should be done by doc_activate 
< 	menu_current_document_set_toggle_wo_activate(NULL, doc->encoding);*/
< 	doc_set_stat_info(doc); /* also sets mtime field */
< 	doc_set_title(doc); /* sets the tooltip as well, so it should be called *after* doc_set_stat_info() */
< 	if (!delay_activate) {
< 		if (opening_in_existing_doc) {
< 			doc_activate(doc);
< 		} 
< 		switch_to_document_by_pointer(bfwin,doc);
< 		doc_activate(doc);
< 		/*filebrowser_open_dir(BFWIN(doc->bfwin),fullfilename); is already called by doc_activate() */
< 	}
< 	bmark_set_for_doc(doc);
< 	bmark_check_length(bfwin,doc);
< /*	bmark_adjust_visible(bfwin);   */
< 	
< 	return doc;
< }
< 
< /**
<  * docs_new_from_files:
<  * @bfwin: #Tbfwin* with the window to open the document in
<  * @file_list: #GList with filenames to open.
<  * @move_to_this_win: #gboolean if the file needs to be moved to this window if it is open already
<  *
<  * Open a number of new documents from files in stringlist file_list.
<  * If a file is open already in another window, it might be moved to this window, else
<  * nothing is done for this file
<  * Report files with problems to user.
<  * If more than 8 files are opened at once, a modal progressbar is shown while loading.
<  *
<  * Return value: void
<  **/
< void docs_new_from_files(Tbfwin *bfwin, GList * file_list, gboolean move_to_this_win) {
< 	GList *tmplist, *errorlist=NULL;
< 	gboolean delay = (g_list_length(file_list) > 1);
< 	gpointer pbar = NULL;
< 	gint i = 0;
< 	DEBUG_MSG("docs_new_from_files, lenght=%d\n", g_list_length(file_list));
< 	
< 	/* Hide the notebook and show a progressbar while
< 	 * adding several files. */
< 	if(g_list_length(file_list) > 8) {
< 		notebook_hide(bfwin);
< 		pbar = progress_popup(bfwin->main_window,_("Loading files..."), g_list_length(file_list));
< 	}
< 	
< 	tmplist = g_list_first(file_list);
< 	while (tmplist) {
< 		DEBUG_MSG("docs_new_from_files, about to open %s, delay=%d\n", (gchar *) tmplist->data, delay);
< 		if (!doc_new_with_file(bfwin,(gchar *) tmplist->data, delay, move_to_this_win)) {
< 			errorlist = g_list_append(errorlist, g_strdup((gchar *) tmplist->data));
< 		}
< 		if(pbar) {
< 			progress_set(pbar, ++i);
< 			flush_queue();
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	if (errorlist){
< 		gchar *message, *tmp;
< 		tmp = stringlist_to_string(errorlist, "\n");
< 		message = g_strconcat(_("These files could not opened:\n\n"), tmp, NULL);
< 		g_free(tmp);
< 		warning_dialog(bfwin->main_window,_("Unable to open file(s)\n"), message);
< 		g_free(message);
< 	}
< 	free_stringlist(errorlist);
< 
< 	if (delay) {
< 		DEBUG_MSG("since we delayed the highlighting, we set the notebook and filebrowser page now\n");
< 
< 		/* Destroy the progressbar and show the notebook when finished. */
< 		progress_destroy(pbar);
< 		notebook_show(bfwin);
< 
< 		gtk_notebook_set_page(GTK_NOTEBOOK(bfwin->notebook),g_list_length(bfwin->documentlist) - 1);
< 		notebook_changed(bfwin,-1);
< 		if (bfwin->current_document && bfwin->current_document->filename) {
< 			/*filebrowser_open_dir(bfwin,bfwin->current_document->filename); is called by doc_activate() */
< 			doc_activate(bfwin->current_document);
< 		}
< 	}
< 	gui_set_title(bfwin, bfwin->current_document);
< }
< 
< /**
<  * doc_reload:
<  * @doc: a #Tdocument
<  *
<  * Revert to file on disk.
<  *
<  * Return value: void
<  **/
< void doc_reload(Tdocument *doc) {
< 	if ((doc->filename == NULL) || (!file_exists_and_readable(doc->filename))) {
< 		statusbar_message(BFWIN(doc->bfwin),_("Unable to open file"), 2000);
< 		return;
< 	}
< 	{
< 		GtkTextIter itstart, itend;
< 		gtk_text_buffer_get_bounds(doc->buffer,&itstart,&itend);
< 		gtk_text_buffer_delete(doc->buffer,&itstart,&itend);
< 	}
< 	
< 	doc_file_to_textbox(doc, doc->filename, FALSE, FALSE);
< 	doc_unre_clear_all(doc);
< 	doc_set_modified(doc, 0);
< 	doc_set_stat_info(doc); /* also sets mtime field */
< }
< 
< /**
<  * doc_activate:
<  * @doc: a #Tdocument
<  *
<  * Perform actions neccessary when a document is focused. I.e. called from the notebook.
<  *
<  * Show textview, warn if the file on disk has been changed,
<  * update line-numbers etc and highlighting.
<  *
<  * Return value: void
<  **/
< void doc_activate(Tdocument *doc) {
< 	gboolean modified;
< 	time_t oldmtime, newmtime;
< #ifdef DEBUG
< 	if (!doc) {
< 		DEBUG_MSG("doc_activate, doc=NULL!!! ABORTING!!\n");
< 		exit(44);
< 	}
< #endif
< 	if (doc == NULL || doc == BFWIN(doc->bfwin)->last_activated_doc) {
< 		return;
< 	}
< 	BFWIN(doc->bfwin)->last_activated_doc = doc;
< 	gtk_widget_show(doc->view); /* This might be the first time this document is activated. */
< #ifdef HAVE_GNOME_VFS
< 	{
< 		GnomeVFSFileInfo *fileinfo;
< 		fileinfo = gnome_vfs_file_info_new();
< 		modified = doc_check_modified_on_disk(doc,&fileinfo);
< 		newmtime = fileinfo->mtime;
< 		if (doc->fileinfo) {
< 			oldmtime = doc->fileinfo->mtime;
< 		}
< 		gnome_vfs_file_info_unref(fileinfo);
< 	}
< #else
< 	{
< 		struct stat statbuf;
< 		modified = doc_check_modified_on_disk(doc,&statbuf);
< 		newmtime = statbuf.st_mtime;
< 		oldmtime = doc->statbuf.st_mtime;
< 	}
< #endif
< 	if (modified) {
< 		gchar *tmpstr, oldtimestr[128], newtimestr[128];/* according to 'man ctime_r' this should be at least 26, so 128 should do ;-)*/
< 		gint retval;
< 		gchar *options[] = {_("_Reload"), _("_Ignore"), NULL};
< 
< 		ctime_r(&newmtime,newtimestr);
< 		ctime_r(&oldmtime,oldtimestr);
< 		tmpstr = g_strdup_printf(_("Filename: %s\n\nNew modification time is: %s\nOld modification time is: %s"), doc->filename, newtimestr, oldtimestr);
< 		retval = multi_warning_dialog(BFWIN(doc->bfwin)->main_window,_("File has been modified by another process\n"), tmpstr, 0, 1, options);
< 		g_free(tmpstr);
< 		if (retval == 1) {
< 			doc_set_stat_info(doc);
< 		} else {
< 			doc_reload(doc);
< 		}
< 	}
< 	DEBUG_MSG("doc_activate, calling gui_set_document_widgets()\n");
< 	gui_set_document_widgets(doc);
< 	gui_set_title(BFWIN(doc->bfwin), doc);
< 	doc_set_statusbar_lncol(doc);
< 	doc_set_statusbar_insovr(doc);
< 	doc_set_statusbar_editmode_encoding(doc);
< 
< 	/* if highlighting is needed for this document do this now !! */
< 	if (doc->need_highlighting && doc->highlightstate) {
< 		doc_highlight_full(doc);
< 		DEBUG_MSG("doc_activate, doc=%p, after doc_highlight_full, need_highlighting=%d\n",doc,doc->need_highlighting);
< 	}
< 
< /*	doc_scroll_to_cursor(doc);*/
< 	if (doc->filename) {
< 		gchar *dir1 = g_path_get_dirname(doc->filename);
< 		gchar *dir2 = ending_slash(dir1);
< 		if (dir2[0] == '/') {
< 			chdir(dir2);
< 		}
< 		if (main_v->props.filebrowser_focus_follow) {
< 			DEBUG_MSG("doc_activate, call filebrowser_open_dir() for %s\n",dir2);
< 			filebrowser_open_dir(BFWIN(doc->bfwin),dir2);
< 		}
< 		g_free(dir1);
< 		g_free(dir2);
< 	}
< 	DEBUG_MSG("doc_activate, doc=%p, about to grab focus\n",doc);
< 	gtk_widget_grab_focus(GTK_WIDGET(doc->view));
< 
< 	DEBUG_MSG("doc_activate, doc=%p, finished\n",doc);
< }
< 
< void doc_force_activate(Tdocument *doc) {
< 	BFWIN(doc->bfwin)->last_activated_doc = NULL;
< 	doc_activate(doc);
< }
< 
< /**************************************************************************/
< /* the start of the callback functions for the menu, acting on a document */
< /**************************************************************************/
< #ifdef EXTERNAL_GREP
< #ifdef EXTERNAL_FIND
< typedef struct {
< 	GList *filenames_to_return;
< 	GtkWidget *win;
< 	GtkWidget *basedir;
< 	GtkWidget *find_pattern;
< 	GtkWidget *recursive;
< 	GtkWidget *grep_pattern;
< 	GtkWidget *is_regex;
< 	Tbfwin *bfwin;
< } Tfiles_advanced;
< 
< static void files_advanced_win_destroy(GtkWidget * widget, Tfiles_advanced *tfs) {
< 	DEBUG_MSG("files_advanced_win_destroy, started\n");
< 	gtk_main_quit();
< 	DEBUG_MSG("files_advanced_win_destroy, gtk_main_quit called\n");
< 	window_destroy(tfs->win);
< }
< 
< static void files_advanced_win_ok_clicked(GtkWidget * widget, Tfiles_advanced *tfs) {
< 	/* create list here */
< 	gchar *command, *temp_file;
< 	gchar *c_basedir, *c_find_pattern, *c_recursive, *c_grep_pattern, *c_is_regex;
< 	temp_file = create_secure_dir_return_filename();
< 	if (!temp_file) {
< 		files_advanced_win_destroy(widget, tfs);
< 		DEBUG_MSG("files_advanced_win_ok_clicked, can't get a secure temp filename ?????\n");
< 		return;
< 	}
< 	DEBUG_MSG("files_advanced_win_ok_clicked, temp_file=%s\n", temp_file);
< 	c_basedir = gtk_editable_get_chars(GTK_EDITABLE(tfs->basedir), 0, -1);
< 	c_find_pattern = gtk_editable_get_chars(GTK_EDITABLE(GTK_COMBO(tfs->find_pattern)->entry), 0, -1);	
< 	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(tfs->recursive))) {
< 		c_recursive= " -maxdepth 100";
< 	} else {
< 		c_recursive = " -maxdepth 1";
< 	}
< 
< 	c_grep_pattern = gtk_editable_get_chars(GTK_EDITABLE(tfs->grep_pattern), 0, -1);
< 	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(tfs->is_regex))) {
< 		c_is_regex = "-E -l ";
< 	} else {
< 		c_is_regex = "-l ";
< 	}
< /*
< command = `find c_basedir c_recursive -name c_find_pattern`
< command = `grep -E 'c_grep_pattern' `find c_basedir c_recursive -name c_find_pattern``
< */
< 	if (strlen(c_grep_pattern) == 0) {
< 		command = g_strconcat (EXTERNAL_FIND, " ", c_basedir, c_recursive, " -name '", c_find_pattern, "' > ", temp_file, NULL);
< 	} else {
< 		command = g_strconcat (EXTERNAL_GREP, " ", c_is_regex, " '", c_grep_pattern, "' `", EXTERNAL_FIND, " ", c_basedir, c_recursive, " -name '", c_find_pattern, "' ` > ", temp_file, NULL);
< 	}
< 	g_free(c_basedir);
< 	g_free(c_find_pattern);
< 	g_free(c_grep_pattern);
< 	DEBUG_MSG("files_advanced_win_ok_clicked, command=%s\n", command);
< 	statusbar_message(tfs->bfwin,_("searching files..."), 1000);
< 	flush_queue();
< 	system(command);
< 	tfs->filenames_to_return = get_stringlist(temp_file, tfs->filenames_to_return);
< 	g_free(command);
< 	remove_secure_dir_and_filename(temp_file);
< 	g_free(temp_file);
< 	files_advanced_win_destroy(widget, tfs);
< }
< static void files_advanced_win_cancel_clicked(GtkWidget * widget, Tfiles_advanced *tfs) {
< 	files_advanced_win_destroy(widget, tfs);
< }
< 
< static void files_advanced_win_select_basedir_lcb(GtkWidget * widget, Tfiles_advanced *tfs) {
< 	gchar *olddir = gtk_editable_get_chars(GTK_EDITABLE(tfs->basedir),0,-1);
< 	/* concat a "/" to the end of the current directory. This fixes a bug where your 
< 	   current working directory was being parsed as /directory/file when you opened 
< 	   the dialog to browse for a directory
< 	*/
< 	gchar *tmpdir = g_strconcat(olddir, "/", NULL);
< 	gchar *newdir = NULL;
< #ifdef HAVE_ATLEAST_GTK_2_4
< 	{
< 		GtkWidget *dialog;
< 		dialog = file_chooser_dialog(tfs->bfwin, _("Select basedir"), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, NULL, TRUE, FALSE, NULL);
< 		if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
< 			newdir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
< 		}
< 		gtk_widget_destroy(dialog);
< 	}
< #else
< 	newdir = return_dir(tmpdir, _("Select basedir"));
< #endif
< 	g_free(tmpdir);
< 	if (newdir) {
< 		gtk_entry_set_text(GTK_ENTRY(tfs->basedir),newdir);
< 		g_free(newdir);
< 	}
< 	g_free(olddir);
< }
< 
< static void files_advanced_win(Tfiles_advanced *tfs) {
< 	GtkWidget *vbox, *hbox, *but, *table;
< 	GList *list;
< 	if (!tfs->basedir) {
< 		gchar *curdir = g_get_current_dir();
< 		tfs->basedir = entry_with_text(curdir, 255);
< 		g_free (curdir);
< 	}
< 	
< 	tfs->win = window_full2(_("Advanced open file selector"), GTK_WIN_POS_MOUSE, 12, G_CALLBACK(files_advanced_win_destroy),tfs, TRUE, tfs->bfwin->main_window);
< 	DEBUG_MSG("files_advanced_win, tfs->win=%p\n",tfs->win);
< 	tfs->filenames_to_return = NULL;
< 	vbox = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(tfs->win), vbox);
< 	
< 	table = gtk_table_new(9, 5, FALSE);
< 	gtk_table_set_row_spacings(GTK_TABLE(table), 12);
< 	gtk_table_set_col_spacings(GTK_TABLE(table), 12);
< 	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);
< 	
< 	gtk_table_attach_defaults(GTK_TABLE(table), gtk_label_new(_("grep {contains} `find {basedir} -name '{file type}'`")), 0, 5, 0, 1);
< 	gtk_table_attach_defaults(GTK_TABLE(table), gtk_hseparator_new(), 0, 5, 1, 2);
< 
< 	/* filename part */
< 	/* curdir should get a value */
< 	bf_label_tad_with_markup(_("<b>General</b>"), 0, 0.5, table, 0, 3, 2, 3);
< 
< 	bf_mnemonic_label_tad_with_alignment(_("Base_dir:"), tfs->basedir, 0, 0.5, table, 1, 2, 3, 4);
< 	gtk_table_attach_defaults(GTK_TABLE(table), tfs->basedir, 2, 4, 3, 4);
< 	gtk_table_attach(GTK_TABLE(table), bf_allbuttons_backend(_("_Browse..."), TRUE, 112, G_CALLBACK(files_advanced_win_select_basedir_lcb), tfs), 4, 5, 3, 4, GTK_SHRINK, GTK_SHRINK, 0, 0);
< 
< /*	g_free(curdir);*/
< 	
< 	list = g_list_append(NULL, "*");
< 	list = g_list_append(list, "*.php");
< 	list = g_list_append(list, "*.php3");
< 	list = g_list_append(list, "*.html");
< 	list = g_list_append(list, "*.htm");
< 	list = g_list_append(list, "*.shtml");
< 	list = g_list_append(list, "*.pl");
< 	list = g_list_append(list, "*.cgi");
< 	list = g_list_append(list, "*.xml");
< 	list = g_list_append(list, "*.c");
< 	list = g_list_append(list, "*.h");
< 	list = g_list_append(list, "*.py");
< 	list = g_list_append(list, "*.java");
< 	tfs->find_pattern = combo_with_popdown("*", list, 1);
< 	bf_mnemonic_label_tad_with_alignment(_("_File Type:"), tfs->find_pattern, 0, 0.5, table, 1, 2, 4, 5);
< 	gtk_table_attach_defaults(GTK_TABLE(table), tfs->find_pattern, 2, 4, 4, 5);
< 
< 	g_list_free(list);
< 
< 	tfs->recursive = checkbut_with_value(NULL, 1);
< 	bf_mnemonic_label_tad_with_alignment(_("_Recursive:"), tfs->recursive, 0, 0.5, table, 1, 2, 5, 6);
< 	gtk_table_attach_defaults(GTK_TABLE(table), tfs->recursive, 2, 3, 5, 6);	
< 	
< 	/* content */
< 	gtk_table_set_row_spacing(GTK_TABLE(table), 5, 18);
< 	bf_label_tad_with_markup(_("<b>Contains</b>"), 0, 0.5, table, 0, 3, 6, 7);
< 
< 	tfs->grep_pattern = entry_with_text(NULL, 255);
< 	bf_mnemonic_label_tad_with_alignment(_("Pa_ttern:"), tfs->grep_pattern, 0, 0.5, table, 1, 2, 7, 8);
< 	gtk_table_attach_defaults(GTK_TABLE(table), tfs->grep_pattern, 2, 4, 7, 8);
< 	
< 	tfs->is_regex = checkbut_with_value(NULL, 0);
< 	bf_mnemonic_label_tad_with_alignment(_("Is rege_x:"), tfs->is_regex, 0, 0.5, table, 1, 2, 8, 9);
< 	gtk_table_attach_defaults(GTK_TABLE(table), tfs->is_regex, 2, 3, 8, 9);
< 	
< 	/* buttons */
< 	hbox = gtk_hbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(hbox), gtk_hseparator_new(), TRUE, TRUE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 12);
< 	hbox = gtk_hbutton_box_new();
< 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
< 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 12);
< 	but = bf_stock_cancel_button(G_CALLBACK(files_advanced_win_cancel_clicked), tfs);
< 	gtk_box_pack_start(GTK_BOX(hbox),but , FALSE, FALSE, 0);
< 	but = bf_stock_ok_button(G_CALLBACK(files_advanced_win_ok_clicked), tfs);
< 	gtk_box_pack_start(GTK_BOX(hbox),but , FALSE, FALSE, 0);
< 	gtk_window_set_default(GTK_WINDOW(tfs->win), but);
< 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
< 	gtk_widget_show_all(GTK_WIDGET(tfs->win));
< /*	gtk_grab_add(GTK_WIDGET(tfs->win));
< 	gtk_widget_realize(GTK_WIDGET(tfs->win));*/
< 	gtk_window_set_transient_for(GTK_WINDOW(tfs->win), GTK_WINDOW(tfs->bfwin->main_window));
< }
< 
< GList *return_files_advanced(Tbfwin *bfwin, gchar *tmppath) {
<   Tfiles_advanced tfs = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, bfwin};
< 	if (tmppath) {
< 		GtkWidget *curdir = entry_with_text(tmppath, 255);
< 		tfs.basedir = curdir;
< 	}
< 		/* this is probably called different!! */
< 	files_advanced_win(&tfs);
< 	DEBUG_MSG("return_files_advanced, calling gtk_main()\n");
< 	gtk_main();
< 	return tfs.filenames_to_return;
< }	
< #endif /* EXTERNAL_FIND */
< #endif /* EXTERNAL_GREP */
< 
< void file_open_from_selection(Tbfwin *bfwin) {
< 	gchar *string;
< 	GtkClipboard* cb;
< 
< 	cb = gtk_clipboard_get(GDK_SELECTION_PRIMARY);
< 	string = gtk_clipboard_wait_for_text(cb);
< 	if (string) {
< 		DEBUG_MSG("file_open_from_selection, opening %s\n",string);
< 		if (NULL == strchr(string,'/') && bfwin->current_document->filename) {
< 			/* now we should look in the directory of the current file */
< 			gchar *dir, *tmp;
< 			dir = g_path_get_dirname(bfwin->current_document->filename);
< 			tmp = g_strconcat(dir, "/", string, NULL);
< 			DEBUG_MSG("file_open_from_selection, trying %s\n",tmp);
< 			doc_new_with_file(bfwin,tmp,FALSE,FALSE);
< 			g_free(dir);
< 			g_free(tmp);
< 		} else {
< 			doc_new_with_file(bfwin,string,FALSE,FALSE);
< 		}
< 		g_free(string);
< 	}
< }
< 
< /**
<  * file_save_cb:
<  * @widget: unused #GtkWidget
<  * @bfwin: #Tbfwin* with the current window
<  *
<  * Save the current document.
<  *
<  * Return value: void
<  **/
< void file_save_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 	doc_save(bfwin->current_document, FALSE, FALSE, FALSE);
< }
< 
< /**
<  * file_save_as_cb:
<  * @widget: unused #GtkWidget
<  * @bfwin: #Tbfwin* with the current window
<  *
<  * Save current document, let user choose filename.
<  *
<  * Return value: void
<  **/
< void file_save_as_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 	doc_save(bfwin->current_document, TRUE, FALSE, FALSE);
< }
< 
< /**
<  * file_move_to_cb:
<  * @widget: unused #GtkWidget
<  * @bfwin: #Tbfwin* with the current window
<  *
<  * Move current document, let user choose filename.
<  *
<  * Return value: void
<  **/
< void file_move_to_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 	doc_save(bfwin->current_document, TRUE, TRUE, FALSE);
< }
< 
< #ifdef HAVE_GNOME_VFS
< typedef struct {
< 	Tbfwin *bfwin;
< 	GtkWidget *win;
< 	GtkWidget *entry;
< } Tou;
< static void open_url_destroy_lcb(GtkWidget *widget, Tou *ou) {
< 	g_free(ou);
< }
< static void open_url_cancel_lcb(GtkWidget *widget, Tou *ou) {
< 	gtk_widget_destroy(ou->win);
< }
< static void open_url_ok_lcb(GtkWidget *widget, Tou *ou) {
< 	gchar *url = gtk_editable_get_chars(GTK_EDITABLE(GTK_COMBO(ou->entry)->entry),0,-1);
< 	doc_new_with_file(ou->bfwin,url,FALSE,FALSE);
< 	g_free(url);
< 	gtk_widget_destroy(ou->win);
< }
< 
< /**
<  * file_open_url_cb:
<  * @widget: #GtkWidget* ignored
<  * @bfwin: #Tbfwin* bfwin pointer
<  *
<  * opens a dialog where you can enter an URL to open of any kind
<  * supported by gnome-vfs
<  *
<  * Return value: void
<  **/
< void file_open_url_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 	GtkWidget *vbox, *hbox, *but;
< 	Tou *ou;
< 	GList *urlhistory = NULL, *tmplist = NULL;
< 	ou = g_new(Tou,1);
< 	ou->bfwin = bfwin;
< 	ou->win = window_full2(_("Open URL"), GTK_WIN_POS_CENTER_ON_PARENT, 12
< 			, G_CALLBACK(open_url_destroy_lcb), ou, TRUE, bfwin->main_window);
< 	gtk_widget_set_size_request(ou->win, 450, 140);
< 	vbox = gtk_vbox_new(FALSE,5);
< 	gtk_box_pack_start(GTK_BOX(vbox), bf_label_with_markup(_("<b>Open URL</b>")), FALSE, FALSE, 5);
< 	gtk_container_add(GTK_CONTAINER(ou->win),vbox);
< 	tmplist = g_list_first(bfwin->session->recent_files);
< 	while (tmplist) {
< 		if (NULL != strchr(tmplist->data, ':')) {
< 			urlhistory = g_list_append(urlhistory, g_strdup(tmplist->data));
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	ou->entry = boxed_combo_with_popdown("", urlhistory, TRUE, vbox);
< 	free_stringlist(urlhistory);
< /*	ou->entry = boxed_entry_with_text("", 255, vbox); */
< 	gtk_box_pack_start(GTK_BOX(vbox), gtk_hseparator_new(), FALSE, FALSE, 5);
< 	hbox = gtk_hbutton_box_new();
< 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
< 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 6);
< 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);
< 	but = bf_stock_cancel_button(G_CALLBACK(open_url_cancel_lcb), ou);
< 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, TRUE, 0);
< 	but = bf_stock_ok_button(G_CALLBACK(open_url_ok_lcb), ou);
< 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, TRUE, 0);
< 	gtk_window_set_default(GTK_WINDOW(ou->win), but);
< 	gtk_widget_show_all(ou->win);
< }
< #endif /* HAVE_GNOME_VFS */
< /**
<  * file_open_cb:
<  * @widget: unused #GtkWidget
<  * @bfwin: #Tbfwin* with the current window
<  *
<  * Prompt user for files to open.
<  *
<  * Return value: void
<  **/
< void file_open_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 	GList *tmplist = NULL;
< 	DEBUG_MSG("file_open_cb, started, calling return_files()\n");
< #ifdef HAVE_ATLEAST_GTK_2_4
< 	{
< 		GtkWidget *dialog;
< 		GSList *slist;
< #ifdef HAVE_GNOME_VFS
< 		gboolean localonly = FALSE;
< #else
< 	gboolean localonly = TRUE;
< #endif /* HAVE_GNOME_VFS */
< 		dialog = file_chooser_dialog(bfwin, _("Select files"), GTK_FILE_CHOOSER_ACTION_OPEN, NULL, localonly, TRUE, NULL);
< 		if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
< #ifdef HAVE_GNOME_VFS
< 			slist = gtk_file_chooser_get_uris(GTK_FILE_CHOOSER(dialog));
< #else
< 			slist = gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(dialog));
< #endif /* HAVE_GNOME_VFS */
< 			tmplist = glist_from_gslist(slist);
< 			g_slist_free(slist);
< 		}
< 		gtk_widget_destroy(dialog);
< 	}
< #else
< 	tmplist = return_files(NULL);
< #endif
< 	if (!tmplist) {
< 		return;
< 	}
< 	{
< 		gint len = g_list_length(tmplist);
< 		gchar *message = g_strdup_printf(_("Loading %d file(s)..."), len);
< 		statusbar_message(bfwin,message,2000+len*50);
< 		g_free(message);
< 		flush_queue();
< 	}
< 	DEBUG_MSG("file_open_cb, calling docs_new_from_files()\n");
< 	docs_new_from_files(bfwin,tmplist, FALSE);
< 	free_stringlist(tmplist);
< }
< #ifdef EXTERNAL_GREP
< #ifdef EXTERNAL_FIND
< void file_open_advanced_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 	GList *tmplist;
< 	tmplist = return_files_advanced(bfwin, NULL);
< 	if (!tmplist) {
< 		return;
< 	}
< 	{
< 		gint len = g_list_length(tmplist);
< 		gchar *message = g_strdup_printf(_("Loading %d file(s)..."), len);
< 		statusbar_message(bfwin,message,2000+len*50);
< 		g_free(message);
< 		flush_queue();
< 	}
< 	docs_new_from_files(bfwin,tmplist, FALSE);
< 	free_stringlist(tmplist);
< }
< 
< void open_advanced_from_filebrowser(Tbfwin *bfwin, gchar *path) {
< 	GList *tmplist;
< 	tmplist = return_files_advanced(bfwin, path);
< 	if (!tmplist) {
< 		return;
< 	}
< 	{
< 		gint len = g_list_length(tmplist);
< 		gchar *message = g_strdup_printf(_("Loading %d file(s)..."), len);
< 		statusbar_message(bfwin,message,2000+len*50);
< 		g_free(message);
< 		flush_queue();
< 	}
< 	docs_new_from_files(bfwin,tmplist,FALSE);
< 	free_stringlist(tmplist);
< }
< #endif
< #endif
< 
< /**
<  * file_insert_menucb:
<  * @bfwin: Tbfwin* which window
<  * @callback_action: unused #guint
<  * @widget: #GtkWidget* unused
<  *
<  * Prompt user for a file, and insert the contents into the current document.
<  *
<  * Return value: void
<  **/
< void file_insert_menucb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
< 	gchar *tmpfilename=NULL;
< #ifdef HAVE_ATLEAST_GTK_2_4
< 	{
< 		GtkWidget *dialog;
< 		dialog = file_chooser_dialog(bfwin, _("Select file to insert"), GTK_FILE_CHOOSER_ACTION_OPEN, NULL, FALSE, FALSE, NULL);
< 		if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT) {
< 			tmpfilename = gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(dialog));
< 		}
< 		gtk_widget_destroy(dialog);
< 	}
< #else 
< 	tmpfilename = return_file_w_title(NULL, _("Select file to insert"));
< #endif
< 	if (tmpfilename == NULL) {
< 		statusbar_message(bfwin,_("No file to insert"), 2000);
< 		return;
< 	} else {
< 		/* do we need to set the insert point in some way ?? */
<         doc_unre_new_group(bfwin->current_document);
< 		doc_file_to_textbox(bfwin->current_document, tmpfilename, TRUE, FALSE);
< 		g_free(tmpfilename);
< 		doc_set_modified(bfwin->current_document, 1);
< 	}
< }
< 
< /**
<  * file_new_cb:
<  * @windget: #GtkWidget* ignored
<  * @bfwin: Tbfwin* where to open the new document
<  *
<  * Create a new, empty file in window bfwin
<  *
<  * Return value: void
<  **/
< void file_new_cb(GtkWidget *widget, Tbfwin *bfwin) {
< 	Tdocument *doc;
< 	doc = doc_new(bfwin, FALSE);
< 	switch_to_document_by_pointer(bfwin,doc);
<  	if (bfwin->project && bfwin->project->template && strlen(bfwin->project->template) > 2) {
< 		doc_file_to_textbox(doc, bfwin->project->template, FALSE, FALSE);
< 		doc_activate(doc);
<  	}
< }
< 
< /**
<  * file_close_cb:
<  * @widget: unused #GtkWidget
<  * @data: unused #gpointer
<  *
<  * Close the current document.
<  *
<  * Return value: void
<  **/
< void file_close_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 	doc_close(bfwin->current_document, 0);
< }
< 
< void bfwin_close_all_documents(Tbfwin *bfwin, gboolean window_closing) {
< 	GList *tmplist;
< 	Tdocument *tmpdoc;
< 	gint retval = -1;
< 
< 	DEBUG_MSG("file_close_all_cb, started\n");
< 
< 	/* first a warning loop */
< 	if (test_docs_modified(bfwin->documentlist)) {
< 		if (g_list_length (bfwin->documentlist) > 1) {
< 			gchar *options[] = {_("_Save All"), _("Close _All"), _("Choose per _File"), _("_Cancel"), NULL};
< 			retval = multi_query_dialog(bfwin->main_window,_("Multiple open files have been changed."), 
< 										_("If you don't save your changes they will be lost."), 3, 3, options);
< 			if (retval == 3) {
< 			DEBUG_MSG("file_close_all_cb, cancel clicked, returning 0\n");
< 			return;
< 			}
< 		} else {
< 			retval = 2;
< 		}
< 	} else {
< 		retval = 1;
< 	}
< 	DEBUG_MSG("file_close_all_cb, after the warnings, retval=%d, now close all the windows\n", retval);
< 
< 	tmplist = g_list_first(bfwin->documentlist);
< 	while (tmplist) {
< 		tmpdoc = (Tdocument *) tmplist->data;
< 		if (test_only_empty_doc_left(bfwin->documentlist)) {
< 			return;
< 		}
< 		
< 		switch (retval) {
< 		case 0:
< 			doc_save(tmpdoc, FALSE, FALSE, window_closing);
< 			if (!tmpdoc->modified) {
< 				doc_destroy(tmpdoc, TRUE);
< 			} else {
< 				return;
< 			}
< 			tmplist = g_list_first(bfwin->documentlist);
< 		break;
< 		case 1:
< 			doc_destroy(tmpdoc, TRUE);
< 			tmplist = g_list_first(bfwin->documentlist);
< 		break;
< 		case 2:
< 			if (doc_close(tmpdoc, 0) != 2) {
< 				tmplist = g_list_first(bfwin->documentlist);
< 			} else {
< /*				notebook_changed();*/
< 				return;
< 			}
< 		break;
< 		default:
< /*			notebook_changed();*/
< 			return;
< 		break;
< 		}
< 	}
< 	notebook_changed(bfwin,-1);
< 	DEBUG_MSG("file_close_all_cb, finished\n");
< }
< 
< /**
<  * file_close_all_cb:
<  * @widget: unused #GtkWidget
<  * @bfwin: #Tbfwin* 
<  *
<  * Close all open files. Prompt user when neccessary.
<  *
<  * Return value: void
<  **/
< void file_close_all_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 	bfwin_close_all_documents(bfwin, FALSE);
< }
< 
< 
< /**
<  * file_save_all_cb:
<  * @widget: unused #GtkWidget
<  * @data: unused #gpointer
<  *
<  * 	Save all editor notebooks
<  *
<  * Return value: void
<  **/
< void file_save_all_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 
< 	GList *tmplist;
< 	Tdocument *tmpdoc;
< 
< 	tmplist = g_list_first(bfwin->documentlist);
< 	while (tmplist) {
< 		tmpdoc = (Tdocument *) tmplist->data;
< 		if (tmpdoc->modified) {
< 			doc_save(tmpdoc, FALSE, FALSE, FALSE);
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< /**
<  * edit_cut_cb:
<  * @widget: unused #GtkWidget
<  * @data: unused #gpointer
<  *
<  * 	Cut selection from current buffer, to clipboard.
<  *
<  * Return value: void
<  **/
< void edit_cut_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 	doc_unre_new_group(bfwin->current_document);
< 	gtk_text_buffer_cut_clipboard(bfwin->current_document->buffer,gtk_clipboard_get(GDK_SELECTION_CLIPBOARD),TRUE);
< 	doc_unre_new_group(bfwin->current_document);
< }
< 
< /**
<  * edit_copy_cb:
<  * @widget: unused #GtkWidget
<  * @data: unused #gpointer
<  *
<  * 	Copy selection from current buffer, to clipboard.
<  *
<  * Return value: void
<  **/
< void edit_copy_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 	gtk_text_buffer_copy_clipboard(bfwin->current_document->buffer,gtk_clipboard_get(GDK_SELECTION_CLIPBOARD));
< }
< 
< /**
<  * edit_paste_cb:
<  * @widget: unused #GtkWidget
<  * @data: unused #gpointer
<  *
<  * 	Paste contents of clipboard. Disable highlighting while pasting, for speed.
<  *
<  * Return value: void
<  **/
< void edit_paste_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 	GtkTextMark *mark;
< 	Tdocument *doc = bfwin->current_document;
< 	DEBUG_MSG("edit_paste_cb, started\n");
< 	if (!doc->paste_operation) {
< 		doc->paste_operation = g_new(Tpasteoperation,1);
< 		PASTEOPERATION(doc->paste_operation)->so = -1;
< 		PASTEOPERATION(doc->paste_operation)->eo = -1;
< 	}
< 	doc_unre_new_group(doc);
< 
< 	DEBUG_MSG("edit_paste_cb, pasting clipboard\n");
< 	gtk_text_buffer_paste_clipboard (doc->buffer,gtk_clipboard_get(GDK_SELECTION_CLIPBOARD),NULL,TRUE);
< 
< 	doc_unre_new_group(doc);
< 	if (PASTEOPERATION(doc->paste_operation)->eo > PASTEOPERATION(doc->paste_operation)->so) {
< 		DEBUG_MSG("edit_paste_cb, start doc_highlight_region for so=%d, eo=%d\n",PASTEOPERATION(doc->paste_operation)->so,PASTEOPERATION(doc->paste_operation)->eo);
< 		doc_highlight_region(doc, PASTEOPERATION(doc->paste_operation)->so, PASTEOPERATION(doc->paste_operation)->eo);
< 	}
< 	g_free(doc->paste_operation);
< 	doc->paste_operation = NULL;
< 	
< 	mark = gtk_text_buffer_get_insert(bfwin->current_document->buffer);
< 	gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(bfwin->current_document->view), mark); 
< 	DEBUG_MSG("edit_paste_cb, finished\n");
< }
< 
< /**
<  * edit_select_all_cb:
<  * @widget: unused #GtkWidget
<  * @data: unused #gpointer
<  *
<  * Mark entire current document as selected.
<  *
<  * Return value: void
<  **/
< void edit_select_all_cb(GtkWidget * widget, Tbfwin *bfwin) {
< 	GtkTextIter itstart, itend;
< 	gtk_text_buffer_get_bounds(bfwin->current_document->buffer,&itstart,&itend);
< 	gtk_text_buffer_move_mark_by_name(bfwin->current_document->buffer,"insert",&itstart);
< 	gtk_text_buffer_move_mark_by_name(bfwin->current_document->buffer,"selection_bound",&itend);
< }
< 
< /**
<  * doc_toggle_highlighting_cb:
<  * @callback_data: unused #gpointer
<  * @action: unused #guint
<  * @widget: unused #GtkWidget*
<  *
<  * Toggle highlighting on/off for current document.
<  *
<  * Return value: void
<  **/
< void doc_toggle_highlighting_cb(Tbfwin *bfwin,guint action,GtkWidget *widget) {
< 	bfwin->current_document->highlightstate = 1 - bfwin->current_document->highlightstate;
< 	DEBUG_MSG("doc_toggle_highlighting_cb, started, highlightstate now is %d\n", bfwin->current_document->highlightstate);
< 	if (bfwin->current_document->highlightstate == 0) {
< 		doc_remove_highlighting(bfwin->current_document);
< 	} else {
< 		doc_highlight_full(bfwin->current_document);
< 	}
< }
< 
< /**
<  * all_documents_apply_settings:
<  *
<  * applies changes from the preferences to all documents
<  *
<  * Return value: void
<  */
< void all_documents_apply_settings() {
< 	GList *tmplist = g_list_first(return_allwindows_documentlist());
< 	while (tmplist){
< 		Tdocument *doc = tmplist->data;
< 		doc_set_tabsize(doc, main_v->props.editor_tab_width);
< 		doc_set_font(doc, main_v->props.editor_font_string);
< 		tmplist = g_list_next(tmplist);
< 	}
< 
< }
< 
< /**
<  * doc_convert_asciichars_in_selection:
<  * @callback_data: unused #gpointer
<  * @callback_action: #guint type of chars to change
<  * @widget: unused #GtkWidget*
<  *
<  * Convert characters in current document to entities.
<  * callback_action set to 1 (only ascii), 2 (only iso) or 3 (both).
<  * or 4 (ToUppercase) or 5 (ToLowercase)
<  *
<  * Return value: void
<  **/
< void doc_convert_asciichars_in_selection(Tbfwin *bfwin,guint callback_action,GtkWidget *widget) {
< 	if (callback_action >= 4) {
< 		doc_convert_case_in_selection(bfwin->current_document, (callback_action == 4));
< 	} else {
< 		doc_convert_chars_to_entities_in_selection(bfwin->current_document, (callback_action != 2), (callback_action != 1));
< 	}
< }
< 
< /**
<  * doc_toggle_highlighting_cb:
<  * @callback_data: unused #gpointer
<  * @action: unused #guint
<  * @widget: unused #GtkWidget*
<  *
<  * Show word-, line- and charcount for current document in the statusbar.
<  * Note: The wordcount() call returns number of actual utf8-chars, not bytes.
<  *
<  * Return value: void
<  **/
< void word_count_cb (Tbfwin *bfwin,guint callback_action,GtkWidget *widget) {
< 	guint chars = 0, lines = 0, words = 0;
< 	gchar *allchars, *wc_message;
< 	
<    allchars = doc_get_chars(bfwin->current_document, 0, -1);
< 	wordcount(allchars, &chars, &lines, &words);
< 	g_free(allchars);
< 	
< 	wc_message = g_strdup_printf(_("Statistics: %d lines, %d words, %d characters"), lines, words, chars);
< 	statusbar_message (bfwin,wc_message, 5000);
< 	g_free (wc_message);
< }
< 
< /**
<  * doc_toggle_highlighting_cb:
<  * @doc: a #Tdocument*
<  * @unindent: #gboolean
<  *
<  * Indent the selected block in current document.
<  * Set unindent to TRUE to unindent.
<  *
<  * Return value: void
<  **/
< void doc_indent_selection(Tdocument *doc, gboolean unindent) {
< 	GtkTextIter itstart,itend;
< 	if (gtk_text_buffer_get_selection_bounds(doc->buffer,&itstart,&itend)) {
< 		GtkTextMark *end;
< /*		gboolean firstrun=TRUE;*/
< 
< 		doc_unbind_signals(doc);
< 		doc_unre_new_group(doc);
< 		/* we have a selection, now we loop trough the characters, and for every newline
< 		we add or remove a tab, we set the end with a mark */
< 		end = gtk_text_buffer_create_mark(doc->buffer,NULL,&itend,TRUE);
< 		if (gtk_text_iter_get_line_offset(&itstart)>0) {
< 			gtk_text_iter_set_line_index(&itstart,0);
< 		}	
< 		while(gtk_text_iter_compare(&itstart,&itend) < 0) {
< 			GtkTextMark *cur;
< /*			if (firstrun && !gtk_text_iter_starts_line(&itstart)) {
< 				gtk_text_iter_forward_line(&itstart);
< 			}
< 			firstrun = FALSE;*/
< 			cur = gtk_text_buffer_create_mark(doc->buffer,NULL,&itstart,TRUE);
< 			if (unindent) {
< 				/* when unindenting we try to set itend to the end of the indenting step
< 				which might be a tab or 'tabsize' spaces, then we delete that part */
< 				gboolean cont=TRUE;
< 				gchar *buf = NULL;
< 				gunichar cchar = gtk_text_iter_get_char(&itstart);
< 				if (cchar == 9) { /* 9 is ascii for tab */
< 					itend = itstart;
< 					cont = gtk_text_iter_forward_char(&itend);
< 					buf = g_strdup("\t");
< 				} else if (cchar == 32) { /* 32 is ascii for space */
< 					gint i=0;
< 					itend = itstart;
< 					gtk_text_iter_forward_chars(&itend,main_v->props.editor_tab_width);
< 					buf = gtk_text_buffer_get_text(doc->buffer,&itstart,&itend,FALSE);
< 					DEBUG_MSG("tab_width=%d, strlen(buf)=%d, buf='%s'\n",main_v->props.editor_tab_width,strlen(buf),buf);
< 					while (cont && buf[i] != '\0') {
< 						cont = (buf[i] == ' ');
< 						DEBUG_MSG("doc_indent_selection, buf[%d]='%c'\n",i,buf[i]);
< 						i++;
< 					}
< 					if (!cont) {
< 						g_free (buf);
< 					}
< 				} else {
< 					cont = FALSE;
< 				}
< 				if (cont) {
< 					gint offsetstart, offsetend;				
< 					offsetstart = gtk_text_iter_get_offset(&itstart);
< 					offsetend = gtk_text_iter_get_offset(&itend);
< 					gtk_text_buffer_delete(doc->buffer,&itstart,&itend);
< 					doc_unre_add(doc, buf, offsetstart, offsetend, UndoDelete);
< 					g_free (buf);
< 				}
< #ifdef DEBUG
< 				else {
< 					DEBUG_MSG("doc_indent_selection, NOT continue!!\n");
< 				}
< #endif
< 			} else { /* indent */
< 				gint offsetstart = gtk_text_iter_get_offset(&itstart);
< 				gchar *indentstring;
< 				gint indentlen;
< 				if (main_v->props.editor_indent_wspaces) {
< 					indentstring = bf_str_repeat(" ", main_v->props.editor_tab_width);
< 					indentlen = main_v->props.editor_tab_width;
< 				} else {
< 					indentstring = g_strdup("\t");
< 					indentlen=1;
< 				}
< 				gtk_text_buffer_insert(doc->buffer,&itstart,indentstring,indentlen);
< 				doc_unre_add(doc, indentstring, offsetstart, offsetstart+indentlen, UndoInsert);
< 				g_free(indentstring);
< 			}
< 			gtk_text_buffer_get_iter_at_mark(doc->buffer,&itstart,cur);
< 			gtk_text_buffer_get_iter_at_mark(doc->buffer,&itend,end);
< 			gtk_text_buffer_delete_mark(doc->buffer,cur);
< 			gtk_text_iter_forward_line(&itstart);
< 			DEBUG_MSG("doc_indent_selection, itstart at %d, itend at %d\n",gtk_text_iter_get_offset(&itstart),gtk_text_iter_get_offset(&itend));
< 		}
< 		gtk_text_buffer_delete_mark(doc->buffer,end);
< 		doc_bind_signals(doc);
< 		doc_set_modified(doc, 1);
< 	} else {
< 		/* there is no selection, work on the current line */
< 		GtkTextIter iter;
< 		gtk_text_buffer_get_iter_at_mark(doc->buffer,&iter,gtk_text_buffer_get_insert(doc->buffer));
< 		gtk_text_iter_set_line_offset(&iter,0);
< 		if (unindent) {
< 			gint deletelen = 0;
< 			gchar *tmpstr, *tmp2str;
< 			GtkTextIter itend = iter;
< 			gtk_text_iter_forward_chars(&itend,main_v->props.editor_tab_width);
< 			tmpstr = gtk_text_buffer_get_text(doc->buffer,&iter,&itend,FALSE);
< 			tmp2str = bf_str_repeat(" ", main_v->props.editor_tab_width);
< 			if (tmpstr[0] == '\t') {
< 				deletelen = 1;
< 			} else if (tmpstr && strncmp(tmpstr,tmp2str,main_v->props.editor_tab_width)==0) {
< 				deletelen = main_v->props.editor_tab_width;
< 			}
< 			g_free(tmpstr);
< 			g_free(tmp2str);
< 			if (deletelen) {
< 				itend = iter;
< 				gtk_text_iter_forward_chars(&itend,deletelen);
< 				gtk_text_buffer_delete(doc->buffer,&iter,&itend);
< 			}
< 		} else { /* indent */
< 			gchar *indentstring;
< 			gint indentlen;
< 			if (main_v->props.editor_indent_wspaces) {
< 				indentstring = bf_str_repeat(" ", main_v->props.editor_tab_width);
< 				indentlen = main_v->props.editor_tab_width;
< 			} else {
< 				indentstring = g_strdup("\t");
< 				indentlen=1;
< 			}
< 			gtk_text_buffer_insert(doc->buffer,&iter,indentstring,indentlen);
< 			g_free(indentstring);
< 		}
< 	}
< }
< 
< void menu_indent_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
< 	if (bfwin->current_document) {
< 		doc_indent_selection(bfwin->current_document, (callback_action == 1));
< 	}
< }
< 
< /**
<  * list_relative_document_filenames:
<  * @curdoc: #Tdocument: the current document
<  *
<  * this function will generate a stringlist with a relative links to 
<  * all other open documents. This list should be freed using free_stringlist()
<  *
<  * Return value: #GList with strings
<  */
< GList *list_relative_document_filenames(Tdocument *curdoc) {
< 	GList *tmplist, *retlist=NULL;
< 	if (curdoc->filename == NULL) {
< 		return NULL;
< 	} 
< 	tmplist = g_list_first(BFWIN(curdoc->bfwin)->documentlist);
< 	while (tmplist) {
< 		Tdocument *tmpdoc = tmplist->data;
< 		if (tmpdoc != curdoc && tmpdoc->filename != NULL) {
< 			retlist = g_list_append(retlist,create_relative_link_to(curdoc->filename, tmpdoc->filename));
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return retlist;
< }
< 
< static void floatingview_destroy_lcb(GtkWidget *widget, Tdocument *doc) {
< 	DEBUG_MSG("floatingview_destroy_lcb, called for doc=%p, doc->floatingview=%p\n",doc,doc->floatingview);
< 	if (doc->floatingview) {
< 		gtk_widget_destroy(FLOATINGVIEW(doc->floatingview)->window);
< 		g_free(doc->floatingview);
< 		doc->floatingview = NULL;
< 	}
< }
< 
< static void new_floatingview(Tdocument *doc) {
< 	Tfloatingview *fv;
< 	gchar *title;
< 	GtkWidget *scrolwin;
< 	if (doc->floatingview) {
< 		fv = FLOATINGVIEW(doc->floatingview);
< 		gtk_window_present(GTK_WINDOW(fv->window));
< 		return;
< 	} 
< 	fv = g_new(Tfloatingview,1);
< 	doc->floatingview = fv;
< 	DEBUG_MSG("new_floatingview for doc=%p is at %p\n",doc,doc->floatingview);
< 	title = (doc->filename) ? doc->filename : "Untitled";
< 	fv->window = window_full2(title, GTK_WIN_POS_NONE, 5, G_CALLBACK(floatingview_destroy_lcb), doc, TRUE, NULL);
< 	gtk_window_set_role(GTK_WINDOW(fv->window), "floatingview");
< 	fv->textview = gtk_text_view_new_with_buffer(doc->buffer);
< 	gtk_text_view_set_editable(GTK_TEXT_VIEW(fv->textview),FALSE);
< 	gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(fv->textview),FALSE);
< 	apply_font_style(fv->textview, main_v->props.editor_font_string);
< 	gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(fv->textview), GTK_WRAP_WORD);
< 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
< 	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolwin), fv->textview);
< 	gtk_container_add(GTK_CONTAINER(fv->window),scrolwin);
< 	gtk_window_set_default_size(GTK_WINDOW(fv->window),600,600);
< 	gtk_widget_show_all(fv->window);
< }
< 
< void file_floatingview_menu_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
< 	new_floatingview(bfwin->current_document);
< }
---
> /* Bluefish HTML Editor
>  * document.c - the document
>  *
>  * Copyright (C) 1998-2006 Olivier Sessink
>  * Copyright (C) 1998 Chris Mazuc
>  * some additions Copyright (C) 2004 Eugene Morenko(More)
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> #include "config.h"
> 
> /* this is needed for Solaris to comply with the latest POSIX standard 
>  * regarding the ctime_r() function
>  */
> #ifdef PLATFORM_SOLARIS
> #define _POSIX_C_SOURCE 200312L
> #endif
> 
> #include <gtk/gtk.h>
> #include <gdk/gdkkeysyms.h>    /* for the keyboard event codes */
> #include <sys/types.h>         /* stat() */
> #include <sys/stat.h>          /* stat() */
> #include <unistd.h>            /* stat() */
> #include <stdio.h>             /* fopen() */
> #include <string.h>            /* strchr() */
> #include <regex.h>             /* regcomp() */
> #include <stdlib.h>            /* system() */
> #include <time.h>              /* ctime_r() */
> #include <pcre.h>
> 
> /* #define DEBUG */
> 
> #ifdef DEBUGPROFILING
> #include <sys/times.h>
> #endif
> 
> #include "bluefish.h"
> #include "document.h"
> #include "bf_lib.h"
> #include "bookmark.h"
> #include "cap.h"
> #include "char_table.h"    /* convert_utf8...() */
> #include "filebrowser.h"
> #include "gtk_easy.h"      /* *_dialog() */
> #include "gui.h"           /* statusbar_message() */
> #include "highlight.h"     /* all highlight functions */
> #include "menu.h"          /* add_to_recent_list */
> #include "pixmap.h"
> #include "rpopup.h"        /* doc_bevent_in_html_tag(), rpopup_edit_tag_cb() */
> #include "snr2.h"          /* snr2_run_extern_replace */
> #include "stringlist.h"    /* free_stringlist() */
> #include "undo_redo.h"     /* doc_unre_init() */
> 
> typedef struct {
> 	GtkWidget *textview;
> 	GtkWidget *window;
> } Tfloatingview;
> #define FLOATINGVIEW(var) ((Tfloatingview *)(var))
> 
> typedef struct {
> 	gint so;
> 	gint eo;
> } Tpasteoperation;
> #define PASTEOPERATION(var) ((Tpasteoperation *)(var))
> 
> void autoclosing_init(void) {
> 	const char *error;
> 	int erroffset;
> 	main_v->autoclosingtag_regc = pcre_compile("^<([a-z][a-z0-9]*)([\n\t ][^<>]*)?>$", PCRE_CASELESS, &error,&erroffset,NULL);
> #ifdef DEBUG
> 	if (!main_v->autoclosingtag_regc) {
> 		DEBUG_MSG("autoclosing_init, ERROR, %s\n",error);
> 	}
> #endif
> }
> 
> /**
>  * return_allwindows_documentlist:
>  *
>  * returns a documentlist with all documents in all windows, the list should be freed, the Tdocuments obviously not
>  *
>  * Return value: #GList* with all documents
>  */
> GList *return_allwindows_documentlist() {
> 	GList *newdoclist=NULL, *bflist, *tmplist=NULL;
> 	bflist = g_list_first(main_v->bfwinlist);
> 	DEBUG_MSG("return_allwindows_documentlist, bfwinlist length=%d\n",g_list_length(main_v->bfwinlist));
> 	while (bflist) {
> 		DEBUG_MSG("return_allwindows_documentlist, current bfwin doclist length=%d\n",g_list_length(BFWIN(bflist->data)->documentlist));
> 		tmplist = g_list_first(BFWIN(bflist->data)->documentlist);
> 		while (tmplist) {
> 			newdoclist = g_list_append(newdoclist,tmplist->data);
> 			tmplist = g_list_next(tmplist);
> 		}
> 		bflist = g_list_next(bflist);
> 	}
> 	DEBUG_MSG("return_allwindows_documentlist, returning list length %d\n",g_list_length(newdoclist));
> 	return newdoclist;
> }
> 
> /**
>  * return_filenamestringlist_from_doclist:
>  * @doclist: #GList*
>  *
>  * Returns a stringlist with filenames given a 
>  * list with documents (#Tdocument*)
>  *
>  * Return value: #GList* stringlist with filenames
>  */
> GList *return_filenamestringlist_from_doclist(GList *doclist) {
> 	GList *newlist=NULL, *tmplist;
> 	DEBUG_MSG("return_filenamestringlist_from_doclist, started for doclist %p, len=%d\n",doclist,g_list_length(doclist));
> 	tmplist = g_list_first(doclist);
> 	while(tmplist){
> 		if (DOCUMENT(tmplist->data)->filename) {
> 			DEBUG_MSG("return_filenamestringlist_from_doclist, adding filename %s\n",DOCUMENT(tmplist->data)->filename);
> 			newlist = g_list_append(newlist, g_strdup(DOCUMENT(tmplist->data)->filename));
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return newlist;
> }
> 
> /*
>  * return_num_untitled_documents:
>  * @doclist: #GList* with documents
>  *
>  * returns the number of untitled documents 
>  * opened in Bluefish
>  *
>  * Return value: #gint with number
>  *
> gint return_num_untitled_documents(GList *doclist) {
> 	gint retval = 0;
> 	GList *tmplist = g_list_first(doclist);
> 	while (tmplist) {
> 		if (DOCUMENT(tmplist->data)->filename == NULL) retval++;
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return retval;
> }*/
> 
> /**
>  * add_filename_to_history:
>  * @bfwin: #Tbfwin* 
>  * @filename: a #gchar
>  * 
>  * adds a filename to the recently opened files list
>  * will not add it to the menu, only to the list and the file
>  **/
> void add_filename_to_history(Tbfwin *bfwin, gchar *filename) {
> 	gchar *dirname;
> 
> 	add_to_recent_list(bfwin, filename, 0, FALSE); /* the recent menu */
> 	dirname = g_path_get_dirname(filename);
> 	DEBUG_MSG("add_filename_to_history, adding %s\n",dirname);
> 	main_v->recent_directories = add_to_history_stringlist(main_v->recent_directories,dirname,FALSE,TRUE);
> 	g_free(dirname);
> }
> 
> /**
>  * documentlist_return_index_from_filename:
>  * @doclist: #GList* with the documents to search in
>  * @filename: a #gchar
>  * 
>  * if the file is open, it returns the index in the documentlist
>  * which is also the index in the notebook
>  * if the file is not open it returns -1
>  *
>  * Return value: the index number on success, -1 if the file is not open
>  **/
> gint documentlist_return_index_from_filename(GList *doclist, gchar *filename) {
> 	GList *tmplist;
> 	gint count=0;
> 
> 	if (!filename) {
> 		return -1;
> 	}
> 	
> 	tmplist = g_list_first(doclist);
> 	while (tmplist) {
> 		if (((Tdocument *)tmplist->data)->filename &&(strcmp(filename, ((Tdocument *)tmplist->data)->filename) ==0)) {
> 			return count;
> 		}
> 		count++;
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return -1;
> }
> /**
>  * documentlist_return_index_from_filename:
>  * @doclist: #GList* with the documents to search in
>  * @filename: a #gchar
>  * 
>  * if the file is open, it returns the Tdocument* in the documentlist
>  * if the file is not open it returns NULL
>  *
>  * Return value: #Tdocument* or NULL if not open
>  **/
> Tdocument *documentlist_return_document_from_filename(GList *doclist, gchar *filename) {
> 	GList *tmplist;
> 	if (!filename) {
> 		DEBUG_MSG("documentlist_return_document_from_filename, no filename! returning\n");
> 		return NULL;
> 	}
> 	DEBUG_MSG("documentlist_return_document_from_filename, filename=%s\n",filename);
> 	tmplist = g_list_first(doclist);
> 	while (tmplist) {
> 		DEBUG_MSG("documentlist_return_document_from_filename, comparing with %s\n",filename);
> 		if (DOCUMENT(tmplist->data)->filename &&(strcmp(filename, DOCUMENT(tmplist->data)->filename) ==0)) {
> 			DEBUG_MSG("documentlist_return_document_from_filename, found, returning %p\n", tmplist->data);
> 			return DOCUMENT(tmplist->data);
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	DEBUG_MSG("documentlist_return_document_from_filename, not found, returning NULL\n");
> 	return NULL;
> }
> 
> /**
>  * documentlist_return_document_from_index:
>  * @doclist: #GList* with the documents to search in
>  * @index: a #gint, index in the documentlist.
>  *
>  * If the index is valid, it returns the appropriate Tdocument.
>  *
>  * Return value: Pointer to Tdocument on success, NULL on invalid index.
>  **/
> Tdocument *documentlist_return_document_from_index(GList *doclist, gint index) {
> 	return (Tdocument *) g_list_nth_data(doclist, index);
> }
> 
> /**
>  * doc_update_highlighting:
>  * @bfwin: #Tbfwin* with the window
>  * @callback_action: #guint ignored
>  * @widget: a #GtkWidget* ignored
>  *
>  * this function works on the current document
>  * if highlighting is disabled, this enables the highlighting
>  * the highlighting is also refreshed for the full document
>  *
>  * Return value: void
>  **/
> void doc_update_highlighting(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
> 	if (!bfwin->current_document) return;
> 	DEBUG_MSG("doc_update_highlighting, curdoc=%p, highlightstate=%d\n", bfwin->current_document, bfwin->current_document->highlightstate);
> 	if (bfwin->current_document->highlightstate == 0) {
> 		setup_toggle_item(gtk_item_factory_from_widget(bfwin->menubar), "/Document/Highlight Syntax", TRUE);
> 		DEBUG_MSG("doc_update_highlighting, calling doc_toggle_highlighting_cb\n");
> 		doc_toggle_highlighting_cb(bfwin, 0, NULL);
> 	} else {
> 		doc_highlight_full(bfwin->current_document);
> 	}
> }
> 
> /**
>  * doc_set_wrap:
>  * @doc: a #Tdocument
>  *
>  * this function will synchronise doc->wrapstate with the textview widget
>  * if doc->wrapstate TRUE it will set the textview to GTK_WRAP_WORD
>  * else (FALSE) it will set the textview to GTK_WRAP_NONE
>  *
>  * Return value: void
>  **/
> void doc_set_wrap(Tdocument * doc) {
> 	if (doc->wrapstate) {
> 		gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(doc->view),GTK_WRAP_WORD);
> 	} else {
> 		gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(doc->view),GTK_WRAP_NONE);
> 	}
> }
> /**
>  * doc_set_filetype:
>  * @doc: a #Tdocument
>  * @ft: a #Tfiletype with the new filetype
>  *
>  * this function will compare the filetype from the document and the new filetype
>  * and if they are different it will remove the old highlighting, set the newfiletype
>  * and set the filetype widget, it will return TRUE if the type was changed
>  *
>  * Return value: #gboolean if the value was changed
>  **/
> gboolean doc_set_filetype(Tdocument *doc, Tfiletype *ft) {
> 	if (ft != doc->hl) {
> 		doc_remove_highlighting(doc);
> 		doc->hl = ft;
> 		doc->need_highlighting = TRUE;
> 		doc->autoclosingtag = (ft->autoclosingtag > 0);
> 		gui_set_document_widgets(doc);
> 		return TRUE;
> 	}
> 	return FALSE;
> }
> /**
>  * get_filetype_by_name:
>  * @name: a #gchar* with the filetype name
>  *
>  * returns the Tfiletype* for corresponding to name
>  *
>  * Return value: Tfiletype* 
>  **/
> Tfiletype *get_filetype_by_name(gchar * name) {
> 	GList *tmplist;
> 	tmplist = g_list_first(main_v->filetypelist);
> 	while (tmplist) {
> 		if (strcmp(((Tfiletype *) tmplist->data)->type, name) == 0) {
> 			return (Tfiletype *) tmplist->data;
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return NULL;
> }
> /**
>  * get_filetype_by_filename_and_content:
>  * @filename: a #gchar* with the filename or NULL
>  * @buf: a #gchar* with the contents to search for with the Tfiletype->content_regex or NULL
>  *
>  * returns the Tfiletype* for corresponding to filename, using the file extension. If
>  * nothing is found using the file extension or filename==NULL it will start matching 
>  * the contents in buf with Tfiletype->content_regex
>  *
>  * if no filetype is found it will return NULL
>  *
>  * Return value: #Tfiletype* or NULL
>  **/
> Tfiletype *get_filetype_by_filename_and_content(gchar *filename, gchar *buf) {
> 	GList *tmplist;
> 
> 	if (filename) {
> 		tmplist = g_list_first(main_v->filetypelist);
> 		while (tmplist) {
> 			if (filename_test_extensions(((Tfiletype *) tmplist->data)->extensions, filename)) {
> 				return (Tfiletype *) tmplist->data;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	if (buf) {
> 		tmplist = g_list_first(main_v->filetypelist);
> 		while (tmplist) {
> 			Tfiletype *ft = (Tfiletype *)tmplist->data;
> 			if (strlen(ft->content_regex)) {
> 				pcre *pcreg;
> 				const char *err=NULL;
> 				int erroffset=0;
> 				DEBUG_MSG("get_filetype_by_filename_and_content, compiling pattern %s\n",ft->content_regex);
> 				pcreg = pcre_compile(ft->content_regex, PCRE_DOTALL|PCRE_MULTILINE,&err, &erroffset,NULL);
> 				if (err) {
> 					g_print("while testing for filetype '%s', pattern '%s' resulted in error '%s' at position %d\n", ft->type, ft->content_regex, err, erroffset);
> 				}
> 				if (pcreg) {
> 					int ovector[30];
> 					int retval = pcre_exec(pcreg,NULL,buf,strlen(buf),0,0,ovector,30);
> 					DEBUG_MSG("get_filetype_by_filename_and_content, buf='%s'\n",buf);
> 					DEBUG_MSG("get_filetype_by_filename_and_content, pcre_exec retval=%d\n",retval);
> 					if (retval > 0) {
> 						/* we have a match!! */
> 						pcre_free(pcreg);
> 						return ft;
> 					}
> 					pcre_free(pcreg);
> 				}
> 			} else {
> 				DEBUG_MSG("get_filetype_by_filename_and_content, type %s does not have a pattern (%s)\n",ft->type,ft->content_regex);
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	return NULL;
> }
> /**
>  * doc_reset_filetype:
>  * @doc: #Tdocument to reset
>  * @newfilename: a #gchar* with the new filename
>  * @buf: a #gchar* with the contents of the file, or NULL if the function should get that from the TextBuffer
>  *
>  * sets the new filetype based on newfilename and content, updates the widgets and highlighting
>  * (using doc_set_filetype())
>  *
>  * Return value: void
>  **/
> void doc_reset_filetype(Tdocument * doc, gchar * newfilename, gchar *buf) {
> 	Tfiletype *ft;
> 	if (buf) {
> 		ft = get_filetype_by_filename_and_content(newfilename, buf);
> 	} else {
> 		gchar *tmp = doc_get_chars(doc, 0, main_v->props.numcharsforfiletype);
> 		ft = get_filetype_by_filename_and_content(newfilename, tmp);
> 		g_free(tmp);
> 	}
> 	if (!ft) {
> 		GList *tmplist;
> 		/* if none found return first set (is default set) */
> 		tmplist = g_list_first(main_v->filetypelist);
> 		if (!tmplist) {
> 			DEBUG_MSG("doc_reset_filetype, no default filetype? huh?\n");
> 			return;
> 		}
> 		ft = (Tfiletype *)tmplist->data;
> 	}
> 	doc_set_filetype(doc, ft);
> }	
> 
> /**
>  * doc_set_font:
>  * @doc: a #Tdocument
>  * @fontstring: a #gchar describing the font
>  *
>  * this function will set the textview from doc to use the font
>  * described by fontstring
>  *
>  * Return value: void
>  **/
> 
> #ifdef __GNUC__
> __inline__ 
> #endif
> void doc_set_font(Tdocument *doc, gchar *fontstring) {
> 	if (fontstring) {
> 		apply_font_style(doc->view, fontstring);
> 	} else {
> 		apply_font_style(doc->view, main_v->props.editor_font_string);
> 	}
> }
> 
> /**
>  * This function is taken from gtksourceview
>  * Copyright (C) 2001
>  * Mikael Hermansson <tyan@linux.se>
>  * Chris Phelps <chicane@reninet.com>
>  */
> static gint textview_calculate_real_tab_width(GtkWidget *textview, gint tab_size) {
> 	gchar *tab_string;
> 	gint counter = 0;
> 	gint tab_width = 0;
> 
> 	if (tab_size <= 0)
> 		return 0;
> 
> 	tab_string = g_malloc (tab_size + 1);
> 	while (counter < tab_size) {
> 		tab_string[counter] = ' ';
> 		counter++;
> 	}
> 	tab_string[tab_size] = '\0';
> 	tab_width =  widget_get_string_size(textview, tab_string);
> 	g_free(tab_string);
> /*	if (tab_width < 0) tab_width = 0;*/
> 	return tab_width;
> }
> 
> /**
>  * doc_set_tabsize:
>  * @doc: a #Tdocument
>  * @tabsize: a #gint with the tab size
>  *
>  * this function will set the textview from doc to use the tabsize
>  * described by tabsize
>  *
>  * Return value: void
>  **/
> void doc_set_tabsize(Tdocument *doc, gint tabsize) {
> 	PangoTabArray *tab_array;
> 	gint pixels = textview_calculate_real_tab_width(GTK_WIDGET(doc->view), tabsize);
> 	DEBUG_MSG("doc_set_tabsize, tabsize=%d, pixels=%d\n", tabsize, pixels);
> 	tab_array = pango_tab_array_new (1, TRUE);
> 	pango_tab_array_set_tab (tab_array, 0, PANGO_TAB_LEFT, pixels);
> 	gtk_text_view_set_tabs (GTK_TEXT_VIEW (doc->view), tab_array);
> 	pango_tab_array_free(tab_array);
> }
> 
> /**
>  * gui_change_tabsize:
>  * @bfwin: #Tbfwin* with the window
>  * @action: a #guint, if 1 increase the tabsize, if 0 decrease
>  * @widget: a #GtkWidget, ignored
>  *
>  * this function is the callback for the menu, based on action
>  * it will increase or decrease the tabsize by one 
>  * for ALL DOCUMENTS (BUG: currently only all documents in the same window)
>  *
>  * Return value: void
>  **/
> void gui_change_tabsize(Tbfwin *bfwin,guint action,GtkWidget *widget) {
> 	GList *tmplist;
> 	PangoTabArray *tab_array;
> 	gint pixels;
> 	if (action == 1) {
> 		main_v->props.editor_tab_width++;
> 	} else {
> 		main_v->props.editor_tab_width--;
> 	}
> 	{
> 		gchar *message = g_strdup_printf("Setting tabsize to %d", main_v->props.editor_tab_width);
> 		statusbar_message(bfwin,message, 2000);
> 		g_free(message);
> 	}
> 	/* this should eventually be the total documentlist, not only for this window */
> 	tmplist = g_list_first(bfwin->documentlist);
> 	pixels = textview_calculate_real_tab_width(GTK_WIDGET(((Tdocument *)tmplist->data)->view), main_v->props.editor_tab_width);
> 	tab_array = pango_tab_array_new (1, TRUE);
> 	pango_tab_array_set_tab (tab_array, 0, PANGO_TAB_LEFT, pixels);
> 	while (tmplist) {
> 		gtk_text_view_set_tabs (GTK_TEXT_VIEW(((Tdocument *)tmplist->data)->view), tab_array);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	pango_tab_array_free(tab_array);
> }
> /**
>  * doc_is_empty_non_modified_and_nameless:
>  * @doc: a #Tdocument
>  *
>  * this function returns TRUE if the document pointer to by doc
>  * is an empty, nameless and non-modified document
>  *
>  * Return value: gboolean, TRUE if doc is empty, non-modified and nameless
>  **/
> gboolean doc_is_empty_non_modified_and_nameless(Tdocument *doc) {
> 	if (!doc) {
> 		return FALSE;
> 	}
> 	if (doc->modified || doc->filename) {
> 		return FALSE;
> 	}
> 	if (gtk_text_buffer_get_char_count(doc->buffer) > 0) {
> 		return FALSE;
> 	}
> 	return TRUE;
> }
> 
> 
> /* gboolean test_docs_modified(GList *doclist)
>  * if doclist is NULL it will use main_v->documentlist as doclist
>  * returns TRUE if there are any modified documents in doclist
>  * returns FALSE if there are no modified documents in doclist
>  */
> 
> /**
>  * test_docs_modified:
>  * @doclist: a #GList with documents
>  *
>  * this function will test if any documents in doclist are modified
>  *
>  * Return value: gboolean
>  **/
>  
> gboolean test_docs_modified(GList *doclist) {
> 
> 	GList *tmplist;
> 	Tdocument *tmpdoc;
> 
> 	if (doclist) {
> 		tmplist = g_list_first(doclist);
> 	} else {
> 		g_print("test_docs_modified, calling without a doclist is deprecated, aborting\n");
> 		exit(144);
> 	}
> 	
> 	while (tmplist) {
> 		tmpdoc = (Tdocument *) tmplist->data;
> #ifdef DEBUG
> 		g_assert(tmpdoc);
> #endif
> 		if (tmpdoc->modified) {
> 			return TRUE;
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return FALSE;
> }
> /**
>  * test_only_empty_doc_left:
>  * @doclist: #GList* with all documents to test in
>  *
>  * returns TRUE if there is only 1 document open, and that document
>  * is not modified and 0 bytes long and without filename
>  * returns FALSE if there are multiple documents open, or 
>  * a modified document is open, or a > 0 bytes document is open
>  * or a document with filename is open
>  *
>  * Return value: void
>  **/
> gboolean test_only_empty_doc_left(GList *doclist) {
> 	if (g_list_length(doclist) > 1) {
> 		return FALSE;
> 	} else {
> 		Tdocument *tmpdoc;
> 		GList *tmplist = g_list_first(doclist);
> 		if (tmplist) {
> #ifdef DEBUG
> 			g_assert(tmplist->data);
> #endif
> 			tmpdoc = tmplist->data;
> 			if (!doc_is_empty_non_modified_and_nameless(tmpdoc)) {
> 				return FALSE;
> 			}
> 		}
> 	}
> 	return TRUE;
> }
> /**
>  * doc_move_to_window:
>  * @doc: #Tdocument*
>  * @newwin: #Tbfwin*
>  *
>  * detaches the document from it's old window (doc->bfwin) and attaches
>  * it to the window newwin
>  *
>  * Return value: void, ignored
>  */
> void doc_move_to_window(Tdocument *doc, Tbfwin *newwin) {
> 	Tbfwin *oldwin = BFWIN(doc->bfwin);
> 	GtkWidget *tab_widget, *scroll;
> 	DEBUG_MSG("doc_move_to_window, oldwin=%p, newwin=%p, doc=%p\n",oldwin,newwin,doc);
> 	tab_widget = doc->tab_eventbox->parent;
> 	scroll = doc->view->parent;
> 	gtk_widget_ref(scroll);
> 	gtk_widget_ref(tab_widget);
> 	gtk_widget_ref(doc->tab_menu);
> 	DEBUG_MSG("doc_move_to_window, tab_label=%p, tab_widget=%p\n",doc->tab_label, tab_widget);
> /*	gtk_container_remove(GTK_CONTAINER(oldwin->notebook), doc->view);*/
> 	gtk_notebook_remove_page(GTK_NOTEBOOK(oldwin->notebook), g_list_index(oldwin->documentlist, doc));
> 	oldwin->documentlist = g_list_remove(oldwin->documentlist, doc);
> 	DEBUG_MSG("doc_move_to_window, removed doc=%p from oldwin %p\n",doc,oldwin);
> 	doc->bfwin = newwin;
> 	newwin->documentlist = g_list_append(newwin->documentlist, doc);
> 	gtk_notebook_append_page_menu(GTK_NOTEBOOK(newwin->notebook), scroll, tab_widget, doc->tab_menu);
> 	DEBUG_MSG("doc_move_to_window, appended doc=%p to newwin %p\n",doc,newwin);
> 
> 	gtk_widget_unref(scroll);
> 	gtk_widget_unref(tab_widget);
> 	gtk_widget_unref(doc->tab_menu);
> 
> 	gtk_widget_show_all(scroll);
> 	gtk_widget_show_all(tab_widget);
> 	gtk_widget_show(doc->tab_menu);
> 	
> 	if (NULL == oldwin->documentlist) {
> 		file_new_cb(NULL, oldwin);
> 	}
> }
> /**
>  * doc_has_selection:
>  * @doc: a #Tdocument
>  *
>  * returns TRUE if the document has a selection
>  * returns FALSE if it does not
>  *
>  * Return value: gboolean
>  **/
> gboolean doc_has_selection(Tdocument *doc) {
> 	return gtk_text_buffer_get_selection_bounds(doc->buffer,NULL,NULL);
> }
> 
> /**
>  * doc_set_tooltip:
>  * @doc: #Tdocument*
>  *
>  * will set the tooltip on the notebook tab eventbox
>  *
>  * Return value: void
>  */
> static void doc_set_tooltip(Tdocument *doc) {
> 	gchar *text, *tmp;
> 	gchar mtimestr[128], *modestr=NULL, *sizestr=NULL;
> 	mtimestr[0] = '\0';
> #ifdef HAVE_GNOME_VFS
> 	DEBUG_MSG("doc_set_tooltip, fileinfo=%p\n", doc->fileinfo);
> 	if (doc->fileinfo) {
> 		if (doc->fileinfo->valid_fields & GNOME_VFS_FILE_INFO_FIELDS_PERMISSIONS) {
> 			modestr = filemode_to_string(doc->fileinfo->permissions);
> 		}
> 		if (doc->fileinfo->valid_fields & GNOME_VFS_FILE_INFO_FIELDS_MTIME) {
> 			ctime_r(&doc->fileinfo->mtime,mtimestr);
> 		}
> 		if (doc->fileinfo->valid_fields & GNOME_VFS_FILE_INFO_FIELDS_SIZE) {
> 			sizestr = gnome_vfs_format_file_size_for_display(doc->fileinfo->size);
> 		}
> 	}
> #else
> 	if (doc->statbuf.st_mode != 0 || doc->statbuf.st_size != 0) {
> 		modestr = filemode_to_string(doc->statbuf.st_mode);
> 		ctime_r(&doc->statbuf.st_mtime,mtimestr);
> 		/*sizestr = g_strdup_printf("%ld", doc->statbuf.st_size);*/
> 		if (sizeof(off_t) == sizeof(unsigned long long int)) {
> 			sizestr = g_strdup_printf("%llu", (unsigned long long int )doc->statbuf.st_size);
> 		} else {
> 			sizestr = g_strdup_printf("%lu", doc->statbuf.st_size);
>         }
> 	}
> #endif
> 	tmp = text = g_strconcat(_("Name: "),gtk_label_get_text(GTK_LABEL(doc->tab_menu))
> 							,_("\nType: "),doc->hl->type
> 							,_("\nEncoding: "), (doc->encoding != NULL) ? doc->encoding : main_v->props.newfile_default_encoding
> 							,NULL);
> 	if (sizestr) {
> 		text = g_strconcat(text, _("\nSize (on disk): "), sizestr, _(" bytes"), NULL);
> 		g_free(tmp);
> 		g_free(sizestr);
> 		tmp = text;
> 	}
> 	if (modestr) {
> 		text = g_strconcat(text, _("\nPermissions: "), modestr, NULL);
> 		g_free(tmp);
> 		g_free(modestr);
> 		tmp = text;
> 	}
> 	if (mtimestr[0] != '\0') {
> 		trunc_on_char(mtimestr, '\n');
> 		text = g_strconcat(text, _("\nLast modified: "), mtimestr, NULL);
> 		g_free(tmp);
> 		tmp = text;
> 	}
> 
> 	gtk_tooltips_set_tip(main_v->tooltips, doc->tab_eventbox, text, "");
> 	g_free(text);
> }
> /**
>  * doc_set_title:
>  * @doc: #Tdocument*
>  *
>  * will set the notebook tab label and the notebook tab menu label
>  * and if this document->bfwin == document->bfwin->current_document
>  * it will update the bfwin title
>  * it will also call doc_set_tooltip() to reflect the changes in the tooltip
>  *
>  * Return value: void
>  */
> static void doc_set_title(Tdocument *doc) {
> 	gchar *label_string, *tabmenu_string;
> 	if (doc->filename) {
> 		label_string = g_path_get_basename(doc->filename);
> 		tabmenu_string = g_strdup(doc->filename);
> 	} else {
> 		label_string = g_strdup_printf(_("Untitled %d"),main_v->num_untitled_documents);
> 		tabmenu_string =  g_strdup(label_string);
> 		main_v->num_untitled_documents++;
> 	}
> 	gtk_label_set(GTK_LABEL(doc->tab_menu),tabmenu_string);
> 	gtk_label_set(GTK_LABEL(doc->tab_label),label_string);
> 	doc_set_tooltip(doc);
> 	g_free(label_string);
> 	g_free(tabmenu_string);
> 	if (doc->bfwin == BFWIN(doc->bfwin)->current_document) {
> 		gui_set_title(doc->bfwin, doc);
> 	}
> }
> /**
>  * doc_set_modified:
>  * @doc: a #Tdocument
>  * @value: a gint TRUE or FALSE
>  *
>  * sets the doc->modified to value
>  * if it already has this value, do nothing
>  * if it does not have this value, it will do some action
>  *
>  * if the document pointed to by doc == the current document
>  * it will update the toolbar and menu undo/redo items
>  *
>  * if value is TRUE, it will make the notebook and notebook-menu
>  * label red, if value is FALSE it will set them to black
>  *
>  * Return value: void
>  **/
> void doc_set_modified(Tdocument *doc, gint value) {
> 	DEBUG_MSG("doc_set_modified, started, doc=%p, value=%d\n", doc, value);
> 	if (doc->modified != value) {
> 		GdkColor colorred = {0, 65535, 0, 0};
> 		GdkColor colorblack = {0, 0, 0, 0};
> 
> 		doc->modified = value;
> 		if (doc->modified) {
> 			gtk_widget_modify_fg(doc->tab_menu, GTK_STATE_NORMAL, &colorred);
> 			gtk_widget_modify_fg(doc->tab_menu, GTK_STATE_PRELIGHT, &colorred);
> 			gtk_widget_modify_fg(doc->tab_label, GTK_STATE_NORMAL, &colorred);
> 			gtk_widget_modify_fg(doc->tab_label, GTK_STATE_PRELIGHT, &colorred);
> 			gtk_widget_modify_fg(doc->tab_label, GTK_STATE_ACTIVE, &colorred);
> 		} else {
> 			gtk_widget_modify_fg(doc->tab_menu, GTK_STATE_NORMAL, &colorblack);
> 			gtk_widget_modify_fg(doc->tab_menu, GTK_STATE_PRELIGHT, &colorblack);
> 			gtk_widget_modify_fg(doc->tab_label, GTK_STATE_NORMAL, &colorblack);
> 			gtk_widget_modify_fg(doc->tab_label, GTK_STATE_PRELIGHT, &colorblack);
> 			gtk_widget_modify_fg(doc->tab_label, GTK_STATE_ACTIVE, &colorblack);
> 		}
> 	}
> #ifdef DEBUG
> 	else {
> 		DEBUG_MSG("doc_set_modified, doc %p did have value %d already\n", doc, value);
> 	}
> #endif
> 	/* only when this is the current document we have to change these */
> 	DEBUG_MSG("doc=%p, doc->bfwin=%p\n",doc,doc->bfwin);
> 	if (doc == BFWIN(doc->bfwin)->current_document) {
> 		gui_set_undo_redo_widgets(BFWIN(doc->bfwin),doc_has_undo_list(doc), doc_has_redo_list(doc));
> 	}
> #ifdef DEBUG
> 	else {
> 		DEBUG_MSG("doc_set_modified, doc != current_document, so we do not update the gui widgets\n");
> 	}
> #endif
> }
> 
> #ifdef HAVE_GNOME_VFS
> /* returns 1 if the file is modified on disk, returns 0 
> if the file is modified by another process, returns
> 0 if there was no previous mtime information available 
> if newstatbuf is not NULL, it will be filled with the new statbuf from the file IF IT WAS CHANGED!!!
> leave NULL if you do not need this information, if the file is not changed, this field will not be set!!
> */
> static gboolean doc_check_modified_on_disk(Tdocument *doc, GnomeVFSFileInfo **newfileinfo) {
> 	if (main_v->props.modified_check_type == 0 || !doc->filename || doc->fileinfo == NULL) {
> 		return FALSE;
> 	} else if (main_v->props.modified_check_type < 4) {
> 		GnomeVFSFileInfo *fileinfo;
> 		gboolean unref_fileinfo = FALSE;
> 		gchar *ondiskencoding = get_filename_on_disk_encoding(doc->filename);
> 		if (*newfileinfo == NULL) {
> 			fileinfo = gnome_vfs_file_info_new();
> 			unref_fileinfo = TRUE;
> 			DEBUG_MSG("doc_check_modified_on_disk, allocating new fileinfo at %p\n", fileinfo);
> 		} else {
> 			fileinfo = *newfileinfo;
> 			DEBUG_MSG("doc_check_modified_on_disk, using existing fileinfo at %p\n", fileinfo);
> 		}
> 		if (gnome_vfs_get_file_info(ondiskencoding, fileinfo
> 					, GNOME_VFS_FILE_INFO_DEFAULT|GNOME_VFS_FILE_INFO_FOLLOW_LINKS) == GNOME_VFS_OK) {
> 			g_free(ondiskencoding);
> 			if (main_v->props.modified_check_type == 1 || main_v->props.modified_check_type == 2) {
> 				if (doc->fileinfo->mtime < fileinfo->mtime) {
> 					if (unref_fileinfo) gnome_vfs_file_info_unref(fileinfo);
> 					return TRUE;
> 				}
> 			}
> 			if (main_v->props.modified_check_type == 1 || main_v->props.modified_check_type == 3) {
> 				if (doc->fileinfo->size != fileinfo->size) {
> 					if (unref_fileinfo) gnome_vfs_file_info_unref(fileinfo);
> 					return TRUE;
> 				}
> 			}
> 		} else g_free(ondiskencoding);
> 		if (unref_fileinfo) gnome_vfs_file_info_unref(fileinfo);
> 	} else {
> 		DEBUG_MSG("doc_check_mtime, type %d checking not yet implemented\n", main_v->props.modified_check_type);
> 	}
> 	return FALSE;
> }
> #else /* HAVE_GNOME_VFS */
> /* returns 1 if the file is modified on disk, returns 0 
> if the file is modified by another process, returns
> 0 if there was no previous mtime information available 
> if newstatbuf is not NULL, it will be filled with the new statbuf from the file IF IT WAS CHANGED!!!
> leave NULL if you do not need this information, if the file is not changed, this field will not be set!!
> */
> static gboolean doc_check_modified_on_disk(Tdocument *doc, struct stat *newstatbuf) {
> 	if (main_v->props.modified_check_type == 0 || !doc->filename || doc->statbuf.st_mtime == 0 || doc->statbuf.st_size == 0) {
> 		return FALSE;
> 	} else if (main_v->props.modified_check_type < 4) {
> 		struct stat statbuf;
> 		gchar *ondiskencoding = get_filename_on_disk_encoding(doc->filename);
> 		if (stat(ondiskencoding, &statbuf) == 0) {
> 			g_free(ondiskencoding);
> 			*newstatbuf = statbuf;
> 			if (main_v->props.modified_check_type == 1 || main_v->props.modified_check_type == 2) {
> 				if (doc->statbuf.st_mtime < statbuf.st_mtime) {
> 					return TRUE;
> 				}
> 			}
> 			if (main_v->props.modified_check_type == 1 || main_v->props.modified_check_type == 3) {
> 				if (doc->statbuf.st_size != statbuf.st_size) {
> 					return TRUE;
> 				}
> 			}
> 		} else g_free(ondiskencoding);
> 	} else {
> 		DEBUG_MSG("doc_check_mtime, type %d checking not yet implemented\n", main_v->props.modified_check_type);
> 	}
> 	return FALSE;
> }
> #endif /* HAVE_GNOME_VFS */
> 
> /* doc_set_stat_info() includes setting the mtime field, so there is no need
> to call doc_update_mtime() as well */
> static void doc_set_stat_info(Tdocument *doc) {
> 	if (doc->filename) {
> 		gchar *ondiskencoding = get_filename_on_disk_encoding(doc->filename);
> #ifdef HAVE_GNOME_VFS
> 		if (doc->fileinfo == NULL) {
> 			doc->fileinfo = gnome_vfs_file_info_new();
> 		}
> 		gnome_vfs_get_file_info(ondiskencoding, doc->fileinfo
> 				,GNOME_VFS_FILE_INFO_DEFAULT|GNOME_VFS_FILE_INFO_FOLLOW_LINKS);
> 		doc->is_symlink = GNOME_VFS_FILE_INFO_SYMLINK(doc->fileinfo);
> #else
> 		struct stat statbuf;
> 		if (lstat(ondiskencoding, &statbuf) == 0) {
> 			if (S_ISLNK(statbuf.st_mode)) {
> 				doc->is_symlink = 1;
> 				stat(ondiskencoding, &statbuf);
> 			} else {
> 				doc->is_symlink = 0;
> 			}
> 			doc->statbuf = statbuf;
> 		}
> #endif
> 		g_free(ondiskencoding);
> 		doc_set_tooltip(doc);
> 	}
> }
> 
> /**
>  * doc_scroll_to_cursor:
>  * @doc: a #Tdocument
>  * 
>  * scolls the document pointer to by doc to its cursor position, 
>  * making the cursor visible
>  * 
>  * Return value: void
>  **/
> void doc_scroll_to_cursor(Tdocument *doc) {
> 	GtkTextMark *mark = gtk_text_buffer_get_insert(doc->buffer);
> 	gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(doc->view),mark,0.25,FALSE,0.5,0.5);
> }
> 
> /**
>  * doc_get_chars:
>  * @doc: a #Tdocument
>  * @start: a #gint, the start position
>  * @end: a #gint, the end position
>  * 
>  * returns all characters (NOT BYTES!!) from start to end from the document 
>  * pointer to by doc. end may be -1 to point to the end of the document
>  * 
>  * Return value: gchar * with the requested characters
>  **/
> gchar *doc_get_chars(Tdocument *doc, gint start, gint end) {
> 	GtkTextIter itstart, itend;
> 	gchar *string;
> 
> 	gtk_text_buffer_get_iter_at_offset(doc->buffer, &itstart,start);
> 	if (end >= 0) {
> 		gtk_text_buffer_get_iter_at_offset(doc->buffer, &itend, end);
> 	} else if (end == -1) {
> 		gtk_text_buffer_get_end_iter(doc->buffer, &itend);
> 	} else {
> 		DEBUG_MSG("doc_get_chars, end < -1, returning NULL\n");
> 		return NULL;
> 	}
> 	DEBUG_MSG("doc_get_chars, retrieving string, start=%d, end=%d\n", start, end);
> 	string = gtk_text_buffer_get_text(doc->buffer, &itstart, &itend,FALSE);
> 	DEBUG_MSG("doc_get_chars, retrieved string (%p)\n", string);
> 	return string;
> }
> /**
>  * doc_get_max_offset:
>  * @doc: a #Tdocument
>  * 
>  * returns the number of characters (NOT BYTES!!) in this document
>  * 
>  * Return value: gint with the number of characters
>  **/
> gint doc_get_max_offset(Tdocument *doc) {
> 	return gtk_text_buffer_get_char_count(doc->buffer);
> }
> 
> /**
>  * doc_select_region:
>  * @doc: a #Tdocument
>  * @start: a #gint with the start of selection
>  * @end: a #gint with the end of the selection
>  * @do_scroll: a #gboolean, if we should scroll to the selection
>  * 
>  * selects from start to end in the doc, and if do_scroll is set it will make
>  * sure the selection is visible to the user
>  *
>  * Return value: void
>  **/
> void doc_select_region(Tdocument *doc, gint start, gint end, gboolean do_scroll) {
> 	GtkTextIter itstart, itend;
> 	gtk_text_buffer_get_iter_at_offset(doc->buffer, &itstart,start);
> 	gtk_text_buffer_get_iter_at_offset(doc->buffer, &itend,end);
> 	gtk_text_buffer_move_mark_by_name(doc->buffer, "insert", &itstart);
> 	gtk_text_buffer_move_mark_by_name(doc->buffer, "selection_bound", &itend);
> 	if (do_scroll) {
> 		gtk_text_view_scroll_to_iter(GTK_TEXT_VIEW(doc->view),&itstart,0.25,FALSE,0.5,0.5);
> 	}
> }
> 
> /**
>  * doc_select_line:
>  * @doc: a #Tdocument
>  * @line: a #gint with the line number to select
>  * @do_scroll: a #gboolean, if we should scroll to the selection
>  * 
>  * selects the line in doc, and if do_scroll is set it will make
>  * sure the selection is visible to the user
>  * the line number starts at line 1, not at line 0!!
>  *
>  * Return value: void
>  **/
> void doc_select_line(Tdocument *doc, gint line, gboolean do_scroll) {
> 	GtkTextIter itstart, itend;
> 	gtk_text_buffer_get_iter_at_line(doc->buffer,&itstart,line-1);
> 	itend = itstart;
> 	gtk_text_iter_forward_to_line_end(&itend);
> 	gtk_text_buffer_move_mark_by_name(doc->buffer, "insert", &itstart);
> 	gtk_text_buffer_move_mark_by_name(doc->buffer, "selection_bound", &itend);
> 	if (do_scroll) {
> 		gtk_text_view_scroll_to_iter(GTK_TEXT_VIEW(doc->view),&itstart,0.25,FALSE,0.5,0.5);	
> 	}
> }
> 
> /**
>  * doc_get_selection:
>  * @doc: a #Tdocument
>  * @start: a #gint * to store the start
>  * @end: a #gint * to store the end
>  * 
>  *  returns FALSE if there is no selection
>  *  returns TRUE if there is a selection, and start and end will be set
>  *  to the current selection
>  *
>  * Return value: gboolean if there is a selection
>  **/
> gboolean doc_get_selection(Tdocument *doc, gint *start, gint *end) {
> 	GtkTextIter itstart, itend;
> 	GtkTextMark *mark = gtk_text_buffer_get_insert(doc->buffer);
> 	gtk_text_buffer_get_iter_at_mark(doc->buffer,&itstart,mark);
> 	mark = gtk_text_buffer_get_selection_bound(doc->buffer);
> 	gtk_text_buffer_get_iter_at_mark(doc->buffer,&itend,mark);
> 	*start = gtk_text_iter_get_offset(&itstart);
> 	*end = gtk_text_iter_get_offset(&itend);
> 	DEBUG_MSG("doc_get_selection, start=%d, end=%d\n", *start, *end);
> 	if (*start == *end) {
> 		return FALSE;
> 	}
> 	if (*start > *end) {
> 		gint tmp = *start;
> 		*start = *end;
> 		*end = tmp;
> 	}
> 	return TRUE;
> }
> /**
>  * doc_get_cursor_position:
>  * @doc: a #Tdocument
>  * 
>  * returns the cursor position in doc as character offset
>  *
>  * Return value: gint with the character offset of the cursor
>  **/
> gint doc_get_cursor_position(Tdocument *doc) {
> 	GtkTextIter iter;
> 	GtkTextMark *mark = gtk_text_buffer_get_insert(doc->buffer);
> 	gtk_text_buffer_get_iter_at_mark(doc->buffer, &iter, mark);
> 	return gtk_text_iter_get_offset(&iter);
> }
> 
> /**
>  * doc_set_statusbar_lncol:
>  * @doc: a #Tdocument
>  * 
>  * Return value: void
>  **/
> static void doc_set_statusbar_lncol(Tdocument *doc) {
> 	gchar *msg;
> 	gint line;
> 	gint col = 0;
> 	GtkTextIter iter, start;
> 
> 	gtk_text_buffer_get_iter_at_mark(doc->buffer, &iter, gtk_text_buffer_get_insert(doc->buffer));
> 
> 	line = gtk_text_iter_get_line(&iter);
> 	
> 	start = iter;
> 	gtk_text_iter_set_line_offset(&start, 0);
> 
> 	while (!gtk_text_iter_equal(&start, &iter)) {
> 		if (gtk_text_iter_get_char(&start) == '\t') {
> 			col += (main_v->props.editor_tab_width - (col  % main_v->props.editor_tab_width));
> 		} else ++col;
> 		gtk_text_iter_forward_char(&start);
> 	}
> 
> 	msg = g_strdup_printf(_(" Ln: %d, Col: %d"), line + 1, col + 1);
> 
> 	gtk_statusbar_pop(GTK_STATUSBAR(BFWIN(doc->bfwin)->statusbar_lncol), 0);
> 	gtk_statusbar_push(GTK_STATUSBAR(BFWIN(doc->bfwin)->statusbar_lncol), 0, msg);
> 
> 	g_free(msg);
> }
> 
> /**
>  * doc_set_statusbar_insovr:
>  * @doc: a #Tdocument
>  * 
>  * 
>  *
>  * Return value: void
>  **/
> void doc_set_statusbar_insovr(Tdocument *doc)
> {
> 	gtk_statusbar_pop(GTK_STATUSBAR(BFWIN(doc->bfwin)->statusbar_insovr), 0);
> 	gtk_statusbar_push(GTK_STATUSBAR(BFWIN(doc->bfwin)->statusbar_insovr), 0, (doc->overwrite_mode ? " OVR" : " INS"));
> }
> /**
>  * doc_set_statusbar_editmode_encoding:
>  * @doc: a #Tdocument
>  * 
>  * 
>  * 
>  *
>  * Return value: void
>  **/
> void doc_set_statusbar_editmode_encoding(Tdocument *doc)
> {
> 	gchar *msg;
> 	if (doc->hl == NULL) msg = g_strdup_printf(_("  %s, %s"), "unknown", doc->encoding);
> 	else msg = g_strdup_printf(_("  %s, %s"), doc->hl->type, doc->encoding);
> 	gtk_statusbar_pop(GTK_STATUSBAR(BFWIN(doc->bfwin)->statusbar_editmode), 0);
> 	gtk_statusbar_push(GTK_STATUSBAR(BFWIN(doc->bfwin)->statusbar_editmode), 0, msg);
> 	g_free(msg);		
> }
> 
> /**
>  * doc_replace_text_backend:
>  * @doc: a #Tdocument
>  * @newstring: a #const char * with the new string
>  * @start: a gint with the start character position
>  * @end: a gint with the end character position
>  * 
>  * unbinds all signals so there will be no call to a highlighting 
>  * update or anything else
>  * deletes the text in the region between start and end
>  * registers that text to the undo/redo functionality
>  * inserts newstring at that same position
>  * registers this to the undo/redo functionality
>  * marks the document as modified and marks it as needing highlighting
>  * binds the signals again to their callbacks
>  *
>  * multiple calls to doc_replace_text_backend will all be in the same undo/redo group
>  *
>  * Return value: void
>  **/
> void doc_replace_text_backend(Tdocument *doc, const gchar * newstring, gint start, gint end) {
> 	doc_unbind_signals(doc);
> 	/* delete region, and add that to undo/redo list */
> 	{
> 		gchar *buf;
> 		GtkTextIter itstart, itend;
> 		DEBUG_MSG("doc_replace_text_backend, get iters at start %d and end %d\n", start, end);
> 		gtk_text_buffer_get_iter_at_offset(doc->buffer, &itstart,start);
> 		gtk_text_buffer_get_iter_at_offset(doc->buffer, &itend,end);
> 		buf = gtk_text_buffer_get_text(doc->buffer, &itstart, &itend,FALSE);
> 		gtk_text_buffer_delete(doc->buffer,&itstart,&itend);
> 		DEBUG_MSG("doc_replace_text_backend, calling doc_unre_add for buf=%s, start=%d and end=%d\n", buf, start, end);
> 		doc_unre_add(doc, buf, start, end, UndoDelete);
> 		g_free(buf);
> 		DEBUG_MSG("doc_replace_text_backend, text deleted from %d to %d\n", start, end);
> 	}
> 
> 	/* add new text to this region, the buffer is changed so re-calculate itstart */
> 	{
> 		GtkTextIter itstart;
> 		gint insert = (end > start) ? start : end;
> 		DEBUG_MSG("doc_replace_text_backend, set insert pos to %d\n", insert);
> 		gtk_text_buffer_get_iter_at_offset(doc->buffer, &itstart,insert);
> 		gtk_text_buffer_insert(doc->buffer,&itstart,newstring,-1);
> 		doc_unre_add(doc, newstring, insert, insert + g_utf8_strlen(newstring,-1), UndoInsert);
> 	}
> 	doc_bind_signals(doc);
> 	doc_set_modified(doc, 1);
> 	doc->need_highlighting=TRUE;
> }					  
> /**
>  * doc_replace_text:
>  * @doc: a #Tdocument
>  * @newstring: a #const char * with the new string
>  * @start: a gint with the start character position
>  * @end: a gint with the end character position
>  * 
>  * identical to doc_replace_text_backend, with one difference, multiple calls to
>  * doc_replace_text will be all be in a different undo/redo group
>  *
>  * Return value: void
>  **/
> void doc_replace_text(Tdocument * doc, const gchar * newstring, gint start, gint end) {
> 	doc_unre_new_group(doc);
> 	doc_replace_text_backend(doc, newstring, start, end);
> 	doc_unre_new_group(doc);
> }
> 
> static void doc_convert_chars_to_entities(Tdocument *doc, gint start, gint end, gboolean ascii, gboolean iso) {
> 	gchar *string;
> 	DEBUG_MSG("doc_convert_chars_to_entities, start=%d, end=%d\n", start,end);
> 	string = doc_get_chars(doc, start, end);
> 	if (string) {
> 		gchar *newstring = convert_string_utf8_to_html(string, ascii, iso);
> 		g_free(string);
> 		if (newstring) {
> 			doc_replace_text(doc, newstring, start, end);
> 			g_free(newstring);
> 		}
> #ifdef DEBUG
> 		 else {
> 		 	DEBUG_MSG("doc_convert_chars_to_entities, newstring=NULL\n");
> 		 }
> #endif
> 	}
> #ifdef DEBUG
> 		 else {
> 		 	DEBUG_MSG("doc_convert_chars_to_entities, string=NULL\n");
> 		 }
> #endif		 
> }
> 
> static void doc_convert_chars_to_entities_in_selection(Tdocument *doc, gboolean ascii, gboolean iso) {
> 	gint start, end;
> 	if (doc_get_selection(doc, &start, &end)) {
> 		DEBUG_MSG("doc_convert_chars_to_entities_in_selection, start=%d, end=%d\n", start, end);
> 		doc_convert_chars_to_entities(doc, start, end, ascii, iso);
> 	}
> }
> 
> static void doc_convert_case_in_selection(Tdocument *doc, gboolean toUpper) {
> 	gint start, end;
> 	if (doc_get_selection(doc, &start, &end)) {
> 		gchar *string = doc_get_chars(doc, start, end);
> 		if (string) {
> 			gchar *newstring = (toUpper) ? g_utf8_strup(string,-1) : g_utf8_strdown(string,-1);
> 			g_free(string);
> 			if (newstring) {
> 				doc_replace_text(doc, newstring, start, end);
> 				g_free(newstring);
> 			}
> 		}
> 	}
> }
> 
> 
> /**
>  * doc_insert_two_strings:
>  * @doc: a #Tdocument
>  * @before_str: a #const char * with the first string
>  * @after_str: a #const char * with the second string
>  * 
>  * if the marks 'diag_ins' and 'diag_sel' exist, they will be used
>  * as pos1 and pos2
>  * if a selection exists, the selection start and end will be pos1 and pos2
>  * if both not exist the cursor position will be both pos1 and pos2
>  *
>  * inserts the first string at pos1 and the second at pos2 in doc
>  * it does not unbind any signal, so the insert callback will have to do 
>  * do the undo/redo, modified and highlighting stuff
>  *
>  * multiple calls to this function will be in separate undo/redo groups
>  *
>  * Return value: void
>  **/
> void doc_insert_two_strings(Tdocument *doc, const gchar *before_str, const gchar *after_str) {
> 	GtkTextIter itinsert, itselect;
> 	GtkTextMark *insert, *select;
> 	gboolean have_diag_marks = FALSE;
> 	insert = gtk_text_buffer_get_mark(doc->buffer,"diag_ins");
> 	if (insert) {
> 		select = gtk_text_buffer_get_mark(doc->buffer,"diag_sel");
> 		have_diag_marks = TRUE;
> 	} else {
> 		insert = gtk_text_buffer_get_insert(doc->buffer);
> 		select = gtk_text_buffer_get_selection_bound(doc->buffer);
> 	}
> 	gtk_text_buffer_get_iter_at_mark(doc->buffer,&itinsert,insert);
> 	gtk_text_buffer_get_iter_at_mark(doc->buffer,&itselect,select);
> #ifdef DEBUG
> 	g_print("doc_insert_two_strings, current marks: itinsert=%d, itselect=%d\n",gtk_text_iter_get_offset(&itinsert),gtk_text_iter_get_offset(&itselect));
> #endif	
> 
> 	if (gtk_text_iter_equal(&itinsert, &itselect)) {
> 		/* no selection */
> 		gchar *double_str = g_strconcat(before_str, after_str, NULL);
> 		gtk_text_buffer_insert(doc->buffer,&itinsert,double_str,-1);
> 		g_free(double_str);
> 		if (after_str && strlen(after_str)) {
> 			/* the buffer has changed, but gtk_text_buffer_insert makes sure */
> 			/* that itinsert points to the end of the inserted text. */
> 			/* thus, no need to get a new one. */
> 			gtk_text_iter_backward_chars(&itinsert, g_utf8_strlen(after_str, -1));
> 			gtk_text_buffer_place_cursor(doc->buffer, &itinsert);
> 			gtk_widget_grab_focus(doc->view);
> 		}
> 	} else { /* there is a selection */
> 		GtkTextMark *marktoresetto;
> 		GtkTextIter firstiter;
> 		if (gtk_text_iter_compare(&itinsert,&itselect) < 0) {
> 			firstiter = itinsert;
> 			marktoresetto = (have_diag_marks) ? gtk_text_buffer_get_selection_bound(doc->buffer) : select;
> 		} else {
> 			firstiter = itselect;
> 			marktoresetto = (have_diag_marks) ? gtk_text_buffer_get_insert(doc->buffer) : insert;
> 		}
> 		/* there is a selection */
> 		gtk_text_buffer_insert(doc->buffer,&firstiter,before_str,-1);
> 		if (after_str && strlen(after_str)) {
> 			/* the buffer is changed, reset the select iterator */
> 			gtk_text_buffer_get_iter_at_mark(doc->buffer,&itselect,marktoresetto);
> 			gtk_text_buffer_insert(doc->buffer,&itselect,after_str,-1);
> 			/* now the only thing left is to move the selection and insert mark back to their correct places
> 			to preserve the users selection */
> 			gtk_text_buffer_get_iter_at_mark(doc->buffer,&itselect,marktoresetto);
> 			gtk_text_iter_backward_chars(&itselect, g_utf8_strlen(after_str, -1));
> 			gtk_text_buffer_move_mark(doc->buffer,marktoresetto,&itselect);
> 		}
> 		
> 	}
> 	doc_unre_new_group(doc);
> 	DEBUG_MSG("doc_insert_two_strings, finished\n");
> }
> 
> static void add_encoding_to_list(gchar *encoding) {
> 	gchar **enc = g_new0(gchar *,3);
> 	enc[0] = g_strdup(encoding);
> 	if (!arraylist_value_exists(main_v->props.encodings, enc, 1, FALSE)) {
> 		GList *tmplist;
> 		enc[1] = g_strdup(encoding);
> 		main_v->props.encodings = g_list_insert(main_v->props.encodings, enc, 1);
> 		tmplist = g_list_first(main_v->bfwinlist);
> 		while (tmplist) {
> 			encoding_menu_rebuild(BFWIN(tmplist->data));
> 			tmplist = g_list_next(tmplist);
> 		}
> 	} else {
> 		g_free(enc[0]);
> 		g_free(enc);
> 	}
> }
> 
> #ifdef HAVE_GNOME_VFS
> #define STARTING_BUFFER_SIZE 8192
> static gchar *get_buffer_from_filename(Tbfwin *bfwin, gchar *filename, int *returnsize) {
> 	GnomeVFSResult result= GNOME_VFS_NUM_ERRORS;
> /*	GnomeVFSHandle *handle;
> 	GnomeVFSFileSize bytes_read;
> 	gchar chunk[STARTING_BUFFER_SIZE];
> 	unsigned long long buffer_size = STARTING_BUFFER_SIZE;*/
> 	gchar *buffer=NULL;
> 
> 	DEBUG_MSG("get_buffer_from_filename, started for %s\n",filename);
> /*	result = gnome_vfs_open (&handle, filename, GNOME_VFS_OPEN_READ);
> 	if (result != GNOME_VFS_OK) {
> 		gchar *errmessage = g_strconcat(_("Could not read file:\n"), filename, NULL);
> 		warning_dialog(bfwin->main_window,errmessage, NULL);
> 		g_free(errmessage);
> 		DEBUG_MSG("get_buffer_from_filename, ERROR (result=%d), returning NULL\n",result);
> 		return NULL;
> 	}
> 	buffer = g_malloc(1+(buffer_size * sizeof(gchar)));
> 	while (result == GNOME_VFS_OK) {
> 		result = gnome_vfs_read(handle, chunk, STARTING_BUFFER_SIZE, &bytes_read);
> 		memcpy(&buffer[buffer_size-STARTING_BUFFER_SIZE], chunk, STARTING_BUFFER_SIZE);
> 		DEBUG_MSG("get_buffer_from_filename, copy %lld bytes to position %lld, size=%lld\n",(long long)STARTING_BUFFER_SIZE, (long long)buffer_size-STARTING_BUFFER_SIZE, (long long)bytes_read);
> 		if (bytes_read == STARTING_BUFFER_SIZE) {
> 			buffer_size += STARTING_BUFFER_SIZE;
> 			buffer = g_realloc(buffer, 1+(buffer_size * sizeof(gchar)));
> 		} else {
> 			DEBUG_MSG("get_buffer_from_filename, bytes_read was only %lld, result=%d\n",bytes_read,result);
> 			break;
> 		}
> 	}
> 	DEBUG_MSG("get_buffer_from_filename, size=%lld, terminating buffer at %lld\n",bytes_read,buffer_size-STARTING_BUFFER_SIZE+bytes_read);
> 	buffer[buffer_size-STARTING_BUFFER_SIZE+bytes_read] = '\0';
> 	*returnsize= buffer_size-STARTING_BUFFER_SIZE+bytes_read;
> 	gnome_vfs_close(handle);*/
> 	/* using gnome_vfs_read_entire_file results in a buffer without \0 at the end */
> 	
> 	/* a small hack to better support Zope. gnome-vfs metadata should be
> 	used to get the source-link for WebDAV request but unfortunatelly
> 	that functionality is yet not functional on gnome-vfs.*/
> 	if (main_v->props.server_zope_compat) {
> 		GnomeVFSURI* uri=gnome_vfs_uri_new(filename);
> 		if (uri) {
> 			gchar const *scheme=gnome_vfs_uri_get_scheme(uri);
> 			if (scheme && (strcmp(scheme, "http")==0 || strcmp(scheme, "https")==0)) {
> 				GnomeVFSURI* sourceuri;
> #ifdef HAVE_ATLEAST_GNOME_2_6
> 				/* TODO */
> 				/* use metadata to get source property */
> 				sourceuri=gnome_vfs_uri_append_file_name(uri, "document_src");
> #else
> 				sourceuri=gnome_vfs_uri_append_file_name(uri, "document_src");
> #endif
> 				if (sourceuri) {
> 					gchar *sourcefilename=gnome_vfs_uri_to_string(sourceuri, 0);
> 					if (sourcefilename) {
> 						result = gnome_vfs_read_entire_file(sourcefilename,returnsize,&buffer);
> 						DEBUG_MSG("get_buffer_from_filename, loading %s returns %d\n", sourcefilename, result);
> 						g_free(sourcefilename);
> 					}
> 					gnome_vfs_uri_unref(sourceuri);
> 				}
> 			}
> 			gnome_vfs_uri_unref(uri);
> 		}
> 	}
> 	if (GNOME_VFS_OK != result) {
> 		gchar *ondiskencoding = get_filename_on_disk_encoding(filename);
> 		DEBUG_MSG("get_buffer_from_filename, about to read entire file\n");
> 		result = gnome_vfs_read_entire_file(ondiskencoding,returnsize,&buffer);
> 		DEBUG_MSG("get_buffer_from_filename, read file, buffer len=%d!\n",strlen(buffer));
> 		g_free(ondiskencoding);
> 	}
> 	if (GNOME_VFS_OK != result) {
> 		gchar *errmessage = g_strconcat(_("Could not read file:\n"), filename, NULL);
> 		warning_dialog(bfwin->main_window,errmessage, NULL);
> 		g_free(errmessage);
> 		DEBUG_MSG("get_buffer_from_filename, GNOME_VFS ERROR (result=%d), returning NULL\n",result);
> 		DEBUG_MSG("get_buffer_from_filename, gnome_vfs error was: %s\n", gnome_vfs_result_to_string(result));
> 		return NULL;
> 	}
> 	buffer  = g_realloc(buffer, *returnsize+1);
> 	buffer[*returnsize] = '\0';
> 	return buffer;
> }
> #else /* no gnome-vfs */
> static gchar *get_buffer_from_filename(Tbfwin *bfwin, gchar *filename, int *returnsize) {
> 	gboolean result;
> 	gchar *buffer;
> 	GError *error=NULL;
> 	gsize length;
> 	gchar *ondiskencoding = get_filename_on_disk_encoding(filename);
> 	result = g_file_get_contents(ondiskencoding,&buffer,&length,&error);
> 	g_free(ondiskencoding);
> 	if (result == FALSE) {
> 		gchar *errmessage = g_strconcat(_("Could not read file:\n"), filename, NULL);
> 		warning_dialog(bfwin->main_window,errmessage, NULL);
> 		g_free(errmessage);
> 		return NULL;
> 	}
> 	*returnsize = length;
> 	return buffer;
> }
> #endif
> 
> /**
>  * doc_file_to_textbox:
>  * @doc: The #Tdocument target.
>  * @filename: Filename to read in.
>  * @enable_undo: #gboolean
>  * @delay: Whether to delay GUI-calls.
>  *
>  * Open and read in a file to the doc buffer.
>  * The data is inserted starting at the current cursor position.
>  * Charset is detected, and highlighting performed (if applicable).
>  *
>  * Return value: A #gboolean, TRUE if successful, FALSE on error.
>  **/ 
> gboolean doc_file_to_textbox(Tdocument * doc, gchar * filename, gboolean enable_undo, gboolean delay) {
> 	gchar *message;
> 	gint cursor_offset;
> 	int document_size=0;
> 
> 	if (!enable_undo) {
> 		doc_unbind_signals(doc);
> 	}
> 	message = g_strconcat(_("Opening file "), filename, NULL);
> 	statusbar_message(BFWIN(doc->bfwin),message, 1000);
> 	g_free(message);
> 
> 	/* now get the current cursor position */
> 	{
> 		GtkTextMark* insert;
> 		GtkTextIter iter;
> 		insert = gtk_text_buffer_get_insert(doc->buffer);
> 		gtk_text_buffer_get_iter_at_mark(doc->buffer, &iter, insert);
> 		cursor_offset = gtk_text_iter_get_offset(&iter);
> 	}
> 
> 	/* This opens the contents of a file to a textbox */
> 	{
> 		gchar *encoding=NULL;
> 		gchar *newbuf=NULL;
> 		gsize wsize;
> 		GError *error=NULL;
> 		gchar *buffer = get_buffer_from_filename(BFWIN(doc->bfwin), filename, &document_size);
> 		if (!buffer) {
> 			DEBUG_MSG("doc_file_to_textbox, buffer==NULL, returning\n");
> 			return FALSE;
> 		}
> 		/* the first try is if the encoding is set in the file */
> 		{
> 			regex_t preg;
> 			regmatch_t pmatch[10];
> 			gint retval;
> 			gchar *pattern = "<meta[ \t\n]http-equiv[ \t\n]*=[ \t\n]*\"content-type\"[ \t\n]+content[ \t\n]*=[ \t\n]*\"text/html;[ \t\n]*charset=([a-z0-9-]+)\"[ \t\n]*/?>";
> 			retval = regcomp(&preg,pattern,REG_EXTENDED|REG_ICASE);
> #ifdef DEBUG
> 			if (retval) {
> 				g_print("regcomp error!\n");
> 			}
> #endif
> 			/* we do a nasty trick to make regexec search only in the first N bytes */
> 			if (document_size > main_v->props.encoding_search_Nbytes) {
> 				gchar tmp = buffer[main_v->props.encoding_search_Nbytes];
> 				buffer[main_v->props.encoding_search_Nbytes] = '\0';
> 				retval = regexec(&preg,buffer,10,pmatch,0);
> 				buffer[main_v->props.encoding_search_Nbytes] = tmp;
> 			} else {
> 				retval = regexec(&preg,buffer,10,pmatch,0);
> 			}
> #ifdef DEBUG
> 			if (retval) {
> 				gchar errbuf[1024];
> 				regerror(retval, &preg, errbuf, 1024);
> 				g_print("regexec error! %s\n", errbuf);
> 			}
> #endif
> 			if (retval==0 && pmatch[0].rm_so != -1 && pmatch[1].rm_so != -1) {
> 				/* we have a match */
> 				DEBUG_MSG("doc_file_to_textbox, match so=%d,eo=%d\n", pmatch[1].rm_so,pmatch[1].rm_eo);
> 				encoding = g_strndup(&buffer[pmatch[1].rm_so], pmatch[1].rm_eo-pmatch[1].rm_so);
> 				DEBUG_MSG("doc_file_to_textbox, detected encoding %s\n", encoding);
> 			}
> 			regfree(&preg);
> #ifdef DEBUGPROFILING
> 			times(&locals.tms1);
> 			print_time_diff("encoding regex match", &locals.tms2, &locals.tms1);
> #endif		
> 		}
> 		if (encoding) {
> 			DEBUG_MSG("doc_file_to_textbox, try encoding %s from <meta>\n", encoding);
> 			newbuf = g_convert(buffer,-1,"UTF-8",encoding,NULL, &wsize, &error);
> 			if (!newbuf || error) {
> 				DEBUG_MSG("doc_file_to_textbox, cound not convert %s to UTF-8: \n", encoding);
> 				g_free(encoding);
> 				encoding=NULL;
> 			}
> 		}
> 		if (!newbuf) {
> 			DEBUG_MSG("doc_file_to_textbox, file does not have <meta> encoding, or could not convert, trying newfile default encoding %s\n", main_v->props.newfile_default_encoding);
> 			newbuf = g_convert(buffer,-1,"UTF-8",main_v->props.newfile_default_encoding,NULL, &wsize, NULL);
> 			if (newbuf) {
> 				DEBUG_MSG("doc_file_to_textbox, file is in default encoding: %s\n", main_v->props.newfile_default_encoding);
> 				encoding = g_strdup(main_v->props.newfile_default_encoding);
> 			}
> 		}
> 		if (!newbuf) {
> 			DEBUG_MSG("doc_file_to_textbox, file is not in UTF-8, trying encoding from locale\n");
> 			newbuf = g_locale_to_utf8(buffer,-1,NULL,&wsize,NULL);
> 			if (newbuf) {
> 				const gchar *tmpencoding=NULL;
> 				g_get_charset(&tmpencoding);
> 				DEBUG_MSG("doc_file_to_textbox, file is in locale encoding: %s\n", tmpencoding);
> 				encoding = g_strdup(tmpencoding);
> 			}
> 		}
> 		if (!newbuf) {
> 			DEBUG_MSG("doc_file_to_textbox, file NOT is converted yet, trying UTF-8 encoding\n");
> 			if(g_utf8_validate(buffer, -1, NULL)) {
> 				encoding = g_strdup("UTF-8");
> 			}
> 		}
> 		if (!newbuf) {
> 			GList *tmplist;
> 			DEBUG_MSG("doc_file_to_textbox, tried the most obvious encodings, nothing found.. go trough list\n");
> 			tmplist = g_list_first(main_v->props.encodings);
> 			while (tmplist) {
> 				gchar **enc = tmplist->data;
> 				DEBUG_MSG("doc_file_to_textbox, trying encoding %s\n", enc[1]);
> 				newbuf = g_convert(buffer,-1,"UTF-8",enc[1],NULL, &wsize, NULL);
> 				if (newbuf) {
> 					encoding = g_strdup(enc[1]);
> 					tmplist = NULL;
> 				} else {
> 					DEBUG_MSG("doc_file_to_textbox, no newbuf, next in list\n");
> 					tmplist = g_list_next(tmplist);
> 				}
> 			}
> 		}
> 		if (!newbuf) {
> 			error_dialog(BFWIN(doc->bfwin)->main_window,_("Cannot display file, unknown characters found."), NULL);
> 		} else {
> 			g_free(buffer);
> 			buffer = newbuf;
> 			if (doc->encoding) g_free(doc->encoding);
> 			doc->encoding = encoding;
> 			add_encoding_to_list(encoding);
> 		}
> 		if (buffer) {
> 			gtk_text_buffer_insert_at_cursor(doc->buffer,buffer,-1);
> 			g_free(buffer);
> 		}
> 	}
> 	if (doc->highlightstate) {
> 		doc->need_highlighting=TRUE;
> 		DEBUG_MSG("doc_file_to_textbox, highlightstate=%d, need_highlighting=%d, delay=%d\n",doc->highlightstate,doc->need_highlighting,delay);
> 		if (!delay) {
> #ifdef DEBUG
> 			g_print("doc_file_to_textbox, doc->hlset=%p\n", doc->hl);
> 			if (doc->hl) {
> 				g_print("doc_file_to_textbox, doc->hlset->highlightlist=%p\n", doc->hl->highlightlist);
> 			}
> #endif
> 			doc_highlight_full(doc);
> 		}
> 	}
> 	if (!enable_undo) {
> 		doc_bind_signals(doc);
> 	}
> 	
> 	{
> 		/* set the cursor position back */
> 		GtkTextIter iter;
> 		gtk_text_buffer_get_iter_at_offset(doc->buffer,&iter,cursor_offset);
> 		gtk_text_buffer_place_cursor(doc->buffer,&iter);
> 		if (!delay) {
> 			gtk_text_view_place_cursor_onscreen(GTK_TEXT_VIEW(doc->view));
> 		}
> /*		gtk_notebook_set_page(GTK_NOTEBOOK(main_v->notebook),g_list_length(main_v->documentlist) - 1);
> 		notebook_changed(-1);*/
> 	}
> 	return TRUE;
> }
> 
> /**
>  * doc_check_backup:
>  * @doc: #Tdocument*
>  *
>  * creates a backup, depending on the configuration
>  * returns 1 on success, 0 on failure
>  * if no backup is required, or no filename known, 1 is returned
>  *
>  * Return value: #gint 1 on success or 0 on failure
>  */
> static gint doc_check_backup(Tdocument *doc) {
> 	gint res = 1;
> 
> 	if (main_v->props.backup_file && doc->filename && file_exists_and_readable(doc->filename)) {
> 		gchar *backupfilename, *ondiskencoding;
> 		backupfilename = g_strconcat(doc->filename, main_v->props.backup_filestring, NULL);
> 		ondiskencoding = get_filename_on_disk_encoding(backupfilename);
> 		res = file_copy(doc->filename, backupfilename);
> #ifdef HAVE_GNOME_VFS
> 		if (doc->fileinfo) {
> 			gnome_vfs_set_file_info(ondiskencoding, doc->fileinfo, GNOME_VFS_SET_FILE_INFO_PERMISSIONS|GNOME_VFS_SET_FILE_INFO_OWNER);
> 		}
> #else
> 		if (doc->statbuf.st_uid != -1 && !doc->is_symlink) {
> 			chmod(ondiskencoding, doc->statbuf.st_mode);
> 			chown(ondiskencoding, doc->statbuf.st_uid, doc->statbuf.st_gid);
> 		}
> #endif
> 		g_free(ondiskencoding);
> 		g_free(backupfilename);
> 	}
> 	return res;
> }
> 
> static void doc_buffer_insert_text_lcb(GtkTextBuffer *textbuffer,GtkTextIter * iter,gchar * string,gint len, Tdocument * doc) {
> 	gint pos = gtk_text_iter_get_offset(iter);
> 	gint clen = g_utf8_strlen(string, len);
> 	DEBUG_MSG("doc_buffer_insert_text_lcb, started, string='%s', len=%d, clen=%d\n", string, len, clen);
> 	/* the 'len' seems to be the number of bytes and not the number of characters.. */
> 
> 	if (doc->paste_operation) {
> 		if ((pos + clen) > PASTEOPERATION(doc->paste_operation)->eo) PASTEOPERATION(doc->paste_operation)->eo = pos + clen;
> 		if (pos < PASTEOPERATION(doc->paste_operation)->so || PASTEOPERATION(doc->paste_operation)->so == -1) PASTEOPERATION(doc->paste_operation)->so = pos;
> 	} else if (len == 1) {
> 		/* undo_redo stuff */
> 		if (!doc_unre_test_last_entry(doc, UndoInsert, -1, pos)
> 				|| string[0] == ' ' 
> 				|| string[0] == '\n' 
> 				|| string[0] == '\t'
> 				|| string[0] == '\r') {
> 			DEBUG_MSG("doc_buffer_insert_text_lcb, need a new undogroup\n");
> 			doc_unre_new_group(doc);
> 		}
> 	}
> 	/* we do not call doc_unre_new_group() for multi character inserts, these are from paste, and edit_paste_cb groups them already */
> 	/*  else if (clen != 1) {
> 		doc_unre_new_group(doc);
> 	} */
> 	
> 	doc_unre_add(doc, string, pos, pos+clen, UndoInsert);
> 	doc_set_modified(doc, 1);	
> 	DEBUG_MSG("doc_buffer_insert_text_lcb, done\n");
> }
> static gboolean find_char(gunichar ch,gchar *data) {
> #ifdef DEBUG
> 	if (ch < 127) {
> 		DEBUG_MSG("find_char, looking at character %c, searching for '%s', returning %d\n",ch,data,(strchr(data, ch) != NULL));
> 	} else {
> 		DEBUG_MSG("find_char, looking at character code %d, searching for '%s', returning %d\n",ch,data,(strchr(data, ch) != NULL));
> 	}
> #endif
> 	return (strchr(data, ch) != NULL);
> }
> static gchar *noclosingtag [] = {"br","input","img","hr","meta","frame","map","base","link",NULL};
> 
> static gchar *closingtagtoinsert(Tdocument *doc, const gchar *tagname, GtkTextIter *iter) {
> 	/* only for XML all start tags have to end on < /> so we check for that, all other tags 
> 	 * will be treated like HTML tags */
> 	if (tagname[0] != '/') {
> 		if (main_v->props.xhtml || (doc->hl && doc->hl->autoclosingtag == 1) /* xml mode */) {
> 			gchar *tmp;
> 			GtkTextIter itstart = *iter, itend=*iter;
> 			gtk_text_iter_backward_chars(&itstart,2);
> 			tmp = gtk_text_buffer_get_text(doc->buffer,&itstart,&itend,FALSE);
> 			DEBUG_MSG("closingtagtoinsert, while testing for XML < />, tmp=%s\n",tmp);
> 			if (tmp[0] == '/') {
> 				g_free(tmp);
> 				return NULL;
> 			}
> 			g_free(tmp);
> 			return g_strconcat("</",tagname,">", NULL);
> 		} else /* should be doc->hl == 2, which is html mode */{
> 			/* HTML, test if this tag needs closing */
> 			gchar **tmp=noclosingtag;
> 			DEBUG_MSG("closingtagtoinsert, test if %s needs closing in HTML\n",tagname);
> 			while (*tmp) {
> 				if (strcmp(*tmp,tagname)==0) {
> 					return NULL;
> 				}
> 				tmp++;
> 			}
> 			return g_strconcat("</",cap(tagname),">", NULL);
> 		}
> 	}
> 	return NULL;
> }
> static void doc_buffer_insert_text_after_lcb(GtkTextBuffer *textbuffer,GtkTextIter * iter,gchar * string,gint len, Tdocument * doc) {
> 	DEBUG_MSG("doc_buffer_insert_text_after_lcb, started for string '%s'\n",string);
> 	if (!doc->paste_operation) {
> 		/* highlighting stuff */
> 		if (doc->highlightstate && string && doc->hl) {
> 			gboolean do_highlighting = FALSE;
> 			if (doc->hl->update_chars[0] == '\0' ) {
> 				do_highlighting = TRUE;
> 			} else {
> 				gint i=0;
> 				while (string[i] != '\0') {
> 					if (strchr(doc->hl->update_chars, string[i])) {
> 						do_highlighting = TRUE;
> 						break;
> 					}
> 					i++;
> 				}
> 			}
> 			if (do_highlighting) {
> 				doc_highlight_line(doc);
> 			}
> 		}
> 	}
> #ifdef DEBUG
> 	else {
> 		DEBUG_MSG("doc_buffer_insert_text_after_lcb, paste_operation, NOT DOING ANYTHING\n");
> 	}
> #endif
> }
> 
> static gboolean doc_view_key_press_lcb(GtkWidget *widget,GdkEventKey *kevent,Tdocument *doc) {
> 	DEBUG_MSG("doc_view_key_press_lcb, keyval=%d, hardware_keycode=%d\n",kevent->keyval, kevent->hardware_keycode);
> 	main_v->lastkp_keyval = kevent->keyval;
> 	main_v->lastkp_hardware_keycode = kevent->hardware_keycode;
> 
> 	if (!(kevent->state & GDK_CONTROL_MASK) && 
> 	       ((kevent->keyval == GDK_Home) || (kevent->keyval == GDK_KP_Home) || (kevent->keyval == GDK_End) || (kevent->keyval == GDK_KP_End)) && 
> 	       main_v->props.editor_smart_cursor) {
>                 GtkTextMark* imark;
>                 GtkTextIter  iter, currentpos, linestart;
>    
>         		imark = gtk_text_buffer_get_insert (doc->buffer);		
>         		gtk_text_buffer_get_iter_at_mark (doc->buffer, &currentpos, imark);
>         
>         		iter = currentpos;
>         		
>         		if ((kevent->keyval == GDK_Home) || (kevent->keyval == GDK_KP_Home)) {
>                     gtk_text_iter_backward_cursor_positions (&iter, gtk_text_iter_get_line_offset (&iter));
>                     linestart = iter;
>         
>                     while (g_unichar_isspace (gtk_text_iter_get_char (&iter)) && !gtk_text_iter_ends_line (&iter))
>                             gtk_text_iter_forward_char (&iter);
>                             
>                 } else { /* (kevent->keyval == GDK_End) || (kevent->keyval == GDK_KP_End) */
> 		            if (!gtk_text_iter_ends_line (&iter))
> 		                gtk_text_iter_forward_to_line_end (&iter);
> 
> 		            linestart = iter;
>                     
>                     if (gtk_text_iter_is_end (&iter) && !gtk_text_iter_starts_line (&iter))
>                         gtk_text_iter_backward_char (&iter);
>                         
> 		            while (g_unichar_isspace (gtk_text_iter_get_char (&iter)) && !gtk_text_iter_starts_line (&iter))
> 			                gtk_text_iter_backward_char (&iter);
> 
>                     if ((!gtk_text_iter_starts_line (&iter) || !gtk_text_iter_ends_line (&iter)) && !g_unichar_isspace (gtk_text_iter_get_char (&iter)))
>                         gtk_text_iter_forward_char (&iter);
>                 }
>                 
>         		if (gtk_text_iter_compare (&currentpos, &iter) == 0)
>         			iter = linestart;
>         
>         		if (kevent->state & GDK_SHIFT_MASK)
>         			gtk_text_buffer_move_mark (doc->buffer, imark, &iter);
>         		else {		
>         			gtk_text_buffer_place_cursor (doc->buffer, &iter);
>         		}
>         
>                 gtk_text_view_scroll_mark_onscreen (GTK_TEXT_VIEW (doc->view), gtk_text_buffer_get_insert (doc->buffer));
> 
>         		return TRUE;
> 	}
> 
> 	if (kevent->keyval == GDK_Tab && main_v->props.editor_indent_wspaces) {
>   		GtkTextMark* imark;
> 		GtkTextIter iter;
> 		gchar *string;
> 
>   	   /* replace the tab with spaces if the user wants that */
>   	   string = bf_str_repeat(" ", main_v->props.editor_tab_width);
>   	   imark = gtk_text_buffer_get_insert(doc->buffer);
>   	   gtk_text_buffer_get_iter_at_mark(doc->buffer,&iter,imark);
>   	   gtk_text_buffer_insert(doc->buffer,&iter,string,main_v->props.editor_tab_width);
>   	   g_free(string);
> 
>   	   return TRUE; /* we handled the event, stop the event from cascading further */
>   	}
>   	
> 	return FALSE; /* we didn't handle all of the event */
> }
> 
> static gboolean doc_view_key_release_lcb(GtkWidget *widget,GdkEventKey *kevent,Tdocument *doc) {
> #ifdef DEBUG
> 	guint32 character = gdk_keyval_to_unicode(kevent->keyval);
> 	DEBUG_MSG("doc_view_key_release_lcb, started for keyval=%d (or %X), character=%d, string=%s, state=%d, hw_keycode=%d\n",kevent->keyval,kevent->keyval, character,kevent->string,kevent->state, kevent->hardware_keycode);
> #endif
> 	/* if the shift key is released before the '>' key, we get a key release not for '>' but for '.'. We, therefore
> 	 have set that in the key_press event, and check if the same hardware keycode was released */
> 	if ((kevent->keyval == GDK_greater) || (kevent->hardware_keycode == main_v->lastkp_hardware_keycode && main_v->lastkp_keyval == GDK_greater)) {
> 		if (doc->autoclosingtag) {
> 			/* start the autoclosing! the code is modified from the patch sent by more <more@irpin.com> because that
> 			 * patch did not work with php code (the < and > characters can be inside a php block as well with a 
> 			 * different meaning then a tag), it could not do closing of XML tags and it was limited to a buffer 
> 			 * in Tdocument to hold the current tag name.
> 			 * This code will simply look back in the buffer once a '>' character is pressed, and look if that was
> 			 * the end of a tag. If so it will insert the closing tag for that same tag. Works for XML and HTML. For
> 			 * HTML we need an exception, since <br> and such don't need a closing tag */
> 			GtkTextMark* imark;
> 			GtkTextIter itstart,iter,maxsearch;
> 
> 			imark = gtk_text_buffer_get_insert(doc->buffer);
> 			gtk_text_buffer_get_iter_at_mark(doc->buffer,&iter,imark);
> 			itstart = iter;
> 			maxsearch = iter;
> 			DEBUG_MSG("doc_view_key_release_lcb, autoclosing, started at %d\n",gtk_text_iter_get_offset(&itstart));
> 			gtk_text_iter_backward_chars(&maxsearch,250);
> 			if (gtk_text_iter_backward_find_char(&itstart,(GtkTextCharPredicate)find_char,GINT_TO_POINTER("<"),&maxsearch)) {
> 				/* we use a regular expression to check if the tag is valid, AND to parse the tagname from the string */
> 				gchar *buf;
> 				int ovector[30], ret;
> 				DEBUG_MSG("doc_view_key_release_lcb, we found a '<'\n");
> 				maxsearch = iter; /* re-use maxsearch */
> 				buf = gtk_text_buffer_get_text(doc->buffer,&itstart,&maxsearch,FALSE);
> 				DEBUG_MSG("doc_view_key_release_lcb, buf='%s'\n",buf);
> 				ret = pcre_exec(main_v->autoclosingtag_regc, NULL, buf, strlen(buf), 0,PCRE_ANCHORED, ovector, 30);
> 				if (ret > 0) {
> 					gchar *tagname, *toinsert;
> 					DEBUG_MSG("doc_view_key_release_lcb, autoclosing, we have a tag, ret=%d, starts at ovector[2]=%d, ovector[3]=%d\n",ret, ovector[2], ovector[3]);
> 					tagname = g_strndup(&buf[ovector[2]], ovector[3]-ovector[2]);
> 					DEBUG_MSG("doc_view_key_release_lcb, autoclosing, tagname='%s'\n",tagname);
> 					toinsert = closingtagtoinsert(doc, tagname, &iter);
> 					if (toinsert) {
>  						/* we place this in a new undo/redo group */
> 						doc_unre_new_group(doc);
> 						/* we re-use the maxsearch iter now */
> 						gtk_text_buffer_insert(doc->buffer,&maxsearch,toinsert,-1);
> 						/* now we set the cursor back to its previous location, re-using itstart */
> 						gtk_text_buffer_get_iter_at_mark(doc->buffer,&itstart,gtk_text_buffer_get_insert(doc->buffer));
> 						gtk_text_iter_backward_chars(&itstart,strlen(toinsert));
> 						gtk_text_buffer_place_cursor(doc->buffer,&itstart);
> 						g_free(toinsert);
> 						doc_unre_new_group(doc);
> 					}
> #ifdef DEBUG
> 					 else {
> 						DEBUG_MSG("doc_view_key_release_lcb, no match!! '%s' is not a valid tag\n",buf);
> 					}
> #endif
> 					g_free(tagname);
> 				} else {
> 					DEBUG_MSG("doc_view_key_release_lcb, ret=%d\n",ret);
> 				}
> 				/* cleanup and return */
> 				g_free(buf);
> 			}
> #ifdef DEBUG
> 			 else {
> 				DEBUG_MSG("doc_view_key_release_lcb, did not find a '<' character\n");
> 			}
> #endif
> 		}
> 	} else if ((kevent->keyval == GDK_Return || kevent->keyval == GDK_KP_Enter) && !(kevent->state & GDK_SHIFT_MASK || kevent->state & GDK_CONTROL_MASK || kevent->state & GDK_MOD1_MASK)) {
> 		if (main_v->props.autoindent) {
> 			gchar *string, *indenting;
> 			GtkTextMark* imark;
> 			GtkTextIter itstart, itend;
> 			imark = gtk_text_buffer_get_insert(doc->buffer);
> 			gtk_text_buffer_get_iter_at_mark(doc->buffer,&itend,imark);
> 			itstart = itend;
> 			/* set to the beginning of the previous line */
> 			gtk_text_iter_backward_line(&itstart);
> 			gtk_text_iter_set_line_index(&itstart, 0);
> 			string = gtk_text_buffer_get_text(doc->buffer,&itstart,&itend,FALSE);
> 			if (string) {
> 				/* now count the indenting in this string */
> 				indenting = string;
> 				while (*indenting == '\t' || *indenting == ' ') {
> 					indenting++;
> 				}
> 				/* ending search, non-whitespace found, so terminate at this position */
> 				*indenting = '\0';
> 				if (strlen(string)) {
> 					DEBUG_MSG("doc_buffer_insert_text_lcb, inserting indenting\n");
> 					gtk_text_buffer_insert(doc->buffer,&itend,string,-1);
> 				}
> 				g_free(string);
> 			}
> 		}
> 	}
> 	return FALSE; /* we didn't handle all of the event */
> }
> 
> static void doc_buffer_delete_range_lcb(GtkTextBuffer *textbuffer,GtkTextIter * itstart,GtkTextIter * itend, Tdocument * doc) {
> 	gchar *string;
> 	gboolean do_highlighting=FALSE;
> 	string = gtk_text_buffer_get_text(doc->buffer, itstart, itend, FALSE);
> 	DEBUG_MSG("doc_buffer_delete_range_lcb, string='%s'\n",string);
> 	if (string) {
> 		/* highlighting stuff */
> 		if (doc->highlightstate && string && doc->hl) {
> 			if (strlen(doc->hl->update_chars)==0 ) {
> 				do_highlighting = TRUE;
> 			} else {
> 				gint i=0;
> 				while (string[i] != '\0') {
> 					if (strchr(doc->hl->update_chars, string[i])) {
> 						do_highlighting = TRUE;
> 						break;
> 					}
> 					i++;
> 				}
> 			}
> 			if (do_highlighting) {
> 				doc_highlight_line(doc);
> 			}
> 		}
> 		/* undo_redo stuff */
> 		{
> 			gint start, end, len;
> 			start = gtk_text_iter_get_offset(itstart);
> 			end = gtk_text_iter_get_offset(itend);	
> 			len = end - start;
> 			DEBUG_MSG("doc_buffer_delete_range_lcb, start=%d, end=%d, len=%d, string='%s'\n", start, end, len, string);
> 			if (len == 1) {
> 				if (		(!doc_unre_test_last_entry(doc, UndoDelete, start, -1) /* delete */
> 							&& !doc_unre_test_last_entry(doc, UndoDelete, end, -1)) /* backspace */
> 						|| string[0] == ' ' 
> 						|| string[0] == '\n' 
> 						|| string[0] == '\t'
> 						|| string[0] == '\r') {
> 					DEBUG_MSG("doc_buffer_delete_range_lcb, need a new undogroup\n");
> 					doc_unre_new_group(doc);
> 				}			
> 			} else if (!doc->paste_operation) {
> 				doc_unre_new_group(doc);
> 			}
> 			doc_unre_add(doc, string, start, end, UndoDelete);
> 		}
> 		g_free(string);
> 	}
> 	doc_set_modified(doc, 1);
> }
> 
> static gboolean doc_view_button_release_lcb(GtkWidget *widget,GdkEventButton *bevent, Tdocument *doc) {
> 	DEBUG_MSG("doc_view_button_release_lcb, button %d\n", bevent->button);
> 	if (bevent->button==2) {
> 		/* end of paste */
> 		if (doc->paste_operation) {
> 			if (PASTEOPERATION(doc->paste_operation)->eo > PASTEOPERATION(doc->paste_operation)->so) {
> 				DEBUG_MSG("doc_view_button_release_lcb, start doc-highlight_region for so=%d, eo=%d\n",PASTEOPERATION(doc->paste_operation)->so,PASTEOPERATION(doc->paste_operation)->eo);
> 				doc_highlight_region(doc, PASTEOPERATION(doc->paste_operation)->so, PASTEOPERATION(doc->paste_operation)->eo);
> 			}
> 			g_free(doc->paste_operation);
> 			doc->paste_operation = NULL;
> 		}
> 		/* now we should update the highlighting for the pasted text, but how long is the pasted text ?? */
> 	}
> /*	if (bevent->button == 3) {
> 		GtkWidget *menuitem;
> 		GtkWidget *submenu;
> 		GtkWidget *menu = gtk_menu_new ();
> 		gboolean tag_found;
> 		tag_found = doc_bevent_in_html_tag(doc, bevent);
> 		menuitem = gtk_menu_item_new_with_label(_("Edit tag"));
> 		g_signal_connect(G_OBJECT(menuitem), "activate", G_CALLBACK(rpopup_edit_tag_cb), doc);
> 		if (!tag_found) {
> 			gtk_widget_set_sensitive(menuitem, FALSE);
> 		}
>       gtk_widget_show (menuitem);
> 		gtk_menu_append(GTK_MENU(menu), menuitem);
> 		menuitem = gtk_menu_item_new();
>       gtk_widget_show (menuitem);
> 		gtk_menu_append(GTK_MENU(menu), menuitem);
> 
> 		menuitem = gtk_menu_item_new_with_mnemonic (_("Input _Methods"));
>       gtk_widget_show (menuitem);
> 		submenu = gtk_menu_new ();
>       gtk_menu_item_set_submenu (GTK_MENU_ITEM (menuitem), submenu);
>       gtk_menu_shell_append (GTK_MENU_SHELL (menu), menuitem);
>       gtk_im_multicontext_append_menuitems (GTK_IM_MULTICONTEXT (GTK_TEXT_VIEW(doc->view)->im_context),
> 					    GTK_MENU_SHELL (submenu));
> 		gtk_widget_show_all (menu);
> 		gtk_menu_popup (GTK_MENU (menu), NULL, NULL,
> 			  NULL, doc->view, 0, gtk_get_current_event_time ());
> 	} */
> 	return FALSE;
> }
> 
> static void doc_get_iter_at_bevent(Tdocument *doc, GdkEventButton *bevent, GtkTextIter *iter) {
> 	gint xpos, ypos;
> 	GtkTextWindowType wintype;
> 
> 	wintype = gtk_text_view_get_window_type(GTK_TEXT_VIEW(doc->view), doc->view->window);
> 	gtk_text_view_window_to_buffer_coords(GTK_TEXT_VIEW(doc->view), wintype,bevent->x, bevent->y,
> 					  &xpos, &ypos);
> 	xpos += gtk_text_view_get_border_window_size(GTK_TEXT_VIEW(doc->view),GTK_TEXT_WINDOW_LEFT);
> 	gtk_text_view_get_iter_at_location(GTK_TEXT_VIEW(doc->view), iter, xpos, ypos);
> }
> 
> static gboolean doc_view_button_press_lcb(GtkWidget *widget,GdkEventButton *bevent, Tdocument *doc) {
> 	DEBUG_MSG("doc_view_button_press_lcb, button %d\n", bevent->button);
> 	if (bevent->button==2 && !doc->paste_operation) {
> 		doc->paste_operation = g_new(Tpasteoperation,1);
> 		PASTEOPERATION(doc->paste_operation)->so = -1;
> 		PASTEOPERATION(doc->paste_operation)->eo = -1;
> 	}
> 	if (bevent->button == 3) {
> 		GtkTextIter iter;
> 		doc_get_iter_at_bevent(doc, bevent, &iter);
> 		rpopup_bevent_in_html_code(doc, &iter);
> 		bmark_store_bevent_location(doc, gtk_text_iter_get_offset(&iter));
> 	}
> 	return FALSE;
> }
> 
> static void rpopup_add_bookmark_lcb(GtkWidget *widget, Tdocument *doc) {
> 	bmark_add_at_bevent(doc);
> }
> static void rpopup_del_bookmark_lcb(GtkWidget *widget, Tdocument *doc) {
> 	bmark_del_at_bevent(doc);
> }
> 
> 
> static void doc_view_populate_popup_lcb(GtkTextView *textview,GtkMenu *menu,Tdocument *doc) {
> 	GtkWidget *menuitem;
> 	/* I found no way to connect an item-factory to this menu widget, so we have to do it in the manual way... */
> 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(gtk_menu_item_new()));
> 
> 	menuitem = gtk_image_menu_item_new_with_label(_("Replace"));
> 	g_signal_connect(menuitem, "activate", G_CALLBACK(replace_cb), doc->bfwin);
> 	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menuitem),gtk_image_new_from_stock(GTK_STOCK_FIND_AND_REPLACE, GTK_ICON_SIZE_MENU));
> 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(menuitem));
> 
> 	menuitem = gtk_image_menu_item_new_with_label(_("Find"));
> 	g_signal_connect(menuitem, "activate", G_CALLBACK(search_cb), doc->bfwin);
> 	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menuitem),gtk_image_new_from_stock(GTK_STOCK_FIND, GTK_ICON_SIZE_MENU));
> 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(menuitem));
> 
> 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(gtk_menu_item_new()));
> 
> 	if (bmark_have_bookmark_at_stored_bevent(doc)) {
> 		menuitem = gtk_menu_item_new_with_label(_("Delete bookmark"));
> 		g_signal_connect(menuitem, "activate", G_CALLBACK(rpopup_del_bookmark_lcb), doc);
> 		gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(menuitem));
> 	} else {
> 		menuitem = gtk_menu_item_new_with_label(_("Add bookmark"));
> 		g_signal_connect(menuitem, "activate", G_CALLBACK(rpopup_add_bookmark_lcb), doc);
> 		gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(menuitem));
> 	}
> 
> 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(gtk_menu_item_new()));
> 
> 	menuitem = gtk_image_menu_item_new_with_label(_("Edit color"));
> 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(menuitem));
> 	if (rpopup_doc_located_color(doc)) {
> 		g_signal_connect(G_OBJECT(menuitem), "activate", G_CALLBACK(rpopup_edit_color_cb), doc);
> 	} else {
> 		gtk_widget_set_sensitive(menuitem, FALSE);
> 	}
> 
> 	menuitem = gtk_image_menu_item_new_with_label(_("Edit tag"));
> 	gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menuitem),new_pixmap(113));
> 	gtk_menu_shell_prepend(GTK_MENU_SHELL(menu), GTK_WIDGET(menuitem));
> 	if (rpopup_doc_located_tag(doc)) {
> 		g_signal_connect(G_OBJECT(menuitem), "activate", G_CALLBACK(rpopup_edit_tag_cb), doc);
> 	} else {
> 		gtk_widget_set_sensitive(menuitem, FALSE);
> 	}
> 	
> 	gtk_widget_show_all(GTK_WIDGET(menu));
> }
> 
> static void doc_buffer_mark_set_lcb(GtkTextBuffer *buffer,GtkTextIter *iter,GtkTextMark *set_mark,Tdocument *doc) {
> 	doc_set_statusbar_lncol(doc);
> }
> static void doc_buffer_changed_lcb(GtkTextBuffer *textbuffer,Tdocument*doc) {
> 	doc_set_statusbar_lncol(doc);
> }
> 
> static void doc_view_toggle_overwrite_lcb(GtkTextView *view, Tdocument *doc)
> {	
> 	doc->overwrite_mode = (doc->overwrite_mode ? FALSE : TRUE);	
> 	doc_set_statusbar_insovr(doc);
> }
> 
> /**
>  * doc_bind_signals:
>  * @doc: a #Tdocument
>  *
>  * Bind signals related to the doc's buffer:
>  * "insert-text", "delete-range" and "insert-text" for autoindent
>  *
>  * Return value: void
>  **/
> void doc_bind_signals(Tdocument *doc) {
> 	doc->ins_txt_id = g_signal_connect(G_OBJECT(doc->buffer),
> 					 "insert-text",
> 					 G_CALLBACK(doc_buffer_insert_text_lcb), doc);
> 	doc->del_txt_id = g_signal_connect(G_OBJECT(doc->buffer),
> 					 "delete-range",
> 					 G_CALLBACK(doc_buffer_delete_range_lcb), doc);
> 	doc->ins_aft_txt_id = g_signal_connect_after(G_OBJECT(doc->buffer),
> 					 "insert-text",
> 					 G_CALLBACK(doc_buffer_insert_text_after_lcb), doc);
> }
> 
> /**
>  * doc_unbind_signals:
>  * @doc: a #Tdocument
>  *
>  * Unbind signals related to the doc's buffer:
>  * "insert-text", "delete-range" and "insert-text" for autoindent.
>  * This function checks if each individual signal has been bound before unbinding.
>  *
>  * Return value: void
>  **/
> void doc_unbind_signals(Tdocument *doc) {
> /*	g_print("doc_unbind_signals, before unbind ins=%lu, del=%lu\n", doc->ins_txt_id, doc->del_txt_id);*/
> 	if (doc->ins_txt_id != 0) {
> 		g_signal_handler_disconnect(G_OBJECT(doc->buffer),doc->ins_txt_id);
> 		doc->ins_txt_id = 0;
> 	}
> 	if (doc->del_txt_id != 0) {
> 		g_signal_handler_disconnect(G_OBJECT(doc->buffer),doc->del_txt_id);
> 		doc->del_txt_id = 0;
> 	}
> 	if (doc->ins_aft_txt_id != 0) {
> 		g_signal_handler_disconnect(G_OBJECT(doc->buffer),doc->ins_aft_txt_id);
> 		doc->ins_txt_id = 0;
> 	}
> }
> #ifdef HAVE_GNOME_VFS
> gboolean buffer_to_file(Tbfwin *bfwin, gchar *buffer, gchar *filename) {
> 	GnomeVFSHandle *handle;
> 	GnomeVFSFileSize bytes_written=0;
> 	GnomeVFSResult result;
> 	gchar *ondiskencoding = get_filename_on_disk_encoding(filename);
> 	/* we use create instead of open, because open will not create the file if it does
>       not already exist. The last argument is the permissions to use if the file is created,
>       the second to last tells GnomeVFS that its ok if the file already exists, and just open it */
> 	result = gnome_vfs_create(&handle, ondiskencoding, GNOME_VFS_OPEN_WRITE, FALSE, 0644);
> 	g_free(ondiskencoding);
> 	if (result != GNOME_VFS_OK) {
> 		DEBUG_MSG("buffer_to_file, opening, result=%d, error=%s\n",result, gnome_vfs_result_to_string(result));
> 		return FALSE;
> 	}
> 	/*	the gnome-sftp module does not truncate the file after create on an existing filename,
> 	but adding this truncate code results in an 'Unsupported operation' error */
> /* result = gnome_vfs_truncate_handle(handle, 0);
> 	if (result != GNOME_VFS_OK) {
> 		DEBUG_MSG("buffer_to_file, truncating: result=%d, error=%s\n", result, gnome_vfs_result_to_string(result));
> 	}*/
> 	result = gnome_vfs_write(handle, buffer, strlen(buffer), &bytes_written);
> 	if (bytes_written) {
> 		gnome_vfs_truncate_handle(handle, bytes_written);
> 	}
> 	gnome_vfs_close(handle);
> 	if (result != GNOME_VFS_OK) {
> 		DEBUG_MSG("buffer_to_file, writing: result=%d, error=%s\n", result, gnome_vfs_result_to_string(result));
> 		return FALSE;
> 	}
> 	return TRUE;
> }
> #else /* HAVE_GNOME_VFS */
> gboolean buffer_to_file(Tbfwin *bfwin, gchar *buffer, gchar *filename) {
> 	FILE *fd;
> 	gchar *ondiskencoding = get_filename_on_disk_encoding(filename);
> 	fd = fopen(ondiskencoding, "w");
> 	g_free(ondiskencoding);
> 	if (fd == NULL) {
> 		DEBUG_MSG("buffer_to_file, cannot open file %s\n", filename);
> 		return FALSE;
> 	}
> 	fputs(buffer, fd);
> 	fclose(fd);
> 	return TRUE;
> }
> #endif /* HAVE_GNOME_VFS */
> 
> /**
>  * gint doc_textbox_to_file
>  * @doc: a #Tdocument*
>  * @filename: a #gchar*
>  * @window_closing: a #gboolean if the window is closing, we should supress any statusbar messages then
>  *
>  * If applicable, backup existing file,
>  * possibly update meta-tags (HTML),
>  * and finally write the document to the specified file.
>  *
>  * Return value: #gint set to
>  * 1: on success
>  * 2: on success but the backup failed
>  * -1: if the backup failed and save was aborted
>  * -2: if the file could not be opened or written
>  * -3: if the backup failed and save was aborted by the user
>  * -4: if the charset encoding conversion failed and the save was aborted by the user
>  **/
> gint doc_textbox_to_file(Tdocument * doc, gchar * filename, gboolean window_closing) {
> 	gint backup_retval;
> 	gint write_retval;
> 	gchar *buffer;
> 	GtkTextIter itstart, itend;
> 
> 	if (!window_closing) statusbar_message(BFWIN(doc->bfwin),_("Saving file"), 1000);
> 
> 	/* update author meta tag */
> 	if (main_v->props.auto_update_meta_author) {
> 		const gchar *realname = g_get_real_name();
> 		if (realname && strlen(realname) > 0)  {
> 			gchar *author_tmp;
> 			author_tmp = g_strconcat("<meta name=\"author\" content=\"",realname,"\"",NULL);
> 			snr2_run_extern_replace(doc,"<meta[ \t\n]+name[ \t\n]*=[ \t\n]*\"author\"[ \t\n]+content[ \t\n]*=[ \t\n]*\"[^\"]*\"[ \t\n]*",0,1,0,author_tmp,FALSE);
> 			g_free(author_tmp);
> 		}
> 	}
> 
> 	/* update date meta tag */
> 	if (main_v->props.auto_update_meta_date) {
> 		time_t time_var;
> 		struct tm *time_struct;
> 		gchar isotime[60];
> 		gchar *date_tmp;
> 		
> 		time_var = time(NULL);
> 		time_struct = localtime(&time_var);
> 		strftime(isotime, 30, "%Y-%m-%dT%H:%M:%S%z", time_struct);
> 		
> 		date_tmp = g_strconcat("<meta name=\"date\" content=\"",isotime,"\"",NULL);
> 		snr2_run_extern_replace(doc,"<meta[ \t\n]+name[ \t\n]*=[ \t\n]*\"date\"[ \t\n]+content[ \t\n]*=[ \t\n]*\"[^\"]*\"[ \t\n]*",0,1,0,date_tmp,FALSE);
> 		g_free(date_tmp);
> 	}
> 	
> 	/* update generator meta tag */
> 	if (main_v->props.auto_update_meta_generator) {
> 		/* what is this good for? do we really need it? */
> 		/* Tsearch_result res = doc_search_run_extern(doc,"<meta[ \t\n]+name[ \t\n]*=[ \t\n]*\"generator\"[ \t\n]+content[ \t\n]*=[ \t\n]*\"[^\"]*[bB]luefish[^\"]*\"[ \t\n]*",1,0);
> 		 * if (res.end > 0) { */
> 		snr2_run_extern_replace(doc,"<meta[ \t\n]+name[ \t\n]*=[ \t\n]*\"generator\"[ \t\n]+content[ \t\n]*=[ \t\n]*\"[^\"]*\"[ \t\n]*",0,1,0,"<meta name=\"generator\" content=\"Bluefish "VERSION"\"", FALSE);
> 		/* } */
> 	}
> 
> 	/* This writes the contents of a textbox to a file */
> 	backup_retval = doc_check_backup(doc);
> 
> 	if (!backup_retval) {
> 		if (main_v->props.backup_abort_action == DOCUMENT_BACKUP_ABORT_ABORT) {
> 			DEBUG_MSG("doc_textbox_to_file, backup failure, abort!\n");
> 			return -1;
> 		} else if (main_v->props.backup_abort_action == DOCUMENT_BACKUP_ABORT_ASK) {
> 			gchar *options[] = {_("_Abort save"), _("_Continue save"), NULL};
> 			gint retval;
> 			gchar *tmpstr = g_strdup_printf(_("A backupfile for %s could not be created. If you continue, this file will be overwritten."), filename);
> 			retval = multi_warning_dialog(BFWIN(doc->bfwin)->main_window,_("File backup failure"), tmpstr, 1, 0, options);
> 			g_free(tmpstr);
> 			if (retval == 0) {
> 				DEBUG_MSG("doc_textbox_to_file, backup failure, user aborted!\n");
> 				return -3;
> 			}
> 		}
> 	}
> 	
> 	gtk_text_buffer_get_bounds(doc->buffer,&itstart,&itend);
> 	buffer = gtk_text_buffer_get_text(doc->buffer,&itstart,&itend,FALSE);
> 	
> 	if (doc->encoding) {
> 		gchar *newbuf;
> 		gsize bytes_written=0, bytes_read=0;
> 		DEBUG_MSG("doc_textbox_to_file, converting from UTF-8 to %s\n", doc->encoding);
> 		newbuf = g_convert(buffer,-1,doc->encoding,"UTF-8",&bytes_read,&bytes_written,NULL); 
> 		if (newbuf) {
> 			g_free(buffer);
> 			buffer = newbuf;
> 		} else {
> 			gchar *options[] = {_("_Abort save"), _("_Continue save in UTF-8"), NULL};
> 			gint retval, line, column;
> 			glong position;
> 			gchar *tmpstr, failed[6];
> 			GtkTextIter iter;
> 			position = g_utf8_pointer_to_offset(buffer,buffer+bytes_read);
> 			gtk_text_buffer_get_iter_at_offset(doc->buffer,&iter,position);
> 			line = gtk_text_iter_get_line(&iter);
> 			column = gtk_text_iter_get_line_offset(&iter);
> 			failed[0]='\0';
> 			g_utf8_strncpy(failed,buffer+bytes_read,1);
> 			tmpstr = g_strdup_printf(_("Failed to convert %s to character encoding %s. Encoding failed on character '%s' at line %d column %d\n\nContinue saving in UTF-8 encoding?"), filename, doc->encoding, failed, line+1, column+1);
> 			retval = multi_warning_dialog(BFWIN(doc->bfwin)->main_window,_("File encoding conversion failure"), tmpstr, 1, 0, options);
> 			g_free(tmpstr);
> 			if (retval == 0) {
> 				DEBUG_MSG("doc_textbox_to_file, character set conversion failed, user aborted!\n");
> 				return -4;
> 			} else {
> 				/* continue in UTF-8 */
> 				update_encoding_meta_in_file(doc, "UTF-8");
> 				g_free(buffer);
> 				gtk_text_buffer_get_bounds(doc->buffer,&itstart,&itend);
> 				buffer = gtk_text_buffer_get_text(doc->buffer,&itstart,&itend,FALSE);
> 			}
> 		}
> 	}
> 	
> 	write_retval = buffer_to_file(BFWIN(doc->bfwin), buffer, filename);
> 	DEBUG_MSG("doc_textbox_to_file, write_retval=%d\n",write_retval);
> 	g_free(buffer);
> 	if (!write_retval) {
> 		return -2;
> 	}
> 
> 	if (main_v->props.clear_undo_on_save) {
> 		doc_unre_clear_all(doc);
> 	}
> 	DEBUG_MSG("doc_textbox_to_file, calling doc_set_modified(doc, 0)\n");
> 	doc_set_modified(doc, 0);
> 	if (!backup_retval) {
> 		return 2;
> 	} else {
> 		return 1;
> 	}
> 
> }
> 
> /**
>  * doc_destroy:
>  * @doc: a #Tdocument
>  * @delay_activation: #gboolean whether to delay gui-updates.
>  *
>  * Performs all actions neccessary to remove an open document from the fish:
>  * Adds filename to recent-list,
>  * removes the document from the documentlist and notebook,
>  * change notebook-focus (if !delay_activation),
>  * delete backupfile if required by pref,
>  * free all related memory.
>  *
>  * Return value: void
>  **/
> void doc_destroy(Tdocument * doc, gboolean delay_activation) {
> 	Tbfwin *bfwin = BFWIN(doc->bfwin);
> 
> 	DEBUG_MSG("doc_destroy, calling bmark_clean_for_doc(%p)\n",doc);
> 	bmark_clean_for_doc(doc);
> /*        bmark_adjust_visible(bfwin);   */
> 
> 	if (doc->filename) {
> 		add_to_recent_list(doc->bfwin,doc->filename, 1, FALSE);
> 	}
> 	gui_notebook_unbind_signals(BFWIN(doc->bfwin));
> 	/* to make this go really quick, we first only destroy the notebook page and run flush_queue(), 
> 	after the document is gone from the GUI we complete the destroy, to destroy only the notebook
> 	page we ref+ the scrolthingie, remove the page, and unref it again */
> 	g_object_ref(doc->view->parent);
> 	if (doc->floatingview) {
> 		gtk_widget_destroy(FLOATINGVIEW(doc->floatingview)->window);
> 		doc->floatingview = NULL;
> 	}
> 	/* now we remove the document from the document list */
> 	bfwin->documentlist = g_list_remove(bfwin->documentlist, doc);
> 	DEBUG_MSG("removed %p from documentlist, list %p length=%d\n",doc
> 			, bfwin->documentlist
> 			, g_list_length(bfwin->documentlist));
> 	if (bfwin->current_document == doc) {
> 		bfwin->current_document = NULL;
> 	}
> 	/* then we remove the page from the notebook */
> 	DEBUG_MSG("about to remove widget from notebook (doc=%p, current_document=%p)\n",doc,bfwin->current_document);
> 	gtk_notebook_remove_page(GTK_NOTEBOOK(bfwin->notebook),
> 							 gtk_notebook_page_num(GTK_NOTEBOOK(bfwin->notebook),doc->view->parent));
> 	DEBUG_MSG("doc_destroy, removed widget from notebook (doc=%p), delay_activation=%d\n",doc,delay_activation);
> 	DEBUG_MSG("doc_destroy, (doc=%p) about to bind notebook signals...\n",doc);
> 	gui_notebook_bind_signals(BFWIN(doc->bfwin));
> 	if (!delay_activation) {
> 		notebook_changed(BFWIN(doc->bfwin),-1);
> 	}
> 	DEBUG_MSG("doc_destroy, (doc=%p) after calling notebook_changed()\n",doc);
> 	/* now we really start to destroy the document */
> 	g_object_unref(doc->view->parent);
> 
> 	if (doc->filename) {
> 		if (main_v->props.backup_cleanuponclose) {
> 			gchar *backupfile = g_strconcat(doc->filename, main_v->props.backup_filestring, NULL);
> 			DEBUG_MSG("unlinking %s, doc->filename=%s\n", backupfile,doc->filename);
> 			unlink(backupfile);
> 			g_free(backupfile);
> 		}
> 		g_free(doc->filename);
> 	}
> 	
> 	if (doc->encoding)
> 		g_free(doc->encoding);
> 
> #ifdef HAVE_GNOME_VFS
> 	if (doc->fileinfo) {
> 		gnome_vfs_file_info_unref (doc->fileinfo);
> 	}
> #endif	/* HAVE_GNOME_VFS */
> 
> 	g_object_unref(doc->buffer);
> 	doc_unre_destroy(doc);
> 	DEBUG_MSG("doc_destroy, finished for %p\n", doc);
> 	g_free(doc);
> }
> 
> /**
>  * document_unset_filename:
>  * @document: #Tdocument*
>  *
>  * this function is called if some other document is saved with a filename
>  * equal to this files filename, or when this file is deleted in the filebrowser
>  *
>  * return value: void, ignored
>  */
> void document_unset_filename(Tdocument *doc) {
> 	if (doc->filename) {
> 		gchar *tmpstr2, *tmpstr3;
> 		gchar *tmpstr, *oldfilename = doc->filename;
> 		doc->filename = NULL;
> 		doc_set_title(doc);
> 		tmpstr2 = g_path_get_basename(oldfilename);
> 		tmpstr3 = get_utf8filename_from_on_disk_encoding(tmpstr2);
> 		tmpstr = g_strconcat(_("Previously: "), tmpstr3, NULL);
> 		g_free(tmpstr2);
> 		g_free(tmpstr3);
> 		gtk_label_set(GTK_LABEL(doc->tab_label),tmpstr);
> 		g_free(tmpstr);
> 		g_free(oldfilename);
> 	}
> }
> 
> /**
>  * ask_new_filename:
>  * @bfwin: #Tbfwin* mainly used to set the dialog transient
>  * @oldfilename: #gchar* with the old filename
>  * @gui_name: #const gchar* with the name of the file used in the GUI
>  * @is_move: #gboolean if the title should be move or save as
>  *
>  * returns a newly allocated string with a new filename
>  *
>  * if a file with the selected name name was
>  * open already it will ask the user what to do, return NULL if
>  * the user wants to abort, or will remove the name of the other file if the user wants
>  * to continue
>  *
>  * Return value: gchar* with newly allocated string, or NULL on failure or abort
>  **/
> gchar *ask_new_filename(Tbfwin *bfwin,gchar *oldfilename, const gchar *gui_name, gboolean is_move) {
> 	Tdocument *exdoc;
> 	GList *alldocs;
> 	gchar *ondisk = get_filename_on_disk_encoding(oldfilename);
> 	gchar *newfilename = NULL;
> 	gchar *dialogtext;
> 	
> 	dialogtext = g_strdup_printf((is_move) ? _("Move/rename %s to"): _("Save %s as"), gui_name);
> #ifdef HAVE_ATLEAST_GTK_2_4
> 	{
> 		GtkWidget *dialog;
> 		dialog = file_chooser_dialog(bfwin, dialogtext, GTK_FILE_CHOOSER_ACTION_SAVE, oldfilename, FALSE, FALSE, NULL);
> 		if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT) {
> 			newfilename = gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(dialog));
> 		}
> 		gtk_widget_destroy(dialog);
> 	}
> #else
> 	newfilename = return_file_w_title(ondisk,dialogtext);
> #endif
> 	g_free(ondisk);
> 	g_free(dialogtext);
> 	
> 	if (!newfilename || (oldfilename && strcmp(oldfilename,newfilename)==0)) {
> 		if (newfilename) g_free(newfilename);
> 		return NULL;
> 	}
> 	
> 	/* make a full path, re-use the ondisk variable */
> 	ondisk = newfilename;
> 	newfilename = create_full_path(ondisk, NULL);
> 	g_free(ondisk);
> 
> 	
> 	alldocs = return_allwindows_documentlist();
> 	exdoc = documentlist_return_document_from_filename(alldocs, newfilename);
> 	g_list_free(alldocs);
> 	DEBUG_MSG("ask_new_filename, exdoc=%p, newfilename=%s\n", exdoc, newfilename);
> 	if (exdoc) {
> 		gchar *tmpstr;
> 		gint retval;
> 		gchar *options[] = {_("_Cancel"), _("_Overwrite"), NULL};
> 
> 		tmpstr = g_strdup_printf(_("File %s exists and is opened, overwrite?"), newfilename);
> 		retval = multi_warning_dialog(bfwin->main_window, tmpstr, 
> 		                              _("The file you have selected is being edited in Bluefish."), 1, 0, options);
> 		g_free(tmpstr);
> 		if (retval == 0) {
> 			g_free(newfilename);
> 			return NULL;
> 		} else {
> 			document_unset_filename(exdoc);
> 		}
> 	} else {
>       if (file_exists_and_readable(newfilename)) {      
> 			gchar *tmpstr;
> 			gint retval;
> 			gchar *options[] = {_("_Cancel"), _("_Overwrite"), NULL};
> 			
> 			tmpstr = g_strdup_printf(_("A file named \"%s\" already exists."), newfilename);
> 			retval = multi_warning_dialog(bfwin->main_window, tmpstr, 
>                                        _("Do you want to replace the existing file?"), 1, 0, options);
> 			g_free (tmpstr);
> 			if (retval == 0) {
> 				g_free (newfilename);
> 				return NULL;
> 			}
> 		}
> 	}
> 	return newfilename;
> }
> 
> /**
>  * doc_save:
>  * @doc: the #Tdocument to save
>  * @do_save_as: #gboolean set to 1 if "save as"
>  * @do_move: #gboolean set to 1 if moving the file.
>  * @window_closing: #gboolean if the window is closing, should suppress statusbar messages then
>  *
>  * Performs all neccessary actions to save an open document.
>  * Warns the user of problems, and asks for a filename if neccessary.
>  * 
>  * Return value: #gint set to
>  * 1: on success
>  * 2: on success but the backup failed
>  * 3: on user abort
>  * -1: if the backup failed and save was aborted
>  * -2: if the file pointer could not be opened 
>  * -3: if the backup failed and save was aborted by the user
>  * -4: if there is no filename, after asking one from the user
>  * -5: if another process modified the file, and the user chose cancel
>  **/
> gint doc_save(Tdocument * doc, gboolean do_save_as, gboolean do_move, gboolean window_closing) {
> 	gint retval;
> 	gchar *ondiskencoding = NULL, *ondiskencodingbckup = NULL;
> #ifdef DEBUG
> 	g_assert(doc);
> #endif
> 
> 	DEBUG_MSG("doc_save, doc=%p, save_as=%d, do_move=%d\n", doc, do_save_as, do_move);
> 	if (doc->filename == NULL) {
> 		do_save_as = 1;
> 	}
> 	if (do_move) {
> 		do_save_as = 1;
> 	}
> 
> 	if (do_save_as) {
> 		gchar *newfilename = NULL;
> 		if (!window_closing) statusbar_message(BFWIN(doc->bfwin),_("Save as..."), 1);
> 		newfilename = ask_new_filename(BFWIN(doc->bfwin), doc->filename, gtk_label_get_text(GTK_LABEL(doc->tab_label)), do_move);
> 		if (!newfilename) {
> 			return 3;
> 		}
> 		if (doc->filename) {
> 			if (do_move) {
>                 gchar *backupfilename = NULL;
>                 ondiskencoding = get_filename_on_disk_encoding(doc->filename);
>                 /* Check for a backup file */
>                 backupfilename = g_strconcat (doc->filename, main_v->props.backup_filestring, NULL);
>                 if (file_exists_and_readable(backupfilename)) {
>                     ondiskencodingbckup = get_filename_on_disk_encoding(backupfilename);
>                     DEBUG_MSG("doc_save, do_move, backup file exists, backupfilename = %s\n", ondiskencodingbckup);
>                 }
>                 g_free (backupfilename);
> 			}
> 			g_free(doc->filename);
> 		}
> 		doc->filename = newfilename;
> 		/* TODO: should feed the contents to the function too !! */
> 		doc_reset_filetype(doc, doc->filename, NULL);
> 		doc_set_title(doc);
> 		if (doc == BFWIN(doc->bfwin)->current_document) {
> 			gui_set_title(BFWIN(doc->bfwin), doc);
> 		}
> 	} else /* (!do_save_as) */ {
> 		gboolean modified;
> 		time_t oldmtime, newmtime;
> #ifdef HAVE_GNOME_VFS
> 		GnomeVFSFileInfo *fileinfo;
> 		fileinfo = gnome_vfs_file_info_new();
> 		modified = doc_check_modified_on_disk(doc,&fileinfo);
> 		if (doc->fileinfo && modified) {
> 			newmtime = fileinfo->mtime;
> 			oldmtime = doc->fileinfo->mtime;
> 		}
> 		gnome_vfs_file_info_unref(fileinfo);
> #else
> 		struct stat statbuf;
> 		modified = doc_check_modified_on_disk(doc,&statbuf);
> 		newmtime = statbuf.st_mtime;
> 		oldmtime = doc->statbuf.st_mtime;
> #endif
> 		if (modified) {
> 			gchar *tmpstr, oldtimestr[128], newtimestr[128];/* according to 'man ctime_r' this should be at least 26, so 128 should do ;-)*/
> 			gint retval;
> 			gchar *options[] = {_("_Cancel"), _("_Overwrite"), NULL};
> 	
> 			ctime_r(&newmtime,newtimestr);
> 			ctime_r(&oldmtime,oldtimestr);
> 			tmpstr = g_strdup_printf(_("File: %s\n\nNew modification time: %s\nOld modification time: %s"), doc->filename, newtimestr, oldtimestr);
> 			retval = multi_warning_dialog(BFWIN(doc->bfwin)->main_window,_("File has been modified by another process."), tmpstr, 1, 0, options);
> 			g_free(tmpstr);
> 			if (retval == 0) {
> 				return -5;
> 			}
> 		}
> 	}
> 	
> 	DEBUG_MSG("doc_save, returned file %s\n", doc->filename);
> /*	if (do_save_as && oldfilename && main_v->props.link_management) {
> 		update_filenames_in_file(doc, oldfilename, doc->filename, 1);
> 	}*/
> 	{
> 		gchar *tmp = g_strdup_printf(_("Saving %s"), doc->filename);
> 		if (!window_closing) statusbar_message(BFWIN(doc->bfwin),tmp, 1);
> 		g_free(tmp);
> 		/* re-use tmp */
> 		tmp = g_path_get_dirname(doc->filename);
> 		if (BFWIN(doc->bfwin)->session->savedir) g_free(BFWIN(doc->bfwin)->session->savedir);
> 		BFWIN(doc->bfwin)->session->savedir = tmp;
> 	}
> 	retval = doc_textbox_to_file(doc, doc->filename, window_closing);
> 
> 	switch (retval) {
> 		gchar *errmessage;
> 		case -1:
> 			/* backup failed and aborted */
> 			errmessage = g_strconcat(_("Could not backup file:\n\""), doc->filename, "\"", NULL);
> 			error_dialog(BFWIN(doc->bfwin)->main_window,_("File save aborted.\n"), errmessage);
> 			g_free(errmessage);
> 		break;
> 		case -2:
> 			/* could not open the file pointer */
> 			errmessage = g_strconcat(_("Could not write file:\n\""), doc->filename, "\"", NULL);
> 			error_dialog(BFWIN(doc->bfwin)->main_window,_("File save error"), errmessage);
> 			g_free(errmessage);
> 		break;
> 		case -3:
> 		case -4:
> 			/* do nothing, the save is aborted by the user */
> 		break;
> 		default:
> 			doc_set_stat_info(doc);
> 			{ 
> 				gchar *tmp = path_get_dirname_with_ending_slash(doc->filename);
> 				bfwin_filebrowser_refresh_dir(BFWIN(doc->bfwin),tmp);
> 				g_free(tmp);
> 			}
>             doc_unregroup_reset_changed(doc);
>             if (do_move) {
> #ifdef HAVE_GNOME_VFS
> 				gnome_vfs_unlink(ondiskencoding);
> 				if (ondiskencodingbckup) {
> 				    gnome_vfs_unlink(ondiskencodingbckup);
> 				}
> #else
> 				unlink(ondiskencoding);
> 				if (ondiskencodingbckup) {
> 				    unlink(ondiskencodingbckup);
> 				}				
> #endif
> 				g_free(ondiskencoding);
> 				if (ondiskencodingbckup)    g_free(ondiskencodingbckup);
>             }
> 			DEBUG_MSG("doc_save, received return value %d from doc_textbox_to_file\n", retval);
> 		break;
> 	}
> 	return retval;
> }
> 
> /**
>  * doc_close:
>  * @doc: The #Tdocument to clase.
>  * @warn_only: a #gint set to 1 if the document shouldn't actually be destroyed.
>  *
>  * Get confirmation when closing an unsaved file, save it if neccessary,
>  * and destroy the file unless aborted by user.
>  *
>  * Return value: #gint set to 0 (when cancelled/aborted) or 1 (when closed or saved&closed)
>  **/
> gint doc_close(Tdocument * doc, gint warn_only)
> {
> 	gchar *text;
> 	gint retval;
> #ifdef DEBUG
> 	if (!doc) {
> 		DEBUG_MSG("doc_close, returning because doc=NULL\n");
> 		return 0;
> 	}
> #endif
> 
> 	if (doc_is_empty_non_modified_and_nameless(doc) && g_list_length(BFWIN(doc->bfwin)->documentlist) ==1) {
> 		/* no need to close this doc, it's an Untitled empty document */
> 		DEBUG_MSG("doc_close, 1 untitled empty non-modified document, returning\n");
> 		return 0;
> 	}
> 
> 	if (doc->modified) {
> 		/*if (doc->tab_label) {*/
> 			text = g_strdup_printf(_("Save changes to \"%s\" before closing?."),
> 									gtk_label_get_text (GTK_LABEL (doc->tab_label)));
> 		/*} else {
> 			text = g_strdup(_("Save changes to this untitled file before closing?"));
> 		}*/
> 	
> 		{
> 			gchar *buttons[] = {_("Do_n't save"), GTK_STOCK_CANCEL, GTK_STOCK_SAVE, NULL};
> 			retval = multi_query_dialog(BFWIN(doc->bfwin)->main_window, text, 
> 						_("If you don't save your changes they will be lost."), 2, 1, buttons);
> 		}
> 		g_free(text);
> 
> 		switch (retval) {
> 		case 1:
> 			DEBUG_MSG("doc_close, retval=2 (cancel) , returning\n");
> 			return 2;
> 			break;
> 		case 2:
> 			doc_save(doc, FALSE, FALSE, FALSE);
> 			if (doc->modified == 1) {
> 				/* something went wrong it's still not saved */
> 				return 0;
> 			}
> 			if (!warn_only) {
> 				doc_destroy(doc, FALSE);
> 			}
> 			break;
> 		case 0:
> 			if (!warn_only) {
> 				doc_destroy(doc, FALSE);
> 			}
> 			break;
> 		default:
> 			return 0;			/* something went wrong */
> 			break;
> 		}
> 	} else {
> 		if (!warn_only) {
> 			DEBUG_MSG("doc_close, starting doc_destroy for doc=%p\n", doc);
> 			doc_destroy(doc, FALSE);
> 		}
> 	}
> 	DEBUG_MSG("doc_close, finished\n");
> /*	notebook_changed();*/
> 	return 1;
> }
> 
> static void doc_close_but_clicked_lcb(GtkWidget *wid, gpointer data) {
> 
> 	doc_close(data, 0);
> }
> 
> /* contributed by Oskar Swida <swida@aragorn.pb.bialystok.pl>, with help from the gedit source */
> static gboolean doc_textview_expose_event_lcb(GtkWidget * widget, GdkEventExpose * event, gpointer doc) {
> 	GtkTextView *view = (GtkTextView*)widget;
> 	GdkRectangle rect;
> 	GdkWindow *win;
> 	GtkTextIter l_start,l_end, it;
> 	gint l_top1,l_top2;
> 	PangoLayout *l;
> 	gchar *pomstr;
> 	gint numlines,w,i;
> 	GHashTable *temp_tab;
> 
> 	win = gtk_text_view_get_window(view,GTK_TEXT_WINDOW_LEFT);
> 	if (win!=event->window) return FALSE;
> 
> 	gtk_text_view_get_visible_rect(view,&rect);
> 	gtk_text_view_get_line_at_y(view,&l_start,rect.y,&l_top1);
> 	gtk_text_view_get_line_at_y(view,&l_end,rect.y+rect.height,&l_top2);
> 	l = gtk_widget_create_pango_layout(widget,"");
> 
> 	numlines = gtk_text_buffer_get_line_count(gtk_text_view_get_buffer(view));
> 	pomstr = g_strdup_printf("%d",MAX(99,numlines));
> 	pango_layout_set_text(l,pomstr,-1);
> 	g_free(pomstr);
> 	pango_layout_get_pixel_size(l,&w,NULL);
> 	gtk_text_view_set_border_window_size(view,GTK_TEXT_WINDOW_LEFT,w+4);   
> 	it = l_start;
> 	temp_tab = bmark_get_bookmarked_lines(DOCUMENT(doc),&l_start,&l_end);
> 	for(i=gtk_text_iter_get_line(&l_start);i<=gtk_text_iter_get_line(&l_end);i++) {
> 		gchar* val;
> 		gtk_text_iter_set_line(&it,i);
> 		gtk_text_view_get_line_yrange(view,&it,&w,NULL);      
> 		gtk_text_view_buffer_to_window_coords(view,GTK_TEXT_WINDOW_LEFT,0,w,NULL,&w);
> 		pomstr = NULL;
> 		if (temp_tab) {
> 			val = g_hash_table_lookup(temp_tab,&i);      		
> 			if (val) {
> 				pomstr = g_strdup_printf("<span background=\"%s\" >%d</span>",val[0] == '0' ? "#768BEA" : "#62CB7F",i+1);
> 			}
> 		}
> 		if (pomstr == NULL) {
> 			pomstr = g_strdup_printf("<span>%d</span>",i+1);
> 		} 
> 		pango_layout_set_markup(l,pomstr,-1);
> 		gtk_paint_layout(widget->style,win,GTK_WIDGET_STATE(widget),FALSE,NULL,widget,NULL,2,w,l);
> 		g_free(pomstr);
> 	}
> 	g_object_unref(G_OBJECT(l));
> 	if (temp_tab) g_hash_table_destroy(temp_tab);
> 	return TRUE;
> }
> 
> /**
>  * document_set_line_numbers:
>  * @doc: a #Tdocument*
>  * @value: a #gboolean
>  *
>  * Show or hide linenumbers (at the left of the main GtkTextView).
>  *
>  * Return value: void
>  **/ 
> void document_set_line_numbers(Tdocument *doc, gboolean value) {
> 	if (value) {
> 		gtk_text_view_set_left_margin(GTK_TEXT_VIEW(doc->view),2);
> 		gtk_text_view_set_border_window_size(GTK_TEXT_VIEW(doc->view),GTK_TEXT_WINDOW_LEFT,20);
> 		g_signal_connect(G_OBJECT(doc->view),"expose-event",G_CALLBACK(doc_textview_expose_event_lcb),doc);
> 	} else {
> 		gtk_text_view_set_left_margin(GTK_TEXT_VIEW(doc->view),0);
> 		gtk_text_view_set_border_window_size(GTK_TEXT_VIEW(doc->view),GTK_TEXT_WINDOW_LEFT,0);
> 	}
> }
> 
> static void doc_view_drag_end_lcb(GtkWidget *widget,GdkDragContext *drag_context,Tdocument *doc) {
> 	if (doc->paste_operation) {
> 		if (PASTEOPERATION(doc->paste_operation)->eo > PASTEOPERATION(doc->paste_operation)->so) {
> 			doc_highlight_region(doc, PASTEOPERATION(doc->paste_operation)->so, PASTEOPERATION(doc->paste_operation)->eo);
> 		}
> 		g_free(doc->paste_operation);
> 		doc->paste_operation = NULL;
> 	}
> }
> static void doc_view_drag_begin_lcb(GtkWidget *widget,GdkDragContext *drag_context,Tdocument *doc) {
> 	if (!doc->paste_operation) {
> 		doc->paste_operation = g_new(Tpasteoperation,1);
> 		PASTEOPERATION(doc->paste_operation)->so = -1;
> 		PASTEOPERATION(doc->paste_operation)->eo = -1;
> 	}
> }
> 
> /**
>  * doc_new:
>  * @bfwin: #Tbfwin* with the window to open the document in
>  * @delay_activate: Whether to perform GUI-calls and flush_queue(). Set to TRUE when loading several documents at once.
>  *
>  * Create a new document, related structures and a nice little textview to display the document in.
>  * Finally, add a new tab to the notebook.
>  * The GtkTextView is not actually gtk_widget_shown() if delay_activate == TRUE. This is done by doc_activate() instead.
>  *
>  * Return value: a #Tdocument* pointer to the just created document.
>  **/
> Tdocument *doc_new(Tbfwin* bfwin, gboolean delay_activate) {
> 	GtkWidget *scroll;
> 	Tdocument *newdoc = g_new0(Tdocument, 1);
> 	DEBUG_MSG("doc_new, main_v is at %p, bfwin at %p, newdoc at %p\n", main_v, bfwin, newdoc);
> 	newdoc->bfwin = (gpointer)bfwin;
> 	newdoc->hl = (Tfiletype *)((GList *)g_list_first(main_v->filetypelist))->data;
> 	newdoc->autoclosingtag = (newdoc->hl->autoclosingtag > 0);
> 	newdoc->buffer = gtk_text_buffer_new(highlight_return_tagtable());
> 	newdoc->view = gtk_text_view_new_with_buffer(newdoc->buffer);
> 	scroll = gtk_scrolled_window_new(NULL, NULL);
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll),
> 									   GTK_POLICY_AUTOMATIC,
> 									   GTK_POLICY_AUTOMATIC);
> 	gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW
> 											(scroll), GTK_SHADOW_IN);
> 	gtk_container_add(GTK_CONTAINER(scroll), newdoc->view);
> 
> 	newdoc->linenumberstate = main_v->props.view_line_numbers;
> 	document_set_line_numbers(newdoc, newdoc->linenumberstate);
> 
> 	newdoc->tab_label = gtk_label_new(NULL);
> 	GTK_WIDGET_UNSET_FLAGS(newdoc->tab_label, GTK_CAN_FOCUS);
> 	if (strlen(main_v->props.tab_font_string)) {
> 		apply_font_style(newdoc->tab_label, main_v->props.tab_font_string);
> 	}
> 	newdoc->tab_menu = gtk_label_new(NULL);
> 	newdoc->tab_eventbox = gtk_event_box_new();
> 	gtk_misc_set_alignment(GTK_MISC(newdoc->tab_menu), 0,0);
> 
> 	doc_unre_init(newdoc);
> 	doc_set_font(newdoc, NULL);
> 	newdoc->wrapstate = (bfwin->project) ? bfwin->project->word_wrap : main_v->props.word_wrap;
> 	doc_set_wrap(newdoc);
> 	/* newdoc->modified = 0; */
> 	doc_set_title(newdoc);
> 	/*newdoc->filename = NULL;*/
> 	newdoc->need_highlighting = 0;
> #ifdef HAVE_GNOME_VFS
> 	/*newdoc->fileinfo = NULL;*/
> #else
> 	newdoc->statbuf.st_mtime = 0;
> 	newdoc->statbuf.st_size = 0;
> 	newdoc->statbuf.st_uid = -1;
> 	newdoc->statbuf.st_gid = -1;
> #endif
> 	newdoc->is_symlink = 0;
> 	newdoc->encoding = g_strdup(main_v->props.newfile_default_encoding);
> 	newdoc->overwrite_mode = FALSE;
> 	doc_bind_signals(newdoc);
> 
> 	g_signal_connect(G_OBJECT(newdoc->view), "button-release-event", 
> 		G_CALLBACK(doc_view_button_release_lcb), newdoc);
> 	g_signal_connect(G_OBJECT(newdoc->view), "button-press-event", 
> 		G_CALLBACK(doc_view_button_press_lcb), newdoc);
> 	g_signal_connect(G_OBJECT(newdoc->buffer), "changed",
> 		G_CALLBACK(doc_buffer_changed_lcb), newdoc);
> 	g_signal_connect(G_OBJECT(newdoc->buffer), "mark-set", 
> 		G_CALLBACK(doc_buffer_mark_set_lcb), newdoc);
> 	g_signal_connect(G_OBJECT(newdoc->view), "toggle-overwrite",
> 		G_CALLBACK(doc_view_toggle_overwrite_lcb), newdoc);
> /*	g_signal_connect(G_OBJECT(newdoc->view), "paste-clipboard",
> 		G_CALLBACK(doc_paste_clipboard_lcb), newdoc);
> 	g_signal_connect_after(G_OBJECT(newdoc->view), "button-release-event", 
> 		G_CALLBACK(doc_view_button_release_after_lcb), newdoc);*/
> 	g_signal_connect_after(G_OBJECT(newdoc->view), "drag-end", 
> 		G_CALLBACK(doc_view_drag_end_lcb), newdoc);
> 	g_signal_connect_after(G_OBJECT(newdoc->view), "drag-begin", 
> 		G_CALLBACK(doc_view_drag_begin_lcb), newdoc);
> 	g_signal_connect_after(G_OBJECT(newdoc->view), "key-release-event", 
> 		G_CALLBACK(doc_view_key_release_lcb), newdoc);
> 	g_signal_connect(G_OBJECT(newdoc->view), "key-press-event", 
> 		G_CALLBACK(doc_view_key_press_lcb), newdoc);
> 	g_signal_connect_after(G_OBJECT(newdoc->view), "populate-popup", 
> 		G_CALLBACK(doc_view_populate_popup_lcb), newdoc);
> 
> 	bfwin->documentlist = g_list_append(bfwin->documentlist, newdoc);
> 
> 	if(!delay_activate) gtk_widget_show(newdoc->view); /* Delay _show() if neccessary */
> 
> 	gtk_widget_show(newdoc->tab_label);
> 	gtk_widget_show(scroll);
> 
> 	DEBUG_MSG("doc_new, appending doc to notebook\n");
> 	{
> 		GtkWidget *hbox, *but, *image;
> 		hbox = gtk_hbox_new(FALSE,0);
> 		but = gtk_button_new();
> 		image = new_pixmap(101);
> 		gtk_container_add(GTK_CONTAINER(but), image);
> 		gtk_container_set_border_width(GTK_CONTAINER(but),0);
> #ifndef HAVE_ATLEAST_GTK_2_4
> 		gtk_widget_set_size_request(but, 12,12);
> #endif
> 		gtk_button_set_relief(GTK_BUTTON(but), GTK_RELIEF_NONE);
> 		g_signal_connect(G_OBJECT(but), "clicked", G_CALLBACK(doc_close_but_clicked_lcb), newdoc);
> 		gtk_container_add(GTK_CONTAINER(newdoc->tab_eventbox), newdoc->tab_label);
> 		gtk_box_pack_start(GTK_BOX(hbox), newdoc->tab_eventbox, FALSE, FALSE, 0);
> 		gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, FALSE, 0);
> 		gtk_widget_show_all(hbox);
> 		gtk_notebook_append_page_menu(GTK_NOTEBOOK(bfwin->notebook), scroll ,hbox, newdoc->tab_menu);
> 	}
> 	/* for some reason it only works after the document is appended to the notebook */
> 	doc_set_tabsize(newdoc, main_v->props.editor_tab_width);
> 	
> 	newdoc->highlightstate = main_v->props.defaulthighlight;
> 	DEBUG_MSG("doc_new, need_highlighting=%d, highlightstate=%d\n", newdoc->need_highlighting, newdoc->highlightstate);
> /*	
> 	these lines should not be here since notebook_changed() calls flush_queue()
> 	that means that this document can be closed during notebook_changed(), and functions like open_file 
> 	rely on the fact that this function returns an existing document (and not a closed one!!)
> if (!delay_activate) {
> 		DEBUG_MSG("doc_new, notebook current page=%d, newdoc is on page %d\n",gtk_notebook_get_current_page(GTK_NOTEBOOK(main_v->notebook)),gtk_notebook_page_num(GTK_NOTEBOOK(main_v->notebook),scroll));
> 		DEBUG_MSG("doc_new, setting notebook page to %d\n", g_list_length(main_v->documentlist) - 1);
> 		gtk_notebook_set_current_page(GTK_NOTEBOOK(main_v->notebook),g_list_length(main_v->documentlist) - 1);
> 		if (bfwin->current_document != newdoc) {
> 			notebook_changed(-1);
> 		}*/
> /*		doc_activate() will be called by notebook_changed() and it will grab the focus
> 		gtk_widget_grab_focus(newdoc->view);	*/
> /*	}*/
> 	return newdoc;
> }
> 
> /**
>  * doc_new_with_new_file:
>  * @bfwin: #Tbfwin*
>  * @new_filename: #gchar* filename to give document.
>  *
>  * Create a new document, name it by new_filename, and create the file.
>  *
>  * Return value: void
>  **/
> void doc_new_with_new_file(Tbfwin *bfwin, gchar * new_filename) {
> 	Tdocument *doc;
> 	Tfiletype *ft;
> 	if (new_filename == NULL) {
> 		statusbar_message(bfwin,_("No filename"), 2);
> 		return;
> 	}
> 	if (!main_v->props.allow_multi_instances) {
> 		gboolean res;
> 		res = switch_to_document_by_filename(bfwin,new_filename);
> 		if (res){
> 			return;
> 		}
> 	} 
> 	DEBUG_MSG("doc_new_with_new_file, new_filename=%s\n", new_filename);
> 	add_filename_to_history(bfwin,new_filename);
> 	doc = doc_new(bfwin, FALSE);
> 	doc->filename = g_strdup(new_filename);
> 	if (bfwin->project && bfwin->project->template && strlen(bfwin->project->template) > 2) {
> 		doc_file_to_textbox(doc, bfwin->project->template, FALSE, FALSE);
>  	}
> 	ft = get_filetype_by_filename_and_content(doc->filename, NULL);
> 	if (ft) doc->hl = ft;
> /*	doc->modified = 1;*/
> 	doc_set_title(doc);
> 	doc_save(doc, FALSE, FALSE, FALSE);
> 	doc_set_stat_info(doc); /* also sets mtime field */
> 	switch_to_document_by_pointer(bfwin,doc);
> 	doc_activate(doc);
> }
> 
> /**
>  * doc_new_with_file:
>  * @bfwin: #Tbfwin* with the window to open the document in
>  * @filename: #gchar* with filename to load.
>  * @delay_activate: #gboolean if GUI calls are wanted.
>  * @move_to_this_win: #gboolean if the file should be moved to this window if already open
>  *
>  * Create a new document and read in a file.
>  * Errors are not propagated to user in any other way than returning a pointer or NULL
>  *
>  * Return value: #Tdocument*, or NULL on error
>  **/
> Tdocument * doc_new_with_file(Tbfwin *bfwin, gchar * filename, gboolean delay_activate, gboolean move_to_this_win) {
> 	Tdocument *doc;
> 	gboolean opening_in_existing_doc = FALSE;
> 	gchar *fullfilename;
> 	DEBUG_MSG("doc_new_with_file, called for %s\n",filename);
> 	if ((filename == NULL) || (!file_exists_and_readable(filename))) {
> 		DEBUG_MSG("doc_new_with_file, file %s !file_exists or readable\n", filename);
> 		return NULL;
> 	}
> 	fullfilename = create_full_path(filename, NULL);
> 	if (bfwin) {
> 		gchar *tmpstring = g_path_get_dirname(fullfilename);
> 		if (bfwin->session->opendir) g_free(bfwin->session->opendir);
> 		bfwin->session->opendir = tmpstring;
> 	}
> 	
> 	if (!main_v->props.allow_multi_instances) {
> 		GList *alldocs = return_allwindows_documentlist();
> 		Tdocument *tmpdoc = documentlist_return_document_from_filename(alldocs, fullfilename);
> 		DEBUG_MSG("doc_new_with_file, fullfilename=%s, tmpdoc=%p\n",fullfilename,tmpdoc);
> 		g_list_free(alldocs);
> 		if (tmpdoc) {
> 			DEBUG_MSG("doc_new_with_file, %s is already open %p\n",filename,tmpdoc);
> 			if (move_to_this_win && documentlist_return_document_from_filename(bfwin->documentlist, fullfilename) == NULL) {
> 				doc_move_to_window(tmpdoc, bfwin);
> 			} else {
> 				if (!delay_activate) {
> 					switch_to_document_by_pointer(BFWIN(tmpdoc->bfwin),tmpdoc);
> 					if (bfwin != tmpdoc->bfwin) {
> 						gtk_window_present(GTK_WINDOW(BFWIN(tmpdoc->bfwin)->main_window));
> 					}
> 				}
> 			}
> 			g_free(fullfilename);
> 			return tmpdoc;
> 		}
> 	}
> 	DEBUG_MSG("doc_new_with_file, fullfilename=%s, filename=%s\n", fullfilename, filename);
> 	add_filename_to_history(bfwin,fullfilename);
> 
> 	if (g_list_length(bfwin->documentlist)==1 && doc_is_empty_non_modified_and_nameless(bfwin->current_document)) {
> 		doc = bfwin->current_document;
> 		opening_in_existing_doc = TRUE;
> 		bfwin->last_activated_doc = NULL;
> 	} else {
> 		doc = doc_new(bfwin, delay_activate);
> 	}
> 	/* we do not need to free fullfilename anymore now */
> 	doc->filename = fullfilename;
> 	DEBUG_MSG("doc_new_with_file, hl is resetted to filename, about to load file\n");
> 	doc_file_to_textbox(doc, doc->filename, FALSE, delay_activate);
> 	/* after the textbuffer is filled the filetype can be found */
> 	doc_reset_filetype(doc, doc->filename, NULL);
> 
> 	/* hey, this should be done by doc_activate 
> 	menu_current_document_set_toggle_wo_activate(NULL, doc->encoding);*/
> 	doc_set_stat_info(doc); /* also sets mtime field */
> 	doc_set_title(doc); /* sets the tooltip as well, so it should be called *after* doc_set_stat_info() */
> 	if (!delay_activate) {
> 		if (opening_in_existing_doc) {
> 			doc_activate(doc);
> 		} 
> 		switch_to_document_by_pointer(bfwin,doc);
> 		doc_activate(doc);
> 		/*filebrowser_open_dir(BFWIN(doc->bfwin),fullfilename); is already called by doc_activate() */
> 	}
> 	bmark_set_for_doc(doc);
> 	bmark_check_length(bfwin,doc);
> /*	bmark_adjust_visible(bfwin);   */
> 	
> 	return doc;
> }
> 
> /**
>  * docs_new_from_files:
>  * @bfwin: #Tbfwin* with the window to open the document in
>  * @file_list: #GList with filenames to open.
>  * @move_to_this_win: #gboolean if the file needs to be moved to this window if it is open already
>  *
>  * Open a number of new documents from files in stringlist file_list.
>  * If a file is open already in another window, it might be moved to this window, else
>  * nothing is done for this file
>  * Report files with problems to user.
>  * If more than 8 files are opened at once, a modal progressbar is shown while loading.
>  *
>  * Return value: void
>  **/
> void docs_new_from_files(Tbfwin *bfwin, GList * file_list, gboolean move_to_this_win) {
> 	GList *tmplist, *errorlist=NULL;
> 	gboolean delay = (g_list_length(file_list) > 1);
> 	gpointer pbar = NULL;
> 	gint i = 0;
> 	DEBUG_MSG("docs_new_from_files, lenght=%d\n", g_list_length(file_list));
> 	
> 	/* Hide the notebook and show a progressbar while
> 	 * adding several files. */
> 	if(g_list_length(file_list) > 8) {
> 		notebook_hide(bfwin);
> 		pbar = progress_popup(bfwin->main_window,_("Loading files..."), g_list_length(file_list));
> 	}
> 	
> 	tmplist = g_list_first(file_list);
> 	while (tmplist) {
> 		DEBUG_MSG("docs_new_from_files, about to open %s, delay=%d\n", (gchar *) tmplist->data, delay);
> 		if (!doc_new_with_file(bfwin,(gchar *) tmplist->data, delay, move_to_this_win)) {
> 			errorlist = g_list_append(errorlist, g_strdup((gchar *) tmplist->data));
> 		}
> 		if(pbar) {
> 			progress_set(pbar, ++i);
> 			flush_queue();
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	if (errorlist){
> 		gchar *message, *tmp;
> 		tmp = stringlist_to_string(errorlist, "\n");
> 		message = g_strconcat(_("These files could not opened:\n\n"), tmp, NULL);
> 		g_free(tmp);
> 		warning_dialog(bfwin->main_window,_("Unable to open file(s)\n"), message);
> 		g_free(message);
> 	}
> 	free_stringlist(errorlist);
> 
> 	if (delay) {
> 		DEBUG_MSG("since we delayed the highlighting, we set the notebook and filebrowser page now\n");
> 
> 		/* Destroy the progressbar and show the notebook when finished. */
> 		progress_destroy(pbar);
> 		notebook_show(bfwin);
> 
> 		gtk_notebook_set_page(GTK_NOTEBOOK(bfwin->notebook),g_list_length(bfwin->documentlist) - 1);
> 		notebook_changed(bfwin,-1);
> 		if (bfwin->current_document && bfwin->current_document->filename) {
> 			/*filebrowser_open_dir(bfwin,bfwin->current_document->filename); is called by doc_activate() */
> 			doc_activate(bfwin->current_document);
> 		}
> 	}
> 	gui_set_title(bfwin, bfwin->current_document);
> }
> 
> /**
>  * doc_reload:
>  * @doc: a #Tdocument
>  *
>  * Revert to file on disk.
>  *
>  * Return value: void
>  **/
> void doc_reload(Tdocument *doc) {
> 	if ((doc->filename == NULL) || (!file_exists_and_readable(doc->filename))) {
> 		statusbar_message(BFWIN(doc->bfwin),_("Unable to open file"), 2000);
> 		return;
> 	}
> 	{
> 		GtkTextIter itstart, itend;
> 		gtk_text_buffer_get_bounds(doc->buffer,&itstart,&itend);
> 		gtk_text_buffer_delete(doc->buffer,&itstart,&itend);
> 	}
> 	
> 	doc_file_to_textbox(doc, doc->filename, FALSE, FALSE);
> 	doc_unre_clear_all(doc);
> 	doc_set_modified(doc, 0);
> 	doc_set_stat_info(doc); /* also sets mtime field */
> }
> 
> /**
>  * doc_activate:
>  * @doc: a #Tdocument
>  *
>  * Perform actions neccessary when a document is focused. I.e. called from the notebook.
>  *
>  * Show textview, warn if the file on disk has been changed,
>  * update line-numbers etc and highlighting.
>  *
>  * Return value: void
>  **/
> void doc_activate(Tdocument *doc) {
> 	gboolean modified;
> 	time_t oldmtime, newmtime;
> #ifdef DEBUG
> 	if (!doc) {
> 		DEBUG_MSG("doc_activate, doc=NULL!!! ABORTING!!\n");
> 		exit(44);
> 	}
> #endif
> 	if (doc == NULL || doc == BFWIN(doc->bfwin)->last_activated_doc) {
> 		return;
> 	}
> 	BFWIN(doc->bfwin)->last_activated_doc = doc;
> 	gtk_widget_show(doc->view); /* This might be the first time this document is activated. */
> #ifdef HAVE_GNOME_VFS
> 	{
> 		GnomeVFSFileInfo *fileinfo;
> 		fileinfo = gnome_vfs_file_info_new();
> 		modified = doc_check_modified_on_disk(doc,&fileinfo);
> 		newmtime = fileinfo->mtime;
> 		if (doc->fileinfo) {
> 			oldmtime = doc->fileinfo->mtime;
> 		}
> 		gnome_vfs_file_info_unref(fileinfo);
> 	}
> #else
> 	{
> 		struct stat statbuf;
> 		modified = doc_check_modified_on_disk(doc,&statbuf);
> 		newmtime = statbuf.st_mtime;
> 		oldmtime = doc->statbuf.st_mtime;
> 	}
> #endif
> 	if (modified) {
> 		gchar *tmpstr, oldtimestr[128], newtimestr[128];/* according to 'man ctime_r' this should be at least 26, so 128 should do ;-)*/
> 		gint retval;
> 		gchar *options[] = {_("_Reload"), _("_Ignore"), NULL};
> 
> 		ctime_r(&newmtime,newtimestr);
> 		ctime_r(&oldmtime,oldtimestr);
> 		tmpstr = g_strdup_printf(_("Filename: %s\n\nNew modification time is: %s\nOld modification time is: %s"), doc->filename, newtimestr, oldtimestr);
> 		retval = multi_warning_dialog(BFWIN(doc->bfwin)->main_window,_("File has been modified by another process\n"), tmpstr, 0, 1, options);
> 		g_free(tmpstr);
> 		if (retval == 1) {
> 			doc_set_stat_info(doc);
> 		} else {
> 			doc_reload(doc);
> 		}
> 	}
> 	DEBUG_MSG("doc_activate, calling gui_set_document_widgets()\n");
> 	gui_set_document_widgets(doc);
> 	gui_set_title(BFWIN(doc->bfwin), doc);
> 	doc_set_statusbar_lncol(doc);
> 	doc_set_statusbar_insovr(doc);
> 	doc_set_statusbar_editmode_encoding(doc);
> 
> 	/* if highlighting is needed for this document do this now !! */
> 	if (doc->need_highlighting && doc->highlightstate) {
> 		doc_highlight_full(doc);
> 		DEBUG_MSG("doc_activate, doc=%p, after doc_highlight_full, need_highlighting=%d\n",doc,doc->need_highlighting);
> 	}
> 
> /*	doc_scroll_to_cursor(doc);*/
> 	if (doc->filename) {
> 		gchar *dir1 = g_path_get_dirname(doc->filename);
> 		gchar *dir2 = ending_slash(dir1);
> 		if (dir2[0] == '/') {
> 			chdir(dir2);
> 		}
> 		if (main_v->props.filebrowser_focus_follow) {
> 			DEBUG_MSG("doc_activate, call filebrowser_open_dir() for %s\n",dir2);
> 			filebrowser_open_dir(BFWIN(doc->bfwin),dir2);
> 		}
> 		g_free(dir1);
> 		g_free(dir2);
> 	}
> 	DEBUG_MSG("doc_activate, doc=%p, about to grab focus\n",doc);
> 	gtk_widget_grab_focus(GTK_WIDGET(doc->view));
> 
> 	DEBUG_MSG("doc_activate, doc=%p, finished\n",doc);
> }
> 
> void doc_force_activate(Tdocument *doc) {
> 	BFWIN(doc->bfwin)->last_activated_doc = NULL;
> 	doc_activate(doc);
> }
> 
> /**************************************************************************/
> /* the start of the callback functions for the menu, acting on a document */
> /**************************************************************************/
> #ifdef EXTERNAL_GREP
> #ifdef EXTERNAL_FIND
> typedef struct {
> 	GList *filenames_to_return;
> 	GtkWidget *win;
> 	GtkWidget *basedir;
> 	GtkWidget *find_pattern;
> 	GtkWidget *recursive;
> 	GtkWidget *grep_pattern;
> 	GtkWidget *is_regex;
> 	Tbfwin *bfwin;
> } Tfiles_advanced;
> 
> static void files_advanced_win_destroy(GtkWidget * widget, Tfiles_advanced *tfs) {
> 	DEBUG_MSG("files_advanced_win_destroy, started\n");
> 	gtk_main_quit();
> 	DEBUG_MSG("files_advanced_win_destroy, gtk_main_quit called\n");
> 	window_destroy(tfs->win);
> }
> 
> static void files_advanced_win_ok_clicked(GtkWidget * widget, Tfiles_advanced *tfs) {
> 	/* create list here */
> 	gchar *command, *temp_file;
> 	gchar *c_basedir, *c_find_pattern, *c_recursive, *c_grep_pattern, *c_is_regex;
> 	temp_file = create_secure_dir_return_filename();
> 	if (!temp_file) {
> 		files_advanced_win_destroy(widget, tfs);
> 		DEBUG_MSG("files_advanced_win_ok_clicked, can't get a secure temp filename ?????\n");
> 		return;
> 	}
> 	DEBUG_MSG("files_advanced_win_ok_clicked, temp_file=%s\n", temp_file);
> 	c_basedir = gtk_editable_get_chars(GTK_EDITABLE(tfs->basedir), 0, -1);
> 	c_find_pattern = gtk_editable_get_chars(GTK_EDITABLE(GTK_COMBO(tfs->find_pattern)->entry), 0, -1);	
> 	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(tfs->recursive))) {
> 		c_recursive= " -maxdepth 100";
> 	} else {
> 		c_recursive = " -maxdepth 1";
> 	}
> 
> 	c_grep_pattern = gtk_editable_get_chars(GTK_EDITABLE(tfs->grep_pattern), 0, -1);
> 	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(tfs->is_regex))) {
> 		c_is_regex = "-E -l ";
> 	} else {
> 		c_is_regex = "-l ";
> 	}
> /*
> command = `find c_basedir c_recursive -name c_find_pattern`
> command = `grep -E 'c_grep_pattern' `find c_basedir c_recursive -name c_find_pattern``
> */
> 	if (strlen(c_grep_pattern) == 0) {
> 		command = g_strconcat (EXTERNAL_FIND, " ", c_basedir, c_recursive, " -name '", c_find_pattern, "' > ", temp_file, NULL);
> 	} else {
> 		command = g_strconcat (EXTERNAL_GREP, " ", c_is_regex, " '", c_grep_pattern, "' `", EXTERNAL_FIND, " ", c_basedir, c_recursive, " -name '", c_find_pattern, "' ` > ", temp_file, NULL);
> 	}
> 	g_free(c_basedir);
> 	g_free(c_find_pattern);
> 	g_free(c_grep_pattern);
> 	DEBUG_MSG("files_advanced_win_ok_clicked, command=%s\n", command);
> 	statusbar_message(tfs->bfwin,_("searching files..."), 1000);
> 	flush_queue();
> 	system(command);
> 	tfs->filenames_to_return = get_stringlist(temp_file, tfs->filenames_to_return);
> 	g_free(command);
> 	remove_secure_dir_and_filename(temp_file);
> 	g_free(temp_file);
> 	files_advanced_win_destroy(widget, tfs);
> }
> static void files_advanced_win_cancel_clicked(GtkWidget * widget, Tfiles_advanced *tfs) {
> 	files_advanced_win_destroy(widget, tfs);
> }
> 
> static void files_advanced_win_select_basedir_lcb(GtkWidget * widget, Tfiles_advanced *tfs) {
> 	gchar *olddir = gtk_editable_get_chars(GTK_EDITABLE(tfs->basedir),0,-1);
> 	/* concat a "/" to the end of the current directory. This fixes a bug where your 
> 	   current working directory was being parsed as /directory/file when you opened 
> 	   the dialog to browse for a directory
> 	*/
> 	gchar *tmpdir = g_strconcat(olddir, "/", NULL);
> 	gchar *newdir = NULL;
> #ifdef HAVE_ATLEAST_GTK_2_4
> 	{
> 		GtkWidget *dialog;
> 		dialog = file_chooser_dialog(tfs->bfwin, _("Select basedir"), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, NULL, TRUE, FALSE, NULL);
> 		if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
> 			newdir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
> 		}
> 		gtk_widget_destroy(dialog);
> 	}
> #else
> 	newdir = return_dir(tmpdir, _("Select basedir"));
> #endif
> 	g_free(tmpdir);
> 	if (newdir) {
> 		gtk_entry_set_text(GTK_ENTRY(tfs->basedir),newdir);
> 		g_free(newdir);
> 	}
> 	g_free(olddir);
> }
> 
> static void files_advanced_win(Tfiles_advanced *tfs) {
> 	GtkWidget *vbox, *hbox, *but, *table;
> 	GList *list;
> 	if (!tfs->basedir) {
> 		gchar *curdir = g_get_current_dir();
> 		tfs->basedir = entry_with_text(curdir, 255);
> 		g_free (curdir);
> 	}
> 	
> 	tfs->win = window_full2(_("Advanced open file selector"), GTK_WIN_POS_MOUSE, 12, G_CALLBACK(files_advanced_win_destroy),tfs, TRUE, tfs->bfwin->main_window);
> 	DEBUG_MSG("files_advanced_win, tfs->win=%p\n",tfs->win);
> 	tfs->filenames_to_return = NULL;
> 	vbox = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(tfs->win), vbox);
> 	
> 	table = gtk_table_new(9, 5, FALSE);
> 	gtk_table_set_row_spacings(GTK_TABLE(table), 12);
> 	gtk_table_set_col_spacings(GTK_TABLE(table), 12);
> 	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);
> 	
> 	gtk_table_attach_defaults(GTK_TABLE(table), gtk_label_new(_("grep {contains} `find {basedir} -name '{file type}'`")), 0, 5, 0, 1);
> 	gtk_table_attach_defaults(GTK_TABLE(table), gtk_hseparator_new(), 0, 5, 1, 2);
> 
> 	/* filename part */
> 	/* curdir should get a value */
> 	bf_label_tad_with_markup(_("<b>General</b>"), 0, 0.5, table, 0, 3, 2, 3);
> 
> 	bf_mnemonic_label_tad_with_alignment(_("Base_dir:"), tfs->basedir, 0, 0.5, table, 1, 2, 3, 4);
> 	gtk_table_attach_defaults(GTK_TABLE(table), tfs->basedir, 2, 4, 3, 4);
> 	gtk_table_attach(GTK_TABLE(table), bf_allbuttons_backend(_("_Browse..."), TRUE, 112, G_CALLBACK(files_advanced_win_select_basedir_lcb), tfs), 4, 5, 3, 4, GTK_SHRINK, GTK_SHRINK, 0, 0);
> 
> /*	g_free(curdir);*/
> 	
> 	list = g_list_append(NULL, "*");
> 	list = g_list_append(list, "*.php");
> 	list = g_list_append(list, "*.php3");
> 	list = g_list_append(list, "*.html");
> 	list = g_list_append(list, "*.htm");
> 	list = g_list_append(list, "*.shtml");
> 	list = g_list_append(list, "*.pl");
> 	list = g_list_append(list, "*.cgi");
> 	list = g_list_append(list, "*.xml");
> 	list = g_list_append(list, "*.c");
> 	list = g_list_append(list, "*.h");
> 	list = g_list_append(list, "*.py");
> 	list = g_list_append(list, "*.java");
> 	tfs->find_pattern = combo_with_popdown("*", list, 1);
> 	bf_mnemonic_label_tad_with_alignment(_("_File Type:"), tfs->find_pattern, 0, 0.5, table, 1, 2, 4, 5);
> 	gtk_table_attach_defaults(GTK_TABLE(table), tfs->find_pattern, 2, 4, 4, 5);
> 
> 	g_list_free(list);
> 
> 	tfs->recursive = checkbut_with_value(NULL, 1);
> 	bf_mnemonic_label_tad_with_alignment(_("_Recursive:"), tfs->recursive, 0, 0.5, table, 1, 2, 5, 6);
> 	gtk_table_attach_defaults(GTK_TABLE(table), tfs->recursive, 2, 3, 5, 6);	
> 	
> 	/* content */
> 	gtk_table_set_row_spacing(GTK_TABLE(table), 5, 18);
> 	bf_label_tad_with_markup(_("<b>Contains</b>"), 0, 0.5, table, 0, 3, 6, 7);
> 
> 	tfs->grep_pattern = entry_with_text(NULL, 255);
> 	bf_mnemonic_label_tad_with_alignment(_("Pa_ttern:"), tfs->grep_pattern, 0, 0.5, table, 1, 2, 7, 8);
> 	gtk_table_attach_defaults(GTK_TABLE(table), tfs->grep_pattern, 2, 4, 7, 8);
> 	
> 	tfs->is_regex = checkbut_with_value(NULL, 0);
> 	bf_mnemonic_label_tad_with_alignment(_("Is rege_x:"), tfs->is_regex, 0, 0.5, table, 1, 2, 8, 9);
> 	gtk_table_attach_defaults(GTK_TABLE(table), tfs->is_regex, 2, 3, 8, 9);
> 	
> 	/* buttons */
> 	hbox = gtk_hbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(hbox), gtk_hseparator_new(), TRUE, TRUE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 12);
> 	hbox = gtk_hbutton_box_new();
> 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
> 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 12);
> 	but = bf_stock_cancel_button(G_CALLBACK(files_advanced_win_cancel_clicked), tfs);
> 	gtk_box_pack_start(GTK_BOX(hbox),but , FALSE, FALSE, 0);
> 	but = bf_stock_ok_button(G_CALLBACK(files_advanced_win_ok_clicked), tfs);
> 	gtk_box_pack_start(GTK_BOX(hbox),but , FALSE, FALSE, 0);
> 	gtk_window_set_default(GTK_WINDOW(tfs->win), but);
> 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
> 	gtk_widget_show_all(GTK_WIDGET(tfs->win));
> /*	gtk_grab_add(GTK_WIDGET(tfs->win));
> 	gtk_widget_realize(GTK_WIDGET(tfs->win));*/
> 	gtk_window_set_transient_for(GTK_WINDOW(tfs->win), GTK_WINDOW(tfs->bfwin->main_window));
> }
> 
> GList *return_files_advanced(Tbfwin *bfwin, gchar *tmppath) {
>   Tfiles_advanced tfs = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, bfwin};
> 	if (tmppath) {
> 		GtkWidget *curdir = entry_with_text(tmppath, 255);
> 		tfs.basedir = curdir;
> 	}
> 		/* this is probably called different!! */
> 	files_advanced_win(&tfs);
> 	DEBUG_MSG("return_files_advanced, calling gtk_main()\n");
> 	gtk_main();
> 	return tfs.filenames_to_return;
> }	
> #endif /* EXTERNAL_FIND */
> #endif /* EXTERNAL_GREP */
> 
> void file_open_from_selection(Tbfwin *bfwin) {
> 	gchar *string;
> 	GtkClipboard* cb;
> 
> 	cb = gtk_clipboard_get(GDK_SELECTION_PRIMARY);
> 	string = gtk_clipboard_wait_for_text(cb);
> 	if (string) {
> 		DEBUG_MSG("file_open_from_selection, opening %s\n",string);
> 		if (NULL == strchr(string,'/') && bfwin->current_document->filename) {
> 			/* now we should look in the directory of the current file */
> 			gchar *dir, *tmp;
> 			dir = g_path_get_dirname(bfwin->current_document->filename);
> 			tmp = g_strconcat(dir, "/", string, NULL);
> 			DEBUG_MSG("file_open_from_selection, trying %s\n",tmp);
> 			doc_new_with_file(bfwin,tmp,FALSE,FALSE);
> 			g_free(dir);
> 			g_free(tmp);
> 		} else {
> 			doc_new_with_file(bfwin,string,FALSE,FALSE);
> 		}
> 		g_free(string);
> 	}
> }
> 
> /**
>  * file_save_cb:
>  * @widget: unused #GtkWidget
>  * @bfwin: #Tbfwin* with the current window
>  *
>  * Save the current document.
>  *
>  * Return value: void
>  **/
> void file_save_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 	doc_save(bfwin->current_document, FALSE, FALSE, FALSE);
> }
> 
> /**
>  * file_save_as_cb:
>  * @widget: unused #GtkWidget
>  * @bfwin: #Tbfwin* with the current window
>  *
>  * Save current document, let user choose filename.
>  *
>  * Return value: void
>  **/
> void file_save_as_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 	doc_save(bfwin->current_document, TRUE, FALSE, FALSE);
> }
> 
> /**
>  * file_move_to_cb:
>  * @widget: unused #GtkWidget
>  * @bfwin: #Tbfwin* with the current window
>  *
>  * Move current document, let user choose filename.
>  *
>  * Return value: void
>  **/
> void file_move_to_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 	doc_save(bfwin->current_document, TRUE, TRUE, FALSE);
> }
> 
> #ifdef HAVE_GNOME_VFS
> typedef struct {
> 	Tbfwin *bfwin;
> 	GtkWidget *win;
> 	GtkWidget *entry;
> } Tou;
> static void open_url_destroy_lcb(GtkWidget *widget, Tou *ou) {
> 	g_free(ou);
> }
> static void open_url_cancel_lcb(GtkWidget *widget, Tou *ou) {
> 	gtk_widget_destroy(ou->win);
> }
> static void open_url_ok_lcb(GtkWidget *widget, Tou *ou) {
> 	gchar *url = gtk_editable_get_chars(GTK_EDITABLE(GTK_COMBO(ou->entry)->entry),0,-1);
> 	doc_new_with_file(ou->bfwin,url,FALSE,FALSE);
> 	g_free(url);
> 	gtk_widget_destroy(ou->win);
> }
> 
> /**
>  * file_open_url_cb:
>  * @widget: #GtkWidget* ignored
>  * @bfwin: #Tbfwin* bfwin pointer
>  *
>  * opens a dialog where you can enter an URL to open of any kind
>  * supported by gnome-vfs
>  *
>  * Return value: void
>  **/
> void file_open_url_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 	GtkWidget *vbox, *hbox, *but;
> 	Tou *ou;
> 	GList *urlhistory = NULL, *tmplist = NULL;
> 	ou = g_new(Tou,1);
> 	ou->bfwin = bfwin;
> 	ou->win = window_full2(_("Open URL"), GTK_WIN_POS_CENTER_ON_PARENT, 12
> 			, G_CALLBACK(open_url_destroy_lcb), ou, TRUE, bfwin->main_window);
> 	gtk_widget_set_size_request(ou->win, 450, 140);
> 	vbox = gtk_vbox_new(FALSE,5);
> 	gtk_box_pack_start(GTK_BOX(vbox), bf_label_with_markup(_("<b>Open URL</b>")), FALSE, FALSE, 5);
> 	gtk_container_add(GTK_CONTAINER(ou->win),vbox);
> 	tmplist = g_list_first(bfwin->session->recent_files);
> 	while (tmplist) {
> 		if (NULL != strchr(tmplist->data, ':')) {
> 			urlhistory = g_list_append(urlhistory, g_strdup(tmplist->data));
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	ou->entry = boxed_combo_with_popdown("", urlhistory, TRUE, vbox);
> 	free_stringlist(urlhistory);
> /*	ou->entry = boxed_entry_with_text("", 255, vbox); */
> 	gtk_box_pack_start(GTK_BOX(vbox), gtk_hseparator_new(), FALSE, FALSE, 5);
> 	hbox = gtk_hbutton_box_new();
> 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
> 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 6);
> 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);
> 	but = bf_stock_cancel_button(G_CALLBACK(open_url_cancel_lcb), ou);
> 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, TRUE, 0);
> 	but = bf_stock_ok_button(G_CALLBACK(open_url_ok_lcb), ou);
> 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, TRUE, 0);
> 	gtk_window_set_default(GTK_WINDOW(ou->win), but);
> 	gtk_widget_show_all(ou->win);
> }
> #endif /* HAVE_GNOME_VFS */
> /**
>  * file_open_cb:
>  * @widget: unused #GtkWidget
>  * @bfwin: #Tbfwin* with the current window
>  *
>  * Prompt user for files to open.
>  *
>  * Return value: void
>  **/
> void file_open_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 	GList *tmplist = NULL;
> 	DEBUG_MSG("file_open_cb, started, calling return_files()\n");
> #ifdef HAVE_ATLEAST_GTK_2_4
> 	{
> 		GtkWidget *dialog;
> 		GSList *slist;
> #ifdef HAVE_GNOME_VFS
> 		gboolean localonly = FALSE;
> #else
> 	gboolean localonly = TRUE;
> #endif /* HAVE_GNOME_VFS */
> 		dialog = file_chooser_dialog(bfwin, _("Select files"), GTK_FILE_CHOOSER_ACTION_OPEN, NULL, localonly, TRUE, NULL);
> 		if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
> #ifdef HAVE_GNOME_VFS
> 			slist = gtk_file_chooser_get_uris(GTK_FILE_CHOOSER(dialog));
> #else
> 			slist = gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(dialog));
> #endif /* HAVE_GNOME_VFS */
> 			tmplist = glist_from_gslist(slist);
> 			g_slist_free(slist);
> 		}
> 		gtk_widget_destroy(dialog);
> 	}
> #else
> 	tmplist = return_files(NULL);
> #endif
> 	if (!tmplist) {
> 		return;
> 	}
> 	{
> 		gint len = g_list_length(tmplist);
> 		gchar *message = g_strdup_printf(_("Loading %d file(s)..."), len);
> 		statusbar_message(bfwin,message,2000+len*50);
> 		g_free(message);
> 		flush_queue();
> 	}
> 	DEBUG_MSG("file_open_cb, calling docs_new_from_files()\n");
> 	docs_new_from_files(bfwin,tmplist, FALSE);
> 	free_stringlist(tmplist);
> }
> #ifdef EXTERNAL_GREP
> #ifdef EXTERNAL_FIND
> void file_open_advanced_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 	GList *tmplist;
> 	tmplist = return_files_advanced(bfwin, NULL);
> 	if (!tmplist) {
> 		return;
> 	}
> 	{
> 		gint len = g_list_length(tmplist);
> 		gchar *message = g_strdup_printf(_("Loading %d file(s)..."), len);
> 		statusbar_message(bfwin,message,2000+len*50);
> 		g_free(message);
> 		flush_queue();
> 	}
> 	docs_new_from_files(bfwin,tmplist, FALSE);
> 	free_stringlist(tmplist);
> }
> 
> void open_advanced_from_filebrowser(Tbfwin *bfwin, gchar *path) {
> 	GList *tmplist;
> 	tmplist = return_files_advanced(bfwin, path);
> 	if (!tmplist) {
> 		return;
> 	}
> 	{
> 		gint len = g_list_length(tmplist);
> 		gchar *message = g_strdup_printf(_("Loading %d file(s)..."), len);
> 		statusbar_message(bfwin,message,2000+len*50);
> 		g_free(message);
> 		flush_queue();
> 	}
> 	docs_new_from_files(bfwin,tmplist,FALSE);
> 	free_stringlist(tmplist);
> }
> #endif
> #endif
> 
> /**
>  * file_insert_menucb:
>  * @bfwin: Tbfwin* which window
>  * @callback_action: unused #guint
>  * @widget: #GtkWidget* unused
>  *
>  * Prompt user for a file, and insert the contents into the current document.
>  *
>  * Return value: void
>  **/
> void file_insert_menucb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
> 	gchar *tmpfilename=NULL;
> #ifdef HAVE_ATLEAST_GTK_2_4
> 	{
> 		GtkWidget *dialog;
> 		dialog = file_chooser_dialog(bfwin, _("Select file to insert"), GTK_FILE_CHOOSER_ACTION_OPEN, NULL, FALSE, FALSE, NULL);
> 		if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT) {
> 			tmpfilename = gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(dialog));
> 		}
> 		gtk_widget_destroy(dialog);
> 	}
> #else 
> 	tmpfilename = return_file_w_title(NULL, _("Select file to insert"));
> #endif
> 	if (tmpfilename == NULL) {
> 		statusbar_message(bfwin,_("No file to insert"), 2000);
> 		return;
> 	} else {
> 		/* do we need to set the insert point in some way ?? */
>         doc_unre_new_group(bfwin->current_document);
> 		doc_file_to_textbox(bfwin->current_document, tmpfilename, TRUE, FALSE);
> 		g_free(tmpfilename);
> 		doc_set_modified(bfwin->current_document, 1);
> 	}
> }
> 
> /**
>  * file_new_cb:
>  * @windget: #GtkWidget* ignored
>  * @bfwin: Tbfwin* where to open the new document
>  *
>  * Create a new, empty file in window bfwin
>  *
>  * Return value: void
>  **/
> void file_new_cb(GtkWidget *widget, Tbfwin *bfwin) {
> 	Tdocument *doc;
> 	doc = doc_new(bfwin, FALSE);
> 	switch_to_document_by_pointer(bfwin,doc);
>  	if (bfwin->project && bfwin->project->template && strlen(bfwin->project->template) > 2) {
> 		doc_file_to_textbox(doc, bfwin->project->template, FALSE, FALSE);
> 		doc_activate(doc);
>  	}
> }
> 
> /**
>  * file_close_cb:
>  * @widget: unused #GtkWidget
>  * @data: unused #gpointer
>  *
>  * Close the current document.
>  *
>  * Return value: void
>  **/
> void file_close_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 	doc_close(bfwin->current_document, 0);
> }
> 
> void bfwin_close_all_documents(Tbfwin *bfwin, gboolean window_closing) {
> 	GList *tmplist;
> 	Tdocument *tmpdoc;
> 	gint retval = -1;
> 
> 	DEBUG_MSG("file_close_all_cb, started\n");
> 
> 	/* first a warning loop */
> 	if (test_docs_modified(bfwin->documentlist)) {
> 		if (g_list_length (bfwin->documentlist) > 1) {
> 			gchar *options[] = {_("_Save All"), _("Close _All"), _("Choose per _File"), _("_Cancel"), NULL};
> 			retval = multi_query_dialog(bfwin->main_window,_("Multiple open files have been changed."), 
> 										_("If you don't save your changes they will be lost."), 3, 3, options);
> 			if (retval == 3) {
> 			DEBUG_MSG("file_close_all_cb, cancel clicked, returning 0\n");
> 			return;
> 			}
> 		} else {
> 			retval = 2;
> 		}
> 	} else {
> 		retval = 1;
> 	}
> 	DEBUG_MSG("file_close_all_cb, after the warnings, retval=%d, now close all the windows\n", retval);
> 
> 	tmplist = g_list_first(bfwin->documentlist);
> 	while (tmplist) {
> 		tmpdoc = (Tdocument *) tmplist->data;
> 		if (test_only_empty_doc_left(bfwin->documentlist)) {
> 			return;
> 		}
> 		
> 		switch (retval) {
> 		case 0:
> 			doc_save(tmpdoc, FALSE, FALSE, window_closing);
> 			if (!tmpdoc->modified) {
> 				doc_destroy(tmpdoc, TRUE);
> 			} else {
> 				return;
> 			}
> 			tmplist = g_list_first(bfwin->documentlist);
> 		break;
> 		case 1:
> 			doc_destroy(tmpdoc, TRUE);
> 			tmplist = g_list_first(bfwin->documentlist);
> 		break;
> 		case 2:
> 			if (doc_close(tmpdoc, 0) != 2) {
> 				tmplist = g_list_first(bfwin->documentlist);
> 			} else {
> /*				notebook_changed();*/
> 				return;
> 			}
> 		break;
> 		default:
> /*			notebook_changed();*/
> 			return;
> 		break;
> 		}
> 	}
> 	notebook_changed(bfwin,-1);
> 	DEBUG_MSG("file_close_all_cb, finished\n");
> }
> 
> /**
>  * file_close_all_cb:
>  * @widget: unused #GtkWidget
>  * @bfwin: #Tbfwin* 
>  *
>  * Close all open files. Prompt user when neccessary.
>  *
>  * Return value: void
>  **/
> void file_close_all_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 	bfwin_close_all_documents(bfwin, FALSE);
> }
> 
> 
> /**
>  * file_save_all_cb:
>  * @widget: unused #GtkWidget
>  * @data: unused #gpointer
>  *
>  * 	Save all editor notebooks
>  *
>  * Return value: void
>  **/
> void file_save_all_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 
> 	GList *tmplist;
> 	Tdocument *tmpdoc;
> 
> 	tmplist = g_list_first(bfwin->documentlist);
> 	while (tmplist) {
> 		tmpdoc = (Tdocument *) tmplist->data;
> 		if (tmpdoc->modified) {
> 			doc_save(tmpdoc, FALSE, FALSE, FALSE);
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> /**
>  * edit_cut_cb:
>  * @widget: unused #GtkWidget
>  * @data: unused #gpointer
>  *
>  * 	Cut selection from current buffer, to clipboard.
>  *
>  * Return value: void
>  **/
> void edit_cut_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 	doc_unre_new_group(bfwin->current_document);
> 	gtk_text_buffer_cut_clipboard(bfwin->current_document->buffer,gtk_clipboard_get(GDK_SELECTION_CLIPBOARD),TRUE);
> 	doc_unre_new_group(bfwin->current_document);
> }
> 
> /**
>  * edit_copy_cb:
>  * @widget: unused #GtkWidget
>  * @data: unused #gpointer
>  *
>  * 	Copy selection from current buffer, to clipboard.
>  *
>  * Return value: void
>  **/
> void edit_copy_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 	gtk_text_buffer_copy_clipboard(bfwin->current_document->buffer,gtk_clipboard_get(GDK_SELECTION_CLIPBOARD));
> }
> 
> /**
>  * edit_paste_cb:
>  * @widget: unused #GtkWidget
>  * @data: unused #gpointer
>  *
>  * 	Paste contents of clipboard. Disable highlighting while pasting, for speed.
>  *
>  * Return value: void
>  **/
> void edit_paste_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 	GtkTextMark *mark;
> 	Tdocument *doc = bfwin->current_document;
> 	DEBUG_MSG("edit_paste_cb, started\n");
> 	if (!doc->paste_operation) {
> 		doc->paste_operation = g_new(Tpasteoperation,1);
> 		PASTEOPERATION(doc->paste_operation)->so = -1;
> 		PASTEOPERATION(doc->paste_operation)->eo = -1;
> 	}
> 	doc_unre_new_group(doc);
> 
> 	DEBUG_MSG("edit_paste_cb, pasting clipboard\n");
> 	gtk_text_buffer_paste_clipboard (doc->buffer,gtk_clipboard_get(GDK_SELECTION_CLIPBOARD),NULL,TRUE);
> 
> 	doc_unre_new_group(doc);
> 	if (PASTEOPERATION(doc->paste_operation)->eo > PASTEOPERATION(doc->paste_operation)->so) {
> 		DEBUG_MSG("edit_paste_cb, start doc_highlight_region for so=%d, eo=%d\n",PASTEOPERATION(doc->paste_operation)->so,PASTEOPERATION(doc->paste_operation)->eo);
> 		doc_highlight_region(doc, PASTEOPERATION(doc->paste_operation)->so, PASTEOPERATION(doc->paste_operation)->eo);
> 	}
> 	g_free(doc->paste_operation);
> 	doc->paste_operation = NULL;
> 	
> 	mark = gtk_text_buffer_get_insert(bfwin->current_document->buffer);
> 	gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(bfwin->current_document->view), mark); 
> 	DEBUG_MSG("edit_paste_cb, finished\n");
> }
> 
> /**
>  * edit_select_all_cb:
>  * @widget: unused #GtkWidget
>  * @data: unused #gpointer
>  *
>  * Mark entire current document as selected.
>  *
>  * Return value: void
>  **/
> void edit_select_all_cb(GtkWidget * widget, Tbfwin *bfwin) {
> 	GtkTextIter itstart, itend;
> 	gtk_text_buffer_get_bounds(bfwin->current_document->buffer,&itstart,&itend);
> 	gtk_text_buffer_move_mark_by_name(bfwin->current_document->buffer,"insert",&itstart);
> 	gtk_text_buffer_move_mark_by_name(bfwin->current_document->buffer,"selection_bound",&itend);
> }
> 
> /**
>  * doc_toggle_highlighting_cb:
>  * @callback_data: unused #gpointer
>  * @action: unused #guint
>  * @widget: unused #GtkWidget*
>  *
>  * Toggle highlighting on/off for current document.
>  *
>  * Return value: void
>  **/
> void doc_toggle_highlighting_cb(Tbfwin *bfwin,guint action,GtkWidget *widget) {
> 	bfwin->current_document->highlightstate = 1 - bfwin->current_document->highlightstate;
> 	DEBUG_MSG("doc_toggle_highlighting_cb, started, highlightstate now is %d\n", bfwin->current_document->highlightstate);
> 	if (bfwin->current_document->highlightstate == 0) {
> 		doc_remove_highlighting(bfwin->current_document);
> 	} else {
> 		doc_highlight_full(bfwin->current_document);
> 	}
> }
> 
> /**
>  * all_documents_apply_settings:
>  *
>  * applies changes from the preferences to all documents
>  *
>  * Return value: void
>  */
> void all_documents_apply_settings() {
> 	GList *tmplist = g_list_first(return_allwindows_documentlist());
> 	while (tmplist){
> 		Tdocument *doc = tmplist->data;
> 		doc_set_tabsize(doc, main_v->props.editor_tab_width);
> 		doc_set_font(doc, main_v->props.editor_font_string);
> 		tmplist = g_list_next(tmplist);
> 	}
> 
> }
> 
> /**
>  * doc_convert_asciichars_in_selection:
>  * @callback_data: unused #gpointer
>  * @callback_action: #guint type of chars to change
>  * @widget: unused #GtkWidget*
>  *
>  * Convert characters in current document to entities.
>  * callback_action set to 1 (only ascii), 2 (only iso) or 3 (both).
>  * or 4 (ToUppercase) or 5 (ToLowercase)
>  *
>  * Return value: void
>  **/
> void doc_convert_asciichars_in_selection(Tbfwin *bfwin,guint callback_action,GtkWidget *widget) {
> 	if (callback_action >= 4) {
> 		doc_convert_case_in_selection(bfwin->current_document, (callback_action == 4));
> 	} else {
> 		doc_convert_chars_to_entities_in_selection(bfwin->current_document, (callback_action != 2), (callback_action != 1));
> 	}
> }
> 
> /**
>  * doc_toggle_highlighting_cb:
>  * @callback_data: unused #gpointer
>  * @action: unused #guint
>  * @widget: unused #GtkWidget*
>  *
>  * Show word-, line- and charcount for current document in the statusbar.
>  * Note: The wordcount() call returns number of actual utf8-chars, not bytes.
>  *
>  * Return value: void
>  **/
> void word_count_cb (Tbfwin *bfwin,guint callback_action,GtkWidget *widget) {
> 	guint chars = 0, lines = 0, words = 0;
> 	gchar *allchars, *wc_message;
> 	
>    allchars = doc_get_chars(bfwin->current_document, 0, -1);
> 	wordcount(allchars, &chars, &lines, &words);
> 	g_free(allchars);
> 	
> 	wc_message = g_strdup_printf(_("Statistics: %d lines, %d words, %d characters"), lines, words, chars);
> 	statusbar_message (bfwin,wc_message, 5000);
> 	g_free (wc_message);
> }
> 
> /**
>  * doc_toggle_highlighting_cb:
>  * @doc: a #Tdocument*
>  * @unindent: #gboolean
>  *
>  * Indent the selected block in current document.
>  * Set unindent to TRUE to unindent.
>  *
>  * Return value: void
>  **/
> void doc_indent_selection(Tdocument *doc, gboolean unindent) {
> 	GtkTextIter itstart,itend;
> 	if (gtk_text_buffer_get_selection_bounds(doc->buffer,&itstart,&itend)) {
> 		GtkTextMark *end;
> /*		gboolean firstrun=TRUE;*/
> 
> 		doc_unbind_signals(doc);
> 		doc_unre_new_group(doc);
> 		/* we have a selection, now we loop trough the characters, and for every newline
> 		we add or remove a tab, we set the end with a mark */
> 		end = gtk_text_buffer_create_mark(doc->buffer,NULL,&itend,TRUE);
> 		if (gtk_text_iter_get_line_offset(&itstart)>0) {
> 			gtk_text_iter_set_line_index(&itstart,0);
> 		}	
> 		while(gtk_text_iter_compare(&itstart,&itend) < 0) {
> 			GtkTextMark *cur;
> /*			if (firstrun && !gtk_text_iter_starts_line(&itstart)) {
> 				gtk_text_iter_forward_line(&itstart);
> 			}
> 			firstrun = FALSE;*/
> 			cur = gtk_text_buffer_create_mark(doc->buffer,NULL,&itstart,TRUE);
> 			if (unindent) {
> 				/* when unindenting we try to set itend to the end of the indenting step
> 				which might be a tab or 'tabsize' spaces, then we delete that part */
> 				gboolean cont=TRUE;
> 				gchar *buf = NULL;
> 				gunichar cchar = gtk_text_iter_get_char(&itstart);
> 				if (cchar == 9) { /* 9 is ascii for tab */
> 					itend = itstart;
> 					cont = gtk_text_iter_forward_char(&itend);
> 					buf = g_strdup("\t");
> 				} else if (cchar == 32) { /* 32 is ascii for space */
> 					gint i=0;
> 					itend = itstart;
> 					gtk_text_iter_forward_chars(&itend,main_v->props.editor_tab_width);
> 					buf = gtk_text_buffer_get_text(doc->buffer,&itstart,&itend,FALSE);
> 					DEBUG_MSG("tab_width=%d, strlen(buf)=%d, buf='%s'\n",main_v->props.editor_tab_width,strlen(buf),buf);
> 					while (cont && buf[i] != '\0') {
> 						cont = (buf[i] == ' ');
> 						DEBUG_MSG("doc_indent_selection, buf[%d]='%c'\n",i,buf[i]);
> 						i++;
> 					}
> 					if (!cont) {
> 						g_free (buf);
> 					}
> 				} else {
> 					cont = FALSE;
> 				}
> 				if (cont) {
> 					gint offsetstart, offsetend;				
> 					offsetstart = gtk_text_iter_get_offset(&itstart);
> 					offsetend = gtk_text_iter_get_offset(&itend);
> 					gtk_text_buffer_delete(doc->buffer,&itstart,&itend);
> 					doc_unre_add(doc, buf, offsetstart, offsetend, UndoDelete);
> 					g_free (buf);
> 				}
> #ifdef DEBUG
> 				else {
> 					DEBUG_MSG("doc_indent_selection, NOT continue!!\n");
> 				}
> #endif
> 			} else { /* indent */
> 				gint offsetstart = gtk_text_iter_get_offset(&itstart);
> 				gchar *indentstring;
> 				gint indentlen;
> 				if (main_v->props.editor_indent_wspaces) {
> 					indentstring = bf_str_repeat(" ", main_v->props.editor_tab_width);
> 					indentlen = main_v->props.editor_tab_width;
> 				} else {
> 					indentstring = g_strdup("\t");
> 					indentlen=1;
> 				}
> 				gtk_text_buffer_insert(doc->buffer,&itstart,indentstring,indentlen);
> 				doc_unre_add(doc, indentstring, offsetstart, offsetstart+indentlen, UndoInsert);
> 				g_free(indentstring);
> 			}
> 			gtk_text_buffer_get_iter_at_mark(doc->buffer,&itstart,cur);
> 			gtk_text_buffer_get_iter_at_mark(doc->buffer,&itend,end);
> 			gtk_text_buffer_delete_mark(doc->buffer,cur);
> 			gtk_text_iter_forward_line(&itstart);
> 			DEBUG_MSG("doc_indent_selection, itstart at %d, itend at %d\n",gtk_text_iter_get_offset(&itstart),gtk_text_iter_get_offset(&itend));
> 		}
> 		gtk_text_buffer_delete_mark(doc->buffer,end);
> 		doc_bind_signals(doc);
> 		doc_set_modified(doc, 1);
> 	} else {
> 		/* there is no selection, work on the current line */
> 		GtkTextIter iter;
> 		gtk_text_buffer_get_iter_at_mark(doc->buffer,&iter,gtk_text_buffer_get_insert(doc->buffer));
> 		gtk_text_iter_set_line_offset(&iter,0);
> 		if (unindent) {
> 			gint deletelen = 0;
> 			gchar *tmpstr, *tmp2str;
> 			GtkTextIter itend = iter;
> 			gtk_text_iter_forward_chars(&itend,main_v->props.editor_tab_width);
> 			tmpstr = gtk_text_buffer_get_text(doc->buffer,&iter,&itend,FALSE);
> 			tmp2str = bf_str_repeat(" ", main_v->props.editor_tab_width);
> 			if (tmpstr[0] == '\t') {
> 				deletelen = 1;
> 			} else if (tmpstr && strncmp(tmpstr,tmp2str,main_v->props.editor_tab_width)==0) {
> 				deletelen = main_v->props.editor_tab_width;
> 			}
> 			g_free(tmpstr);
> 			g_free(tmp2str);
> 			if (deletelen) {
> 				itend = iter;
> 				gtk_text_iter_forward_chars(&itend,deletelen);
> 				gtk_text_buffer_delete(doc->buffer,&iter,&itend);
> 			}
> 		} else { /* indent */
> 			gchar *indentstring;
> 			gint indentlen;
> 			if (main_v->props.editor_indent_wspaces) {
> 				indentstring = bf_str_repeat(" ", main_v->props.editor_tab_width);
> 				indentlen = main_v->props.editor_tab_width;
> 			} else {
> 				indentstring = g_strdup("\t");
> 				indentlen=1;
> 			}
> 			gtk_text_buffer_insert(doc->buffer,&iter,indentstring,indentlen);
> 			g_free(indentstring);
> 		}
> 	}
> }
> 
> void menu_indent_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
> 	if (bfwin->current_document) {
> 		doc_indent_selection(bfwin->current_document, (callback_action == 1));
> 	}
> }
> 
> /**
>  * list_relative_document_filenames:
>  * @curdoc: #Tdocument: the current document
>  *
>  * this function will generate a stringlist with a relative links to 
>  * all other open documents. This list should be freed using free_stringlist()
>  *
>  * Return value: #GList with strings
>  */
> GList *list_relative_document_filenames(Tdocument *curdoc) {
> 	GList *tmplist, *retlist=NULL;
> 	if (curdoc->filename == NULL) {
> 		return NULL;
> 	} 
> 	tmplist = g_list_first(BFWIN(curdoc->bfwin)->documentlist);
> 	while (tmplist) {
> 		Tdocument *tmpdoc = tmplist->data;
> 		if (tmpdoc != curdoc && tmpdoc->filename != NULL) {
> 			retlist = g_list_append(retlist,create_relative_link_to(curdoc->filename, tmpdoc->filename));
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return retlist;
> }
> 
> static void floatingview_destroy_lcb(GtkWidget *widget, Tdocument *doc) {
> 	DEBUG_MSG("floatingview_destroy_lcb, called for doc=%p, doc->floatingview=%p\n",doc,doc->floatingview);
> 	if (doc->floatingview) {
> 		gtk_widget_destroy(FLOATINGVIEW(doc->floatingview)->window);
> 		g_free(doc->floatingview);
> 		doc->floatingview = NULL;
> 	}
> }
> 
> static void new_floatingview(Tdocument *doc) {
> 	Tfloatingview *fv;
> 	gchar *title;
> 	GtkWidget *scrolwin;
> 	if (doc->floatingview) {
> 		fv = FLOATINGVIEW(doc->floatingview);
> 		gtk_window_present(GTK_WINDOW(fv->window));
> 		return;
> 	} 
> 	fv = g_new(Tfloatingview,1);
> 	doc->floatingview = fv;
> 	DEBUG_MSG("new_floatingview for doc=%p is at %p\n",doc,doc->floatingview);
> 	title = (doc->filename) ? doc->filename : "Untitled";
> 	fv->window = window_full2(title, GTK_WIN_POS_NONE, 5, G_CALLBACK(floatingview_destroy_lcb), doc, TRUE, NULL);
> 	gtk_window_set_role(GTK_WINDOW(fv->window), "floatingview");
> 	fv->textview = gtk_text_view_new_with_buffer(doc->buffer);
> 	gtk_text_view_set_editable(GTK_TEXT_VIEW(fv->textview),FALSE);
> 	gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(fv->textview),FALSE);
> 	apply_font_style(fv->textview, main_v->props.editor_font_string);
> 	gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(fv->textview), GTK_WRAP_WORD);
> 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
> 	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolwin), fv->textview);
> 	gtk_container_add(GTK_CONTAINER(fv->window),scrolwin);
> 	gtk_window_set_default_size(GTK_WINDOW(fv->window),600,600);
> 	gtk_widget_show_all(fv->window);
> }
> 
> void file_floatingview_menu_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
> 	new_floatingview(bfwin->current_document);
> }
1,2378c1,2373
< /* Bluefish HTML Editor
<  * fref.c - function reference file
<  *
<  * Copyright (C) 2003-2006 Oliver Sessink and Oskar Swida
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< /*
<  * indent --line-length 100 --k-and-r-style --tab-size 4 -bbo --ignore-newlines 
<  */
< 
< #include <gtk/gtk.h>
< #include <string.h>
< #include <gdk/gdkkeysyms.h>
< 
< /* #define DEBUG */
< 
< #include "bluefish.h"
< #include "fref.h"
< #include "rcfile.h"				/* array_from_arglist() */
< #include "stringlist.h"
< #include "document.h"
< #include "bf_lib.h"
< #include "gtk_easy.h"
< #include "char_table.h"
< #include "treetips.h"
< 
< enum {
< 	FREF_ACTION_INSERT,
< 	FREF_ACTION_DIALOG,
< 	FREF_ACTION_INFO
< };
< 
< enum {
< 	FREF_IT_DESC,
< 	FREF_IT_ATTRS,
< 	FREF_IT_NOTES
< };
< 
< enum {
< 	STR_COLUMN,
< 	PTR_COLUMN,
< 	FILE_COLUMN,
< 	N_COLUMNS
< };
< 
< #define FR_TYPE_TAG         1
< #define FR_TYPE_FUNCTION    2
< #define FR_TYPE_CLASS       3
< #define FR_TYPE_GROUP       4
< 
< #define MAX_NEST_LEVEL      20
< 
< typedef struct {
< 	gpointer data;
< 	Tbfwin *bfwin;
< } Tcallbackdata;
< 
< typedef struct {
< 	gchar *name;
< 	gchar *title;
< 	gchar *description;
< 	gchar *def_value;
< 	gboolean required;
< 	gboolean has_list;
< 	gchar *values;
< 	GtkWidget *dlg_item;
< } FRAttrInfo;
< 
< typedef struct {
< 	gchar *name;
< 	gchar *title;
< 	gchar *description;
< 	gchar *def_value;
< 	gchar *type;
< 	gboolean required;
< 	gboolean has_list;
< 	gchar *values;
< 	GtkWidget *dlg_item;
< } FRParamInfo;
< 
< 
< typedef struct {
< 	gchar type;
< 	gchar *name;
< 	gchar *description;
< 	gchar *tip;
< 	gchar *return_type;			/* if function */
< 	gchar *return_description;	/* if function */
< 	GList *attributes;
< 	GList *params;
< 	GList *methods;
< 	gchar *info_text;
< 	gchar *info_title;
< 	gchar *dialog_text;
< 	gchar *dialog_title;
< 	gchar *insert_text;
< } FRInfo;
< 
< typedef struct {
< 	FRInfo *act_info;
< 	FRInfo *act_grp;
< 	FRAttrInfo *act_attr;
< 	FRParamInfo *act_param;
< 	GtkWidget *tree;
< 	GtkTreeStore *store;
< 	GtkTreeIter grp_parent[MAX_NEST_LEVEL];
< 	gint nest_level;
< 	GtkTreeIter parent;
< 	gint state;
< 	gint pstate;
< 	gint vstate;
< 	GHashTable *dict;
< } FRParseAux;
< 
< #define FR_LOADER_STATE_NONE            1
< #define FR_LOADER_STATE_TAG             2
< #define FR_LOADER_STATE_FUNC            3
< #define FR_LOADER_STATE_CLASS           4
< #define FR_LOADER_STATE_ATTR            5
< #define FR_LOADER_STATE_PARAM           6
< #define FR_LOADER_STATE_TIP             7
< #define FR_LOADER_STATE_DESCR           8
< #define FR_LOADER_STATE_INFO            9
< #define FR_LOADER_STATE_DIALOG          10
< #define FR_LOADER_STATE_INSERT          11
< #define FR_LOADER_STATE_VALLIST         12
< #define FR_LOADER_STATE_RETURN          13
< #define FR_LOADER_STATE_GROUPDESC       14
< 
< #define FR_INFO_TITLE    1
< #define FR_INFO_DESC     2
< #define FR_INFO_ATTRS    3
< #define FR_INFO_NOTES    4
< 
< #define FR_COL_1    "#4B6983"
< #define FR_COL_2    "#7590AE"
< #define FR_COL_3    "#666666"
< #define FR_COL_4    "#FFFFFF"
< 
< GtkWidget *fref_prepare_dialog(Tbfwin * bfwin, FRInfo * entry);
< 
< typedef struct {
< 	GtkWidget *tree;
< 	GtkTooltips *argtips;
< 	GtkWidget *infocheck;
< 	GtkWidget *infoview;
< 	GtkWidget *infoscroll;
< 	Tbfwin *bfwin;
< 	TreeTips *tips;
< } Tfref_gui;
< 
< #define FREFGUI(var) ((Tfref_gui *)(var))
< 
< typedef struct {
< 	GtkTreeStore *store;
< 	GHashTable *refcount;		/* Opened reference count */
< } Tfref_data;
< #define FREFDATA(var) ((Tfref_data *)(var))
< 
< typedef struct {
< 	gchar *name;
< 	gchar *description;
< } Tfref_name_data;
< 
< #ifdef DEBUG
< static void free_with_print(gpointer ptr)
< {
< 	DEBUG_MSG("free_wp: free'ing %p\n", ptr);
< 	g_free(ptr);
< }
< #endif
< void fref_free_info(FRInfo * info)
< {
< 	FRAttrInfo *tmpa;
< 	FRParamInfo *tmpp;
< 	GList *lst;
< 	DEBUG_MSG("fref_free_info, freeing info->name=%s\n", info->name);
< 	g_free(info->name);
< 	g_free(info->description);
< 	g_free(info->tip);
< 	g_free(info->return_type);
< 	g_free(info->return_description);
< 	g_free(info->info_text);
< 	g_free(info->info_title);
< 	g_free(info->dialog_text);
< 	g_free(info->dialog_title);
< 	g_free(info->insert_text);
< 	if (info->attributes) {
< 		lst = g_list_first(info->attributes);
< 		while (lst) {
< 			tmpa = (FRAttrInfo *) lst->data;
< 			g_free(tmpa->name);
< 			g_free(tmpa->title);
< 			g_free(tmpa->description);
< 			g_free(tmpa->def_value);
< 			g_free(tmpa->values);
< 			g_free(tmpa);
< 			lst = g_list_next(lst);
< 		}
< 		g_list_free(info->attributes);
< 	}							/* attributes */
< 	if (info->params) {
< 		lst = g_list_first(info->params);
< 		while (lst) {
< 			tmpp = (FRParamInfo *) lst->data;
< 			g_free(tmpp->name);
< 			g_free(tmpp->title);
< 			g_free(tmpp->description);
< 			g_free(tmpp->def_value);
< 			g_free(tmpp->type);
< 			g_free(tmpp->values);
< 			g_free(tmpp);
< 			lst = g_list_next(lst);
< 		}
< 		g_list_free(info->params);
< 	}
< 	/* params */
< 	/* methods */
< 	g_free(info);
< }
< 
< void fref_name_loader_start_element(GMarkupParseContext * context, const gchar * element_name,
< 									const gchar ** attribute_names, const gchar ** attribute_values,
< 									gpointer user_data, GError ** error)
< {
< 	GHashTable *attrs;
< 	int i;
< 	Tfref_name_data *data;
< 	gchar *tmps;
< 
< 	if (user_data == NULL)
< 		return;
< 	data = (Tfref_name_data *) user_data;
< 
< 	attrs = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
< 	i = 0;
< 	while (attribute_names[i] != NULL) {
< 		g_hash_table_insert(attrs, (gpointer) g_strdup(attribute_names[i]),
< 							(gpointer) g_strdup(attribute_values[i]));
< 		i++;
< 	}
< 
< 	if (strcmp(element_name, "ref") == 0) {
< 		tmps = g_hash_table_lookup(attrs, "name");
< 		if (tmps != NULL)
< 			data->name = g_strdup(tmps);
< 		tmps = g_hash_table_lookup(attrs, "description");
< 		if (tmps != NULL)
< 			data->description = g_strdup(tmps);
< 	}
< 	g_hash_table_destroy(attrs);
< }
< 
< void fref_loader_start_element(GMarkupParseContext * context, const gchar * element_name,
< 							   const gchar ** attribute_names, const gchar ** attribute_values,
< 							   gpointer user_data, GError ** error)
< {
< 	FRParseAux *aux;
< 	FRInfo *info;
< 	FRAttrInfo *tmpa;
< 	FRParamInfo *tmpp;
< 	GHashTable *attrs;
< 	int i;
< 	gpointer pomstr;
< 	GtkTreeIter iter;
< 	GtkTreeRowReference *rref;
< 	GtkTreePath *path = NULL;
< 	gchar *string = NULL;
< 
< 	if (user_data == NULL)
< 		return;
< 	aux = (FRParseAux *) user_data;
< 	attrs = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
< 	i = 0;
< 	while (attribute_names[i] != NULL) {
< 		g_hash_table_insert(attrs, (gpointer) g_strdup(attribute_names[i]),
< 							(gpointer) g_strdup(attribute_values[i]));
< 		i++;
< 	}
< 
< 	switch (aux->state) {
< 
< 	case FR_LOADER_STATE_NONE:
< 		if (strcmp(element_name, "group") == 0) {
< 			if (aux->nest_level < MAX_NEST_LEVEL) {
< 				info = g_new0(FRInfo, 1);
< 				info->type = FR_TYPE_GROUP;
< 				info->name = g_strdup(g_hash_table_lookup(attrs, "name"));
< 				gtk_tree_store_append(aux->store, &iter, &aux->parent);
< 				string = g_strdup(g_hash_table_lookup(attrs, "name"));
< 				gtk_tree_store_set(aux->store, &iter, STR_COLUMN,
< 								   string, FILE_COLUMN, NULL, PTR_COLUMN, info, -1);
< 				g_free (string);
< 				aux->grp_parent[aux->nest_level] = aux->parent;
< 				aux->parent = iter;
< 			} else
< 				g_warning("Maximum nesting level reached!");
< 			(aux->nest_level)++;
< 		} else if (strcmp(element_name, "description") == 0) {	/* group description */
< 			FRInfo *tmpinfo;
< 			gtk_tree_model_get(GTK_TREE_MODEL(aux->store), &aux->parent, PTR_COLUMN, &tmpinfo, -1);
< 			if (tmpinfo != NULL) {
< 				aux->pstate = FR_LOADER_STATE_NONE;
< 				aux->state = FR_LOADER_STATE_GROUPDESC;
< 			}
< 		} else if (strcmp(element_name, "tag") == 0) {
< 			aux->state = FR_LOADER_STATE_TAG;
< 			aux->pstate = FR_LOADER_STATE_NONE;
< 			info = g_new0(FRInfo, 1);
< 			info->type = FR_TYPE_TAG;
< 			info->name = g_strdup(g_hash_table_lookup(attrs, "name"));
< 			gtk_tree_store_append(aux->store, &iter, &aux->parent);
< 			gtk_tree_store_set(aux->store, &iter, STR_COLUMN, info->name, PTR_COLUMN, info,
< 							   FILE_COLUMN, NULL, -1);
< 			aux->act_info = info;
< 			path = gtk_tree_model_get_path(GTK_TREE_MODEL(aux->store), &iter);
< 			rref = gtk_tree_row_reference_new(GTK_TREE_MODEL(aux->store), path);
< 			g_hash_table_insert(aux->dict, g_strdup(info->name), rref);
< 		} else if (strcmp(element_name, "function") == 0) {
< 			aux->state = FR_LOADER_STATE_FUNC;
< 			aux->pstate = FR_LOADER_STATE_NONE;
< 			info = g_new0(FRInfo, 1);
< 			info->type = FR_TYPE_FUNCTION;
< 			info->name = g_strdup(g_hash_table_lookup(attrs, "name"));
< 			gtk_tree_store_append(aux->store, &iter, &aux->parent);
< 			gtk_tree_store_set(aux->store, &iter, STR_COLUMN, info->name, PTR_COLUMN, info, -1);
< 			aux->act_info = info;
< 			path = gtk_tree_model_get_path(GTK_TREE_MODEL(aux->store), &iter);
< 			rref = gtk_tree_row_reference_new(GTK_TREE_MODEL(aux->store), path);
< 			g_hash_table_insert(aux->dict, g_strdup(info->name), rref);
< 		} else if (strcmp(element_name, "class") == 0) {
< 			aux->state = FR_LOADER_STATE_CLASS;
< 			aux->pstate = FR_LOADER_STATE_NONE;
< 			info = g_new0(FRInfo, 1);
< 			info->type = FR_TYPE_CLASS;
< 			info->name = g_strdup(g_hash_table_lookup(attrs, "name"));
< 			gtk_tree_store_append(aux->store, &iter, &aux->parent);
< 			gtk_tree_store_set(aux->store, &iter, STR_COLUMN, info->name, PTR_COLUMN, info, -1);
< 			aux->act_info = info;
< 			path = gtk_tree_model_get_path(GTK_TREE_MODEL(aux->store), &iter);
< 			rref = gtk_tree_row_reference_new(GTK_TREE_MODEL(aux->store), path);
< 			g_hash_table_insert(aux->dict, g_strdup(info->name), rref);
< 		} else if (strcmp(element_name, "ref") == 0) {
< 		} else
< 			g_warning("FREF Config Error: Unknown element %s", element_name);
< 		break;					/* state NONE */
< 
< 
< 	case FR_LOADER_STATE_TAG:
< 		if (strcmp(element_name, "description") == 0) {
< 			aux->state = FR_LOADER_STATE_DESCR;
< 			aux->pstate = FR_LOADER_STATE_TAG;
< 		} else if (strcmp(element_name, "tip") == 0) {
< 			aux->state = FR_LOADER_STATE_TIP;
< 			aux->pstate = FR_LOADER_STATE_TAG;
< 		} else if (strcmp(element_name, "attribute") == 0) {
< 			aux->state = FR_LOADER_STATE_ATTR;
< 			aux->pstate = FR_LOADER_STATE_TAG;
< 			tmpa = g_new0(FRAttrInfo, 1);
< 			tmpa->name = g_strdup(g_hash_table_lookup(attrs, "name"));
< 			tmpa->title = g_strdup(g_hash_table_lookup(attrs, "title"));
< 			pomstr = g_hash_table_lookup(attrs, "required");
< 			if (pomstr != NULL
< 				&& (g_strcasecmp(pomstr, "y") == 0 || g_strcasecmp(pomstr, "1") == 0))
< 				tmpa->required = TRUE;
< 			else
< 				tmpa->required = FALSE;
< 			pomstr = g_hash_table_lookup(attrs, "vallist");
< 			if (pomstr != NULL
< 				&& (g_strcasecmp(pomstr, "y") == 0 || g_strcasecmp(pomstr, "1") == 0))
< 				tmpa->has_list = TRUE;
< 			else
< 				tmpa->has_list = FALSE;
< 			tmpa->def_value = g_strdup(g_hash_table_lookup(attrs, "default"));
< 			aux->act_attr = tmpa;
< 			aux->act_info->attributes = g_list_append(aux->act_info->attributes, tmpa);
< 		} else if (strcmp(element_name, "dialog") == 0) {
< 			aux->state = FR_LOADER_STATE_DIALOG;
< 			aux->pstate = FR_LOADER_STATE_TAG;
< 			aux->act_info->dialog_title = g_strdup(g_hash_table_lookup(attrs, "title"));
< 		} else if (strcmp(element_name, "info") == 0) {
< 			aux->state = FR_LOADER_STATE_INFO;
< 			aux->pstate = FR_LOADER_STATE_TAG;
< 			aux->act_info->info_title = g_strdup(g_hash_table_lookup(attrs, "title"));
< 		} else if (strcmp(element_name, "insert") == 0) {
< 			aux->state = FR_LOADER_STATE_INSERT;
< 			aux->pstate = FR_LOADER_STATE_TAG;
< 		} else
< 			g_warning("FREF Config Error: Unknown tag (%s)", element_name);
< 		break;					/* state TAG */
< 	case FR_LOADER_STATE_FUNC:
< 		if (strcmp(element_name, "description") == 0) {
< 			aux->state = FR_LOADER_STATE_DESCR;
< 			aux->pstate = FR_LOADER_STATE_FUNC;
< 		} else if (strcmp(element_name, "tip") == 0) {
< 			aux->state = FR_LOADER_STATE_TIP;
< 			aux->pstate = FR_LOADER_STATE_FUNC;
< 		} else if (strcmp(element_name, "param") == 0) {
< 			aux->state = FR_LOADER_STATE_PARAM;
< 			aux->pstate = FR_LOADER_STATE_FUNC;
< 			tmpp = g_new0(FRParamInfo, 1);
< 			tmpp->name = g_strdup(g_hash_table_lookup(attrs, "name"));
< 			tmpp->title = g_strdup(g_hash_table_lookup(attrs, "title"));
< 			pomstr = g_hash_table_lookup(attrs, "required");
< 			if (pomstr != NULL
< 				&& (g_strcasecmp(pomstr, "y") == 0 || g_strcasecmp(pomstr, "1") == 0))
< 				tmpp->required = TRUE;
< 			else
< 				tmpp->required = FALSE;
< 			pomstr = g_hash_table_lookup(attrs, "vallist");
< 			if (pomstr != NULL
< 				&& (g_strcasecmp(pomstr, "y") == 0 || g_strcasecmp(pomstr, "1") == 0))
< 				tmpp->has_list = TRUE;
< 			else
< 				tmpp->has_list = FALSE;
< 			tmpp->def_value = g_strdup(g_hash_table_lookup(attrs, "default"));
< 			tmpp->type = g_strdup(g_hash_table_lookup(attrs, "type"));
< 			aux->act_param = tmpp;
< 			aux->act_info->params = g_list_append(aux->act_info->params, tmpp);
< 		} else if (strcmp(element_name, "return") == 0) {
< 			aux->state = FR_LOADER_STATE_RETURN;
< 			aux->pstate = FR_LOADER_STATE_FUNC;
< 			aux->act_info->return_type = g_strdup(g_hash_table_lookup(attrs, "type"));
< 		} else if (strcmp(element_name, "dialog") == 0) {
< 			aux->state = FR_LOADER_STATE_DIALOG;
< 			aux->pstate = FR_LOADER_STATE_FUNC;
< 			aux->act_info->dialog_title = g_strdup(g_hash_table_lookup(attrs, "title"));
< 		} else if (strcmp(element_name, "info") == 0) {
< 			aux->state = FR_LOADER_STATE_INFO;
< 			aux->pstate = FR_LOADER_STATE_FUNC;
< 			aux->act_info->info_title = g_strdup(g_hash_table_lookup(attrs, "title"));
< 		} else if (strcmp(element_name, "insert") == 0) {
< 			aux->state = FR_LOADER_STATE_INSERT;
< 			aux->pstate = FR_LOADER_STATE_FUNC;
< 		} else
< 			g_warning("FREF Config Error: Unknown tag (%s)", element_name);
< 		break;					/* state FUNC */
< 	case FR_LOADER_STATE_ATTR:
< 		if (strcmp(element_name, "vallist") == 0) {
< 			aux->state = FR_LOADER_STATE_VALLIST;
< 			aux->vstate = FR_LOADER_STATE_ATTR;
< 		} else
< 			g_warning("FREF Config Error: Unknown tag (%s)", element_name);
< 		break;					/* state ATTR */
< 	case FR_LOADER_STATE_PARAM:
< 		if (strcmp(element_name, "vallist") == 0) {
< 			aux->state = FR_LOADER_STATE_VALLIST;
< 			aux->vstate = FR_LOADER_STATE_PARAM;
< 		} else
< 			g_warning("FREF Config Error: Unknown tag (%s)", element_name);
< 		break;					/* state PARAM */
< 	}							/* switch */
< 
< 	if (path) gtk_tree_path_free (path);
< 	g_hash_table_destroy(attrs);
< }
< 
< void fref_loader_end_element(GMarkupParseContext * context, const gchar * element_name,
< 							 gpointer user_data, GError ** error)
< {
< 	FRParseAux *aux;
< 
< 	if (user_data == NULL)
< 		return;
< 	aux = (FRParseAux *) user_data;
< 	switch (aux->state) {
< 	case FR_LOADER_STATE_TAG:
< 		if (strcmp(element_name, "tag") == 0) {
< 			aux->act_info = NULL;
< 			aux->pstate = FR_LOADER_STATE_NONE;
< 		}
< 		break;					/* tag */
< 	case FR_LOADER_STATE_FUNC:
< 		if (strcmp(element_name, "function") == 0) {
< 			aux->act_info = NULL;
< 			aux->pstate = FR_LOADER_STATE_NONE;
< 		}
< 		break;					/* function */
< 	case FR_LOADER_STATE_ATTR:
< 		if (strcmp(element_name, "attribute") == 0) {
< 			aux->act_attr = NULL;
< 			aux->pstate = FR_LOADER_STATE_TAG;
< 		}
< 		break;					/* attribute */
< 	case FR_LOADER_STATE_PARAM:
< 		if (strcmp(element_name, "param") == 0) {
< 			aux->act_param = NULL;
< 			aux->pstate = FR_LOADER_STATE_FUNC;
< 		}
< 		break;					/* param */
< 	}							/* switch */
< 
< 	if (aux->state != FR_LOADER_STATE_VALLIST)
< 		aux->state = aux->pstate;
< 	else
< 		aux->state = aux->vstate;
< 
< 	if (strcmp(element_name, "group") == 0) {
< 		if (aux->nest_level > 0) {
< 			(aux->nest_level)--;
< 			if (aux->nest_level < MAX_NEST_LEVEL)
< 				aux->parent = aux->grp_parent[aux->nest_level];
< 		}
< 	}
< 
< }
< 
< void fref_loader_text(GMarkupParseContext * context, const gchar * _text, gsize _text_len,
< 					  gpointer user_data, GError ** error)
< {
< 	FRParseAux *aux;
< 	gchar *text;
< 	gint text_len;
< 	FRInfo *tmpinfo;
< 
< 	if (user_data == NULL && _text == NULL)
< 		return;
< 	/* remove white spaces from the begining and the end */
< 	text = g_strdup(_text);
< 	text = g_strstrip(text);
< 	text_len = strlen(text);
< 
< 	aux = (FRParseAux *) user_data;
< 	switch (aux->state) {
< 	case FR_LOADER_STATE_DESCR:
< 		aux->act_info->description = g_strndup(text, text_len);
< 		break;
< 	case FR_LOADER_STATE_TIP:
< 		aux->act_info->tip = g_strndup(text, text_len);
< 		break;
< 	case FR_LOADER_STATE_ATTR:
< 		aux->act_attr->description = g_strndup(text, text_len);
< 		break;
< 	case FR_LOADER_STATE_PARAM:
< 		aux->act_param->description = g_strndup(text, text_len);
< 		break;
< 	case FR_LOADER_STATE_RETURN:
< 		aux->act_info->return_description = g_strndup(text, text_len);
< 		break;
< 	case FR_LOADER_STATE_VALLIST:
< 		if (aux->vstate == FR_LOADER_STATE_ATTR)
< 			aux->act_attr->values = g_strndup(text, text_len);
< 		else if (aux->vstate == FR_LOADER_STATE_PARAM)
< 			aux->act_param->values = g_strndup(text, text_len);
< 		else
< 			g_warning("FREF Config Error: cannot assign vallist");
< 		break;
< 	case FR_LOADER_STATE_DIALOG:
< 		aux->act_info->dialog_text = g_strndup(text, text_len);
< 		break;
< 	case FR_LOADER_STATE_INFO:
< 		aux->act_info->info_text = g_strndup(text, text_len);
< 		break;
< 	case FR_LOADER_STATE_INSERT:
< 		aux->act_info->insert_text = g_strndup(text, text_len);
< 		break;
< 	case FR_LOADER_STATE_GROUPDESC:
< 		gtk_tree_model_get(GTK_TREE_MODEL(aux->store), &aux->parent, PTR_COLUMN, &tmpinfo, -1);
< 		if (tmpinfo != NULL) {
< 			/* BUG?? this appears as if it is freed in fref_free_info()
< 			 * but a small memory leak is shown when opening the HTML ref
< 			 */
< 			tmpinfo->description = g_strndup(text, text_len);
< 		}
< 		break;
< 	}							/* switch */
< 	g_free(text);
< }
< 
< void fref_loader_error(GMarkupParseContext * context, GError * error, gpointer user_data)
< {
< 	if (error != NULL)
< 		g_warning("FREF Config Error: %s", error->message);
< 	else
< 		g_warning("FREF Config Error: Unknown Error");
< }
< 
< /* CONFIG FILE PARSER */
< 
< static GMarkupParser FRParser = {
< 	fref_loader_start_element,
< 	fref_loader_end_element,
< 	fref_loader_text,
< 	NULL,
< 	fref_loader_error
< };
< 
< /* AUXILIARY FILE PARSER */
< 
< static GMarkupParser FRNameParser = {
< 	fref_name_loader_start_element,
< 	NULL,
< 	NULL,
< 	NULL,
< 	fref_loader_error
< };
< 
< gchar *fref_xml_get_refname(gchar * filename)
< {
< 	GMarkupParseContext *ctx;
< 	gchar *config, *refname;
< 	gsize len;
< 	Tfref_name_data *aux = NULL;
< 
< 	if (filename == NULL)
< 		return NULL;
< 
< 	aux = g_new0(Tfref_name_data, 1);
< 	ctx = g_markup_parse_context_new(&FRNameParser, (GMarkupParseFlags) 0, (gpointer) aux, NULL);
< 	if (ctx == NULL) {
< 		g_free(aux);
< 		return NULL;
< 	}
< 	if (!g_file_get_contents(filename, &config, &len, NULL)) {
< 		g_markup_parse_context_free(ctx);
< 		g_free(aux);
< 		return NULL;
< 	}
< 
< 	if (!g_markup_parse_context_parse(ctx, config, len, NULL)) {
< 		g_markup_parse_context_free(ctx);
< 		g_free(aux);
< 		g_free(config);
< 		return NULL;
< 	}
< 
< 	g_markup_parse_context_free(ctx);
< 	refname = aux->name;
< 	g_free(aux->description);
< 	g_free(aux);
< 	g_free(config);
< 	return refname;
< }
< 
< void fref_loader_load_ref_xml(gchar * filename, GtkWidget * tree, GtkTreeStore * store,
< 							  GtkTreeIter * parent, GHashTable * dict)
< {
< 	GMarkupParseContext *ctx;
< 	gchar *config;
< 	gsize len;
< 	FRParseAux *aux;
< 
< 	if (filename == NULL)
< 		return;
< 	aux = g_new0(FRParseAux, 1);
< 	aux->tree = tree;
< 	aux->store = store;
< 	aux->state = FR_LOADER_STATE_NONE;
< 	aux->parent = *parent;
< 	aux->nest_level = 0;
< 	aux->dict = dict;
< 
< 	ctx = g_markup_parse_context_new(&FRParser, (GMarkupParseFlags) 0, (gpointer) aux, NULL);
< 	if (ctx == NULL)
< 		return;
< 	if (!g_file_get_contents(filename, &config, &len, NULL)) {
< 		g_markup_parse_context_free(ctx);
< 		g_free(aux);
< 		return;
< 	}
< 	if (!g_markup_parse_context_parse(ctx, config, len, NULL)) {
< 		g_markup_parse_context_free(ctx);
< 		g_free(aux);
< 		g_free(config);
< 		return;
< 	}
< 	g_markup_parse_context_free(ctx);
< 	if (aux->act_info)
< 		fref_free_info(aux->act_info);
<     if (aux->act_grp)
<         fref_free_info(aux->act_grp);
< 	if (aux->act_attr) {
< 		g_free(aux->act_attr->name);
< 		g_free(aux->act_attr->title);
< 		g_free(aux->act_attr->description);
< 		g_free(aux->act_attr->def_value);
< 		g_free(aux->act_attr->values);
< 		g_free(aux->act_attr);
< 	}
< 	if (aux->act_param) {
< 		g_free(aux->act_param->name);
< 		g_free(aux->act_param->title);
< 		g_free(aux->act_param->description);
< 		g_free(aux->act_param->def_value);
< 		g_free(aux->act_param->type);
< 		g_free(aux->act_param->values);
< 		g_free(aux->act_param);
< 	}
< 	g_free(aux);
< 	g_free(config);
< }
< 
< void fref_loader_unload_ref(GtkTreeStore * store, GtkTreeIter * position)
< {
< 	GtkTreeIter iter;
< 	GtkTreePath *path;
< 
< 	path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), position);
< 	DEBUG_MSG("fref_loader_unload_ref, called for path %s\n", gtk_tree_path_to_string(path));
< 	while (gtk_tree_model_iter_children(GTK_TREE_MODEL(store), &iter, position)) {
< 		FRInfo *entry;
< 		gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, PTR_COLUMN, &entry, -1);
< 		if (gtk_tree_model_iter_has_child(GTK_TREE_MODEL(store), &iter)) {
< 			fref_loader_unload_ref(store, &iter);
< 			/* have not to free entry name, because this is a pointer to info field */
< 		}
< 		/* this is very crappy... on my OpenBSD box gtk_tree_store_remove() has a different
< 		   prototype, and it does *not* return a boolean, but just void, that means we can't 
< 		   use it to step trough the tree... */
< 		gtk_tree_store_remove(store, &iter);
< 		if (entry != NULL) {
< 			fref_free_info(entry);
< 		}
< 	}							/* while */
< 
< 	iter = *position;
< 	if (gtk_tree_path_get_depth(path) > 1) {
< 		gchar *name;
< 		DEBUG_MSG("fref_loader_unload_ref, path depth > 0\n");
< 		/*gtk_tree_model_get_iter(GTK_TREE_MODEL(store),&iter,path); */
< 		gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, STR_COLUMN, &name, -1);
< 		if (name) {
< 			/* have to free name column for group */
< 			DEBUG_MSG("fref_loader_unload_ref, free'ing %s\n", name);
< 			g_free(name);		/* freeing item name */
< 		}
< 	} else {					/* freeing search dictionary */
< 		GHashTable *dict;
< 		DEBUG_MSG("fref_loader_unload_ref, path depth == 0, this is the top node\n");
< 		/*gtk_tree_model_get_iter(GTK_TREE_MODEL(store),&iter,path);  */
< 		gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, PTR_COLUMN, &dict, -1);
< 		if (dict) {
< 			DEBUG_MSG("fref_loader_unload_ref, destroying search hashtable %p\n", dict);
< 			g_hash_table_destroy(dict);
< 			gtk_tree_store_set(store, &iter, PTR_COLUMN, NULL, -1);
< 		}
< 	}
< 	gtk_tree_path_free(path);
< 	DEBUG_MSG("fref_loader_unload, done\n");
< }
< 
< void fref_loader_unload_all(GtkWidget * tree, GtkTreeStore * store)
< {
< 
< 	GtkTreeIter iter;
< 	gint *cnt = NULL;
< 	gpointer *aux;
< 	gboolean do_unload = FALSE;
< 
< 	DEBUG_MSG("fref_loader_unload_all, started for tree=%p, store=%p\n", tree, store);
< 	while (gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(store), &iter, NULL, 0)) {
< 		GtkTreePath *path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &iter);
< 		if (gtk_tree_path_get_depth(path) == 1) {
< 			gchar *cat;
< 			gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, STR_COLUMN, &cat, -1);
< 			DEBUG_MSG("fref_loader_unload_all, cat=%s\n", cat);
< 			aux = g_hash_table_lookup(FREFDATA(main_v->frefdata)->refcount, cat);
< 			if (cat) 
< 				g_free (cat);
< 				
< 			if (aux != NULL) {
< 				cnt = (gint *) aux;
< 				*cnt = (*cnt) - 1;
< 				if (*cnt <= 0)
< 					do_unload = TRUE;
< 				else
< 					do_unload = FALSE;
< 				DEBUG_MSG("fref_loader_unload_all, cnt=%d, do_unload=%d\n", *cnt, do_unload);
< 			} else
< 				do_unload = FALSE;				
< 		} else
< 			do_unload = FALSE;
< 		if (do_unload) {
< 			gchar *file, *name;
< 			DEBUG_MSG("fref_loader_unload_all, calling fref_loader_unload_ref\n");
< 			fref_loader_unload_ref(store, &iter);
< 			gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, STR_COLUMN, &name, FILE_COLUMN, &file,
< 							   -1);
< 			if (file) {
< 				DEBUG_MSG("fref_loader_unload_all, freeing %s\n", file);
< 				g_free(file);
< 			}
< 			if (name) {
< 				DEBUG_MSG("fref_loader_unload_all, freeing %s\n", name);
< 				g_free(name);
< 			}
< 			gtk_tree_store_remove(store, &iter);
< 		}						/* do_unload */
< 		if (path)
< 			gtk_tree_path_free (path);
< 	}							/* while */
< 	/* gtk_tree_store_clear(store); */
< }
< 
< /* END OF CONFIG PARSER */
< 
< /* GUI */
< static void fill_toplevels(Tfref_data * fdata, gboolean empty_first)
< {
< 	GList *reflist;
< 	gint *cnt;
< 
< 	if (empty_first) {
< 		gtk_tree_store_clear(fdata->store);
< 	}
< 	/* prepare first nodes - read from configuration data */
< 	reflist = g_list_first(main_v->props.reference_files);
< 	while (reflist) {
< 		gchar **tmparray = reflist->data;
< 		if (count_array(tmparray) == 2) {
< 			if (file_exists_and_readable(tmparray[1])) {
< 				GtkTreeIter iter;
< 				GtkTreeIter iter2;
< 				gtk_tree_store_append(fdata->store, &iter, NULL);
< 				gtk_tree_store_set(fdata->store, &iter, STR_COLUMN, tmparray[0], PTR_COLUMN, NULL,
< 								   FILE_COLUMN, tmparray[1], -1);
< 				cnt = g_new0(gint, 1);
< 				*cnt = 0;
< 				g_hash_table_replace(fdata->refcount, g_strdup(tmparray[0]), cnt);
< 
< 				/* dummy node for er display */
< 				gtk_tree_store_append(fdata->store, &iter2, &iter);
< 			}
< 		}
< 		reflist = g_list_next(reflist);
< 	}
< }
< 
< void fref_cleanup(Tbfwin * bfwin)
< {
< 	DEBUG_MSG("fref_cleanup, started for bfwin=%p, refcount at %p\n", bfwin,
< 			  FREFDATA(main_v->frefdata)->refcount);
< 	fref_loader_unload_all(FREFGUI(bfwin->fref)->tree, FREFDATA(main_v->frefdata)->store);
< /*	g_hash_table_destroy(FREFDATA(main_v->frefdata)->refcount); */
< /* Ok I'll not free search dictionary too ... O.S. */
< 	FREFGUI(bfwin->fref)->tree = NULL;
< 	FREFGUI(bfwin->fref)->argtips = NULL;
< 	tree_tips_destroy(FREFGUI(bfwin->fref)->tips);
< 	g_free (bfwin->fref);
< 	bfwin->fref = NULL;
< }
< 
< /* fref_init is ONCE called by bluefish.c to init the fref_data structure */
< void fref_init()
< {
< 	Tfref_data *fdata = g_new(Tfref_data, 1);
< 	fdata->store = gtk_tree_store_new(N_COLUMNS, G_TYPE_STRING, G_TYPE_POINTER, G_TYPE_STRING);
< 	fdata->refcount = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
< 	fill_toplevels(fdata, FALSE);
< 	DEBUG_MSG("fref_init, refcount at %p\n", fdata->refcount);
< 	main_v->frefdata = fdata;
< }
< 
< /*------------ PREPARE INFO -----------------------*/
< gchar *fref_prepare_info(FRInfo * entry, gint infotype, gboolean use_colors)
< {
< 	gchar *ret, *tofree;
< 	GList *lst;
< 	FRAttrInfo *tmpa;
< 	FRParamInfo *tmpp;
< 
< 	ret = g_strdup("");
< 	switch (entry->type) {
< 	case FR_TYPE_GROUP:
< 		switch (infotype) {
< 		case FR_INFO_DESC:
< 			if (entry->description != NULL) {
< 				gchar *escaped = xml_escape(entry->description);
< 				tofree = ret;
< 				if (use_colors) {
< 
< 					ret =
< 						g_strconcat(ret, "<span size=\"small\"  foreground=\"#FFFFFF\" >       ",
< 									escaped, "</span>", NULL);
< 				} else {
< 					ret =
< 						g_strconcat(ret, "<span size=\"small\">       ", escaped, "</span>", NULL);
< 				}
< 				g_free(tofree);
< 				g_free(escaped);
< 			}
< 			break;
< 		}
< 		break;
< 	case FR_TYPE_TAG:
< 		switch (infotype) {
< 		case FR_INFO_TITLE:
< 			tofree = ret;
< 			if (use_colors)
< 				ret =
< 					g_strconcat(ret, "<span size=\"medium\" foreground=\"#FFFFFF\" >  TAG: <b>",
< 								entry->name, "</b></span>", NULL);
< 			else
< 				ret =
< 					g_strconcat(ret, "<span size=\"medium\">  TAG: <b>", entry->name, "</b></span>",
< 								NULL);
< 			g_free(tofree);
< 			break;
< 		case FR_INFO_DESC:
< 			if (entry->description != NULL) {
< 				gchar *escaped = xml_escape(entry->description);
< 				tofree = ret;
< 				if (use_colors)
< 					ret =
< 						g_strconcat(ret, "<span size=\"small\"  foreground=\"#FFFFFF\" >       ",
< 									escaped, "</span>", NULL);
< 				else
< 					ret =
< 						g_strconcat(ret, "<span size=\"small\">       ", escaped, "</span>", NULL);
< 				g_free(tofree);
< 				g_free(escaped);
< 			}
< 			break;
< 		case FR_INFO_NOTES:
< 			if (entry->info_text != NULL) {
< 				gchar *escaped = xml_escape(entry->info_text);
< 				tofree = ret;
< 
< 				if (use_colors)
< 					ret =
< 						g_strconcat(ret, "<span size=\"medium\" foreground=\"", FR_COL_4,
< 									"\" ><b>NOTES:</b> \n", escaped, "</span>", NULL);
< 				else
< 					ret =
< 						g_strconcat(ret, "<span size=\"medium\"><b>NOTES:</b> \n", escaped,
< 									"</span>", NULL);
< 				g_free(tofree);
< 				g_free(escaped);
< 			}
< 			break;
< 		case FR_INFO_ATTRS:
< 			lst = g_list_first(entry->attributes);
< 			while (lst) {
< 				gchar *escaped1, *escaped2;
< 				tmpa = (FRAttrInfo *) lst->data;
< 				tofree = ret;
< 				escaped1 = xml_escape(tmpa->name);
< 				escaped2 = xml_escape(tmpa->description);
< 				if (use_colors) 
< 					
< 					ret =
< 						g_strconcat(ret, "<span size=\"small\" >          <b><i>", escaped1,
< 									"</i></b></span> - <span size=\"small\" foreground=\"",
< 									FR_COL_3, "\" >", escaped2, "</span>\n", NULL);
< 				else
< 					ret =
< 						g_strconcat(ret, "<span size=\"small\" >          <b><i>", escaped1,
< 									"</i></b></span> - <span size=\"small\">", escaped2,
< 									"</span>\n", NULL);
< 				g_free(escaped1);
< 				g_free(escaped2);
< 				g_free(tofree);
< 				lst = g_list_next(lst);
< 			}
< 			break;
< 		}						/* switch infotype */
< 		break;					/* TAG */
< 	case FR_TYPE_FUNCTION:
< 		switch (infotype) {
< 		case FR_INFO_TITLE:
< 			tofree = ret;
< 			if (use_colors)
< 				ret =
< 					g_strconcat(ret,
< 								"<span size=\"medium\" foreground=\"#FFFFFF\" >  FUNCTION: <b>",
< 								entry->name, "</b></span>", NULL);
< 			else
< 				ret =
< 					g_strconcat(ret, "<span size=\"medium\">  FUNCTION: <b>", entry->name,
< 								"</b></span>", NULL);
< 			g_free(tofree);
< 			break;
< 		case FR_INFO_DESC:
< 			if (entry->description != NULL) {
< 				gchar *escaped = xml_escape(entry->description);
< 				tofree = ret;
< 				if (use_colors)
< 					ret =
< 						g_strconcat(ret, "<span size=\"small\" foreground=\"#FFFFFF\" >       <i>",
< 									escaped, "</i></span>\n", NULL);
< 				else
< 					ret =
< 						g_strconcat(ret, "<span size=\"small\">       <i>", escaped,
< 									"</i></span>\n", NULL);
< 				g_free(tofree);
< 				g_free(escaped);
< 			}
< 			if (entry->return_type != NULL) {
< 				tofree = ret;
< 				if (use_colors)
< 					ret =
< 						g_strconcat(ret, "<span size=\"medium\" foreground=\"", FR_COL_4,
< 									"\">       <b>RETURNS: ", entry->return_type, "</b></span>\n",
< 									NULL);
< 				else
< 					ret =
< 						g_strconcat(ret, "<span size=\"medium\">       <b>RETURNS: ",
< 									entry->return_type, "</b></span>\n", NULL);
< 				g_free(tofree);
< 			}
< 			if (entry->return_description != NULL) {
< 				tofree = ret;
< 				if (use_colors)
< 					ret =
< 						g_strconcat(ret, "<span size=\"small\" foreground=\"", FR_COL_4,
< 									"\">       ", entry->return_description, "</span>\n", NULL);
< 				else
< 					ret =
< 						g_strconcat(ret, "<span size=\"small\">       ", entry->return_description,
< 									"</span>\n", NULL);
< 				g_free(tofree);
< 			}
< 			break;
< 		case FR_INFO_NOTES:
< 			if (entry->info_text != NULL) {
< 				gchar *escaped = xml_escape(entry->info_text);
< 				tofree = ret;
< 				if (use_colors)
< 					ret =
< 						g_strconcat(ret, "<span size=\"medium\" foreground=\"", FR_COL_4,
< 									"\"><b>NOTES:</b> \n", escaped, "</span>", NULL);
< 				else
< 					ret =
< 						g_strconcat(ret, "<span size=\"medium\"><b>NOTES:</b> \n", escaped,
< 									"</span>", NULL);
< 				g_free(tofree);
< 				g_free(escaped);
< 			}
< 			break;
< 		case FR_INFO_ATTRS:
< 			lst = g_list_first(entry->params);
< 			while (lst) {
< 				tmpp = (FRParamInfo *) lst->data;
< 				tofree = ret;
< 				if (tmpp->description != NULL && tmpp->type != NULL) {
< 					gchar *escaped1, *escaped2, *escaped3;
< 					escaped1 = xml_escape(tmpp->name);
< 					escaped2 = xml_escape(tmpp->type);
< 					escaped3 = xml_escape(tmpp->description);
< 					if (use_colors)
< 						ret =
< 							g_strconcat(ret, "<span size=\"small\">          <b><i>", escaped1,
< 										"(", escaped2,
< 										")</i></b></span> - <span size=\"small\" foreground=\"",
< 										FR_COL_3, "\">", escaped3, "</span>\n", NULL);
< 					else
< 						ret =
< 							g_strconcat(ret, "<span size=\"small\">          <b><i>", escaped1,
< 										"(", escaped2, ")</i></b></span> - <span size=\"small\">",
< 										escaped3, "</span>\n", NULL);
< 					g_free(escaped1);
< 					g_free(escaped2);
< 					g_free(escaped3);
< 				} else if (tmpp->type != NULL) {
< 					gchar *escaped1, *escaped2;
< 					escaped1 = xml_escape(tmpp->name);
< 					escaped2 = xml_escape(tmpp->type);
< 					ret =
< 						g_strconcat(ret, "<span size=\"small\">          <b><i>", escaped1, "(",
< 									escaped2, ")</i></b></span>\n", NULL);
< 					g_free(escaped1);
< 					g_free(escaped2);
< 				} else {
< 					gchar *escaped1;
< 					escaped1 = xml_escape(tmpp->name);
< 					ret =
< 						g_strconcat(ret, "<span size=\"small\">          <b><i>", escaped1,
< 									"</i></b></span>\n", NULL);
< 					g_free(escaped1);
< 				}
< 				g_free(tofree);
< 				lst = g_list_next(lst);
< 			}
< 			break;
< 		}						/* switch infotype */
< 		break;
< 	}
< 	return ret;
< }
< 
< /*------------ SHOW INFO -----------------------*/
< static void info_window_close_lcb(GtkWidget * widget, gpointer data)
< {
< 	gtk_widget_destroy(data);
< }
< 
< 
< 
< gchar *fref_prepare_text(FRInfo * entry, GtkWidget * dialog)
< {
< 	/* Here attribute/param names have to be replaced by values from dialog */
< 	gchar *p, *prev, *stringdup, *tofree;
< 	gchar *tmp, *dest, *tmp3 = NULL;
< 	GList *lst;
< 	gint d1, d2;
< 	FRAttrInfo *tmpa;
< 	FRParamInfo *tmpp;
< 	const gchar *converted = NULL, *tmp2 = NULL;
< 
< 	dest = g_strdup("");
< 	stringdup = g_strdup(entry->dialog_text);
< 	prev = stringdup;
< 	p = strchr(prev, '%');
< 	while (p) {
< 		tmp = dest;
< 		*p = '\0';
< 		p++;
< 		if (*p == '%') {
< 			converted = "%";
< 		} else {
< 
< 			switch (entry->type) {
< 			case FR_TYPE_TAG:
< 				d1 = g_ascii_digit_value(*p);
< 				if (d1 != -1) {
< 					d2 = g_ascii_digit_value(*(p + 1));
< 					if (d2 != -1)
< 						d1 = d1 * 10 + d2;
< 					lst = g_list_nth(entry->attributes, d1);
< 					if (lst != NULL) {
< 						tmpa = (FRAttrInfo *) lst->data;
< 						if (tmpa->dlg_item) {
< 							if (GTK_IS_COMBO(tmpa->dlg_item))
< 								converted =
< 									gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(tmpa->dlg_item)->entry));
< 							else
< 								converted = gtk_entry_get_text(GTK_ENTRY(tmpa->dlg_item));
< 						} else
< 							converted = "";
< 					} else
< 						converted = "";
< 				} else if (*p == '_') {	/* non empty attributes */
< 					lst = g_list_first(entry->attributes);
< 					tmp3 = g_strdup("");
< 					while (lst != NULL) {
< 						tmpa = (FRAttrInfo *) lst->data;
< 						if (tmpa->dlg_item) {
< 							if (GTK_IS_COMBO(tmpa->dlg_item))
< 								tmp2 =
< 									gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(tmpa->dlg_item)->entry));
< 							else
< 								tmp2 = gtk_entry_get_text(GTK_ENTRY(tmpa->dlg_item));
< 							if (strcmp(tmp2, "") != 0) {
< 								tofree = tmp3;
< 								tmp3 = g_strconcat(tmp3, " ", tmpa->name, "=\"", tmp2, "\"", NULL);
< 								g_free(tofree);
< 							}
< 						}
< 						lst = g_list_next(lst);
< 					}			/* while */
< 					converted = tmp3;
< 				} else if (*p == '~') {	/* non empty attributes and required  */
< 					lst = g_list_first(entry->attributes);
< 					tmp3 = g_strdup("");
< 					while (lst != NULL) {
< 						tmpa = (FRAttrInfo *) lst->data;
< 						if (tmpa->dlg_item) {
< 							if (GTK_IS_COMBO(tmpa->dlg_item))
< 								tmp2 =
< 									gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(tmpa->dlg_item)->entry));
< 							else
< 								tmp2 = gtk_entry_get_text(GTK_ENTRY(tmpa->dlg_item));
< 							if (strcmp(tmp2, "") != 0 || tmpa->required) {
< 								tofree = tmp3;
< 								tmp3 = g_strconcat(tmp3, " ", tmpa->name, "=\"", tmp2, "\"", NULL);
< 								g_free(tofree);
< 							}
< 						}
< 						lst = g_list_next(lst);
< 					}			/* while */
< 					converted = tmp3;
< 				}				/* required and non-empty */
< 				break;
< 			case FR_TYPE_FUNCTION:
< 				d1 = g_ascii_digit_value(*p);
< 				if (d1 != -1) {
< 					d2 = g_ascii_digit_value(*(p + 1));
< 					if (d2 != -1)
< 						d1 = d1 * 10 + d2;
< 					lst = g_list_nth(entry->params, d1);
< 					if (lst != NULL) {
< 						tmpp = (FRParamInfo *) lst->data;
< 						if (tmpp->dlg_item) {
< 							if (GTK_IS_COMBO(tmpp->dlg_item))
< 								converted =
< 									gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(tmpp->dlg_item)->entry));
< 							else
< 								converted = gtk_entry_get_text(GTK_ENTRY(tmpp->dlg_item));
< 						} else
< 							converted = "";
< 					} else
< 						converted = "";
< 				}
< 				break;
< 
< 			}					/* switch */
< 		}
< 		dest = g_strconcat(dest, prev, converted, NULL);
< 		g_free(tmp);			/* here I free the dest (tmp=dest) */
< 		g_free(tmp3);
< 		prev = ++p;
< 		p = strchr(p, '%');
< 	}
< 	tmp = dest;
< 	dest = g_strconcat(dest, prev, NULL);
< 	g_free(tmp);
< 	g_free(stringdup);
< 	return dest;
< }
< 
< GList *fref_string_to_list(gchar * string, gchar * delimiter)
< {
< 	GList *lst;
< 	gchar **arr;
< 	gint i;
< 
< 	lst = NULL;
< 	arr = g_strsplit(string, delimiter, 0);
< 	i = 0;
< 	while (arr[i] != NULL) {
< 		lst = g_list_append(lst, arr[i]);
< 		i++;
< 	}
< 	return lst;
< }
< 
< 
< /* CALLBACKS */
< 
< static GtkWidget *togglemenuitem(GSList * group, gchar * name, gboolean selected,
< 								 GCallback toggledfunc, gpointer toggleddata)
< {
< 	GtkWidget *retval;
< 	retval = gtk_radio_menu_item_new_with_label(group, name);
< 	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(retval), selected);
< 	g_signal_connect(GTK_OBJECT(retval), "toggled", toggledfunc, toggleddata);
< 	DEBUG_MSG("togglemenuitem, created %p and set to %d\n", retval, selected);
< 	return retval;
< }
< 
< static void fref_ldblclck_changed(GtkWidget * widget, gpointer data)
< {
< 	if (GTK_CHECK_MENU_ITEM(widget)->active) {
< 		DEBUG_MSG("fref_ldblclck_changed, set to %d\n", GPOINTER_TO_INT(data));
< 		main_v->globses.fref_ldoubleclick_action = GPOINTER_TO_INT(data);
< 	}
< }
< 
< static void fref_infotype_changed(GtkWidget * widget, gpointer data)
< {
< 	if (GTK_CHECK_MENU_ITEM(widget)->active) {
< 		DEBUG_MSG("fref_infotype_changed, set to %d\n", GPOINTER_TO_INT(data));
< 		main_v->globses.fref_info_type = GPOINTER_TO_INT(data);
< 	}
< }
< 
< static FRInfo *get_current_entry(Tbfwin * bfwin)
< {
< 	GtkTreePath *path;
< 	GtkTreeViewColumn *col;
< 	gint depth;
< 	
< 	gtk_tree_view_get_cursor(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), &path, &col);
< 	depth = gtk_tree_path_get_depth (path);
< 	if (depth > 1) {
<         if (path != NULL) {
<     	    FRInfo *retval = NULL;
<     	    GValue *val;
<     	    GtkTreeIter iter;
<     	    gtk_tree_model_get_iter(gtk_tree_view_get_model(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree)),
<     	    						&iter, path);
<     	    gtk_tree_path_free(path);
<     	    val = g_new0(GValue, 1);
<     	    gtk_tree_model_get_value(gtk_tree_view_get_model(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree)),
<     	    						 &iter, 1, val);
<     	    if (G_IS_VALUE(val) && g_value_fits_pointer(val)) {
<     	    	retval = (FRInfo *) g_value_peek_pointer(val);
<     	    }
<     	    g_value_unset(val);
<     	    g_free(val);
<     	    return retval;
<         }
<     }
< 	return NULL;
< }
< 
< gboolean frefcb_info_keypress(GtkWidget * widget, GdkEventKey * event, Tcallbackdata * cd)
< {
< 	if (event->keyval == GDK_Escape && cd->data != NULL) {
< 		gtk_widget_destroy(GTK_WIDGET(cd->data));
< 		g_free(cd);
< 		return FALSE;
< 	}
< 	return TRUE;
< }
< 
< static void frefcb_info_close(GtkButton * button, Tcallbackdata * cd)
< {
< 	if (cd->data != NULL) {
< 		gtk_widget_destroy(GTK_WIDGET(cd->data));
< 	}
< 	g_free(cd);
< }
< 
< 
< static void frefcb_row_expanded(GtkTreeView * treeview, GtkTreeIter * arg1, GtkTreePath * arg2,
< 								gpointer user_data)
< {
< 	GValue *val;
< 	GtkTreeIter iter;
< 	gchar *cat;
< 	gint *cnt = NULL;
< 	gpointer *aux;
< 	gboolean do_load = FALSE;
< 	GHashTable *dict;
< 
< 	if (gtk_tree_path_get_depth(arg2) == 1) {
< 		val = g_new0(GValue, 1);
< 		gtk_tree_model_get_value(GTK_TREE_MODEL(user_data), arg1, 0, val);
< 		cat = (gchar *) (g_value_peek_pointer(val));
< 		aux = g_hash_table_lookup(FREFDATA(main_v->frefdata)->refcount, cat);
< 		if (aux != NULL) {
< 			cnt = (gint *) aux;
< 			*cnt = (*cnt) + 1;
< 			if (*cnt == 1)
< 				do_load = TRUE;
< 			else
< 				do_load = FALSE;
< 		} else
< 			do_load = FALSE;
< 		g_value_unset (val);
< 		g_free (val);
< 	} else
< 		do_load = FALSE;
< 	if (do_load) {
< 		val = g_new0(GValue, 1);
< 		gtk_tree_model_get_value(GTK_TREE_MODEL(user_data), arg1, 2, val);
< 		dict =
< 			g_hash_table_new_full(g_str_hash, g_str_equal, g_free,
< 								  (GDestroyNotify) gtk_tree_row_reference_free);
< 		DEBUG_MSG("frefcb_row_expanded, search hash_table at %p\n", dict);
< 		gtk_tree_store_set(GTK_TREE_STORE(user_data), arg1, PTR_COLUMN, dict, -1);
< 		if (G_IS_VALUE(val) && g_value_peek_pointer(val) != NULL) {
< 			fref_loader_load_ref_xml((gchar *) g_value_peek_pointer(val), GTK_WIDGET(treeview),
< 									 GTK_TREE_STORE(user_data), arg1, dict);
< 		}
< 
< 		/* remove dummy */
< 
< 		if (g_value_peek_pointer(val) != NULL
< 			&& gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(user_data), &iter, arg1, 0)) {
< 			gtk_tree_store_remove(GTK_TREE_STORE(user_data), &iter);
< 		}
< 		g_value_unset (val);
< 		g_free (val);
< 	}
< }
< 
< static void frefcb_info_dialog(GtkButton * button, Tcallbackdata * cd)
< {
< 	FRInfo *entry;
< 	GtkWidget *dialog;
< 	gchar *pomstr;
< 	gint resp;
< 	Tbfwin *bfwin = cd->bfwin;
< 
< 	if (cd->data != NULL) {
< 		gtk_widget_destroy(GTK_WIDGET(cd->data));
< 		g_free(cd);
< 	}
< 	entry = get_current_entry(bfwin);
< 	if (entry == NULL)
< 		return;
< 
< 	dialog = fref_prepare_dialog(bfwin, entry);
< 	if (dialog) {
< 		resp = gtk_dialog_run(GTK_DIALOG(dialog));
< 		if (resp == GTK_RESPONSE_OK) {
< 			pomstr = fref_prepare_text(entry, dialog);
< 			gtk_widget_destroy(dialog);
< 			doc_insert_two_strings(bfwin->current_document, pomstr, NULL);
< 			g_free(pomstr);
< 		} else
< 			gtk_widget_destroy(dialog);
< 	}
< }
< 
< static void frefcb_info_insert(GtkButton * button, Tcallbackdata * cd)
< {
< 	FRInfo *entry;
< 	Tbfwin *bfwin = cd->bfwin;
< 	if (cd->data != NULL) {
< 		gtk_widget_destroy(GTK_WIDGET(cd->data));
< 		g_free(cd);
< 	}
< 	entry = get_current_entry(bfwin);
< 	if (entry == NULL || entry->insert_text == NULL)
< 		return;
< 	doc_insert_two_strings(bfwin->current_document, entry->insert_text, NULL);
< 
< }
< 
< void fref_show_info(Tbfwin * bfwin, FRInfo * entry, gboolean modal, GtkWidget * parent)
< {
< 	GtkWidget *label_t, *frame, *scroll, *view, *btn1, *btn2, *btn3, *vbox, *hbox, *fourbox,
< 		*label_d, *label_a, *label_n, *ev_t, *ev_d, *ev_a, *ev_n;
< 	GtkWidget *info_window;
< 	Tcallbackdata *cd;
< 	GdkColor col1, col2, col4;
< 
< 	cd = g_new(Tcallbackdata, 1);
< 	gdk_color_parse(FR_COL_1, &col1);
< 	gdk_color_parse(FR_COL_2, &col2);
< 	gdk_color_parse(FR_COL_4, &col4);
< 
< 	label_t = gtk_label_new(fref_prepare_info(entry, FR_INFO_TITLE, TRUE));
< 	label_d = gtk_label_new(fref_prepare_info(entry, FR_INFO_DESC, TRUE));
< 	label_a = gtk_label_new(fref_prepare_info(entry, FR_INFO_ATTRS, TRUE));
< 	label_n = gtk_label_new(fref_prepare_info(entry, FR_INFO_NOTES, TRUE));
< 	gtk_label_set_use_markup(GTK_LABEL(label_t), TRUE);
< 	gtk_label_set_use_markup(GTK_LABEL(label_d), TRUE);
< 	gtk_label_set_use_markup(GTK_LABEL(label_a), TRUE);
< 	gtk_label_set_use_markup(GTK_LABEL(label_n), TRUE);
< 	gtk_misc_set_alignment(GTK_MISC(label_t), 0.0, 0.0);
< 	gtk_misc_set_padding(GTK_MISC(label_t), 5, 5);
< 	gtk_label_set_line_wrap(GTK_LABEL(label_t), TRUE);
< 	gtk_misc_set_alignment(GTK_MISC(label_d), 0.0, 0.0);
< 	gtk_misc_set_padding(GTK_MISC(label_d), 5, 5);
< 	gtk_label_set_line_wrap(GTK_LABEL(label_d), TRUE);
< 	gtk_misc_set_alignment(GTK_MISC(label_a), 0.0, 0.0);
< 	gtk_misc_set_padding(GTK_MISC(label_a), 5, 5);
< 	gtk_label_set_line_wrap(GTK_LABEL(label_a), TRUE);
< 	gtk_misc_set_alignment(GTK_MISC(label_n), 0.0, 0.0);
< 	gtk_misc_set_padding(GTK_MISC(label_n), 5, 5);
< 	gtk_label_set_line_wrap(GTK_LABEL(label_n), TRUE);
< 	ev_t = gtk_event_box_new();
< 	gtk_widget_modify_bg(GTK_WIDGET(ev_t), GTK_STATE_NORMAL, &col1);
< 	gtk_container_add(GTK_CONTAINER(ev_t), label_t);
< 	ev_d = gtk_event_box_new();
< 	gtk_widget_modify_bg(GTK_WIDGET(ev_d), GTK_STATE_NORMAL, &col2);
< 	gtk_container_add(GTK_CONTAINER(ev_d), label_d);
< 	ev_a = gtk_event_box_new();
< 	gtk_widget_modify_bg(GTK_WIDGET(ev_a), GTK_STATE_NORMAL, &col4);
< 	gtk_container_add(GTK_CONTAINER(ev_a), label_a);
< 	ev_n = gtk_event_box_new();
< 	gtk_widget_modify_bg(GTK_WIDGET(ev_n), GTK_STATE_NORMAL, &col1);
< 	gtk_container_add(GTK_CONTAINER(ev_n), label_n);
< 
< 	scroll = gtk_scrolled_window_new(NULL, NULL);
< 	btn2 = NULL;
< 	btn3 = NULL;
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_NEVER,
< 								   GTK_POLICY_AUTOMATIC);
< 	view =
< 		gtk_viewport_new(GTK_ADJUSTMENT(gtk_adjustment_new(0, 0, 1024, 1, 100, 200)),
< 						 GTK_ADJUSTMENT(gtk_adjustment_new(0, 0, 768, 1, 100, 200)));
< 	info_window = window_full2(_("Info"), GTK_WIN_POS_NONE, 0, G_CALLBACK(info_window_close_lcb)
< 							   , NULL, TRUE, FALSE);
< 
< 	if (modal) {
< 		gtk_window_set_modal(GTK_WINDOW(info_window), TRUE);
< 	}
< 
< 	fourbox = gtk_vbox_new(FALSE, 0);
< 
< 	frame = gtk_frame_new(NULL);
< 
< 	hbox = gtk_hbox_new(TRUE, 5);
< 
< 	gtk_container_add(GTK_CONTAINER(view), GTK_WIDGET(fourbox));
< 	gtk_box_pack_start(GTK_BOX(fourbox), ev_t, TRUE, TRUE, 0);
< 	gtk_box_pack_start(GTK_BOX(fourbox), ev_d, TRUE, TRUE, 0);
< 	gtk_box_pack_start(GTK_BOX(fourbox), ev_a, TRUE, TRUE, 0);
< 	gtk_box_pack_start(GTK_BOX(fourbox), ev_n, TRUE, TRUE, 0);
< 
< 	btn1 = gtk_button_new_with_label(_("Close"));
< 	gtk_box_pack_start(GTK_BOX(hbox), btn1, TRUE, TRUE, 5);
< 
< 	if (!modal) {
< 		btn2 = gtk_button_new_with_label(_("Dialog"));
< 		btn3 = gtk_button_new_with_label(_("Insert"));
< 		gtk_box_pack_start(GTK_BOX(hbox), btn2, TRUE, TRUE, 5);
< 		gtk_box_pack_start(GTK_BOX(hbox), btn3, TRUE, TRUE, 5);
< 	}
< 
< 	gtk_container_add(GTK_CONTAINER(scroll), GTK_WIDGET(view));
< 	gtk_container_add(GTK_CONTAINER(info_window), GTK_WIDGET(frame));
< 
< 	vbox = gtk_vbox_new(FALSE, 1);
< 	gtk_box_pack_start(GTK_BOX(vbox), scroll, TRUE, TRUE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 5);
< 
< 	gtk_container_add(GTK_CONTAINER(frame), GTK_WIDGET(vbox));
< 	gtk_container_set_border_width(GTK_CONTAINER(frame), 0);
< 	gtk_frame_set_label_widget(GTK_FRAME(frame), NULL);
< 
< 	gtk_widget_set_size_request(info_window, 400, 300);
< 	gtk_frame_set_shadow_type(GTK_FRAME(frame), GTK_SHADOW_ETCHED_IN);
< 
< 	cd->data = info_window;
< 	cd->bfwin = bfwin;
< 
< 	g_signal_connect(G_OBJECT(info_window), "key-press-event", G_CALLBACK(frefcb_info_keypress),
< 					 cd);
< 	g_signal_connect(G_OBJECT(btn1), "clicked", G_CALLBACK(frefcb_info_close), cd);
< 	if (!modal) {
< 		g_signal_connect(G_OBJECT(btn2), "clicked", G_CALLBACK(frefcb_info_dialog), cd);
< 		g_signal_connect(G_OBJECT(btn3), "clicked", G_CALLBACK(frefcb_info_insert), cd);
< 	}
< 	gtk_widget_show_all(info_window);
< }
< 
< void frefcb_info_show(GtkButton * button, Tbfwin * bfwin)
< {
< 	FRInfo *entry;
< 	entry = get_current_entry(bfwin);
< 	if (entry == NULL)
< 		return;
< 
< 	fref_show_info(bfwin, entry, TRUE, gtk_widget_get_toplevel(GTK_WIDGET(button)));
< }
< 
< GtkWidget *fref_prepare_dialog(Tbfwin * bfwin, FRInfo * entry)
< {
< 	GtkWidget *dialog;
< 	GtkWidget *vbox;
< 	GtkWidget *table;
< 	GtkWidget *label;
< 	GtkWidget *input;
< 	GtkWidget *combo;
< 	GtkWidget *dialog_action_area;
< 	GtkWidget *cancelbutton;
< 	GtkWidget *okbutton;
< 	GtkWidget *infobutton;
< 	GtkWidget *scroll;
< 	GtkRequisition req, req2;
< 	FRAttrInfo *attr = NULL;
< 	FRParamInfo *par = NULL;
< 	GList *list = NULL;
< 	gint itnum, w, h;
< 
< 	DEBUG_MSG("fref_prepare_dialog, started\n");
< 	dialog = gtk_dialog_new();
< 	if (entry->dialog_title != NULL)
< 		gtk_window_set_title(GTK_WINDOW(dialog), entry->dialog_title);
< 	vbox = GTK_DIALOG(dialog)->vbox;
< 
< 	scroll = gtk_scrolled_window_new(NULL, NULL);
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC,
< 								   GTK_POLICY_AUTOMATIC);
< 	gtk_widget_show(scroll);
< 
< 	gtk_widget_show(vbox);
< 
< 	switch (entry->type) {
< 	case FR_TYPE_TAG:
< 		list = entry->attributes;
< 		break;
< 	case FR_TYPE_FUNCTION:
< 		list = entry->params;
< 		break;
< 	case FR_TYPE_CLASS:
< 		list = NULL;
< 		break;
< 	}
< 	if (list == NULL) {
< 		gtk_widget_destroy(dialog);
< 		DEBUG_MSG("fref_prepare_dialog, list==NULL, aborting..\n");
< 		return NULL;
< 	}
< 
< 	table = gtk_table_new(g_list_length(list), 2, FALSE);
< 
< 
< 	gtk_box_pack_start(GTK_BOX(vbox), scroll, TRUE, TRUE, 0);
< 	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scroll), table);
< 
< 	switch (entry->type) {
< 	case FR_TYPE_TAG:
< 		{
< 			list = g_list_first(list);
< 			attr = (FRAttrInfo *) g_list_nth_data(list, 0);
< 			itnum = 0;
< 			while (itnum < g_list_length(list)) {
< 				if (attr->title != NULL) {
< 					label = gtk_label_new("");
< 					if (attr->required) {
< 						gchar *tofree =
< 							g_strconcat("<span color='#FF0000'>", attr->title, "</span>", NULL);
< 						gtk_label_set_markup(GTK_LABEL(label), tofree);
< 						g_free(tofree);
< 					} else {
< 						gtk_label_set_text(GTK_LABEL(label), attr->title);
< 					}
< 				} else {
< 					label = gtk_label_new("");
< 					if (attr->required) {
< 						gchar *tofree =
< 							g_strconcat("<span color='#FF0000'>", attr->name, "</span>", NULL);
< 						gtk_label_set_markup(GTK_LABEL(label), tofree);
< 						g_free(tofree);
< 					} else {
< 						gtk_label_set_text(GTK_LABEL(label), attr->name);
< 					}
< 				}
< 				gtk_widget_show(label);
< 				gtk_table_attach(GTK_TABLE(table), label, 0, 1, itnum, itnum + 1,
< 								 (GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 5, 6);
< 				gtk_label_set_justify(GTK_LABEL(label), GTK_JUSTIFY_LEFT);
< 				gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
< 				if (attr->has_list) {
< 					combo = gtk_combo_new();
< 					gtk_widget_show(combo);
< 					gtk_table_attach(GTK_TABLE(table), combo, 1, 2, itnum, itnum + 1,
< 									 (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
< 									 (GtkAttachOptions) (0), 5, 5);
< 					/*  gtk_combo_set_value_in_list(GTK_COMBO(combo), TRUE,
< 					   TRUE); */
< 					gtk_combo_set_popdown_strings(GTK_COMBO(combo),
< 												  fref_string_to_list(attr->values, ","));
< 					if (attr->def_value != NULL)
< 						gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), attr->def_value);
< 					attr->dlg_item = combo;
< 					gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, GTK_COMBO(combo)->entry,
< 										 attr->description, "");
< 				} else {
< 					input = gtk_entry_new();
< 					if (attr->def_value != NULL)
< 						gtk_entry_set_text(GTK_ENTRY(input), attr->def_value);
< 					gtk_widget_show(input);
< 					gtk_table_attach(GTK_TABLE(table), input, 1, 2, itnum, itnum + 1,
< 									 (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
< 									 (GtkAttachOptions) (0), 5, 5);
< 					attr->dlg_item = input;
< 					gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, input, attr->description,
< 										 "");
< 				}
< 				itnum++;
< 				attr = (FRAttrInfo *) g_list_nth_data(list, itnum);
< 			}
< 		};
< 		break;
< 	case FR_TYPE_FUNCTION:
< 		{
< 			list = g_list_first(list);
< 			par = (FRParamInfo *) g_list_nth_data(list, 0);
< 			itnum = 0;
< 			while (itnum < g_list_length(list)) {
< 				if (par->title != NULL) {
< 					label = gtk_label_new("");
< 					if (par->required) {
< 						gchar *tofree = NULL;
< 						if (par->type != NULL)
< 							tofree =
< 								g_strconcat("<span color='#FF0000'>", par->title, " (", par->type,
< 											") ", "</span>", NULL);
< 						else
< 							tofree =
< 								g_strconcat("<span color='#FF0000'>", par->title, " </span>", NULL);
< 						gtk_label_set_markup(GTK_LABEL(label), tofree);
< 						g_free(tofree);
< 					} else {
< 						gchar *tofree = NULL;
< 						if (par->type != NULL)
< 							tofree = g_strconcat(par->title, " (", par->type, ") ", NULL);
< 						else
< 							tofree = g_strconcat(par->title, " ", NULL);
< 						gtk_label_set_text(GTK_LABEL(label), tofree);
< 						g_free(tofree);
< 					}
< 				} else {
< 					label = gtk_label_new("");
< 					if (par->required) {
< 						gchar *tofree = NULL;
< 						if (par->type != NULL)
< 							tofree =
< 								g_strconcat("<span color='#FF0000'>", par->name, " (", par->type,
< 											") ", "</span>", NULL);
< 						else
< 							tofree =
< 								g_strconcat("<span color='#FF0000'>", par->name, " </span>", NULL);
< 						gtk_label_set_markup(GTK_LABEL(label), tofree);
< 						g_free(tofree);
< 					} else {
< 						gchar *tofree = NULL;
< 						if (par->type != NULL)
< 							tofree = g_strconcat(par->name, " (", par->type, ") ", NULL);
< 						else
< 							tofree = g_strconcat(par->name, " ", NULL);
< 						gtk_label_set_text(GTK_LABEL(label), tofree);
< 						g_free(tofree);
< 					}
< 				}
< 
< 
< 				gtk_widget_show(label);
< 				gtk_table_attach(GTK_TABLE(table), label, 0, 1, itnum, itnum + 1,
< 								 (GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 5, 6);
< 				gtk_label_set_justify(GTK_LABEL(label), GTK_JUSTIFY_LEFT);
< 				gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
< 				if (par->has_list) {
< 					combo = gtk_combo_new();
< 					gtk_widget_show(combo);
< 					gtk_table_attach(GTK_TABLE(table), combo, 1, 2, itnum, itnum + 1,
< 									 (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
< 									 (GtkAttachOptions) (0), 5, 5);
< 					/*gtk_combo_set_value_in_list(GTK_COMBO(combo), TRUE,TRUE); */
< 					gtk_combo_set_popdown_strings(GTK_COMBO(combo),
< 												  fref_string_to_list(par->values, ","));
< 					if (par->def_value != NULL)
< 						gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), par->def_value);
< 					par->dlg_item = combo;
< 					gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, GTK_COMBO(combo)->entry,
< 										 par->description, "");
< 				} else {
< 					input = gtk_entry_new();
< 					if (par->def_value != NULL)
< 						gtk_entry_set_text(GTK_ENTRY(input), par->def_value);
< 					gtk_widget_show(input);
< 					gtk_table_attach(GTK_TABLE(table), input, 1, 2, itnum, itnum + 1,
< 									 (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
< 									 (GtkAttachOptions) (0), 5, 5);
< 					par->dlg_item = input;
< 					if (par->description != NULL)
< 						gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, input, par->description,
< 											 "");
< 				}
< 				itnum++;
< 				par = (FRParamInfo *) g_list_nth_data(list, itnum);
< 			}
< 		};
< 		break;
< 
< 	}							/* switch */
< 
< 	dialog_action_area = GTK_DIALOG(dialog)->action_area;
< 	gtk_widget_show(dialog_action_area);
< 	gtk_button_box_set_layout(GTK_BUTTON_BOX(dialog_action_area), GTK_BUTTONBOX_END);
< 
< 
< 	infobutton = gtk_button_new_with_label(_("Info"));
< 	gtk_widget_show(infobutton);
< 	gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->action_area), infobutton, FALSE, FALSE, 2);
< 	g_signal_connect(G_OBJECT(infobutton), "clicked", G_CALLBACK(frefcb_info_show), bfwin);
< 
< 	cancelbutton = gtk_button_new_from_stock("gtk-cancel");
< 	gtk_widget_show(cancelbutton);
< 	gtk_dialog_add_action_widget(GTK_DIALOG(dialog), cancelbutton, GTK_RESPONSE_CANCEL);
< 
< 	okbutton = gtk_button_new_from_stock("gtk-ok");
< 	gtk_widget_show(okbutton);
< 	gtk_dialog_add_action_widget(GTK_DIALOG(dialog), okbutton, GTK_RESPONSE_OK);
< 	gtk_tooltips_enable(FREFGUI(bfwin->fref)->argtips);
< 
< 	gtk_widget_show(table);
< 	gtk_window_get_size(GTK_WINDOW(dialog), &w, &h);
< 	gtk_widget_size_request(table, &req);
< 	gtk_widget_size_request(dialog_action_area, &req2);
< 	gtk_window_resize(GTK_WINDOW(dialog), req.width + 10, MIN(400, req.height + req2.height + 20));
< 	return dialog;
< }
< 
< static void fref_popup_menu_dialog(GtkWidget * widget, Tcallbackdata * cd)
< {
< 	GtkWidget *dialog;
< 	gint resp;
< 	gchar *pomstr;
< 	FRInfo *entry = cd->data;
< 	Tbfwin *bfwin = cd->bfwin;
< 	g_free(cd);
< 	DEBUG_MSG("starting dialog\n");
< 	dialog = fref_prepare_dialog(bfwin, entry);
< 	if (dialog) {
< 		resp = gtk_dialog_run(GTK_DIALOG(dialog));
< 		if (resp == GTK_RESPONSE_OK) {
< 			pomstr = fref_prepare_text(entry, dialog);
< 			gtk_widget_destroy(dialog);
< 			doc_insert_two_strings(bfwin->current_document, pomstr, NULL);
< 			g_free(pomstr);
< 		} else
< 			gtk_widget_destroy(dialog);
< 	}
< }
< static void fref_popup_menu_insert(GtkWidget * widget, Tcallbackdata * cd)
< {
< 	FRInfo *entry = cd->data;
< 	Tbfwin *bfwin = cd->bfwin;
< 	g_free(cd);
< 	doc_insert_two_strings(bfwin->current_document, entry->insert_text, NULL);
< }
< 
< 
< static void fref_popup_menu_info(GtkWidget * widget, Tcallbackdata * cd)
< {
< 	FRInfo *entry = cd->data;
< 	Tbfwin *bfwin = cd->bfwin;
< 	g_free(cd);
< 	fref_show_info(bfwin, entry, FALSE, NULL);
< }
< 
< 
< static void fref_popup_menu_rescan_lcb(GtkWidget * widget, gpointer user_data)
< {
< 	gchar *userdir = g_strconcat(g_get_home_dir(), "/.bluefish/", NULL);
< 	DEBUG_MSG("fref_popup_menu_rescan_lcb, started\n");
< #ifndef WIN32
< 	fref_rescan_dir(PKGDATADIR);
< #else
< 	printf("fref.c:1822\n");
< 	fref_rescan_dir(PKG_DATA_DIR);
< #endif
< 	fref_rescan_dir(userdir);
< 	g_free(userdir);
< 	DEBUG_MSG("about to refill toplevels\n");
< 	fill_toplevels(FREFDATA(main_v->frefdata), TRUE);
< }
< 
< static GtkWidget *fref_popup_menu(Tbfwin * bfwin, FRInfo * entry)
< {
< 	GtkWidget *menu, *menu_item;
< 	DEBUG_MSG("fref_popup_menu, started\n");
< 	menu = gtk_menu_new();
< 	if (entry) {
< 		Tcallbackdata *cd = g_new(Tcallbackdata, 1);
< 		cd->bfwin = bfwin;
< 		cd->data = entry;
< 		menu_item = gtk_menu_item_new_with_label(_("Dialog"));
< 		g_signal_connect(GTK_OBJECT(menu_item), "activate", G_CALLBACK(fref_popup_menu_dialog), cd);
< 		gtk_menu_append(GTK_MENU(menu), menu_item);
< 		menu_item = gtk_menu_item_new_with_label(_("Insert"));
< 		g_signal_connect(GTK_OBJECT(menu_item), "activate", G_CALLBACK(fref_popup_menu_insert), cd);
< 		gtk_menu_append(GTK_MENU(menu), menu_item);
< 		menu_item = gtk_menu_item_new_with_label(_("Info"));
< 		g_signal_connect(GTK_OBJECT(menu_item), "activate", G_CALLBACK(fref_popup_menu_info), cd);
< 		gtk_menu_append(GTK_MENU(menu), menu_item);
< 		menu_item = gtk_menu_item_new();
< 		gtk_menu_append(GTK_MENU(menu), menu_item);
< 	}
< 	menu_item = gtk_menu_item_new_with_label(_("Options"));
< 	gtk_menu_append(GTK_MENU(menu), menu_item);
< 	{
< 		GtkWidget *optionsmenu, *ldblclckmenu, *infowinmenu;
< 		GSList *group = NULL;
< 		GSList *group2 = NULL;
< 		optionsmenu = gtk_menu_new();
< 		gtk_menu_item_set_submenu(GTK_MENU_ITEM(menu_item), optionsmenu);
< 		menu_item = gtk_menu_item_new_with_label(_("Rescan reference files"));
< 		g_signal_connect(GTK_OBJECT(menu_item), "activate", G_CALLBACK(fref_popup_menu_rescan_lcb),
< 						 NULL);
< 		gtk_menu_append(GTK_MENU(optionsmenu), menu_item);
< 		menu_item = gtk_menu_item_new_with_label(_("Left doubleclick action"));
< 		gtk_menu_append(GTK_MENU(optionsmenu), menu_item);
< 
< 		ldblclckmenu = gtk_menu_new();
< 		gtk_menu_item_set_submenu(GTK_MENU_ITEM(menu_item), ldblclckmenu);
< 		menu_item =
< 			togglemenuitem(NULL, _("Insert"),
< 						   (main_v->globses.fref_ldoubleclick_action == FREF_ACTION_INSERT),
< 						   G_CALLBACK(fref_ldblclck_changed), GINT_TO_POINTER(FREF_ACTION_INSERT));
< 		group = gtk_radio_menu_item_group(GTK_RADIO_MENU_ITEM(menu_item));
< 		gtk_menu_append(GTK_MENU(ldblclckmenu), menu_item);
< 		menu_item =
< 			togglemenuitem(group, _("Dialog"),
< 						   (main_v->globses.fref_ldoubleclick_action == FREF_ACTION_DIALOG),
< 						   G_CALLBACK(fref_ldblclck_changed), GINT_TO_POINTER(FREF_ACTION_DIALOG));
< 		gtk_menu_append(GTK_MENU(ldblclckmenu), menu_item);
< 		menu_item =
< 			togglemenuitem(group, _("Info"),
< 						   (main_v->globses.fref_ldoubleclick_action == FREF_ACTION_INFO),
< 						   G_CALLBACK(fref_ldblclck_changed), GINT_TO_POINTER(FREF_ACTION_INFO));
< 		gtk_menu_append(GTK_MENU(ldblclckmenu), menu_item);
< 
< 		menu_item = gtk_menu_item_new_with_label(_("Info type"));
< 		gtk_menu_append(GTK_MENU(optionsmenu), menu_item);
< 		infowinmenu = gtk_menu_new();
< 		gtk_menu_item_set_submenu(GTK_MENU_ITEM(menu_item), infowinmenu);
< 		menu_item =
< 			togglemenuitem(NULL, _("Description"), (main_v->globses.fref_info_type == FREF_IT_DESC),
< 						   G_CALLBACK(fref_infotype_changed), GINT_TO_POINTER(FREF_IT_DESC));
< 		group2 = gtk_radio_menu_item_group(GTK_RADIO_MENU_ITEM(menu_item));
< 		gtk_menu_append(GTK_MENU(infowinmenu), menu_item);
< 		menu_item =
< 			togglemenuitem(group2, _("Attributes/Parameters"),
< 						   (main_v->globses.fref_info_type == FREF_IT_ATTRS),
< 						   G_CALLBACK(fref_infotype_changed), GINT_TO_POINTER(FREF_IT_ATTRS));
< 		gtk_menu_append(GTK_MENU(infowinmenu), menu_item);
< 		menu_item =
< 			togglemenuitem(group2, _("Notes"), (main_v->globses.fref_info_type == FREF_IT_NOTES),
< 						   G_CALLBACK(fref_infotype_changed), GINT_TO_POINTER(FREF_IT_NOTES));
< 		gtk_menu_append(GTK_MENU(infowinmenu), menu_item);
< 
< 
< 	}
< 	gtk_widget_show_all(menu);
< 	g_signal_connect_after(G_OBJECT(menu), "destroy", G_CALLBACK(destroy_disposable_menu_cb), menu);
< 	return menu;
< }
< 
< static gboolean frefcb_event_keypress(GtkWidget * widget, GdkEventKey * event, Tbfwin * bfwin)
< {
< 	FRInfo *entry;
< 	entry = get_current_entry(bfwin);
< 	if (entry != NULL) {
< 		if (g_strcasecmp(gdk_keyval_name(event->keyval), "F1") == 0) {
< 			fref_show_info(bfwin, entry, FALSE, NULL);
< 			return TRUE;
< 		}
< 	}
< 	return FALSE;
< }
< 
< static gboolean reference_file_known(gchar * path)
< {
< 	GList *tmplist = g_list_first(main_v->props.reference_files);
< 	while (tmplist) {
< 		gchar **arr = tmplist->data;
< 		if (count_array(arr) == 2 && strcmp(arr[1], path) == 0) {
< 			return TRUE;
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return FALSE;
< }
< 
< void fref_rescan_dir(const gchar * dir)
< {
< 	const gchar *filename;
< 	GError *error = NULL;
< 	gchar *tofree;
< 	GPatternSpec *ps = g_pattern_spec_new("funcref_*.xml");
< 	GDir *gd = g_dir_open(dir, 0, &error);
< 	filename = g_dir_read_name(gd);
< 	while (filename) {
< 		if (g_pattern_match(ps, strlen(filename), filename, NULL)) {
< 			gchar *path = g_strconcat(dir, filename, NULL);
< 			DEBUG_MSG("filename %s has a match!\n", filename);
< 			if (!reference_file_known(path)) {
< 				tofree = fref_xml_get_refname(path);
< 				main_v->props.reference_files =
< 					g_list_append(main_v->props.reference_files,
< 								  array_from_arglist(g_strdup(tofree), path, NULL));
< 				g_free(tofree);
< 			}
< 			g_free(path);
< 		}
< 		filename = g_dir_read_name(gd);
< 	}
< 	g_dir_close(gd);
< 	g_pattern_spec_free(ps);
< }
< 
< typedef struct {
< 	Tbfwin *bfwin;
< 	gchar *cat;
< } Tfref_cleanup;
< 
< static guint fref_idle_cleanup(Tfref_cleanup * data)
< {
< 	GtkTreeIter iter;
< 	gboolean cont = TRUE;
< 	DEBUG_MSG("fref_idle_cleanup, started for data=%s\n", data->cat);
< 	gtk_tree_model_get_iter_first(GTK_TREE_MODEL(FREFDATA(main_v->frefdata)->store), &iter);
< 	while (cont) {
< 		gchar *str = NULL;
< 		gtk_tree_model_get(GTK_TREE_MODEL(FREFDATA(main_v->frefdata)->store), &iter, STR_COLUMN,
< 						   &str, -1);
< 		DEBUG_MSG("fref_idle_cleanup, comparing %s,%s\n", str, data->cat);
< 		if (strcmp(str, data->cat) == 0) {
< 			DEBUG_MSG("fref_idle_cleanup, found!\n");
< 			fref_loader_unload_ref(GTK_TREE_STORE(FREFDATA(main_v->frefdata)->store), &iter);
< 			break;
< 		}
< 		g_free (str);
< 		cont = gtk_tree_model_iter_next(GTK_TREE_MODEL(FREFDATA(main_v->frefdata)->store), &iter);
< 	}
< 	{
< 		GtkTreeIter newiter;
< 		gtk_tree_store_append(GTK_TREE_STORE(FREFDATA(main_v->frefdata)->store), &newiter, &iter);
< 	}
< 	g_free (data->cat);
< 	g_free (data);
< 	return FALSE;				/* do not call again */
< }
< 
< static void frefcb_row_collapsed(GtkTreeView * treeview, GtkTreeIter * arg1, GtkTreePath * arg2,
< 								 Tbfwin * bfwin)
< {
< 	gint *cnt = NULL;
< 	gpointer *aux;
< 	gboolean do_unload = FALSE;
< 	GtkTreeModel *treemodel = GTK_TREE_MODEL(FREFDATA(main_v->frefdata)->store);
< 	if (gtk_tree_path_get_depth(arg2) == 1) {
< 		gchar *cat;
< 		gtk_tree_model_get(treemodel, arg1, STR_COLUMN, &cat, -1);
< 		DEBUG_MSG("frefcb_row_collapsed, lookup for the refcount of %s\n", cat);
< 		aux = g_hash_table_lookup(FREFDATA(main_v->frefdata)->refcount, cat);
< 		if (aux != NULL) {
< 			cnt = (gint *) aux;
< 			DEBUG_MSG("frefcb_row_collapsed, refcount=%d, about to decrease\n", *cnt);
< 			*cnt = (*cnt) - 1;
< 			if (*cnt == 0) {
< 				Tfref_cleanup *data = g_new(Tfref_cleanup, 1);
< 				do_unload = TRUE;
< 				data->cat = cat;
< 				data->bfwin = bfwin;
< 				gtk_timeout_add(250, (GtkFunction) fref_idle_cleanup, data);
< 			}
< 		} else
< 			do_unload = FALSE;
< 	} else
< 		do_unload = FALSE;
< /*	if (do_unload) {
< 		DEBUG_MSG("frefcb_row_collapsed, do_unload=%d, unloading!\n",do_unload);
< 		val = g_new0(GValue, 1);
< 		gtk_tree_model_get_value(GTK_TREE_MODEL(treemodel), arg1, 2, val);
< 		if (G_IS_VALUE(val) && g_value_peek_pointer(val)!=NULL) {
< 			DEBUG_MSG("frefcb_row_collapsed, calling fref_loader_unload_ref\n");
< 			fref_loader_unload_ref(GTK_TREE_STORE(treemodel),arg1);
< 			/ * dummy node for expander display * /
< 			DEBUG_MSG("frefcb_row_collapsed, appending dummy node\n");
< 			gtk_tree_store_append(GTK_TREE_STORE(treemodel), &iter, arg1);
< 		}
< 		g_free(val);
< 	}*/
< }
< 
< 
< static void frefcb_full_info(GtkButton * button, Tbfwin * bfwin)
< {
< 	FRInfo *entry;
< 	entry = get_current_entry(bfwin);
< 	if (entry == NULL || entry->type == FR_TYPE_GROUP)
< 		return;
< 
< 	fref_show_info(bfwin, entry, FALSE, NULL);
< }
< 
< static void frefcb_search(GtkButton * button, Tbfwin * bfwin)
< {
< 	GtkTreePath *path;
< 	GtkTreeViewColumn *col;
< 	GtkWidget *dlg, *entry;
< 	GValue *val;
< 	GtkTreeIter iter;
< 	GHashTable *dict;
< 	gint result;
< 	gchar *stf = NULL;
< 
< 	gtk_tree_view_get_cursor(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), &path, &col);
< 	if (path != NULL) {
< 		while (gtk_tree_path_get_depth(path) > 1 && gtk_tree_path_up(path));
< 
< 		gtk_tree_model_get_iter(gtk_tree_view_get_model(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree)),
< 								&iter, path);
< 		gtk_tree_path_free(path);
< 		val = g_new0(GValue, 1);
< 		/* first column of reference title holds dictionary */
< 		gtk_tree_model_get_value(gtk_tree_view_get_model(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree)),
< 								 &iter, 1, val);
< 		if (G_IS_VALUE(val) && g_value_fits_pointer(val)) {
< 			dict = (GHashTable *) g_value_peek_pointer(val);
< 			if (dict != NULL) {
< 				gpointer ret = NULL;
< 				dlg =
< 					gtk_dialog_new_with_buttons(_("Reference search"), NULL, GTK_DIALOG_MODAL,
< 												GTK_STOCK_CANCEL, GTK_RESPONSE_REJECT, GTK_STOCK_OK,
< 												GTK_RESPONSE_ACCEPT, NULL);
< 				gtk_dialog_set_default_response(GTK_DIALOG(dlg), GTK_RESPONSE_ACCEPT);
< 				entry = gtk_entry_new();
< 				gtk_entry_set_activates_default(GTK_ENTRY(entry), TRUE);
< 				gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dlg)->vbox), entry, TRUE, TRUE, 0);
< 				gtk_widget_show(entry);
< 				result = gtk_dialog_run(GTK_DIALOG(dlg));
< 				if (result == GTK_RESPONSE_ACCEPT) {
< 					stf = g_strdup(gtk_entry_get_text(GTK_ENTRY(entry)));
< 					ret = g_hash_table_lookup(dict, stf);
< 					g_free(stf);
< 					if (!ret)
< 						error_dialog(bfwin->main_window, _("Reference search"),
< 									 _("Reference not found"));
< 				}
< 				gtk_widget_destroy(dlg);
< 
< 				if (ret != NULL) {
< 					GtkTreePath *path2 = gtk_tree_row_reference_get_path(ret);
< #ifndef HAVE_ATLEAST_GTK_2_2
< 					gtktreepath_expand_to_root(FREFGUI(bfwin->fref)->tree, path2);
< #else
< 					gtk_tree_view_expand_to_path(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), path2);
< #endif
< 					gtk_tree_view_set_cursor(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), path2,
< 											 gtk_tree_view_get_column(GTK_TREE_VIEW
< 																	  (FREFGUI(bfwin->fref)->tree),
< 																	  0), FALSE);
< 				}
< 			} else
< 				error_dialog(bfwin->main_window, _("Error"),
< 							 _
< 							 ("Perhaps you didn't load a reference, or you did not select a reference to search in."));
< 		}
< 		g_value_unset(val);
< 		g_free(val);
< 	}
< }
< 
< static gboolean frefcb_event_mouseclick(GtkWidget * widget, GdkEventButton * event, Tbfwin * bfwin)
< {
< 	FRInfo *entry;
< 
< 	if (widget != FREFGUI(bfwin->fref)->tree)
< 		return FALSE;
< 
< 	entry = get_current_entry(bfwin);
< 	if (entry == NULL) {
< 		if (event->button == 3 && event->type == GDK_BUTTON_PRESS) {
< 			gtk_menu_popup(GTK_MENU(fref_popup_menu(bfwin, NULL)), NULL, NULL, NULL, NULL,
< 						   event->button, event->time);
< 			return TRUE;
< 		} else
< 			return FALSE;
< 	}
< 
< 	if (event->button == 3 && event->type == GDK_BUTTON_PRESS) {	/* right mouse click */
< 		gtk_menu_popup(GTK_MENU(fref_popup_menu(bfwin, entry)), NULL, NULL, NULL, NULL,
< 					   event->button, event->time);
< 	} else if (event->button == 1 && event->type == GDK_2BUTTON_PRESS) {	/* double click  */
< 		Tcallbackdata *cd = g_new(Tcallbackdata, 1);
< 		cd->data = entry;
< 		cd->bfwin = bfwin;
< 		switch (main_v->globses.fref_ldoubleclick_action) {
< 		case FREF_ACTION_INSERT:
< 			fref_popup_menu_insert(NULL, cd);
< 			break;
< 		case FREF_ACTION_DIALOG:
< 			fref_popup_menu_dialog(NULL, cd);
< 			break;
< 		case FREF_ACTION_INFO:
< 			fref_popup_menu_info(NULL, cd);
< 			break;
< 		default:
< 			g_print("weird, fref_doubleclick_action=%d\n",
< 					main_v->globses.fref_ldoubleclick_action);
< 			main_v->globses.fref_ldoubleclick_action = FREF_ACTION_DIALOG;
< 			break;
< 		}
< 	}
< 	return FALSE;				/* we have handled the event, but the treeview freezes if you return TRUE,    so we return FALSE */
< }
< 
< static void frefcb_cursor_changed(GtkTreeView * treeview, Tbfwin * bfwin)
< {
< 	FRInfo *entry;
< 	gchar *info = NULL, *tmpinfo = NULL; 
< 	GdkRectangle rect;
< 
< 	entry = get_current_entry(bfwin);
< 	if (entry == NULL)
< 		return;
< 	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(FREFGUI(bfwin->fref)->infocheck))) {
< 		if (entry->description != NULL) {
< 			switch (main_v->globses.fref_info_type) {
< 			case FREF_IT_DESC:
< 				tmpinfo = fref_prepare_info(entry, FR_INFO_DESC, FALSE);
< 				info = g_strconcat("<span size=\"small\"><b>Description:</b></span>\n", tmpinfo, NULL);
< 				break;
< 			case FREF_IT_ATTRS:
< 				tmpinfo = fref_prepare_info(entry, FR_INFO_ATTRS, FALSE);
< 				switch (entry->type) {
< 				case FR_TYPE_TAG:
< 					info = g_strconcat("<span size=\"small\"><b>Attributes:</b></span>\n", tmpinfo, NULL);
< 					break;
< 				case FR_TYPE_FUNCTION:
< 					info = g_strconcat("<span size=\"small\"><b>Parameters:</b></span>\n", tmpinfo, NULL);
< 					break;
< 				}
< 				break;
< 			case FREF_IT_NOTES:
< 				info = fref_prepare_info(entry, FR_INFO_NOTES, FALSE);
< 				break;
< 			default:
< 				info = g_strdup("Unknown fref_info_type");
< 			}					/* switch */
< 			gtk_tree_view_get_visible_rect(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), &rect);
< 			gtk_widget_set_size_request(FREFGUI(bfwin->fref)->infoview, rect.width, -1);
< 			gtk_label_set_markup(GTK_LABEL(FREFGUI(bfwin->fref)->infoview), info);
< 			if (tmpinfo) g_free (tmpinfo);
< 			g_free(info);
< 		} else
< 			gtk_label_set_text(GTK_LABEL(FREFGUI(bfwin->fref)->infoview), "");
< 	}
< }
< 
< static void frefcb_infocheck_toggled(GtkToggleButton * togglebutton, Tbfwin * bfwin)
< {
< 	if (gtk_toggle_button_get_active(togglebutton))
< 		gtk_widget_show(FREFGUI(bfwin->fref)->infoscroll);
< 	else
< 		gtk_widget_hide(FREFGUI(bfwin->fref)->infoscroll);
< }
< 
< gchar *fref_tip(gconstpointer win, gconstpointer tree, gint x, gint y)
< {
< 	gchar *str = NULL, *tofree = NULL;
< 	GList *lst;
< 	FRAttrInfo *tmpa;
< 	FRParamInfo *tmpp;
< 	FRInfo *info = NULL;
< 	GtkTreePath *path;
< 
< 
< 	if (!gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tree), x, y, &path, NULL, NULL, NULL))
< 		return NULL;
< 
< 	if (path != NULL) {
< 		GValue *val;
< 		GtkTreeIter iter;
< 		gtk_tree_model_get_iter(gtk_tree_view_get_model(GTK_TREE_VIEW(tree)), &iter, path);
< 		gtk_tree_path_free(path);
< 		val = g_new0(GValue, 1);
< 		gtk_tree_model_get_value(gtk_tree_view_get_model(GTK_TREE_VIEW(tree)), &iter, 1, val);
< 		if (G_IS_VALUE(val) && g_value_fits_pointer(val)) {
< 			info = (FRInfo *) (g_value_peek_pointer(val));
< 		}
< 		g_value_unset(val);
< 		g_free(val);
< 	}
< 
< 	if (!info)
< 		return NULL;
< 
< 	switch (info->type) {
< 	case FR_TYPE_TAG:
< 		str = g_strdup_printf("<b>%s:</b> ", info->name);
< 		lst = g_list_first(info->attributes);
< 		while (lst) {
< 			tmpa = (FRAttrInfo *) lst->data;
< 			tofree = str;
< 			str = g_strconcat(str, "<span size=\"small\" ><i>", tmpa->name, "</i></span>  ", NULL);
< 			g_free(tofree);
< 			lst = g_list_next(lst);
< 		}
< 		break;
< 	case FR_TYPE_FUNCTION:
< 		if (info->return_type != NULL)
< 			str = g_strdup_printf("<i>%s</i>  %s( ", info->return_type, info->name);
< 		else
< 			str = g_strdup_printf("%s( ", info->name);
< 		lst = g_list_first(info->params);
< 		while (lst) {
< 			tmpp = (FRParamInfo *) lst->data;
< 			tofree = str;
< 			if (tmpp->type != NULL)
< 				str = g_strconcat(str, "<i>", tmpp->type, "</i>  <b>", tmpp->name, "</b>", NULL);
< 			else
< 				str = g_strconcat(str, "<b>", tmpp->name, "</b>", NULL);
< 			g_free(tofree);
< 			lst = g_list_next(lst);
< 			if (lst) {
< 				tofree = str;
< 				str = g_strconcat(str, ",", NULL);
< 				g_free(tofree);
< 			}
< 		}
< 		tofree = str;
< 		str = g_strconcat(str, " )", NULL);
< 		g_free(tofree);
< 		break;
< 	}
< 	return str;
< }
< 
< GtkWidget *fref_gui(Tbfwin * bfwin)
< {
< 	GtkWidget *scroll, *box, *pane, *box2, *btn1, *btn2, *btn3;
< 	GtkCellRenderer *cell;
< 	GtkTreeViewColumn *column;
< 	Tfref_data *fdata = FREFDATA(main_v->frefdata);
< 	GtkTreeIter it;
< 
< 	bfwin->fref = g_new0(Tfref_gui, 1);
< 
< 	pane = gtk_vpaned_new();
< 	box = gtk_vbox_new(FALSE, 1);
< 	box2 = gtk_hbox_new(FALSE, 1);
< 
< 	scroll = gtk_scrolled_window_new(NULL, NULL);
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC,
< 								   GTK_POLICY_AUTOMATIC);
< 	FREFGUI(bfwin->fref)->infoscroll = gtk_scrolled_window_new(NULL, NULL);
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(FREFGUI(bfwin->fref)->infoscroll),
< 								   GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
< 
< 	FREFGUI(bfwin->fref)->tree = gtk_tree_view_new_with_model(GTK_TREE_MODEL(fdata->store));
< 	gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), FALSE);
< 	/*gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (FREFGUI(bfwin->fref)->tree), TRUE);*/
< 	cell = gtk_cell_renderer_text_new();
< 	column = gtk_tree_view_column_new_with_attributes("", cell, "text", STR_COLUMN, NULL);
< 	gtk_tree_view_append_column(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), column);
< 
< 	gtk_container_add(GTK_CONTAINER(scroll), FREFGUI(bfwin->fref)->tree);
< 	gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), FALSE);
< 
< 	g_signal_connect(G_OBJECT(FREFGUI(bfwin->fref)->tree), "row-collapsed",
< 					 G_CALLBACK(frefcb_row_collapsed), bfwin);
< 	g_signal_connect(G_OBJECT(FREFGUI(bfwin->fref)->tree), "row-expanded",
< 					 G_CALLBACK(frefcb_row_expanded), fdata->store);
< 	g_signal_connect(G_OBJECT(FREFGUI(bfwin->fref)->tree), "button-press-event",
< 					 G_CALLBACK(frefcb_event_mouseclick), bfwin);
< 	g_signal_connect(G_OBJECT(FREFGUI(bfwin->fref)->tree), "key-press-event",
< 					 G_CALLBACK(frefcb_event_keypress), bfwin);
< 
< 	gtk_widget_show(FREFGUI(bfwin->fref)->tree);
< 	gtk_widget_show(scroll);
< 
< 	/* BUG??: don't we have a global tooltips object somewhere ? 
< 	FREFGUI(bfwin->fref)->argtips = gtk_tooltips_new();*/
< 	FREFGUI(bfwin->fref)->argtips = main_v->tooltips;
< 	FREFGUI(bfwin->fref)->tips =
< 		tree_tips_new_full(bfwin, GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), fref_tip);
< 	tree_tips_set_hide_interval(FREFGUI(bfwin->fref)->tips, 5000);
< 
< 	FREFGUI(bfwin->fref)->infoview = gtk_label_new(NULL);
< 	gtk_label_set_line_wrap(GTK_LABEL(FREFGUI(bfwin->fref)->infoview), TRUE);
< 	gtk_label_set_use_markup(GTK_LABEL(FREFGUI(bfwin->fref)->infoview), TRUE);
< 	gtk_misc_set_alignment(GTK_MISC(FREFGUI(bfwin->fref)->infoview), 0.0, 0.0);
< 	gtk_misc_set_padding(GTK_MISC(FREFGUI(bfwin->fref)->infoview), 5, 5);
< 
< 	g_signal_connect(G_OBJECT(FREFGUI(bfwin->fref)->tree), "cursor-changed",
< 					 G_CALLBACK(frefcb_cursor_changed), bfwin);
< 
< 	FREFGUI(bfwin->fref)->infocheck = gtk_check_button_new_with_label(_("Show info window"));
< 	gtk_widget_show(FREFGUI(bfwin->fref)->infocheck);
< 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(FREFGUI(bfwin->fref)->infocheck), TRUE);
< 	g_signal_connect(G_OBJECT(FREFGUI(bfwin->fref)->infocheck), "toggled",
< 					 G_CALLBACK(frefcb_infocheck_toggled), bfwin);
< 	{
< 		/* BUG??: is this ever freed ??? */
< 		Tcallbackdata *cd = g_new(Tcallbackdata, 1);
< 		cd->data = NULL;
< 		cd->bfwin = bfwin;
< 		btn1 = bf_allbuttons_backend(NULL, FALSE, 108, G_CALLBACK(frefcb_info_dialog), cd);
< 	}
< 	btn2 = bf_allbuttons_backend(NULL, FALSE, 107, G_CALLBACK(frefcb_full_info), bfwin);
< 	btn3 = bf_allbuttons_backend(NULL, FALSE, 109, G_CALLBACK(frefcb_search), bfwin);
< 	gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, btn1, _("Dialog"), "");
< 	gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, btn2, _("Info"), "");
< 	gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, btn3, _("Search"), "");
< 
< 	gtk_box_pack_start(GTK_BOX(box2), FREFGUI(bfwin->fref)->infocheck, TRUE, TRUE, 0);
< 	gtk_box_pack_start(GTK_BOX(box2), btn3, FALSE, TRUE, 0);
< 	gtk_box_pack_start(GTK_BOX(box2), btn2, FALSE, TRUE, 0);
< 	gtk_box_pack_start(GTK_BOX(box2), btn1, FALSE, TRUE, 0);
< 
< 	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(FREFGUI(bfwin->fref)->infoscroll),
< 										  FREFGUI(bfwin->fref)->infoview);
< 	gtk_box_pack_start(GTK_BOX(box), scroll, TRUE, TRUE, 0);
< 	gtk_box_pack_start(GTK_BOX(box), box2, FALSE, TRUE, 0);
< 	gtk_paned_pack1(GTK_PANED(pane), box, TRUE, FALSE);
< 	gtk_paned_pack2(GTK_PANED(pane), FREFGUI(bfwin->fref)->infoscroll, TRUE, TRUE);
< 	gtk_widget_show_all(pane);
< 
< 	if (!gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(fdata->store), &it, NULL, 0))
< 		fill_toplevels(fdata, FALSE);
< 	return pane;
< }
---
> /* Bluefish HTML Editor
>  * fref.c - function reference file
>  *
>  * Copyright (C) 2003-2006 Oliver Sessink and Oskar Swida
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> /*
>  * indent --line-length 100 --k-and-r-style --tab-size 4 -bbo --ignore-newlines 
>  */
> 
> #include <gtk/gtk.h>
> #include <string.h>
> #include <gdk/gdkkeysyms.h>
> 
> /* #define DEBUG */
> 
> #include "bluefish.h"
> #include "fref.h"
> #include "rcfile.h"				/* array_from_arglist() */
> #include "stringlist.h"
> #include "document.h"
> #include "bf_lib.h"
> #include "gtk_easy.h"
> #include "char_table.h"
> #include "treetips.h"
> 
> enum {
> 	FREF_ACTION_INSERT,
> 	FREF_ACTION_DIALOG,
> 	FREF_ACTION_INFO
> };
> 
> enum {
> 	FREF_IT_DESC,
> 	FREF_IT_ATTRS,
> 	FREF_IT_NOTES
> };
> 
> enum {
> 	STR_COLUMN,
> 	PTR_COLUMN,
> 	FILE_COLUMN,
> 	N_COLUMNS
> };
> 
> #define FR_TYPE_TAG         1
> #define FR_TYPE_FUNCTION    2
> #define FR_TYPE_CLASS       3
> #define FR_TYPE_GROUP       4
> 
> #define MAX_NEST_LEVEL      20
> 
> typedef struct {
> 	gpointer data;
> 	Tbfwin *bfwin;
> } Tcallbackdata;
> 
> typedef struct {
> 	gchar *name;
> 	gchar *title;
> 	gchar *description;
> 	gchar *def_value;
> 	gboolean required;
> 	gboolean has_list;
> 	gchar *values;
> 	GtkWidget *dlg_item;
> } FRAttrInfo;
> 
> typedef struct {
> 	gchar *name;
> 	gchar *title;
> 	gchar *description;
> 	gchar *def_value;
> 	gchar *type;
> 	gboolean required;
> 	gboolean has_list;
> 	gchar *values;
> 	GtkWidget *dlg_item;
> } FRParamInfo;
> 
> 
> typedef struct {
> 	gchar type;
> 	gchar *name;
> 	gchar *description;
> 	gchar *tip;
> 	gchar *return_type;			/* if function */
> 	gchar *return_description;	/* if function */
> 	GList *attributes;
> 	GList *params;
> 	GList *methods;
> 	gchar *info_text;
> 	gchar *info_title;
> 	gchar *dialog_text;
> 	gchar *dialog_title;
> 	gchar *insert_text;
> } FRInfo;
> 
> typedef struct {
> 	FRInfo *act_info;
> 	FRInfo *act_grp;
> 	FRAttrInfo *act_attr;
> 	FRParamInfo *act_param;
> 	GtkWidget *tree;
> 	GtkTreeStore *store;
> 	GtkTreeIter grp_parent[MAX_NEST_LEVEL];
> 	gint nest_level;
> 	GtkTreeIter parent;
> 	gint state;
> 	gint pstate;
> 	gint vstate;
> 	GHashTable *dict;
> } FRParseAux;
> 
> #define FR_LOADER_STATE_NONE            1
> #define FR_LOADER_STATE_TAG             2
> #define FR_LOADER_STATE_FUNC            3
> #define FR_LOADER_STATE_CLASS           4
> #define FR_LOADER_STATE_ATTR            5
> #define FR_LOADER_STATE_PARAM           6
> #define FR_LOADER_STATE_TIP             7
> #define FR_LOADER_STATE_DESCR           8
> #define FR_LOADER_STATE_INFO            9
> #define FR_LOADER_STATE_DIALOG          10
> #define FR_LOADER_STATE_INSERT          11
> #define FR_LOADER_STATE_VALLIST         12
> #define FR_LOADER_STATE_RETURN          13
> #define FR_LOADER_STATE_GROUPDESC       14
> 
> #define FR_INFO_TITLE    1
> #define FR_INFO_DESC     2
> #define FR_INFO_ATTRS    3
> #define FR_INFO_NOTES    4
> 
> #define FR_COL_1    "#4B6983"
> #define FR_COL_2    "#7590AE"
> #define FR_COL_3    "#666666"
> #define FR_COL_4    "#FFFFFF"
> 
> GtkWidget *fref_prepare_dialog(Tbfwin * bfwin, FRInfo * entry);
> 
> typedef struct {
> 	GtkWidget *tree;
> 	GtkTooltips *argtips;
> 	GtkWidget *infocheck;
> 	GtkWidget *infoview;
> 	GtkWidget *infoscroll;
> 	Tbfwin *bfwin;
> 	TreeTips *tips;
> } Tfref_gui;
> 
> #define FREFGUI(var) ((Tfref_gui *)(var))
> 
> typedef struct {
> 	GtkTreeStore *store;
> 	GHashTable *refcount;		/* Opened reference count */
> } Tfref_data;
> #define FREFDATA(var) ((Tfref_data *)(var))
> 
> typedef struct {
> 	gchar *name;
> 	gchar *description;
> } Tfref_name_data;
> 
> #ifdef DEBUG
> static void free_with_print(gpointer ptr)
> {
> 	DEBUG_MSG("free_wp: free'ing %p\n", ptr);
> 	g_free(ptr);
> }
> #endif
> void fref_free_info(FRInfo * info)
> {
> 	FRAttrInfo *tmpa;
> 	FRParamInfo *tmpp;
> 	GList *lst;
> 	DEBUG_MSG("fref_free_info, freeing info->name=%s\n", info->name);
> 	g_free(info->name);
> 	g_free(info->description);
> 	g_free(info->tip);
> 	g_free(info->return_type);
> 	g_free(info->return_description);
> 	g_free(info->info_text);
> 	g_free(info->info_title);
> 	g_free(info->dialog_text);
> 	g_free(info->dialog_title);
> 	g_free(info->insert_text);
> 	if (info->attributes) {
> 		lst = g_list_first(info->attributes);
> 		while (lst) {
> 			tmpa = (FRAttrInfo *) lst->data;
> 			g_free(tmpa->name);
> 			g_free(tmpa->title);
> 			g_free(tmpa->description);
> 			g_free(tmpa->def_value);
> 			g_free(tmpa->values);
> 			g_free(tmpa);
> 			lst = g_list_next(lst);
> 		}
> 		g_list_free(info->attributes);
> 	}							/* attributes */
> 	if (info->params) {
> 		lst = g_list_first(info->params);
> 		while (lst) {
> 			tmpp = (FRParamInfo *) lst->data;
> 			g_free(tmpp->name);
> 			g_free(tmpp->title);
> 			g_free(tmpp->description);
> 			g_free(tmpp->def_value);
> 			g_free(tmpp->type);
> 			g_free(tmpp->values);
> 			g_free(tmpp);
> 			lst = g_list_next(lst);
> 		}
> 		g_list_free(info->params);
> 	}
> 	/* params */
> 	/* methods */
> 	g_free(info);
> }
> 
> void fref_name_loader_start_element(GMarkupParseContext * context, const gchar * element_name,
> 									const gchar ** attribute_names, const gchar ** attribute_values,
> 									gpointer user_data, GError ** error)
> {
> 	GHashTable *attrs;
> 	int i;
> 	Tfref_name_data *data;
> 	gchar *tmps;
> 
> 	if (user_data == NULL)
> 		return;
> 	data = (Tfref_name_data *) user_data;
> 
> 	attrs = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
> 	i = 0;
> 	while (attribute_names[i] != NULL) {
> 		g_hash_table_insert(attrs, (gpointer) g_strdup(attribute_names[i]),
> 							(gpointer) g_strdup(attribute_values[i]));
> 		i++;
> 	}
> 
> 	if (strcmp(element_name, "ref") == 0) {
> 		tmps = g_hash_table_lookup(attrs, "name");
> 		if (tmps != NULL)
> 			data->name = g_strdup(tmps);
> 		tmps = g_hash_table_lookup(attrs, "description");
> 		if (tmps != NULL)
> 			data->description = g_strdup(tmps);
> 	}
> 	g_hash_table_destroy(attrs);
> }
> 
> void fref_loader_start_element(GMarkupParseContext * context, const gchar * element_name,
> 							   const gchar ** attribute_names, const gchar ** attribute_values,
> 							   gpointer user_data, GError ** error)
> {
> 	FRParseAux *aux;
> 	FRInfo *info;
> 	FRAttrInfo *tmpa;
> 	FRParamInfo *tmpp;
> 	GHashTable *attrs;
> 	int i;
> 	gpointer pomstr;
> 	GtkTreeIter iter;
> 	GtkTreeRowReference *rref;
> 	GtkTreePath *path = NULL;
> 	gchar *string = NULL;
> 
> 	if (user_data == NULL)
> 		return;
> 	aux = (FRParseAux *) user_data;
> 	attrs = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
> 	i = 0;
> 	while (attribute_names[i] != NULL) {
> 		g_hash_table_insert(attrs, (gpointer) g_strdup(attribute_names[i]),
> 							(gpointer) g_strdup(attribute_values[i]));
> 		i++;
> 	}
> 
> 	switch (aux->state) {
> 
> 	case FR_LOADER_STATE_NONE:
> 		if (strcmp(element_name, "group") == 0) {
> 			if (aux->nest_level < MAX_NEST_LEVEL) {
> 				info = g_new0(FRInfo, 1);
> 				info->type = FR_TYPE_GROUP;
> 				info->name = g_strdup(g_hash_table_lookup(attrs, "name"));
> 				gtk_tree_store_append(aux->store, &iter, &aux->parent);
> 				string = g_strdup(g_hash_table_lookup(attrs, "name"));
> 				gtk_tree_store_set(aux->store, &iter, STR_COLUMN,
> 								   string, FILE_COLUMN, NULL, PTR_COLUMN, info, -1);
> 				g_free (string);
> 				aux->grp_parent[aux->nest_level] = aux->parent;
> 				aux->parent = iter;
> 			} else
> 				g_warning("Maximum nesting level reached!");
> 			(aux->nest_level)++;
> 		} else if (strcmp(element_name, "description") == 0) {	/* group description */
> 			FRInfo *tmpinfo;
> 			gtk_tree_model_get(GTK_TREE_MODEL(aux->store), &aux->parent, PTR_COLUMN, &tmpinfo, -1);
> 			if (tmpinfo != NULL) {
> 				aux->pstate = FR_LOADER_STATE_NONE;
> 				aux->state = FR_LOADER_STATE_GROUPDESC;
> 			}
> 		} else if (strcmp(element_name, "tag") == 0) {
> 			aux->state = FR_LOADER_STATE_TAG;
> 			aux->pstate = FR_LOADER_STATE_NONE;
> 			info = g_new0(FRInfo, 1);
> 			info->type = FR_TYPE_TAG;
> 			info->name = g_strdup(g_hash_table_lookup(attrs, "name"));
> 			gtk_tree_store_append(aux->store, &iter, &aux->parent);
> 			gtk_tree_store_set(aux->store, &iter, STR_COLUMN, info->name, PTR_COLUMN, info,
> 							   FILE_COLUMN, NULL, -1);
> 			aux->act_info = info;
> 			path = gtk_tree_model_get_path(GTK_TREE_MODEL(aux->store), &iter);
> 			rref = gtk_tree_row_reference_new(GTK_TREE_MODEL(aux->store), path);
> 			g_hash_table_insert(aux->dict, g_strdup(info->name), rref);
> 		} else if (strcmp(element_name, "function") == 0) {
> 			aux->state = FR_LOADER_STATE_FUNC;
> 			aux->pstate = FR_LOADER_STATE_NONE;
> 			info = g_new0(FRInfo, 1);
> 			info->type = FR_TYPE_FUNCTION;
> 			info->name = g_strdup(g_hash_table_lookup(attrs, "name"));
> 			gtk_tree_store_append(aux->store, &iter, &aux->parent);
> 			gtk_tree_store_set(aux->store, &iter, STR_COLUMN, info->name, PTR_COLUMN, info, -1);
> 			aux->act_info = info;
> 			path = gtk_tree_model_get_path(GTK_TREE_MODEL(aux->store), &iter);
> 			rref = gtk_tree_row_reference_new(GTK_TREE_MODEL(aux->store), path);
> 			g_hash_table_insert(aux->dict, g_strdup(info->name), rref);
> 		} else if (strcmp(element_name, "class") == 0) {
> 			aux->state = FR_LOADER_STATE_CLASS;
> 			aux->pstate = FR_LOADER_STATE_NONE;
> 			info = g_new0(FRInfo, 1);
> 			info->type = FR_TYPE_CLASS;
> 			info->name = g_strdup(g_hash_table_lookup(attrs, "name"));
> 			gtk_tree_store_append(aux->store, &iter, &aux->parent);
> 			gtk_tree_store_set(aux->store, &iter, STR_COLUMN, info->name, PTR_COLUMN, info, -1);
> 			aux->act_info = info;
> 			path = gtk_tree_model_get_path(GTK_TREE_MODEL(aux->store), &iter);
> 			rref = gtk_tree_row_reference_new(GTK_TREE_MODEL(aux->store), path);
> 			g_hash_table_insert(aux->dict, g_strdup(info->name), rref);
> 		} else if (strcmp(element_name, "ref") == 0) {
> 		} else
> 			g_warning("FREF Config Error: Unknown element %s", element_name);
> 		break;					/* state NONE */
> 
> 
> 	case FR_LOADER_STATE_TAG:
> 		if (strcmp(element_name, "description") == 0) {
> 			aux->state = FR_LOADER_STATE_DESCR;
> 			aux->pstate = FR_LOADER_STATE_TAG;
> 		} else if (strcmp(element_name, "tip") == 0) {
> 			aux->state = FR_LOADER_STATE_TIP;
> 			aux->pstate = FR_LOADER_STATE_TAG;
> 		} else if (strcmp(element_name, "attribute") == 0) {
> 			aux->state = FR_LOADER_STATE_ATTR;
> 			aux->pstate = FR_LOADER_STATE_TAG;
> 			tmpa = g_new0(FRAttrInfo, 1);
> 			tmpa->name = g_strdup(g_hash_table_lookup(attrs, "name"));
> 			tmpa->title = g_strdup(g_hash_table_lookup(attrs, "title"));
> 			pomstr = g_hash_table_lookup(attrs, "required");
> 			if (pomstr != NULL
> 				&& (g_strcasecmp(pomstr, "y") == 0 || g_strcasecmp(pomstr, "1") == 0))
> 				tmpa->required = TRUE;
> 			else
> 				tmpa->required = FALSE;
> 			pomstr = g_hash_table_lookup(attrs, "vallist");
> 			if (pomstr != NULL
> 				&& (g_strcasecmp(pomstr, "y") == 0 || g_strcasecmp(pomstr, "1") == 0))
> 				tmpa->has_list = TRUE;
> 			else
> 				tmpa->has_list = FALSE;
> 			tmpa->def_value = g_strdup(g_hash_table_lookup(attrs, "default"));
> 			aux->act_attr = tmpa;
> 			aux->act_info->attributes = g_list_append(aux->act_info->attributes, tmpa);
> 		} else if (strcmp(element_name, "dialog") == 0) {
> 			aux->state = FR_LOADER_STATE_DIALOG;
> 			aux->pstate = FR_LOADER_STATE_TAG;
> 			aux->act_info->dialog_title = g_strdup(g_hash_table_lookup(attrs, "title"));
> 		} else if (strcmp(element_name, "info") == 0) {
> 			aux->state = FR_LOADER_STATE_INFO;
> 			aux->pstate = FR_LOADER_STATE_TAG;
> 			aux->act_info->info_title = g_strdup(g_hash_table_lookup(attrs, "title"));
> 		} else if (strcmp(element_name, "insert") == 0) {
> 			aux->state = FR_LOADER_STATE_INSERT;
> 			aux->pstate = FR_LOADER_STATE_TAG;
> 		} else
> 			g_warning("FREF Config Error: Unknown tag (%s)", element_name);
> 		break;					/* state TAG */
> 	case FR_LOADER_STATE_FUNC:
> 		if (strcmp(element_name, "description") == 0) {
> 			aux->state = FR_LOADER_STATE_DESCR;
> 			aux->pstate = FR_LOADER_STATE_FUNC;
> 		} else if (strcmp(element_name, "tip") == 0) {
> 			aux->state = FR_LOADER_STATE_TIP;
> 			aux->pstate = FR_LOADER_STATE_FUNC;
> 		} else if (strcmp(element_name, "param") == 0) {
> 			aux->state = FR_LOADER_STATE_PARAM;
> 			aux->pstate = FR_LOADER_STATE_FUNC;
> 			tmpp = g_new0(FRParamInfo, 1);
> 			tmpp->name = g_strdup(g_hash_table_lookup(attrs, "name"));
> 			tmpp->title = g_strdup(g_hash_table_lookup(attrs, "title"));
> 			pomstr = g_hash_table_lookup(attrs, "required");
> 			if (pomstr != NULL
> 				&& (g_strcasecmp(pomstr, "y") == 0 || g_strcasecmp(pomstr, "1") == 0))
> 				tmpp->required = TRUE;
> 			else
> 				tmpp->required = FALSE;
> 			pomstr = g_hash_table_lookup(attrs, "vallist");
> 			if (pomstr != NULL
> 				&& (g_strcasecmp(pomstr, "y") == 0 || g_strcasecmp(pomstr, "1") == 0))
> 				tmpp->has_list = TRUE;
> 			else
> 				tmpp->has_list = FALSE;
> 			tmpp->def_value = g_strdup(g_hash_table_lookup(attrs, "default"));
> 			tmpp->type = g_strdup(g_hash_table_lookup(attrs, "type"));
> 			aux->act_param = tmpp;
> 			aux->act_info->params = g_list_append(aux->act_info->params, tmpp);
> 		} else if (strcmp(element_name, "return") == 0) {
> 			aux->state = FR_LOADER_STATE_RETURN;
> 			aux->pstate = FR_LOADER_STATE_FUNC;
> 			aux->act_info->return_type = g_strdup(g_hash_table_lookup(attrs, "type"));
> 		} else if (strcmp(element_name, "dialog") == 0) {
> 			aux->state = FR_LOADER_STATE_DIALOG;
> 			aux->pstate = FR_LOADER_STATE_FUNC;
> 			aux->act_info->dialog_title = g_strdup(g_hash_table_lookup(attrs, "title"));
> 		} else if (strcmp(element_name, "info") == 0) {
> 			aux->state = FR_LOADER_STATE_INFO;
> 			aux->pstate = FR_LOADER_STATE_FUNC;
> 			aux->act_info->info_title = g_strdup(g_hash_table_lookup(attrs, "title"));
> 		} else if (strcmp(element_name, "insert") == 0) {
> 			aux->state = FR_LOADER_STATE_INSERT;
> 			aux->pstate = FR_LOADER_STATE_FUNC;
> 		} else
> 			g_warning("FREF Config Error: Unknown tag (%s)", element_name);
> 		break;					/* state FUNC */
> 	case FR_LOADER_STATE_ATTR:
> 		if (strcmp(element_name, "vallist") == 0) {
> 			aux->state = FR_LOADER_STATE_VALLIST;
> 			aux->vstate = FR_LOADER_STATE_ATTR;
> 		} else
> 			g_warning("FREF Config Error: Unknown tag (%s)", element_name);
> 		break;					/* state ATTR */
> 	case FR_LOADER_STATE_PARAM:
> 		if (strcmp(element_name, "vallist") == 0) {
> 			aux->state = FR_LOADER_STATE_VALLIST;
> 			aux->vstate = FR_LOADER_STATE_PARAM;
> 		} else
> 			g_warning("FREF Config Error: Unknown tag (%s)", element_name);
> 		break;					/* state PARAM */
> 	}							/* switch */
> 
> 	if (path) gtk_tree_path_free (path);
> 	g_hash_table_destroy(attrs);
> }
> 
> void fref_loader_end_element(GMarkupParseContext * context, const gchar * element_name,
> 							 gpointer user_data, GError ** error)
> {
> 	FRParseAux *aux;
> 
> 	if (user_data == NULL)
> 		return;
> 	aux = (FRParseAux *) user_data;
> 	switch (aux->state) {
> 	case FR_LOADER_STATE_TAG:
> 		if (strcmp(element_name, "tag") == 0) {
> 			aux->act_info = NULL;
> 			aux->pstate = FR_LOADER_STATE_NONE;
> 		}
> 		break;					/* tag */
> 	case FR_LOADER_STATE_FUNC:
> 		if (strcmp(element_name, "function") == 0) {
> 			aux->act_info = NULL;
> 			aux->pstate = FR_LOADER_STATE_NONE;
> 		}
> 		break;					/* function */
> 	case FR_LOADER_STATE_ATTR:
> 		if (strcmp(element_name, "attribute") == 0) {
> 			aux->act_attr = NULL;
> 			aux->pstate = FR_LOADER_STATE_TAG;
> 		}
> 		break;					/* attribute */
> 	case FR_LOADER_STATE_PARAM:
> 		if (strcmp(element_name, "param") == 0) {
> 			aux->act_param = NULL;
> 			aux->pstate = FR_LOADER_STATE_FUNC;
> 		}
> 		break;					/* param */
> 	}							/* switch */
> 
> 	if (aux->state != FR_LOADER_STATE_VALLIST)
> 		aux->state = aux->pstate;
> 	else
> 		aux->state = aux->vstate;
> 
> 	if (strcmp(element_name, "group") == 0) {
> 		if (aux->nest_level > 0) {
> 			(aux->nest_level)--;
> 			if (aux->nest_level < MAX_NEST_LEVEL)
> 				aux->parent = aux->grp_parent[aux->nest_level];
> 		}
> 	}
> 
> }
> 
> void fref_loader_text(GMarkupParseContext * context, const gchar * _text, gsize _text_len,
> 					  gpointer user_data, GError ** error)
> {
> 	FRParseAux *aux;
> 	gchar *text;
> 	gint text_len;
> 	FRInfo *tmpinfo;
> 
> 	if (user_data == NULL && _text == NULL)
> 		return;
> 	/* remove white spaces from the begining and the end */
> 	text = g_strdup(_text);
> 	text = g_strstrip(text);
> 	text_len = strlen(text);
> 
> 	aux = (FRParseAux *) user_data;
> 	switch (aux->state) {
> 	case FR_LOADER_STATE_DESCR:
> 		aux->act_info->description = g_strndup(text, text_len);
> 		break;
> 	case FR_LOADER_STATE_TIP:
> 		aux->act_info->tip = g_strndup(text, text_len);
> 		break;
> 	case FR_LOADER_STATE_ATTR:
> 		aux->act_attr->description = g_strndup(text, text_len);
> 		break;
> 	case FR_LOADER_STATE_PARAM:
> 		aux->act_param->description = g_strndup(text, text_len);
> 		break;
> 	case FR_LOADER_STATE_RETURN:
> 		aux->act_info->return_description = g_strndup(text, text_len);
> 		break;
> 	case FR_LOADER_STATE_VALLIST:
> 		if (aux->vstate == FR_LOADER_STATE_ATTR)
> 			aux->act_attr->values = g_strndup(text, text_len);
> 		else if (aux->vstate == FR_LOADER_STATE_PARAM)
> 			aux->act_param->values = g_strndup(text, text_len);
> 		else
> 			g_warning("FREF Config Error: cannot assign vallist");
> 		break;
> 	case FR_LOADER_STATE_DIALOG:
> 		aux->act_info->dialog_text = g_strndup(text, text_len);
> 		break;
> 	case FR_LOADER_STATE_INFO:
> 		aux->act_info->info_text = g_strndup(text, text_len);
> 		break;
> 	case FR_LOADER_STATE_INSERT:
> 		aux->act_info->insert_text = g_strndup(text, text_len);
> 		break;
> 	case FR_LOADER_STATE_GROUPDESC:
> 		gtk_tree_model_get(GTK_TREE_MODEL(aux->store), &aux->parent, PTR_COLUMN, &tmpinfo, -1);
> 		if (tmpinfo != NULL) {
> 			/* BUG?? this appears as if it is freed in fref_free_info()
> 			 * but a small memory leak is shown when opening the HTML ref
> 			 */
> 			tmpinfo->description = g_strndup(text, text_len);
> 		}
> 		break;
> 	}							/* switch */
> 	g_free(text);
> }
> 
> void fref_loader_error(GMarkupParseContext * context, GError * error, gpointer user_data)
> {
> 	if (error != NULL)
> 		g_warning("FREF Config Error: %s", error->message);
> 	else
> 		g_warning("FREF Config Error: Unknown Error");
> }
> 
> /* CONFIG FILE PARSER */
> 
> static GMarkupParser FRParser = {
> 	fref_loader_start_element,
> 	fref_loader_end_element,
> 	fref_loader_text,
> 	NULL,
> 	fref_loader_error
> };
> 
> /* AUXILIARY FILE PARSER */
> 
> static GMarkupParser FRNameParser = {
> 	fref_name_loader_start_element,
> 	NULL,
> 	NULL,
> 	NULL,
> 	fref_loader_error
> };
> 
> gchar *fref_xml_get_refname(gchar * filename)
> {
> 	GMarkupParseContext *ctx;
> 	gchar *config, *refname;
> 	gsize len;
> 	Tfref_name_data *aux = NULL;
> 
> 	if (filename == NULL)
> 		return NULL;
> 
> 	aux = g_new0(Tfref_name_data, 1);
> 	ctx = g_markup_parse_context_new(&FRNameParser, (GMarkupParseFlags) 0, (gpointer) aux, NULL);
> 	if (ctx == NULL) {
> 		g_free(aux);
> 		return NULL;
> 	}
> 	if (!g_file_get_contents(filename, &config, &len, NULL)) {
> 		g_markup_parse_context_free(ctx);
> 		g_free(aux);
> 		return NULL;
> 	}
> 
> 	if (!g_markup_parse_context_parse(ctx, config, len, NULL)) {
> 		g_markup_parse_context_free(ctx);
> 		g_free(aux);
> 		g_free(config);
> 		return NULL;
> 	}
> 
> 	g_markup_parse_context_free(ctx);
> 	refname = aux->name;
> 	g_free(aux->description);
> 	g_free(aux);
> 	g_free(config);
> 	return refname;
> }
> 
> void fref_loader_load_ref_xml(gchar * filename, GtkWidget * tree, GtkTreeStore * store,
> 							  GtkTreeIter * parent, GHashTable * dict)
> {
> 	GMarkupParseContext *ctx;
> 	gchar *config;
> 	gsize len;
> 	FRParseAux *aux;
> 
> 	if (filename == NULL)
> 		return;
> 	aux = g_new0(FRParseAux, 1);
> 	aux->tree = tree;
> 	aux->store = store;
> 	aux->state = FR_LOADER_STATE_NONE;
> 	aux->parent = *parent;
> 	aux->nest_level = 0;
> 	aux->dict = dict;
> 
> 	ctx = g_markup_parse_context_new(&FRParser, (GMarkupParseFlags) 0, (gpointer) aux, NULL);
> 	if (ctx == NULL)
> 		return;
> 	if (!g_file_get_contents(filename, &config, &len, NULL)) {
> 		g_markup_parse_context_free(ctx);
> 		g_free(aux);
> 		return;
> 	}
> 	if (!g_markup_parse_context_parse(ctx, config, len, NULL)) {
> 		g_markup_parse_context_free(ctx);
> 		g_free(aux);
> 		g_free(config);
> 		return;
> 	}
> 	g_markup_parse_context_free(ctx);
> 	if (aux->act_info)
> 		fref_free_info(aux->act_info);
>     if (aux->act_grp)
>         fref_free_info(aux->act_grp);
> 	if (aux->act_attr) {
> 		g_free(aux->act_attr->name);
> 		g_free(aux->act_attr->title);
> 		g_free(aux->act_attr->description);
> 		g_free(aux->act_attr->def_value);
> 		g_free(aux->act_attr->values);
> 		g_free(aux->act_attr);
> 	}
> 	if (aux->act_param) {
> 		g_free(aux->act_param->name);
> 		g_free(aux->act_param->title);
> 		g_free(aux->act_param->description);
> 		g_free(aux->act_param->def_value);
> 		g_free(aux->act_param->type);
> 		g_free(aux->act_param->values);
> 		g_free(aux->act_param);
> 	}
> 	g_free(aux);
> 	g_free(config);
> }
> 
> void fref_loader_unload_ref(GtkTreeStore * store, GtkTreeIter * position)
> {
> 	GtkTreeIter iter;
> 	GtkTreePath *path;
> 
> 	path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), position);
> 	DEBUG_MSG("fref_loader_unload_ref, called for path %s\n", gtk_tree_path_to_string(path));
> 	while (gtk_tree_model_iter_children(GTK_TREE_MODEL(store), &iter, position)) {
> 		FRInfo *entry;
> 		gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, PTR_COLUMN, &entry, -1);
> 		if (gtk_tree_model_iter_has_child(GTK_TREE_MODEL(store), &iter)) {
> 			fref_loader_unload_ref(store, &iter);
> 			/* have not to free entry name, because this is a pointer to info field */
> 		}
> 		/* this is very crappy... on my OpenBSD box gtk_tree_store_remove() has a different
> 		   prototype, and it does *not* return a boolean, but just void, that means we can't 
> 		   use it to step trough the tree... */
> 		gtk_tree_store_remove(store, &iter);
> 		if (entry != NULL) {
> 			fref_free_info(entry);
> 		}
> 	}							/* while */
> 
> 	iter = *position;
> 	if (gtk_tree_path_get_depth(path) > 1) {
> 		gchar *name;
> 		DEBUG_MSG("fref_loader_unload_ref, path depth > 0\n");
> 		/*gtk_tree_model_get_iter(GTK_TREE_MODEL(store),&iter,path); */
> 		gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, STR_COLUMN, &name, -1);
> 		if (name) {
> 			/* have to free name column for group */
> 			DEBUG_MSG("fref_loader_unload_ref, free'ing %s\n", name);
> 			g_free(name);		/* freeing item name */
> 		}
> 	} else {					/* freeing search dictionary */
> 		GHashTable *dict;
> 		DEBUG_MSG("fref_loader_unload_ref, path depth == 0, this is the top node\n");
> 		/*gtk_tree_model_get_iter(GTK_TREE_MODEL(store),&iter,path);  */
> 		gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, PTR_COLUMN, &dict, -1);
> 		if (dict) {
> 			DEBUG_MSG("fref_loader_unload_ref, destroying search hashtable %p\n", dict);
> 			g_hash_table_destroy(dict);
> 			gtk_tree_store_set(store, &iter, PTR_COLUMN, NULL, -1);
> 		}
> 	}
> 	gtk_tree_path_free(path);
> 	DEBUG_MSG("fref_loader_unload, done\n");
> }
> 
> void fref_loader_unload_all(GtkWidget * tree, GtkTreeStore * store)
> {
> 
> 	GtkTreeIter iter;
> 	gint *cnt = NULL;
> 	gpointer *aux;
> 	gboolean do_unload = FALSE;
> 
> 	DEBUG_MSG("fref_loader_unload_all, started for tree=%p, store=%p\n", tree, store);
> 	while (gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(store), &iter, NULL, 0)) {
> 		GtkTreePath *path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &iter);
> 		if (gtk_tree_path_get_depth(path) == 1) {
> 			gchar *cat;
> 			gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, STR_COLUMN, &cat, -1);
> 			DEBUG_MSG("fref_loader_unload_all, cat=%s\n", cat);
> 			aux = g_hash_table_lookup(FREFDATA(main_v->frefdata)->refcount, cat);
> 			if (cat) 
> 				g_free (cat);
> 				
> 			if (aux != NULL) {
> 				cnt = (gint *) aux;
> 				*cnt = (*cnt) - 1;
> 				if (*cnt <= 0)
> 					do_unload = TRUE;
> 				else
> 					do_unload = FALSE;
> 				DEBUG_MSG("fref_loader_unload_all, cnt=%d, do_unload=%d\n", *cnt, do_unload);
> 			} else
> 				do_unload = FALSE;				
> 		} else
> 			do_unload = FALSE;
> 		if (do_unload) {
> 			gchar *file, *name;
> 			DEBUG_MSG("fref_loader_unload_all, calling fref_loader_unload_ref\n");
> 			fref_loader_unload_ref(store, &iter);
> 			gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, STR_COLUMN, &name, FILE_COLUMN, &file,
> 							   -1);
> 			if (file) {
> 				DEBUG_MSG("fref_loader_unload_all, freeing %s\n", file);
> 				g_free(file);
> 			}
> 			if (name) {
> 				DEBUG_MSG("fref_loader_unload_all, freeing %s\n", name);
> 				g_free(name);
> 			}
> 			gtk_tree_store_remove(store, &iter);
> 		}						/* do_unload */
> 		if (path)
> 			gtk_tree_path_free (path);
> 	}							/* while */
> 	/* gtk_tree_store_clear(store); */
> }
> 
> /* END OF CONFIG PARSER */
> 
> /* GUI */
> static void fill_toplevels(Tfref_data * fdata, gboolean empty_first)
> {
> 	GList *reflist;
> 	gint *cnt;
> 
> 	if (empty_first) {
> 		gtk_tree_store_clear(fdata->store);
> 	}
> 	/* prepare first nodes - read from configuration data */
> 	reflist = g_list_first(main_v->props.reference_files);
> 	while (reflist) {
> 		gchar **tmparray = reflist->data;
> 		if (count_array(tmparray) == 2) {
> 			if (file_exists_and_readable(tmparray[1])) {
> 				GtkTreeIter iter;
> 				GtkTreeIter iter2;
> 				gtk_tree_store_append(fdata->store, &iter, NULL);
> 				gtk_tree_store_set(fdata->store, &iter, STR_COLUMN, tmparray[0], PTR_COLUMN, NULL,
> 								   FILE_COLUMN, tmparray[1], -1);
> 				cnt = g_new0(gint, 1);
> 				*cnt = 0;
> 				g_hash_table_replace(fdata->refcount, g_strdup(tmparray[0]), cnt);
> 
> 				/* dummy node for er display */
> 				gtk_tree_store_append(fdata->store, &iter2, &iter);
> 			}
> 		}
> 		reflist = g_list_next(reflist);
> 	}
> }
> 
> void fref_cleanup(Tbfwin * bfwin)
> {
> 	DEBUG_MSG("fref_cleanup, started for bfwin=%p, refcount at %p\n", bfwin,
> 			  FREFDATA(main_v->frefdata)->refcount);
> 	fref_loader_unload_all(FREFGUI(bfwin->fref)->tree, FREFDATA(main_v->frefdata)->store);
> /*	g_hash_table_destroy(FREFDATA(main_v->frefdata)->refcount); */
> /* Ok I'll not free search dictionary too ... O.S. */
> 	FREFGUI(bfwin->fref)->tree = NULL;
> 	FREFGUI(bfwin->fref)->argtips = NULL;
> 	tree_tips_destroy(FREFGUI(bfwin->fref)->tips);
> 	g_free (bfwin->fref);
> 	bfwin->fref = NULL;
> }
> 
> /* fref_init is ONCE called by bluefish.c to init the fref_data structure */
> void fref_init()
> {
> 	Tfref_data *fdata = g_new(Tfref_data, 1);
> 	fdata->store = gtk_tree_store_new(N_COLUMNS, G_TYPE_STRING, G_TYPE_POINTER, G_TYPE_STRING);
> 	fdata->refcount = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
> 	fill_toplevels(fdata, FALSE);
> 	DEBUG_MSG("fref_init, refcount at %p\n", fdata->refcount);
> 	main_v->frefdata = fdata;
> }
> 
> /*------------ PREPARE INFO -----------------------*/
> gchar *fref_prepare_info(FRInfo * entry, gint infotype, gboolean use_colors)
> {
> 	gchar *ret, *tofree;
> 	GList *lst;
> 	FRAttrInfo *tmpa;
> 	FRParamInfo *tmpp;
> 
> 	ret = g_strdup("");
> 	switch (entry->type) {
> 	case FR_TYPE_GROUP:
> 		switch (infotype) {
> 		case FR_INFO_DESC:
> 			if (entry->description != NULL) {
> 				gchar *escaped = xml_escape(entry->description);
> 				tofree = ret;
> 				if (use_colors) {
> 
> 					ret =
> 						g_strconcat(ret, "<span size=\"small\"  foreground=\"#FFFFFF\" >       ",
> 									escaped, "</span>", NULL);
> 				} else {
> 					ret =
> 						g_strconcat(ret, "<span size=\"small\">       ", escaped, "</span>", NULL);
> 				}
> 				g_free(tofree);
> 				g_free(escaped);
> 			}
> 			break;
> 		}
> 		break;
> 	case FR_TYPE_TAG:
> 		switch (infotype) {
> 		case FR_INFO_TITLE:
> 			tofree = ret;
> 			if (use_colors)
> 				ret =
> 					g_strconcat(ret, "<span size=\"medium\" foreground=\"#FFFFFF\" >  TAG: <b>",
> 								entry->name, "</b></span>", NULL);
> 			else
> 				ret =
> 					g_strconcat(ret, "<span size=\"medium\">  TAG: <b>", entry->name, "</b></span>",
> 								NULL);
> 			g_free(tofree);
> 			break;
> 		case FR_INFO_DESC:
> 			if (entry->description != NULL) {
> 				gchar *escaped = xml_escape(entry->description);
> 				tofree = ret;
> 				if (use_colors)
> 					ret =
> 						g_strconcat(ret, "<span size=\"small\"  foreground=\"#FFFFFF\" >       ",
> 									escaped, "</span>", NULL);
> 				else
> 					ret =
> 						g_strconcat(ret, "<span size=\"small\">       ", escaped, "</span>", NULL);
> 				g_free(tofree);
> 				g_free(escaped);
> 			}
> 			break;
> 		case FR_INFO_NOTES:
> 			if (entry->info_text != NULL) {
> 				gchar *escaped = xml_escape(entry->info_text);
> 				tofree = ret;
> 
> 				if (use_colors)
> 					ret =
> 						g_strconcat(ret, "<span size=\"medium\" foreground=\"", FR_COL_4,
> 									"\" ><b>NOTES:</b> \n", escaped, "</span>", NULL);
> 				else
> 					ret =
> 						g_strconcat(ret, "<span size=\"medium\"><b>NOTES:</b> \n", escaped,
> 									"</span>", NULL);
> 				g_free(tofree);
> 				g_free(escaped);
> 			}
> 			break;
> 		case FR_INFO_ATTRS:
> 			lst = g_list_first(entry->attributes);
> 			while (lst) {
> 				gchar *escaped1, *escaped2;
> 				tmpa = (FRAttrInfo *) lst->data;
> 				tofree = ret;
> 				escaped1 = xml_escape(tmpa->name);
> 				escaped2 = xml_escape(tmpa->description);
> 				if (use_colors) 
> 					
> 					ret =
> 						g_strconcat(ret, "<span size=\"small\" >          <b><i>", escaped1,
> 									"</i></b></span> - <span size=\"small\" foreground=\"",
> 									FR_COL_3, "\" >", escaped2, "</span>\n", NULL);
> 				else
> 					ret =
> 						g_strconcat(ret, "<span size=\"small\" >          <b><i>", escaped1,
> 									"</i></b></span> - <span size=\"small\">", escaped2,
> 									"</span>\n", NULL);
> 				g_free(escaped1);
> 				g_free(escaped2);
> 				g_free(tofree);
> 				lst = g_list_next(lst);
> 			}
> 			break;
> 		}						/* switch infotype */
> 		break;					/* TAG */
> 	case FR_TYPE_FUNCTION:
> 		switch (infotype) {
> 		case FR_INFO_TITLE:
> 			tofree = ret;
> 			if (use_colors)
> 				ret =
> 					g_strconcat(ret,
> 								"<span size=\"medium\" foreground=\"#FFFFFF\" >  FUNCTION: <b>",
> 								entry->name, "</b></span>", NULL);
> 			else
> 				ret =
> 					g_strconcat(ret, "<span size=\"medium\">  FUNCTION: <b>", entry->name,
> 								"</b></span>", NULL);
> 			g_free(tofree);
> 			break;
> 		case FR_INFO_DESC:
> 			if (entry->description != NULL) {
> 				gchar *escaped = xml_escape(entry->description);
> 				tofree = ret;
> 				if (use_colors)
> 					ret =
> 						g_strconcat(ret, "<span size=\"small\" foreground=\"#FFFFFF\" >       <i>",
> 									escaped, "</i></span>\n", NULL);
> 				else
> 					ret =
> 						g_strconcat(ret, "<span size=\"small\">       <i>", escaped,
> 									"</i></span>\n", NULL);
> 				g_free(tofree);
> 				g_free(escaped);
> 			}
> 			if (entry->return_type != NULL) {
> 				tofree = ret;
> 				if (use_colors)
> 					ret =
> 						g_strconcat(ret, "<span size=\"medium\" foreground=\"", FR_COL_4,
> 									"\">       <b>RETURNS: ", entry->return_type, "</b></span>\n",
> 									NULL);
> 				else
> 					ret =
> 						g_strconcat(ret, "<span size=\"medium\">       <b>RETURNS: ",
> 									entry->return_type, "</b></span>\n", NULL);
> 				g_free(tofree);
> 			}
> 			if (entry->return_description != NULL) {
> 				tofree = ret;
> 				if (use_colors)
> 					ret =
> 						g_strconcat(ret, "<span size=\"small\" foreground=\"", FR_COL_4,
> 									"\">       ", entry->return_description, "</span>\n", NULL);
> 				else
> 					ret =
> 						g_strconcat(ret, "<span size=\"small\">       ", entry->return_description,
> 									"</span>\n", NULL);
> 				g_free(tofree);
> 			}
> 			break;
> 		case FR_INFO_NOTES:
> 			if (entry->info_text != NULL) {
> 				gchar *escaped = xml_escape(entry->info_text);
> 				tofree = ret;
> 				if (use_colors)
> 					ret =
> 						g_strconcat(ret, "<span size=\"medium\" foreground=\"", FR_COL_4,
> 									"\"><b>NOTES:</b> \n", escaped, "</span>", NULL);
> 				else
> 					ret =
> 						g_strconcat(ret, "<span size=\"medium\"><b>NOTES:</b> \n", escaped,
> 									"</span>", NULL);
> 				g_free(tofree);
> 				g_free(escaped);
> 			}
> 			break;
> 		case FR_INFO_ATTRS:
> 			lst = g_list_first(entry->params);
> 			while (lst) {
> 				tmpp = (FRParamInfo *) lst->data;
> 				tofree = ret;
> 				if (tmpp->description != NULL && tmpp->type != NULL) {
> 					gchar *escaped1, *escaped2, *escaped3;
> 					escaped1 = xml_escape(tmpp->name);
> 					escaped2 = xml_escape(tmpp->type);
> 					escaped3 = xml_escape(tmpp->description);
> 					if (use_colors)
> 						ret =
> 							g_strconcat(ret, "<span size=\"small\">          <b><i>", escaped1,
> 										"(", escaped2,
> 										")</i></b></span> - <span size=\"small\" foreground=\"",
> 										FR_COL_3, "\">", escaped3, "</span>\n", NULL);
> 					else
> 						ret =
> 							g_strconcat(ret, "<span size=\"small\">          <b><i>", escaped1,
> 										"(", escaped2, ")</i></b></span> - <span size=\"small\">",
> 										escaped3, "</span>\n", NULL);
> 					g_free(escaped1);
> 					g_free(escaped2);
> 					g_free(escaped3);
> 				} else if (tmpp->type != NULL) {
> 					gchar *escaped1, *escaped2;
> 					escaped1 = xml_escape(tmpp->name);
> 					escaped2 = xml_escape(tmpp->type);
> 					ret =
> 						g_strconcat(ret, "<span size=\"small\">          <b><i>", escaped1, "(",
> 									escaped2, ")</i></b></span>\n", NULL);
> 					g_free(escaped1);
> 					g_free(escaped2);
> 				} else {
> 					gchar *escaped1;
> 					escaped1 = xml_escape(tmpp->name);
> 					ret =
> 						g_strconcat(ret, "<span size=\"small\">          <b><i>", escaped1,
> 									"</i></b></span>\n", NULL);
> 					g_free(escaped1);
> 				}
> 				g_free(tofree);
> 				lst = g_list_next(lst);
> 			}
> 			break;
> 		}						/* switch infotype */
> 		break;
> 	}
> 	return ret;
> }
> 
> /*------------ SHOW INFO -----------------------*/
> static void info_window_close_lcb(GtkWidget * widget, gpointer data)
> {
> 	gtk_widget_destroy(data);
> }
> 
> 
> 
> gchar *fref_prepare_text(FRInfo * entry, GtkWidget * dialog)
> {
> 	/* Here attribute/param names have to be replaced by values from dialog */
> 	gchar *p, *prev, *stringdup, *tofree;
> 	gchar *tmp, *dest, *tmp3 = NULL;
> 	GList *lst;
> 	gint d1, d2;
> 	FRAttrInfo *tmpa;
> 	FRParamInfo *tmpp;
> 	const gchar *converted = NULL, *tmp2 = NULL;
> 
> 	dest = g_strdup("");
> 	stringdup = g_strdup(entry->dialog_text);
> 	prev = stringdup;
> 	p = strchr(prev, '%');
> 	while (p) {
> 		tmp = dest;
> 		*p = '\0';
> 		p++;
> 		if (*p == '%') {
> 			converted = "%";
> 		} else {
> 
> 			switch (entry->type) {
> 			case FR_TYPE_TAG:
> 				d1 = g_ascii_digit_value(*p);
> 				if (d1 != -1) {
> 					d2 = g_ascii_digit_value(*(p + 1));
> 					if (d2 != -1)
> 						d1 = d1 * 10 + d2;
> 					lst = g_list_nth(entry->attributes, d1);
> 					if (lst != NULL) {
> 						tmpa = (FRAttrInfo *) lst->data;
> 						if (tmpa->dlg_item) {
> 							if (GTK_IS_COMBO(tmpa->dlg_item))
> 								converted =
> 									gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(tmpa->dlg_item)->entry));
> 							else
> 								converted = gtk_entry_get_text(GTK_ENTRY(tmpa->dlg_item));
> 						} else
> 							converted = "";
> 					} else
> 						converted = "";
> 				} else if (*p == '_') {	/* non empty attributes */
> 					lst = g_list_first(entry->attributes);
> 					tmp3 = g_strdup("");
> 					while (lst != NULL) {
> 						tmpa = (FRAttrInfo *) lst->data;
> 						if (tmpa->dlg_item) {
> 							if (GTK_IS_COMBO(tmpa->dlg_item))
> 								tmp2 =
> 									gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(tmpa->dlg_item)->entry));
> 							else
> 								tmp2 = gtk_entry_get_text(GTK_ENTRY(tmpa->dlg_item));
> 							if (strcmp(tmp2, "") != 0) {
> 								tofree = tmp3;
> 								tmp3 = g_strconcat(tmp3, " ", tmpa->name, "=\"", tmp2, "\"", NULL);
> 								g_free(tofree);
> 							}
> 						}
> 						lst = g_list_next(lst);
> 					}			/* while */
> 					converted = tmp3;
> 				} else if (*p == '~') {	/* non empty attributes and required  */
> 					lst = g_list_first(entry->attributes);
> 					tmp3 = g_strdup("");
> 					while (lst != NULL) {
> 						tmpa = (FRAttrInfo *) lst->data;
> 						if (tmpa->dlg_item) {
> 							if (GTK_IS_COMBO(tmpa->dlg_item))
> 								tmp2 =
> 									gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(tmpa->dlg_item)->entry));
> 							else
> 								tmp2 = gtk_entry_get_text(GTK_ENTRY(tmpa->dlg_item));
> 							if (strcmp(tmp2, "") != 0 || tmpa->required) {
> 								tofree = tmp3;
> 								tmp3 = g_strconcat(tmp3, " ", tmpa->name, "=\"", tmp2, "\"", NULL);
> 								g_free(tofree);
> 							}
> 						}
> 						lst = g_list_next(lst);
> 					}			/* while */
> 					converted = tmp3;
> 				}				/* required and non-empty */
> 				break;
> 			case FR_TYPE_FUNCTION:
> 				d1 = g_ascii_digit_value(*p);
> 				if (d1 != -1) {
> 					d2 = g_ascii_digit_value(*(p + 1));
> 					if (d2 != -1)
> 						d1 = d1 * 10 + d2;
> 					lst = g_list_nth(entry->params, d1);
> 					if (lst != NULL) {
> 						tmpp = (FRParamInfo *) lst->data;
> 						if (tmpp->dlg_item) {
> 							if (GTK_IS_COMBO(tmpp->dlg_item))
> 								converted =
> 									gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(tmpp->dlg_item)->entry));
> 							else
> 								converted = gtk_entry_get_text(GTK_ENTRY(tmpp->dlg_item));
> 						} else
> 							converted = "";
> 					} else
> 						converted = "";
> 				}
> 				break;
> 
> 			}					/* switch */
> 		}
> 		dest = g_strconcat(dest, prev, converted, NULL);
> 		g_free(tmp);			/* here I free the dest (tmp=dest) */
> 		g_free(tmp3);
> 		prev = ++p;
> 		p = strchr(p, '%');
> 	}
> 	tmp = dest;
> 	dest = g_strconcat(dest, prev, NULL);
> 	g_free(tmp);
> 	g_free(stringdup);
> 	return dest;
> }
> 
> GList *fref_string_to_list(gchar * string, gchar * delimiter)
> {
> 	GList *lst;
> 	gchar **arr;
> 	gint i;
> 
> 	lst = NULL;
> 	arr = g_strsplit(string, delimiter, 0);
> 	i = 0;
> 	while (arr[i] != NULL) {
> 		lst = g_list_append(lst, arr[i]);
> 		i++;
> 	}
> 	return lst;
> }
> 
> 
> /* CALLBACKS */
> 
> static GtkWidget *togglemenuitem(GSList * group, gchar * name, gboolean selected,
> 								 GCallback toggledfunc, gpointer toggleddata)
> {
> 	GtkWidget *retval;
> 	retval = gtk_radio_menu_item_new_with_label(group, name);
> 	gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(retval), selected);
> 	g_signal_connect(GTK_OBJECT(retval), "toggled", toggledfunc, toggleddata);
> 	DEBUG_MSG("togglemenuitem, created %p and set to %d\n", retval, selected);
> 	return retval;
> }
> 
> static void fref_ldblclck_changed(GtkWidget * widget, gpointer data)
> {
> 	if (GTK_CHECK_MENU_ITEM(widget)->active) {
> 		DEBUG_MSG("fref_ldblclck_changed, set to %d\n", GPOINTER_TO_INT(data));
> 		main_v->globses.fref_ldoubleclick_action = GPOINTER_TO_INT(data);
> 	}
> }
> 
> static void fref_infotype_changed(GtkWidget * widget, gpointer data)
> {
> 	if (GTK_CHECK_MENU_ITEM(widget)->active) {
> 		DEBUG_MSG("fref_infotype_changed, set to %d\n", GPOINTER_TO_INT(data));
> 		main_v->globses.fref_info_type = GPOINTER_TO_INT(data);
> 	}
> }
> 
> static FRInfo *get_current_entry(Tbfwin * bfwin)
> {
> 	GtkTreePath *path;
> 	GtkTreeViewColumn *col;
> 	gint depth;
> 	
> 	gtk_tree_view_get_cursor(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), &path, &col);
> 	depth = gtk_tree_path_get_depth (path);
> 	if (depth > 1) {
>         if (path != NULL) {
>     	    FRInfo *retval = NULL;
>     	    GValue *val;
>     	    GtkTreeIter iter;
>     	    gtk_tree_model_get_iter(gtk_tree_view_get_model(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree)),
>     	    						&iter, path);
>     	    gtk_tree_path_free(path);
>     	    val = g_new0(GValue, 1);
>     	    gtk_tree_model_get_value(gtk_tree_view_get_model(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree)),
>     	    						 &iter, 1, val);
>     	    if (G_IS_VALUE(val) && g_value_fits_pointer(val)) {
>     	    	retval = (FRInfo *) g_value_peek_pointer(val);
>     	    }
>     	    g_value_unset(val);
>     	    g_free(val);
>     	    return retval;
>         }
>     }
> 	return NULL;
> }
> 
> gboolean frefcb_info_keypress(GtkWidget * widget, GdkEventKey * event, Tcallbackdata * cd)
> {
> 	if (event->keyval == GDK_Escape && cd->data != NULL) {
> 		gtk_widget_destroy(GTK_WIDGET(cd->data));
> 		g_free(cd);
> 		return FALSE;
> 	}
> 	return TRUE;
> }
> 
> static void frefcb_info_close(GtkButton * button, Tcallbackdata * cd)
> {
> 	if (cd->data != NULL) {
> 		gtk_widget_destroy(GTK_WIDGET(cd->data));
> 	}
> 	g_free(cd);
> }
> 
> 
> static void frefcb_row_expanded(GtkTreeView * treeview, GtkTreeIter * arg1, GtkTreePath * arg2,
> 								gpointer user_data)
> {
> 	GValue *val;
> 	GtkTreeIter iter;
> 	gchar *cat;
> 	gint *cnt = NULL;
> 	gpointer *aux;
> 	gboolean do_load = FALSE;
> 	GHashTable *dict;
> 
> 	if (gtk_tree_path_get_depth(arg2) == 1) {
> 		val = g_new0(GValue, 1);
> 		gtk_tree_model_get_value(GTK_TREE_MODEL(user_data), arg1, 0, val);
> 		cat = (gchar *) (g_value_peek_pointer(val));
> 		aux = g_hash_table_lookup(FREFDATA(main_v->frefdata)->refcount, cat);
> 		if (aux != NULL) {
> 			cnt = (gint *) aux;
> 			*cnt = (*cnt) + 1;
> 			if (*cnt == 1)
> 				do_load = TRUE;
> 			else
> 				do_load = FALSE;
> 		} else
> 			do_load = FALSE;
> 		g_value_unset (val);
> 		g_free (val);
> 	} else
> 		do_load = FALSE;
> 	if (do_load) {
> 		val = g_new0(GValue, 1);
> 		gtk_tree_model_get_value(GTK_TREE_MODEL(user_data), arg1, 2, val);
> 		dict =
> 			g_hash_table_new_full(g_str_hash, g_str_equal, g_free,
> 								  (GDestroyNotify) gtk_tree_row_reference_free);
> 		DEBUG_MSG("frefcb_row_expanded, search hash_table at %p\n", dict);
> 		gtk_tree_store_set(GTK_TREE_STORE(user_data), arg1, PTR_COLUMN, dict, -1);
> 		if (G_IS_VALUE(val) && g_value_peek_pointer(val) != NULL) {
> 			fref_loader_load_ref_xml((gchar *) g_value_peek_pointer(val), GTK_WIDGET(treeview),
> 									 GTK_TREE_STORE(user_data), arg1, dict);
> 		}
> 
> 		/* remove dummy */
> 
> 		if (g_value_peek_pointer(val) != NULL
> 			&& gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(user_data), &iter, arg1, 0)) {
> 			gtk_tree_store_remove(GTK_TREE_STORE(user_data), &iter);
> 		}
> 		g_value_unset (val);
> 		g_free (val);
> 	}
> }
> 
> static void frefcb_info_dialog(GtkButton * button, Tcallbackdata * cd)
> {
> 	FRInfo *entry;
> 	GtkWidget *dialog;
> 	gchar *pomstr;
> 	gint resp;
> 	Tbfwin *bfwin = cd->bfwin;
> 
> 	if (cd->data != NULL) {
> 		gtk_widget_destroy(GTK_WIDGET(cd->data));
> 		g_free(cd);
> 	}
> 	entry = get_current_entry(bfwin);
> 	if (entry == NULL)
> 		return;
> 
> 	dialog = fref_prepare_dialog(bfwin, entry);
> 	if (dialog) {
> 		resp = gtk_dialog_run(GTK_DIALOG(dialog));
> 		if (resp == GTK_RESPONSE_OK) {
> 			pomstr = fref_prepare_text(entry, dialog);
> 			gtk_widget_destroy(dialog);
> 			doc_insert_two_strings(bfwin->current_document, pomstr, NULL);
> 			g_free(pomstr);
> 		} else
> 			gtk_widget_destroy(dialog);
> 	}
> }
> 
> static void frefcb_info_insert(GtkButton * button, Tcallbackdata * cd)
> {
> 	FRInfo *entry;
> 	Tbfwin *bfwin = cd->bfwin;
> 	if (cd->data != NULL) {
> 		gtk_widget_destroy(GTK_WIDGET(cd->data));
> 		g_free(cd);
> 	}
> 	entry = get_current_entry(bfwin);
> 	if (entry == NULL || entry->insert_text == NULL)
> 		return;
> 	doc_insert_two_strings(bfwin->current_document, entry->insert_text, NULL);
> 
> }
> 
> void fref_show_info(Tbfwin * bfwin, FRInfo * entry, gboolean modal, GtkWidget * parent)
> {
> 	GtkWidget *label_t, *frame, *scroll, *view, *btn1, *btn2, *btn3, *vbox, *hbox, *fourbox,
> 		*label_d, *label_a, *label_n, *ev_t, *ev_d, *ev_a, *ev_n;
> 	GtkWidget *info_window;
> 	Tcallbackdata *cd;
> 	GdkColor col1, col2, col4;
> 
> 	cd = g_new(Tcallbackdata, 1);
> 	gdk_color_parse(FR_COL_1, &col1);
> 	gdk_color_parse(FR_COL_2, &col2);
> 	gdk_color_parse(FR_COL_4, &col4);
> 
> 	label_t = gtk_label_new(fref_prepare_info(entry, FR_INFO_TITLE, TRUE));
> 	label_d = gtk_label_new(fref_prepare_info(entry, FR_INFO_DESC, TRUE));
> 	label_a = gtk_label_new(fref_prepare_info(entry, FR_INFO_ATTRS, TRUE));
> 	label_n = gtk_label_new(fref_prepare_info(entry, FR_INFO_NOTES, TRUE));
> 	gtk_label_set_use_markup(GTK_LABEL(label_t), TRUE);
> 	gtk_label_set_use_markup(GTK_LABEL(label_d), TRUE);
> 	gtk_label_set_use_markup(GTK_LABEL(label_a), TRUE);
> 	gtk_label_set_use_markup(GTK_LABEL(label_n), TRUE);
> 	gtk_misc_set_alignment(GTK_MISC(label_t), 0.0, 0.0);
> 	gtk_misc_set_padding(GTK_MISC(label_t), 5, 5);
> 	gtk_label_set_line_wrap(GTK_LABEL(label_t), TRUE);
> 	gtk_misc_set_alignment(GTK_MISC(label_d), 0.0, 0.0);
> 	gtk_misc_set_padding(GTK_MISC(label_d), 5, 5);
> 	gtk_label_set_line_wrap(GTK_LABEL(label_d), TRUE);
> 	gtk_misc_set_alignment(GTK_MISC(label_a), 0.0, 0.0);
> 	gtk_misc_set_padding(GTK_MISC(label_a), 5, 5);
> 	gtk_label_set_line_wrap(GTK_LABEL(label_a), TRUE);
> 	gtk_misc_set_alignment(GTK_MISC(label_n), 0.0, 0.0);
> 	gtk_misc_set_padding(GTK_MISC(label_n), 5, 5);
> 	gtk_label_set_line_wrap(GTK_LABEL(label_n), TRUE);
> 	ev_t = gtk_event_box_new();
> 	gtk_widget_modify_bg(GTK_WIDGET(ev_t), GTK_STATE_NORMAL, &col1);
> 	gtk_container_add(GTK_CONTAINER(ev_t), label_t);
> 	ev_d = gtk_event_box_new();
> 	gtk_widget_modify_bg(GTK_WIDGET(ev_d), GTK_STATE_NORMAL, &col2);
> 	gtk_container_add(GTK_CONTAINER(ev_d), label_d);
> 	ev_a = gtk_event_box_new();
> 	gtk_widget_modify_bg(GTK_WIDGET(ev_a), GTK_STATE_NORMAL, &col4);
> 	gtk_container_add(GTK_CONTAINER(ev_a), label_a);
> 	ev_n = gtk_event_box_new();
> 	gtk_widget_modify_bg(GTK_WIDGET(ev_n), GTK_STATE_NORMAL, &col1);
> 	gtk_container_add(GTK_CONTAINER(ev_n), label_n);
> 
> 	scroll = gtk_scrolled_window_new(NULL, NULL);
> 	btn2 = NULL;
> 	btn3 = NULL;
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_NEVER,
> 								   GTK_POLICY_AUTOMATIC);
> 	view =
> 		gtk_viewport_new(GTK_ADJUSTMENT(gtk_adjustment_new(0, 0, 1024, 1, 100, 200)),
> 						 GTK_ADJUSTMENT(gtk_adjustment_new(0, 0, 768, 1, 100, 200)));
> 	info_window = window_full2(_("Info"), GTK_WIN_POS_NONE, 0, G_CALLBACK(info_window_close_lcb)
> 							   , NULL, TRUE, FALSE);
> 
> 	if (modal) {
> 		gtk_window_set_modal(GTK_WINDOW(info_window), TRUE);
> 	}
> 
> 	fourbox = gtk_vbox_new(FALSE, 0);
> 
> 	frame = gtk_frame_new(NULL);
> 
> 	hbox = gtk_hbox_new(TRUE, 5);
> 
> 	gtk_container_add(GTK_CONTAINER(view), GTK_WIDGET(fourbox));
> 	gtk_box_pack_start(GTK_BOX(fourbox), ev_t, TRUE, TRUE, 0);
> 	gtk_box_pack_start(GTK_BOX(fourbox), ev_d, TRUE, TRUE, 0);
> 	gtk_box_pack_start(GTK_BOX(fourbox), ev_a, TRUE, TRUE, 0);
> 	gtk_box_pack_start(GTK_BOX(fourbox), ev_n, TRUE, TRUE, 0);
> 
> 	btn1 = gtk_button_new_with_label(_("Close"));
> 	gtk_box_pack_start(GTK_BOX(hbox), btn1, TRUE, TRUE, 5);
> 
> 	if (!modal) {
> 		btn2 = gtk_button_new_with_label(_("Dialog"));
> 		btn3 = gtk_button_new_with_label(_("Insert"));
> 		gtk_box_pack_start(GTK_BOX(hbox), btn2, TRUE, TRUE, 5);
> 		gtk_box_pack_start(GTK_BOX(hbox), btn3, TRUE, TRUE, 5);
> 	}
> 
> 	gtk_container_add(GTK_CONTAINER(scroll), GTK_WIDGET(view));
> 	gtk_container_add(GTK_CONTAINER(info_window), GTK_WIDGET(frame));
> 
> 	vbox = gtk_vbox_new(FALSE, 1);
> 	gtk_box_pack_start(GTK_BOX(vbox), scroll, TRUE, TRUE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 5);
> 
> 	gtk_container_add(GTK_CONTAINER(frame), GTK_WIDGET(vbox));
> 	gtk_container_set_border_width(GTK_CONTAINER(frame), 0);
> 	gtk_frame_set_label_widget(GTK_FRAME(frame), NULL);
> 
> 	gtk_widget_set_size_request(info_window, 400, 300);
> 	gtk_frame_set_shadow_type(GTK_FRAME(frame), GTK_SHADOW_ETCHED_IN);
> 
> 	cd->data = info_window;
> 	cd->bfwin = bfwin;
> 
> 	g_signal_connect(G_OBJECT(info_window), "key-press-event", G_CALLBACK(frefcb_info_keypress),
> 					 cd);
> 	g_signal_connect(G_OBJECT(btn1), "clicked", G_CALLBACK(frefcb_info_close), cd);
> 	if (!modal) {
> 		g_signal_connect(G_OBJECT(btn2), "clicked", G_CALLBACK(frefcb_info_dialog), cd);
> 		g_signal_connect(G_OBJECT(btn3), "clicked", G_CALLBACK(frefcb_info_insert), cd);
> 	}
> 	gtk_widget_show_all(info_window);
> }
> 
> void frefcb_info_show(GtkButton * button, Tbfwin * bfwin)
> {
> 	FRInfo *entry;
> 	entry = get_current_entry(bfwin);
> 	if (entry == NULL)
> 		return;
> 
> 	fref_show_info(bfwin, entry, TRUE, gtk_widget_get_toplevel(GTK_WIDGET(button)));
> }
> 
> GtkWidget *fref_prepare_dialog(Tbfwin * bfwin, FRInfo * entry)
> {
> 	GtkWidget *dialog;
> 	GtkWidget *vbox;
> 	GtkWidget *table;
> 	GtkWidget *label;
> 	GtkWidget *input;
> 	GtkWidget *combo;
> 	GtkWidget *dialog_action_area;
> 	GtkWidget *cancelbutton;
> 	GtkWidget *okbutton;
> 	GtkWidget *infobutton;
> 	GtkWidget *scroll;
> 	GtkRequisition req, req2;
> 	FRAttrInfo *attr = NULL;
> 	FRParamInfo *par = NULL;
> 	GList *list = NULL;
> 	gint itnum, w, h;
> 
> 	DEBUG_MSG("fref_prepare_dialog, started\n");
> 	dialog = gtk_dialog_new();
> 	if (entry->dialog_title != NULL)
> 		gtk_window_set_title(GTK_WINDOW(dialog), entry->dialog_title);
> 	vbox = GTK_DIALOG(dialog)->vbox;
> 
> 	scroll = gtk_scrolled_window_new(NULL, NULL);
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC,
> 								   GTK_POLICY_AUTOMATIC);
> 	gtk_widget_show(scroll);
> 
> 	gtk_widget_show(vbox);
> 
> 	switch (entry->type) {
> 	case FR_TYPE_TAG:
> 		list = entry->attributes;
> 		break;
> 	case FR_TYPE_FUNCTION:
> 		list = entry->params;
> 		break;
> 	case FR_TYPE_CLASS:
> 		list = NULL;
> 		break;
> 	}
> 	if (list == NULL) {
> 		gtk_widget_destroy(dialog);
> 		DEBUG_MSG("fref_prepare_dialog, list==NULL, aborting..\n");
> 		return NULL;
> 	}
> 
> 	table = gtk_table_new(g_list_length(list), 2, FALSE);
> 
> 
> 	gtk_box_pack_start(GTK_BOX(vbox), scroll, TRUE, TRUE, 0);
> 	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scroll), table);
> 
> 	switch (entry->type) {
> 	case FR_TYPE_TAG:
> 		{
> 			list = g_list_first(list);
> 			attr = (FRAttrInfo *) g_list_nth_data(list, 0);
> 			itnum = 0;
> 			while (itnum < g_list_length(list)) {
> 				if (attr->title != NULL) {
> 					label = gtk_label_new("");
> 					if (attr->required) {
> 						gchar *tofree =
> 							g_strconcat("<span color='#FF0000'>", attr->title, "</span>", NULL);
> 						gtk_label_set_markup(GTK_LABEL(label), tofree);
> 						g_free(tofree);
> 					} else {
> 						gtk_label_set_text(GTK_LABEL(label), attr->title);
> 					}
> 				} else {
> 					label = gtk_label_new("");
> 					if (attr->required) {
> 						gchar *tofree =
> 							g_strconcat("<span color='#FF0000'>", attr->name, "</span>", NULL);
> 						gtk_label_set_markup(GTK_LABEL(label), tofree);
> 						g_free(tofree);
> 					} else {
> 						gtk_label_set_text(GTK_LABEL(label), attr->name);
> 					}
> 				}
> 				gtk_widget_show(label);
> 				gtk_table_attach(GTK_TABLE(table), label, 0, 1, itnum, itnum + 1,
> 								 (GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 5, 6);
> 				gtk_label_set_justify(GTK_LABEL(label), GTK_JUSTIFY_LEFT);
> 				gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
> 				if (attr->has_list) {
> 					combo = gtk_combo_new();
> 					gtk_widget_show(combo);
> 					gtk_table_attach(GTK_TABLE(table), combo, 1, 2, itnum, itnum + 1,
> 									 (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
> 									 (GtkAttachOptions) (0), 5, 5);
> 					/*  gtk_combo_set_value_in_list(GTK_COMBO(combo), TRUE,
> 					   TRUE); */
> 					gtk_combo_set_popdown_strings(GTK_COMBO(combo),
> 												  fref_string_to_list(attr->values, ","));
> 					if (attr->def_value != NULL)
> 						gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), attr->def_value);
> 					attr->dlg_item = combo;
> 					gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, GTK_COMBO(combo)->entry,
> 										 attr->description, "");
> 				} else {
> 					input = gtk_entry_new();
> 					if (attr->def_value != NULL)
> 						gtk_entry_set_text(GTK_ENTRY(input), attr->def_value);
> 					gtk_widget_show(input);
> 					gtk_table_attach(GTK_TABLE(table), input, 1, 2, itnum, itnum + 1,
> 									 (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
> 									 (GtkAttachOptions) (0), 5, 5);
> 					attr->dlg_item = input;
> 					gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, input, attr->description,
> 										 "");
> 				}
> 				itnum++;
> 				attr = (FRAttrInfo *) g_list_nth_data(list, itnum);
> 			}
> 		};
> 		break;
> 	case FR_TYPE_FUNCTION:
> 		{
> 			list = g_list_first(list);
> 			par = (FRParamInfo *) g_list_nth_data(list, 0);
> 			itnum = 0;
> 			while (itnum < g_list_length(list)) {
> 				if (par->title != NULL) {
> 					label = gtk_label_new("");
> 					if (par->required) {
> 						gchar *tofree = NULL;
> 						if (par->type != NULL)
> 							tofree =
> 								g_strconcat("<span color='#FF0000'>", par->title, " (", par->type,
> 											") ", "</span>", NULL);
> 						else
> 							tofree =
> 								g_strconcat("<span color='#FF0000'>", par->title, " </span>", NULL);
> 						gtk_label_set_markup(GTK_LABEL(label), tofree);
> 						g_free(tofree);
> 					} else {
> 						gchar *tofree = NULL;
> 						if (par->type != NULL)
> 							tofree = g_strconcat(par->title, " (", par->type, ") ", NULL);
> 						else
> 							tofree = g_strconcat(par->title, " ", NULL);
> 						gtk_label_set_text(GTK_LABEL(label), tofree);
> 						g_free(tofree);
> 					}
> 				} else {
> 					label = gtk_label_new("");
> 					if (par->required) {
> 						gchar *tofree = NULL;
> 						if (par->type != NULL)
> 							tofree =
> 								g_strconcat("<span color='#FF0000'>", par->name, " (", par->type,
> 											") ", "</span>", NULL);
> 						else
> 							tofree =
> 								g_strconcat("<span color='#FF0000'>", par->name, " </span>", NULL);
> 						gtk_label_set_markup(GTK_LABEL(label), tofree);
> 						g_free(tofree);
> 					} else {
> 						gchar *tofree = NULL;
> 						if (par->type != NULL)
> 							tofree = g_strconcat(par->name, " (", par->type, ") ", NULL);
> 						else
> 							tofree = g_strconcat(par->name, " ", NULL);
> 						gtk_label_set_text(GTK_LABEL(label), tofree);
> 						g_free(tofree);
> 					}
> 				}
> 
> 
> 				gtk_widget_show(label);
> 				gtk_table_attach(GTK_TABLE(table), label, 0, 1, itnum, itnum + 1,
> 								 (GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 5, 6);
> 				gtk_label_set_justify(GTK_LABEL(label), GTK_JUSTIFY_LEFT);
> 				gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
> 				if (par->has_list) {
> 					combo = gtk_combo_new();
> 					gtk_widget_show(combo);
> 					gtk_table_attach(GTK_TABLE(table), combo, 1, 2, itnum, itnum + 1,
> 									 (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
> 									 (GtkAttachOptions) (0), 5, 5);
> 					/*gtk_combo_set_value_in_list(GTK_COMBO(combo), TRUE,TRUE); */
> 					gtk_combo_set_popdown_strings(GTK_COMBO(combo),
> 												  fref_string_to_list(par->values, ","));
> 					if (par->def_value != NULL)
> 						gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(combo)->entry), par->def_value);
> 					par->dlg_item = combo;
> 					gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, GTK_COMBO(combo)->entry,
> 										 par->description, "");
> 				} else {
> 					input = gtk_entry_new();
> 					if (par->def_value != NULL)
> 						gtk_entry_set_text(GTK_ENTRY(input), par->def_value);
> 					gtk_widget_show(input);
> 					gtk_table_attach(GTK_TABLE(table), input, 1, 2, itnum, itnum + 1,
> 									 (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
> 									 (GtkAttachOptions) (0), 5, 5);
> 					par->dlg_item = input;
> 					if (par->description != NULL)
> 						gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, input, par->description,
> 											 "");
> 				}
> 				itnum++;
> 				par = (FRParamInfo *) g_list_nth_data(list, itnum);
> 			}
> 		};
> 		break;
> 
> 	}							/* switch */
> 
> 	dialog_action_area = GTK_DIALOG(dialog)->action_area;
> 	gtk_widget_show(dialog_action_area);
> 	gtk_button_box_set_layout(GTK_BUTTON_BOX(dialog_action_area), GTK_BUTTONBOX_END);
> 
> 
> 	infobutton = gtk_button_new_with_label(_("Info"));
> 	gtk_widget_show(infobutton);
> 	gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->action_area), infobutton, FALSE, FALSE, 2);
> 	g_signal_connect(G_OBJECT(infobutton), "clicked", G_CALLBACK(frefcb_info_show), bfwin);
> 
> 	cancelbutton = gtk_button_new_from_stock("gtk-cancel");
> 	gtk_widget_show(cancelbutton);
> 	gtk_dialog_add_action_widget(GTK_DIALOG(dialog), cancelbutton, GTK_RESPONSE_CANCEL);
> 
> 	okbutton = gtk_button_new_from_stock("gtk-ok");
> 	gtk_widget_show(okbutton);
> 	gtk_dialog_add_action_widget(GTK_DIALOG(dialog), okbutton, GTK_RESPONSE_OK);
> 	gtk_tooltips_enable(FREFGUI(bfwin->fref)->argtips);
> 
> 	gtk_widget_show(table);
> 	gtk_window_get_size(GTK_WINDOW(dialog), &w, &h);
> 	gtk_widget_size_request(table, &req);
> 	gtk_widget_size_request(dialog_action_area, &req2);
> 	gtk_window_resize(GTK_WINDOW(dialog), req.width + 10, MIN(400, req.height + req2.height + 20));
> 	return dialog;
> }
> 
> static void fref_popup_menu_dialog(GtkWidget * widget, Tcallbackdata * cd)
> {
> 	GtkWidget *dialog;
> 	gint resp;
> 	gchar *pomstr;
> 	FRInfo *entry = cd->data;
> 	Tbfwin *bfwin = cd->bfwin;
> 	g_free(cd);
> 	DEBUG_MSG("starting dialog\n");
> 	dialog = fref_prepare_dialog(bfwin, entry);
> 	if (dialog) {
> 		resp = gtk_dialog_run(GTK_DIALOG(dialog));
> 		if (resp == GTK_RESPONSE_OK) {
> 			pomstr = fref_prepare_text(entry, dialog);
> 			gtk_widget_destroy(dialog);
> 			doc_insert_two_strings(bfwin->current_document, pomstr, NULL);
> 			g_free(pomstr);
> 		} else
> 			gtk_widget_destroy(dialog);
> 	}
> }
> static void fref_popup_menu_insert(GtkWidget * widget, Tcallbackdata * cd)
> {
> 	FRInfo *entry = cd->data;
> 	Tbfwin *bfwin = cd->bfwin;
> 	g_free(cd);
> 	doc_insert_two_strings(bfwin->current_document, entry->insert_text, NULL);
> }
> 
> 
> static void fref_popup_menu_info(GtkWidget * widget, Tcallbackdata * cd)
> {
> 	FRInfo *entry = cd->data;
> 	Tbfwin *bfwin = cd->bfwin;
> 	g_free(cd);
> 	fref_show_info(bfwin, entry, FALSE, NULL);
> }
> 
> 
> static void fref_popup_menu_rescan_lcb(GtkWidget * widget, gpointer user_data)
> {
> 	gchar *userdir = g_strconcat(g_get_home_dir(), "/.bluefish/", NULL);
> 	DEBUG_MSG("fref_popup_menu_rescan_lcb, started\n");
> 	fref_rescan_dir(PKGDATADIR);
> 	fref_rescan_dir(userdir);
> 	g_free(userdir);
> 	DEBUG_MSG("about to refill toplevels\n");
> 	fill_toplevels(FREFDATA(main_v->frefdata), TRUE);
> }
> 
> static GtkWidget *fref_popup_menu(Tbfwin * bfwin, FRInfo * entry)
> {
> 	GtkWidget *menu, *menu_item;
> 	DEBUG_MSG("fref_popup_menu, started\n");
> 	menu = gtk_menu_new();
> 	if (entry) {
> 		Tcallbackdata *cd = g_new(Tcallbackdata, 1);
> 		cd->bfwin = bfwin;
> 		cd->data = entry;
> 		menu_item = gtk_menu_item_new_with_label(_("Dialog"));
> 		g_signal_connect(GTK_OBJECT(menu_item), "activate", G_CALLBACK(fref_popup_menu_dialog), cd);
> 		gtk_menu_append(GTK_MENU(menu), menu_item);
> 		menu_item = gtk_menu_item_new_with_label(_("Insert"));
> 		g_signal_connect(GTK_OBJECT(menu_item), "activate", G_CALLBACK(fref_popup_menu_insert), cd);
> 		gtk_menu_append(GTK_MENU(menu), menu_item);
> 		menu_item = gtk_menu_item_new_with_label(_("Info"));
> 		g_signal_connect(GTK_OBJECT(menu_item), "activate", G_CALLBACK(fref_popup_menu_info), cd);
> 		gtk_menu_append(GTK_MENU(menu), menu_item);
> 		menu_item = gtk_menu_item_new();
> 		gtk_menu_append(GTK_MENU(menu), menu_item);
> 	}
> 	menu_item = gtk_menu_item_new_with_label(_("Options"));
> 	gtk_menu_append(GTK_MENU(menu), menu_item);
> 	{
> 		GtkWidget *optionsmenu, *ldblclckmenu, *infowinmenu;
> 		GSList *group = NULL;
> 		GSList *group2 = NULL;
> 		optionsmenu = gtk_menu_new();
> 		gtk_menu_item_set_submenu(GTK_MENU_ITEM(menu_item), optionsmenu);
> 		menu_item = gtk_menu_item_new_with_label(_("Rescan reference files"));
> 		g_signal_connect(GTK_OBJECT(menu_item), "activate", G_CALLBACK(fref_popup_menu_rescan_lcb),
> 						 NULL);
> 		gtk_menu_append(GTK_MENU(optionsmenu), menu_item);
> 		menu_item = gtk_menu_item_new_with_label(_("Left doubleclick action"));
> 		gtk_menu_append(GTK_MENU(optionsmenu), menu_item);
> 
> 		ldblclckmenu = gtk_menu_new();
> 		gtk_menu_item_set_submenu(GTK_MENU_ITEM(menu_item), ldblclckmenu);
> 		menu_item =
> 			togglemenuitem(NULL, _("Insert"),
> 						   (main_v->globses.fref_ldoubleclick_action == FREF_ACTION_INSERT),
> 						   G_CALLBACK(fref_ldblclck_changed), GINT_TO_POINTER(FREF_ACTION_INSERT));
> 		group = gtk_radio_menu_item_group(GTK_RADIO_MENU_ITEM(menu_item));
> 		gtk_menu_append(GTK_MENU(ldblclckmenu), menu_item);
> 		menu_item =
> 			togglemenuitem(group, _("Dialog"),
> 						   (main_v->globses.fref_ldoubleclick_action == FREF_ACTION_DIALOG),
> 						   G_CALLBACK(fref_ldblclck_changed), GINT_TO_POINTER(FREF_ACTION_DIALOG));
> 		gtk_menu_append(GTK_MENU(ldblclckmenu), menu_item);
> 		menu_item =
> 			togglemenuitem(group, _("Info"),
> 						   (main_v->globses.fref_ldoubleclick_action == FREF_ACTION_INFO),
> 						   G_CALLBACK(fref_ldblclck_changed), GINT_TO_POINTER(FREF_ACTION_INFO));
> 		gtk_menu_append(GTK_MENU(ldblclckmenu), menu_item);
> 
> 		menu_item = gtk_menu_item_new_with_label(_("Info type"));
> 		gtk_menu_append(GTK_MENU(optionsmenu), menu_item);
> 		infowinmenu = gtk_menu_new();
> 		gtk_menu_item_set_submenu(GTK_MENU_ITEM(menu_item), infowinmenu);
> 		menu_item =
> 			togglemenuitem(NULL, _("Description"), (main_v->globses.fref_info_type == FREF_IT_DESC),
> 						   G_CALLBACK(fref_infotype_changed), GINT_TO_POINTER(FREF_IT_DESC));
> 		group2 = gtk_radio_menu_item_group(GTK_RADIO_MENU_ITEM(menu_item));
> 		gtk_menu_append(GTK_MENU(infowinmenu), menu_item);
> 		menu_item =
> 			togglemenuitem(group2, _("Attributes/Parameters"),
> 						   (main_v->globses.fref_info_type == FREF_IT_ATTRS),
> 						   G_CALLBACK(fref_infotype_changed), GINT_TO_POINTER(FREF_IT_ATTRS));
> 		gtk_menu_append(GTK_MENU(infowinmenu), menu_item);
> 		menu_item =
> 			togglemenuitem(group2, _("Notes"), (main_v->globses.fref_info_type == FREF_IT_NOTES),
> 						   G_CALLBACK(fref_infotype_changed), GINT_TO_POINTER(FREF_IT_NOTES));
> 		gtk_menu_append(GTK_MENU(infowinmenu), menu_item);
> 
> 
> 	}
> 	gtk_widget_show_all(menu);
> 	g_signal_connect_after(G_OBJECT(menu), "destroy", G_CALLBACK(destroy_disposable_menu_cb), menu);
> 	return menu;
> }
> 
> static gboolean frefcb_event_keypress(GtkWidget * widget, GdkEventKey * event, Tbfwin * bfwin)
> {
> 	FRInfo *entry;
> 	entry = get_current_entry(bfwin);
> 	if (entry != NULL) {
> 		if (g_strcasecmp(gdk_keyval_name(event->keyval), "F1") == 0) {
> 			fref_show_info(bfwin, entry, FALSE, NULL);
> 			return TRUE;
> 		}
> 	}
> 	return FALSE;
> }
> 
> static gboolean reference_file_known(gchar * path)
> {
> 	GList *tmplist = g_list_first(main_v->props.reference_files);
> 	while (tmplist) {
> 		gchar **arr = tmplist->data;
> 		if (count_array(arr) == 2 && strcmp(arr[1], path) == 0) {
> 			return TRUE;
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return FALSE;
> }
> 
> void fref_rescan_dir(const gchar * dir)
> {
> 	const gchar *filename;
> 	GError *error = NULL;
> 	gchar *tofree;
> 	GPatternSpec *ps = g_pattern_spec_new("funcref_*.xml");
> 	GDir *gd = g_dir_open(dir, 0, &error);
> 	filename = g_dir_read_name(gd);
> 	while (filename) {
> 		if (g_pattern_match(ps, strlen(filename), filename, NULL)) {
> 			gchar *path = g_strconcat(dir, filename, NULL);
> 			DEBUG_MSG("filename %s has a match!\n", filename);
> 			if (!reference_file_known(path)) {
> 				tofree = fref_xml_get_refname(path);
> 				main_v->props.reference_files =
> 					g_list_append(main_v->props.reference_files,
> 								  array_from_arglist(g_strdup(tofree), path, NULL));
> 				g_free(tofree);
> 			}
> 			g_free(path);
> 		}
> 		filename = g_dir_read_name(gd);
> 	}
> 	g_dir_close(gd);
> 	g_pattern_spec_free(ps);
> }
> 
> typedef struct {
> 	Tbfwin *bfwin;
> 	gchar *cat;
> } Tfref_cleanup;
> 
> static guint fref_idle_cleanup(Tfref_cleanup * data)
> {
> 	GtkTreeIter iter;
> 	gboolean cont = TRUE;
> 	DEBUG_MSG("fref_idle_cleanup, started for data=%s\n", data->cat);
> 	gtk_tree_model_get_iter_first(GTK_TREE_MODEL(FREFDATA(main_v->frefdata)->store), &iter);
> 	while (cont) {
> 		gchar *str = NULL;
> 		gtk_tree_model_get(GTK_TREE_MODEL(FREFDATA(main_v->frefdata)->store), &iter, STR_COLUMN,
> 						   &str, -1);
> 		DEBUG_MSG("fref_idle_cleanup, comparing %s,%s\n", str, data->cat);
> 		if (strcmp(str, data->cat) == 0) {
> 			DEBUG_MSG("fref_idle_cleanup, found!\n");
> 			fref_loader_unload_ref(GTK_TREE_STORE(FREFDATA(main_v->frefdata)->store), &iter);
> 			break;
> 		}
> 		g_free (str);
> 		cont = gtk_tree_model_iter_next(GTK_TREE_MODEL(FREFDATA(main_v->frefdata)->store), &iter);
> 	}
> 	{
> 		GtkTreeIter newiter;
> 		gtk_tree_store_append(GTK_TREE_STORE(FREFDATA(main_v->frefdata)->store), &newiter, &iter);
> 	}
> 	g_free (data->cat);
> 	g_free (data);
> 	return FALSE;				/* do not call again */
> }
> 
> static void frefcb_row_collapsed(GtkTreeView * treeview, GtkTreeIter * arg1, GtkTreePath * arg2,
> 								 Tbfwin * bfwin)
> {
> 	gint *cnt = NULL;
> 	gpointer *aux;
> 	gboolean do_unload = FALSE;
> 	GtkTreeModel *treemodel = GTK_TREE_MODEL(FREFDATA(main_v->frefdata)->store);
> 	if (gtk_tree_path_get_depth(arg2) == 1) {
> 		gchar *cat;
> 		gtk_tree_model_get(treemodel, arg1, STR_COLUMN, &cat, -1);
> 		DEBUG_MSG("frefcb_row_collapsed, lookup for the refcount of %s\n", cat);
> 		aux = g_hash_table_lookup(FREFDATA(main_v->frefdata)->refcount, cat);
> 		if (aux != NULL) {
> 			cnt = (gint *) aux;
> 			DEBUG_MSG("frefcb_row_collapsed, refcount=%d, about to decrease\n", *cnt);
> 			*cnt = (*cnt) - 1;
> 			if (*cnt == 0) {
> 				Tfref_cleanup *data = g_new(Tfref_cleanup, 1);
> 				do_unload = TRUE;
> 				data->cat = cat;
> 				data->bfwin = bfwin;
> 				gtk_timeout_add(250, (GtkFunction) fref_idle_cleanup, data);
> 			}
> 		} else
> 			do_unload = FALSE;
> 	} else
> 		do_unload = FALSE;
> /*	if (do_unload) {
> 		DEBUG_MSG("frefcb_row_collapsed, do_unload=%d, unloading!\n",do_unload);
> 		val = g_new0(GValue, 1);
> 		gtk_tree_model_get_value(GTK_TREE_MODEL(treemodel), arg1, 2, val);
> 		if (G_IS_VALUE(val) && g_value_peek_pointer(val)!=NULL) {
> 			DEBUG_MSG("frefcb_row_collapsed, calling fref_loader_unload_ref\n");
> 			fref_loader_unload_ref(GTK_TREE_STORE(treemodel),arg1);
> 			/ * dummy node for expander display * /
> 			DEBUG_MSG("frefcb_row_collapsed, appending dummy node\n");
> 			gtk_tree_store_append(GTK_TREE_STORE(treemodel), &iter, arg1);
> 		}
> 		g_free(val);
> 	}*/
> }
> 
> 
> static void frefcb_full_info(GtkButton * button, Tbfwin * bfwin)
> {
> 	FRInfo *entry;
> 	entry = get_current_entry(bfwin);
> 	if (entry == NULL || entry->type == FR_TYPE_GROUP)
> 		return;
> 
> 	fref_show_info(bfwin, entry, FALSE, NULL);
> }
> 
> static void frefcb_search(GtkButton * button, Tbfwin * bfwin)
> {
> 	GtkTreePath *path;
> 	GtkTreeViewColumn *col;
> 	GtkWidget *dlg, *entry;
> 	GValue *val;
> 	GtkTreeIter iter;
> 	GHashTable *dict;
> 	gint result;
> 	gchar *stf = NULL;
> 
> 	gtk_tree_view_get_cursor(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), &path, &col);
> 	if (path != NULL) {
> 		while (gtk_tree_path_get_depth(path) > 1 && gtk_tree_path_up(path));
> 
> 		gtk_tree_model_get_iter(gtk_tree_view_get_model(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree)),
> 								&iter, path);
> 		gtk_tree_path_free(path);
> 		val = g_new0(GValue, 1);
> 		/* first column of reference title holds dictionary */
> 		gtk_tree_model_get_value(gtk_tree_view_get_model(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree)),
> 								 &iter, 1, val);
> 		if (G_IS_VALUE(val) && g_value_fits_pointer(val)) {
> 			dict = (GHashTable *) g_value_peek_pointer(val);
> 			if (dict != NULL) {
> 				gpointer ret = NULL;
> 				dlg =
> 					gtk_dialog_new_with_buttons(_("Reference search"), NULL, GTK_DIALOG_MODAL,
> 												GTK_STOCK_CANCEL, GTK_RESPONSE_REJECT, GTK_STOCK_OK,
> 												GTK_RESPONSE_ACCEPT, NULL);
> 				gtk_dialog_set_default_response(GTK_DIALOG(dlg), GTK_RESPONSE_ACCEPT);
> 				entry = gtk_entry_new();
> 				gtk_entry_set_activates_default(GTK_ENTRY(entry), TRUE);
> 				gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dlg)->vbox), entry, TRUE, TRUE, 0);
> 				gtk_widget_show(entry);
> 				result = gtk_dialog_run(GTK_DIALOG(dlg));
> 				if (result == GTK_RESPONSE_ACCEPT) {
> 					stf = g_strdup(gtk_entry_get_text(GTK_ENTRY(entry)));
> 					ret = g_hash_table_lookup(dict, stf);
> 					g_free(stf);
> 					if (!ret)
> 						error_dialog(bfwin->main_window, _("Reference search"),
> 									 _("Reference not found"));
> 				}
> 				gtk_widget_destroy(dlg);
> 
> 				if (ret != NULL) {
> 					GtkTreePath *path2 = gtk_tree_row_reference_get_path(ret);
> #ifndef HAVE_ATLEAST_GTK_2_2
> 					gtktreepath_expand_to_root(FREFGUI(bfwin->fref)->tree, path2);
> #else
> 					gtk_tree_view_expand_to_path(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), path2);
> #endif
> 					gtk_tree_view_set_cursor(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), path2,
> 											 gtk_tree_view_get_column(GTK_TREE_VIEW
> 																	  (FREFGUI(bfwin->fref)->tree),
> 																	  0), FALSE);
> 				}
> 			} else
> 				error_dialog(bfwin->main_window, _("Error"),
> 							 _
> 							 ("Perhaps you didn't load a reference, or you did not select a reference to search in."));
> 		}
> 		g_value_unset(val);
> 		g_free(val);
> 	}
> }
> 
> static gboolean frefcb_event_mouseclick(GtkWidget * widget, GdkEventButton * event, Tbfwin * bfwin)
> {
> 	FRInfo *entry;
> 
> 	if (widget != FREFGUI(bfwin->fref)->tree)
> 		return FALSE;
> 
> 	entry = get_current_entry(bfwin);
> 	if (entry == NULL) {
> 		if (event->button == 3 && event->type == GDK_BUTTON_PRESS) {
> 			gtk_menu_popup(GTK_MENU(fref_popup_menu(bfwin, NULL)), NULL, NULL, NULL, NULL,
> 						   event->button, event->time);
> 			return TRUE;
> 		} else
> 			return FALSE;
> 	}
> 
> 	if (event->button == 3 && event->type == GDK_BUTTON_PRESS) {	/* right mouse click */
> 		gtk_menu_popup(GTK_MENU(fref_popup_menu(bfwin, entry)), NULL, NULL, NULL, NULL,
> 					   event->button, event->time);
> 	} else if (event->button == 1 && event->type == GDK_2BUTTON_PRESS) {	/* double click  */
> 		Tcallbackdata *cd = g_new(Tcallbackdata, 1);
> 		cd->data = entry;
> 		cd->bfwin = bfwin;
> 		switch (main_v->globses.fref_ldoubleclick_action) {
> 		case FREF_ACTION_INSERT:
> 			fref_popup_menu_insert(NULL, cd);
> 			break;
> 		case FREF_ACTION_DIALOG:
> 			fref_popup_menu_dialog(NULL, cd);
> 			break;
> 		case FREF_ACTION_INFO:
> 			fref_popup_menu_info(NULL, cd);
> 			break;
> 		default:
> 			g_print("weird, fref_doubleclick_action=%d\n",
> 					main_v->globses.fref_ldoubleclick_action);
> 			main_v->globses.fref_ldoubleclick_action = FREF_ACTION_DIALOG;
> 			break;
> 		}
> 	}
> 	return FALSE;				/* we have handled the event, but the treeview freezes if you return TRUE,    so we return FALSE */
> }
> 
> static void frefcb_cursor_changed(GtkTreeView * treeview, Tbfwin * bfwin)
> {
> 	FRInfo *entry;
> 	gchar *info = NULL, *tmpinfo = NULL; 
> 	GdkRectangle rect;
> 
> 	entry = get_current_entry(bfwin);
> 	if (entry == NULL)
> 		return;
> 	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(FREFGUI(bfwin->fref)->infocheck))) {
> 		if (entry->description != NULL) {
> 			switch (main_v->globses.fref_info_type) {
> 			case FREF_IT_DESC:
> 				tmpinfo = fref_prepare_info(entry, FR_INFO_DESC, FALSE);
> 				info = g_strconcat("<span size=\"small\"><b>Description:</b></span>\n", tmpinfo, NULL);
> 				break;
> 			case FREF_IT_ATTRS:
> 				tmpinfo = fref_prepare_info(entry, FR_INFO_ATTRS, FALSE);
> 				switch (entry->type) {
> 				case FR_TYPE_TAG:
> 					info = g_strconcat("<span size=\"small\"><b>Attributes:</b></span>\n", tmpinfo, NULL);
> 					break;
> 				case FR_TYPE_FUNCTION:
> 					info = g_strconcat("<span size=\"small\"><b>Parameters:</b></span>\n", tmpinfo, NULL);
> 					break;
> 				}
> 				break;
> 			case FREF_IT_NOTES:
> 				info = fref_prepare_info(entry, FR_INFO_NOTES, FALSE);
> 				break;
> 			default:
> 				info = g_strdup("Unknown fref_info_type");
> 			}					/* switch */
> 			gtk_tree_view_get_visible_rect(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), &rect);
> 			gtk_widget_set_size_request(FREFGUI(bfwin->fref)->infoview, rect.width, -1);
> 			gtk_label_set_markup(GTK_LABEL(FREFGUI(bfwin->fref)->infoview), info);
> 			if (tmpinfo) g_free (tmpinfo);
> 			g_free(info);
> 		} else
> 			gtk_label_set_text(GTK_LABEL(FREFGUI(bfwin->fref)->infoview), "");
> 	}
> }
> 
> static void frefcb_infocheck_toggled(GtkToggleButton * togglebutton, Tbfwin * bfwin)
> {
> 	if (gtk_toggle_button_get_active(togglebutton))
> 		gtk_widget_show(FREFGUI(bfwin->fref)->infoscroll);
> 	else
> 		gtk_widget_hide(FREFGUI(bfwin->fref)->infoscroll);
> }
> 
> gchar *fref_tip(gconstpointer win, gconstpointer tree, gint x, gint y)
> {
> 	gchar *str = NULL, *tofree = NULL;
> 	GList *lst;
> 	FRAttrInfo *tmpa;
> 	FRParamInfo *tmpp;
> 	FRInfo *info = NULL;
> 	GtkTreePath *path;
> 
> 
> 	if (!gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tree), x, y, &path, NULL, NULL, NULL))
> 		return NULL;
> 
> 	if (path != NULL) {
> 		GValue *val;
> 		GtkTreeIter iter;
> 		gtk_tree_model_get_iter(gtk_tree_view_get_model(GTK_TREE_VIEW(tree)), &iter, path);
> 		gtk_tree_path_free(path);
> 		val = g_new0(GValue, 1);
> 		gtk_tree_model_get_value(gtk_tree_view_get_model(GTK_TREE_VIEW(tree)), &iter, 1, val);
> 		if (G_IS_VALUE(val) && g_value_fits_pointer(val)) {
> 			info = (FRInfo *) (g_value_peek_pointer(val));
> 		}
> 		g_value_unset(val);
> 		g_free(val);
> 	}
> 
> 	if (!info)
> 		return NULL;
> 
> 	switch (info->type) {
> 	case FR_TYPE_TAG:
> 		str = g_strdup_printf("<b>%s:</b> ", info->name);
> 		lst = g_list_first(info->attributes);
> 		while (lst) {
> 			tmpa = (FRAttrInfo *) lst->data;
> 			tofree = str;
> 			str = g_strconcat(str, "<span size=\"small\" ><i>", tmpa->name, "</i></span>  ", NULL);
> 			g_free(tofree);
> 			lst = g_list_next(lst);
> 		}
> 		break;
> 	case FR_TYPE_FUNCTION:
> 		if (info->return_type != NULL)
> 			str = g_strdup_printf("<i>%s</i>  %s( ", info->return_type, info->name);
> 		else
> 			str = g_strdup_printf("%s( ", info->name);
> 		lst = g_list_first(info->params);
> 		while (lst) {
> 			tmpp = (FRParamInfo *) lst->data;
> 			tofree = str;
> 			if (tmpp->type != NULL)
> 				str = g_strconcat(str, "<i>", tmpp->type, "</i>  <b>", tmpp->name, "</b>", NULL);
> 			else
> 				str = g_strconcat(str, "<b>", tmpp->name, "</b>", NULL);
> 			g_free(tofree);
> 			lst = g_list_next(lst);
> 			if (lst) {
> 				tofree = str;
> 				str = g_strconcat(str, ",", NULL);
> 				g_free(tofree);
> 			}
> 		}
> 		tofree = str;
> 		str = g_strconcat(str, " )", NULL);
> 		g_free(tofree);
> 		break;
> 	}
> 	return str;
> }
> 
> GtkWidget *fref_gui(Tbfwin * bfwin)
> {
> 	GtkWidget *scroll, *box, *pane, *box2, *btn1, *btn2, *btn3;
> 	GtkCellRenderer *cell;
> 	GtkTreeViewColumn *column;
> 	Tfref_data *fdata = FREFDATA(main_v->frefdata);
> 	GtkTreeIter it;
> 
> 	bfwin->fref = g_new0(Tfref_gui, 1);
> 
> 	pane = gtk_vpaned_new();
> 	box = gtk_vbox_new(FALSE, 1);
> 	box2 = gtk_hbox_new(FALSE, 1);
> 
> 	scroll = gtk_scrolled_window_new(NULL, NULL);
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC,
> 								   GTK_POLICY_AUTOMATIC);
> 	FREFGUI(bfwin->fref)->infoscroll = gtk_scrolled_window_new(NULL, NULL);
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(FREFGUI(bfwin->fref)->infoscroll),
> 								   GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
> 
> 	FREFGUI(bfwin->fref)->tree = gtk_tree_view_new_with_model(GTK_TREE_MODEL(fdata->store));
> 	gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), FALSE);
> 	/*gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (FREFGUI(bfwin->fref)->tree), TRUE);*/
> 	cell = gtk_cell_renderer_text_new();
> 	column = gtk_tree_view_column_new_with_attributes("", cell, "text", STR_COLUMN, NULL);
> 	gtk_tree_view_append_column(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), column);
> 
> 	gtk_container_add(GTK_CONTAINER(scroll), FREFGUI(bfwin->fref)->tree);
> 	gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), FALSE);
> 
> 	g_signal_connect(G_OBJECT(FREFGUI(bfwin->fref)->tree), "row-collapsed",
> 					 G_CALLBACK(frefcb_row_collapsed), bfwin);
> 	g_signal_connect(G_OBJECT(FREFGUI(bfwin->fref)->tree), "row-expanded",
> 					 G_CALLBACK(frefcb_row_expanded), fdata->store);
> 	g_signal_connect(G_OBJECT(FREFGUI(bfwin->fref)->tree), "button-press-event",
> 					 G_CALLBACK(frefcb_event_mouseclick), bfwin);
> 	g_signal_connect(G_OBJECT(FREFGUI(bfwin->fref)->tree), "key-press-event",
> 					 G_CALLBACK(frefcb_event_keypress), bfwin);
> 
> 	gtk_widget_show(FREFGUI(bfwin->fref)->tree);
> 	gtk_widget_show(scroll);
> 
> 	/* BUG??: don't we have a global tooltips object somewhere ? 
> 	FREFGUI(bfwin->fref)->argtips = gtk_tooltips_new();*/
> 	FREFGUI(bfwin->fref)->argtips = main_v->tooltips;
> 	FREFGUI(bfwin->fref)->tips =
> 		tree_tips_new_full(bfwin, GTK_TREE_VIEW(FREFGUI(bfwin->fref)->tree), fref_tip);
> 	tree_tips_set_hide_interval(FREFGUI(bfwin->fref)->tips, 5000);
> 
> 	FREFGUI(bfwin->fref)->infoview = gtk_label_new(NULL);
> 	gtk_label_set_line_wrap(GTK_LABEL(FREFGUI(bfwin->fref)->infoview), TRUE);
> 	gtk_label_set_use_markup(GTK_LABEL(FREFGUI(bfwin->fref)->infoview), TRUE);
> 	gtk_misc_set_alignment(GTK_MISC(FREFGUI(bfwin->fref)->infoview), 0.0, 0.0);
> 	gtk_misc_set_padding(GTK_MISC(FREFGUI(bfwin->fref)->infoview), 5, 5);
> 
> 	g_signal_connect(G_OBJECT(FREFGUI(bfwin->fref)->tree), "cursor-changed",
> 					 G_CALLBACK(frefcb_cursor_changed), bfwin);
> 
> 	FREFGUI(bfwin->fref)->infocheck = gtk_check_button_new_with_label(_("Show info window"));
> 	gtk_widget_show(FREFGUI(bfwin->fref)->infocheck);
> 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(FREFGUI(bfwin->fref)->infocheck), TRUE);
> 	g_signal_connect(G_OBJECT(FREFGUI(bfwin->fref)->infocheck), "toggled",
> 					 G_CALLBACK(frefcb_infocheck_toggled), bfwin);
> 	{
> 		/* BUG??: is this ever freed ??? */
> 		Tcallbackdata *cd = g_new(Tcallbackdata, 1);
> 		cd->data = NULL;
> 		cd->bfwin = bfwin;
> 		btn1 = bf_allbuttons_backend(NULL, FALSE, 108, G_CALLBACK(frefcb_info_dialog), cd);
> 	}
> 	btn2 = bf_allbuttons_backend(NULL, FALSE, 107, G_CALLBACK(frefcb_full_info), bfwin);
> 	btn3 = bf_allbuttons_backend(NULL, FALSE, 109, G_CALLBACK(frefcb_search), bfwin);
> 	gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, btn1, _("Dialog"), "");
> 	gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, btn2, _("Info"), "");
> 	gtk_tooltips_set_tip(FREFGUI(bfwin->fref)->argtips, btn3, _("Search"), "");
> 
> 	gtk_box_pack_start(GTK_BOX(box2), FREFGUI(bfwin->fref)->infocheck, TRUE, TRUE, 0);
> 	gtk_box_pack_start(GTK_BOX(box2), btn3, FALSE, TRUE, 0);
> 	gtk_box_pack_start(GTK_BOX(box2), btn2, FALSE, TRUE, 0);
> 	gtk_box_pack_start(GTK_BOX(box2), btn1, FALSE, TRUE, 0);
> 
> 	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(FREFGUI(bfwin->fref)->infoscroll),
> 										  FREFGUI(bfwin->fref)->infoview);
> 	gtk_box_pack_start(GTK_BOX(box), scroll, TRUE, TRUE, 0);
> 	gtk_box_pack_start(GTK_BOX(box), box2, FALSE, TRUE, 0);
> 	gtk_paned_pack1(GTK_PANED(pane), box, TRUE, FALSE);
> 	gtk_paned_pack2(GTK_PANED(pane), FREFGUI(bfwin->fref)->infoscroll, TRUE, TRUE);
> 	gtk_widget_show_all(pane);
> 
> 	if (!gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(fdata->store), &it, NULL, 0))
> 		fill_toplevels(fdata, FALSE);
> 	return pane;
> }
1,1750c1,1748
< /* Bluefish HTML Editor
<  * gtk_easy.c
<  *
<  * Copyright (C) 1999-2006 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< /* #define DEBUG */
< 
< #include <gtk/gtk.h>
< #include <gdk/gdkkeysyms.h>    /* GDK_Return */
< #include <stdlib.h>            /* strtod() */
< #include <string.h>            /* strlen() */
< 
< #include "bluefish.h"
< #include "gtk_easy.h"
< #include "bf_lib.h"
< #include "char_table.h"    /* xml_escape() */
< #include "gui.h"           /* statusbar_message() */
< #include "pixmap.h"
< 
< #ifdef WIN32
< #ifndef _WIN_32_DIRSTRCHR
< #define DIRSTR "\\"
< #define DIRCHR 92
< #endif /* _WIN_32_DIRSTRCHR */
< #else
< #define DIRSTR "/"
< #define DIRCHR '/'
< #endif
< 
< /**
<  * flush_queue:
<  * 
<  * handles the gtk and gdk queue
<  * 
<  * Return value: void
<  **/
< void flush_queue(void) {
< 	while(g_main_context_pending(NULL)) {
< 		g_main_context_iteration (NULL, TRUE);
< 	}
< }
< /**
<  * widget_get_string_size:
<  * @widget: #GtkWidget* to put the string on
<  * @string: #ghcar* with the string
<  *
<  * This function will calculate the width in pixels from the
<  * string passed to it in string, using the font from widget
<  *
<  * Return value: #gint pixels
<  */
< gint widget_get_string_size(GtkWidget *widget, gchar *string) {
< 	PangoLayout *layout;
< 	gint retval = -1;
< 	layout = gtk_widget_create_pango_layout(widget,string);
< 	if (layout != NULL) {
< 		pango_layout_get_pixel_size(layout, &retval, NULL);
< 		g_object_unref(G_OBJECT (layout));
< 	}
< 	return retval;
< }
< 
< void widget_set_visible(GtkWidget *widget, gboolean visible) {
< 	if (visible) {
< 		gtk_widget_show(widget);
< 	} else {
< 		gtk_widget_hide(widget);	
< 	}
< }
< 
< /**
<  * window_destroy:
<  * @windowname: a #GtkWidget pointer to the window
<  * 
<  * Remove grab and signals and then destroy window
<  * 
<  * Return value: void
<  **/
< void window_destroy(GtkWidget * windowname) {
< 	DEBUG_MSG("window_destroy, windowname=%p, first the signal handlers\n", windowname);
< 	g_signal_handlers_destroy(G_OBJECT(windowname));
< 	DEBUG_MSG("window_destroy, then remove the grab\n");
< 	gtk_grab_remove(windowname);
< 	DEBUG_MSG("window_destroy, then destroy the widget\n");
< 	gtk_widget_destroy(windowname);
< 	DEBUG_MSG("window_destroy, done\n");
< }
< 
< /**
<  * window_close_by_widget_cb:
<  * 	@widget: #GtkWidget the parent window of this widget will be destroyed
<  * 	@data: gpointer, ignored
<  *
<  * 	destroy the toplevel window for widget
<  *
<  * Return value: void
<  */
< void window_close_by_widget_cb(GtkWidget * widget, gpointer data) {
< 	DEBUG_MSG("window_close_by_widget_cb, widget=%p\n", widget);
< 	window_destroy(gtk_widget_get_toplevel(widget));
< }
< 
< /**
<  * window_close_by_data_cb:
<  * 	@widget: #GtkWidget, ignored
<  * 	@data: #gpointer to a gtk-window which will be detroyed
<  *
<  * 	destroy a window using the gpointer data
<  *
<  * Return value: void
<  */
< void window_close_by_data_cb(GtkWidget * widget, gpointer data) {
< 	DEBUG_MSG("window_close_by_data_cb, data=%p\n", data);
< 	window_destroy(GTK_WIDGET(data));
< }
< 
< /**
<  * setup_toggle_item:
<  * 	@ifactory: #GtkItemFactory * the itemfactory where the toggle item is in defined
<  * 	@path: #gchar * the path in the itemfactory to find the toggle item
<  * 	@state: #gint the state to put it in (0 or 1)
<  * 
<  * 	change the setting of a toggle item in a menu to state
<  *
<  * Return value: void
<  */
< void setup_toggle_item(GtkItemFactory * ifactory, gchar * path, gint state) {
< 	GtkWidget *toggle;
< 	toggle = gtk_item_factory_get_widget(ifactory, path);
< 	if (!toggle) {
< 		g_print("warning, menuitem \"%s\" does NOT exist! check the translation!\n", path);
< 		return;
< 	}
< 	DEBUG_MSG("setting path %s to %d\n",path,state);
< 	if ((GTK_CHECK_MENU_ITEM(toggle)->active) && state == 0) {
< 		GTK_CHECK_MENU_ITEM(toggle)->active = state;
< 		return;
< 	}
< 	if ((!GTK_CHECK_MENU_ITEM(toggle)->active) && state == 1) {
< 		GTK_CHECK_MENU_ITEM(toggle)->active = state;
< 		return;
< 	}
< }
< 
< /**
<  * string_apply:
<  * @config_var: # gchar **, a pointer to a gchar pointer with where the content should be placed
<  * 	@entry: the entry #GtkWidget * to read
<  *
<  * 	free the old string in **config_var, and replaces it with the new string from entry
<  *
<  * Return value:	void
<  */
< void string_apply(gchar ** config_var, GtkWidget * entry)
< {
< 	gchar *tmpstring;
< 	DEBUG_MSG("string_apply, start\n");
< 
< 	tmpstring = gtk_editable_get_chars(GTK_EDITABLE(entry), 0, -1);
< 	DEBUG_MSG("string_apply, tmpstring(%p)=%s\n", tmpstring, tmpstring);
< 	if (tmpstring) {
< 		if (config_var != NULL) {
< 			g_free(*config_var);
< 		}
< 		*config_var = tmpstring;
< 	}
< #ifdef DEBUG
< 	else {
< 		DEBUG_MSG("string_apply, ***** tmpstring == NULL *****\n");
< 	}
< #endif
< }
< /**
<  * string_apply:
<  * @config_var: #gint*, a pointer to a gint with where the content should be placed
<  * 	@entry: the spinbutton or checkbox #GtkWidget * to read
<  * @is_checkbox: a gboolean, TRUE if entry is a checkbox
<  *
<  * 	sets the content from the widget to the variable pointed to by the config_var pointer
<  *
<  * Return value: void
<  */
< void integer_apply(gint *config_var, GtkWidget * widget, gboolean is_checkbox) {
< 	if (is_checkbox) {
< 		*config_var = (GTK_TOGGLE_BUTTON(widget)->active);
< 	} else {
< 		*config_var = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(widget));
< 	}
< 	DEBUG_MSG("integer_apply, config_var(%p)=%i\n", config_var, *config_var);
< }
< /**
<  * combo_with_popdown:
<  * 	@setstring: #gchar* to set in textbox, if NULL it will be set ""
<  * 	@which_list: #GList* to set in popdown widget
<  * 	@editable: #gint if the combo should be editable (1 or 0)
<  *
<  * 	Create new combo and preset some values
<  *
<  * Return value: #GtkWidget* pointer to created combo
<  */
< GtkWidget *combo_with_popdown(const gchar * setstring, GList * which_list, gint editable) {
< 	GtkWidget *returnwidget;
< 
< 	returnwidget = gtk_combo_new();
< 	gtk_combo_set_case_sensitive(GTK_COMBO(returnwidget),TRUE);
< 	if (which_list != NULL) {
< 		gtk_combo_set_popdown_strings(GTK_COMBO(returnwidget), which_list);
< 	}
< 	if (setstring != NULL) {
< 		gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(returnwidget)->entry), setstring);
< 	} else {
< 		gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(returnwidget)->entry), "");
< 	}
< 	if (editable == 0) {
< 		gtk_editable_set_editable(GTK_EDITABLE(GTK_ENTRY(GTK_COMBO(returnwidget)->entry)), FALSE);
< 	}
< 	gtk_combo_disable_activate(GTK_COMBO(returnwidget));
< 	gtk_entry_set_activates_default (GTK_ENTRY (GTK_COMBO (returnwidget)->entry), TRUE);
< 	return returnwidget;
< }
< /**
<  * boxed_combo_with_popdown:
<  * 	@setstring: #gchar* to set in textbox, if NULL it will be set ""
<  * 	@which_list: #GList* to set in popdown widget
<  * 	@editable: #gint if the combo should be editable (1 or 0)
<  * @box: the #GtkWidget* box widget to add the combo to
<  *
<  * 	create a new combo with presets like in combo_with_popdown()
<  * and add it to the box
<  *
<  * Return value: #GtkWidget* pointer to created combo
<  */
< GtkWidget *boxed_combo_with_popdown(const gchar * setstring, GList * which_list, gint editable, GtkWidget *box) {
< 	GtkWidget *returnwidget;
< 	
< 	returnwidget = combo_with_popdown(setstring, which_list, editable);
< 	gtk_box_pack_start(GTK_BOX(box), returnwidget, TRUE, TRUE, 3);
< 	return returnwidget;
< }
< /**
<  * combo_with_popdown_sized:
<  * 	@setstring: #gchar* to set in textbox, if NULL it will be set ""
<  * 	@which_list: #GList* to set in popdown widget
<  * 	@editable: #gint if the combo should be editable (1 or 0)
<  * @width: #gint with the width in pixels the widget should be
<  *
<  * 	Create new combo and preset some values, with a horizontal size
<  *
<  * Return value: #GtkWidget* pointer to created combo
<  */
< GtkWidget *combo_with_popdown_sized(const gchar * setstring, GList * which_list, gint editable, gint width) {
< 	GtkWidget *returnwidget;
< 	
< 	returnwidget = combo_with_popdown(setstring, which_list, editable);
< 	gtk_widget_set_size_request(returnwidget, width , -1);
< 	return returnwidget;
< }
< 
< /**
<  * entry_with_text:
<  * 	@setstring: #const gchar* if not NULL set this text
<  * 	@max_lenght: #gint max. characters in the entry
<  *
<  * 	Create new entry with some preset values
<  *
<  * Return value: #GtkWidget* pointer to the new entry widget
<  */
< GtkWidget *entry_with_text(const gchar * setstring, gint max_lenght) {
< 	GtkWidget *returnwidget;
< 
< 	if (max_lenght) {
< 		returnwidget = gtk_entry_new_with_max_length(max_lenght);
< 	} else {
< 		returnwidget = gtk_entry_new();
< 	}
< 	if (setstring) {
< 		gtk_entry_set_text(GTK_ENTRY(returnwidget), setstring);
< 	}
< 	gtk_entry_set_activates_default(GTK_ENTRY(returnwidget), TRUE);
< 	return returnwidget;
< }
< /**
<  * boxed_entry_with_text:
<  * 	@setstring: #const gchar* if not NULL set this text
<  * 	@max_lenght: #gint max. characters in the entry
<  * @box: the #GtkWidget* box widget to add the entry to
<  *
<  * 	Create new entry with some preset values, and add it to a box
<  *
<  * Return value: #GtkWidget* pointer to the new entry widget
<  */
< GtkWidget *boxed_entry_with_text(const gchar * setstring, gint max_lenght, GtkWidget *box) {
< 	GtkWidget *returnwidget;
< 	
< 	returnwidget = entry_with_text(setstring, max_lenght);
< 	gtk_box_pack_start(GTK_BOX(box), returnwidget, TRUE, TRUE, 0);
< 	return returnwidget;
< 
< }
< /**
<  * boxed_full_entry:
<  * @labeltest: #const gchar * with the text for the label
<  * 	@setstring: #const gchar* if not NULL set this text
<  * 	@max_lenght: #gint max. characters in the entry
<  * @box: the #GtkWidget* box widget to add the entry to
<  *
<  * 	Create new entry with some preset values, and add together 
<  * with a label to a hbox, and add that hbox to
<  * the box pointer
<  *
<  * Return value: #GtkWidget* pointer to the new entry widget
<  */
< GtkWidget *boxed_full_entry(const gchar * labeltext, gchar * setstring,gint max_lenght, GtkWidget * box) {
< 	GtkWidget *hbox, *return_widget, *label;
< 
< 	hbox = gtk_hbox_new(FALSE,3);
< 	label = gtk_label_new_with_mnemonic(labeltext);
< 	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 3);
< 	return_widget = boxed_entry_with_text(setstring, max_lenght, hbox);
< 	gtk_label_set_mnemonic_widget(GTK_LABEL(label), return_widget);
< 	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 3);
< 
< 	return return_widget;
< }
< /**
<  * checkbut_with_value:
<  * @labeltest: #const gchar * with the text for the label
<  * 	@which_config_int: #gint whether or not to set the checkbutton active
<  *
<  * 	Create new checkbutton with some value
<  *
<  * Return value: #GtkWidget* pointer to the new checkbutton widget
<  */
< GtkWidget *checkbut_with_value(gchar *labeltext, gint which_config_int) {
< 	GtkWidget *returnwidget;
< 
< 	returnwidget = gtk_check_button_new_with_mnemonic(labeltext);
< 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(returnwidget), which_config_int);
< 	return returnwidget;
< }
< /**
<  * boxed_checkbut_with_value:
<  * @labeltest: #const gchar * with the text for the label
<  * 	@which_config_int: #gint whether or not to set the checkbutton active
<  * @box: the #GtkWidget* box widget to add the entry to
<  *
<  * 	Create new checkbutton with some value, and add it to box
<  *
<  * Return value: #GtkWidget* pointer to the new checkbutton widget
<  */
< GtkWidget *boxed_checkbut_with_value(gchar *labeltext, gint which_config_int, GtkWidget * box) {
< 	GtkWidget *returnwidget;
< 
< 	returnwidget = checkbut_with_value(labeltext, which_config_int);
< 	gtk_box_pack_start(GTK_BOX(box), returnwidget, FALSE, FALSE, 3);
< 	return returnwidget;
< }
< /**
<  * radiobut_with_value:
<  * @labeltest: #const gchar * with the text for the label
<  * 	@enabled: #gint if the radiobutton is enabled or not
<  * @prevbut: #GtkRadioButton* pointer to the first button or NULL if none
<  *
<  * 	Create new radiobutton with some value, and if there is a first button 
<  * for this group, add this button to that group
<  *
<  * Return value: #GtkWidget* pointer to the new radiobutton widget
<  */
< GtkWidget *radiobut_with_value(gchar *labeltext, gint enabled, GtkRadioButton *prevbut) {
< 	GtkWidget *returnwidget;
< 	GSList *group=NULL;
< 
< 	if (prevbut) {
< 		group = gtk_radio_button_group(prevbut);
< 	}	
< 	returnwidget = gtk_radio_button_new_with_mnemonic(group, labeltext);
< 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(returnwidget), enabled);
< 	return returnwidget;
< }
< /**
<  * boxed_radiobut_with_value:
<  * @labeltest: #const gchar * with the text for the label
<  * 	@enabled: #gint if the radiobutton is enabled or not
<  * @prevbut: #GtkRadioButton* pointer to the first button or NULL if none
<  * @box: the #GtkWidget* box widget to add the entry to
<  *
<  * 	Create new radiobutton with some value, and if there is a first button 
<  * for this group, add this button to that group, and this button to box
<  *
<  * Return value: #GtkWidget* pointer to the new radiobutton widget
<  */
< GtkWidget *boxed_radiobut_with_value(gchar *labeltext, gint enabled, GtkRadioButton *prevbut, GtkWidget *box) {
< 	GtkWidget *returnwidget;
< 
< 	returnwidget = radiobut_with_value(labeltext, enabled, prevbut);
< 	gtk_box_pack_start(GTK_BOX(box), returnwidget, FALSE, FALSE, 0);
< 	return returnwidget;
< }
< 
< static gint is_int(gfloat testval) {
< 	DEBUG_MSG("is_int, (int)testval=%d\n", (int)testval);
< 	if ((gfloat)(((int) testval) - ((gfloat) testval )) == 0) {
< 		DEBUG_MSG("is_int, %f int!\n", testval);
< 		return 1;
< 	} else {
< 		DEBUG_MSG("is_int, %f float!\n", testval);
< 		return 0;
< 	}
< }
< 
< /**
<  * spinbut_with_value:
<  * @value: #const gchar * with the value as string for the spinbut
<  * 	@lower: a #gfloat with the lower value for the range
<  * @upper: a #gfloat with the upper value for the range
<  * @step_increment: a #gfloat with the stepsize for the spinbutton
<  * @page_increment: a #gfloat with the pagesize (pgup/pgdn) for the spinbutton
<  *
<  * 	Create new spinbutton with the specified value and range
<  *
<  * Return value: #GtkWidget* pointer to the new spinbutton widget
<  */
< GtkWidget *spinbut_with_value(gchar *value, gfloat lower, gfloat upper, gfloat step_increment, gfloat page_increment) {
< 	GtkAdjustment *adj;
< 	GtkWidget *returnwidget;
< 	guint digits;
< 	double fvalue=0;
< 
< 	if (value) {
< 		fvalue = strtod(value, NULL);
< 	}
< 	adj = (GtkAdjustment *) gtk_adjustment_new((gfloat)fvalue, (gfloat)lower, (gfloat)upper, step_increment, page_increment, 0.0);
< 	digits = (is_int(lower) ? 0 : 2);
< 	returnwidget = gtk_spin_button_new(adj, step_increment, digits);
< /*	g_object_set(G_OBJECT(returnwidget), "numeric", TRUE, NULL);*/
< 	gtk_spin_button_set_numeric(GTK_SPIN_BUTTON(returnwidget), FALSE);
< 	gtk_spin_button_set_snap_to_ticks(GTK_SPIN_BUTTON(returnwidget), FALSE);
< /*	gtk_spin_button_set_update_policy(GTK_SPIN_BUTTON(returnwidget), GTK_UPDATE_IF_VALID);*/
< 	if (!value) {
< 		gtk_entry_set_text(GTK_ENTRY(GTK_SPIN_BUTTON(returnwidget)), "");
< 	}
< 	
< 	return returnwidget;
< }
< /* THIS ONE IS NEVERUSED
< GtkWidget *boxed_spinbut_with_value(gchar *value, gfloat lower, gfloat upper, gfloat step_increment, gfloat page_increment, GtkWidget *box) {
< 	GtkWidget *returnwidget;
< 	returnwidget = spinbut_with_value(value, lower, upper, step_increment, page_increment);
< 	gtk_box_pack_start(GTK_BOX(box), returnwidget, FALSE, FALSE, 0);
< 	return returnwidget;
< }
< */
< /**
<  * optionmenu_with_value:
<  * @options: a #gchar** NULL terminated array with option strings
<  * @curval: a #gint with the current selected item
<  *
<  * Create new popupmenu from options, and set the selected index from curval
<  *
<  * Return value: #GtkWidget* pointer to the new menu widget
<  * Created by: RubÃ©n Dorta
<  */
< 
< GtkWidget *optionmenu_with_value(gchar **options, gint curval) {
< 	GtkWidget *returnwidget;
< 	GtkWidget *menu, *menuitem;
< 	gchar **str;
< 
< 	returnwidget = gtk_option_menu_new();
< 	menu = gtk_menu_new();
< 	str = options;
< 
< 	while (*str) {
< 		DEBUG_MSG("prefs_optionmenu, adding %s to optionmenu\n", *str);
< 		menuitem = gtk_menu_item_new_with_label(_(*str));
< 		gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
< 		str++;
< 	}
< 
< 	gtk_option_menu_set_menu(GTK_OPTION_MENU(returnwidget), menu);
< 	gtk_option_menu_set_history(GTK_OPTION_MENU(returnwidget), curval);
< 	return returnwidget;
< }
< 
< /**
<  * boxed_optionmenu_with_value:
<  * @labeltext: a #const gchar* with the text for the label
<  * @curval: a #gint with the current selected item
<  * @box: a #GtkWidget* with the box to add this to
<  * @options: a #gchar** NULL terminated array with option strings
<  *
<  * Create a new horizontal box with a labeltext and a new popupmenu using the options array
<  * setting the selected index from curval
<  *
<  * Return value: #GtkWidget* pointer to the new menu widget
<  * Modified by: RubÃ©n Dorta
<  */
< 
< GtkWidget *boxed_optionmenu_with_value(const gchar *labeltext, gint curval, GtkWidget *box, gchar **options) {
< 	GtkWidget *returnwidget;
< 	GtkWidget *hbox;
< 
< 	hbox = gtk_hbox_new(FALSE,3);
< 	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 3);
< 	gtk_box_pack_start(GTK_BOX(hbox), gtk_label_new(labeltext), FALSE, FALSE, 3);
< 	returnwidget = optionmenu_with_value(options, curval);
< 	gtk_box_pack_start(GTK_BOX(hbox), returnwidget, FALSE, FALSE, 3);
< 	return returnwidget;
< }
< 
< /**
<  * window_with_title:
<  * 	@title: #gchar* the title string
<  * 	@position: the gtk window position
<  * 	@type: the gtk window type
<  *
<  * 	Create new window with title and some more settings
<  *
<  * Return value: #GtkWidget* pointer to created window
<  */
< GtkWidget *window_with_title(const gchar * title, GtkWindowPosition position, gint borderwidth) {
< 	GtkWidget *returnwidget;
< 
< 	returnwidget = gtk_window_new(GTK_WINDOW_TOPLEVEL);
< 	if (title) {
< 		gtk_window_set_title(GTK_WINDOW(returnwidget), title);
< 	}
< 	if (borderwidth) {
< 		gtk_container_set_border_width(GTK_CONTAINER(returnwidget), borderwidth);
< 	}
< 	if (position) {
< 		gtk_window_set_position(GTK_WINDOW(returnwidget), position);
< 	}
< #ifdef DEBUG
< 	 else {
< 		g_print("window_with_title, **NOT** setting position!!\n");
< 	}
< #endif
< 	return returnwidget;
< }
< /* GtkWindowPosition can be 
< GTK_WIN_POS_NONE
< GTK_WIN_POS_CENTER
< GTK_WIN_POS_MOUSE */
< 
< static gboolean window_full_key_press_event_lcb(GtkWidget *widget,GdkEventKey *event,GtkWidget *win) {
< 	DEBUG_MSG("window_full_key_press_event_lcb, started\n");
< 	if (event->keyval == GDK_Escape) {
< 		DEBUG_MSG("window_full_key_press_event_lcb, emit delete_event on %p\n", win);
< /*		g_signal_emit_by_name(G_OBJECT(win), "delete_event");*/
< 		gtk_widget_destroy(win);
< 		DEBUG_MSG("window_full_key_press_event_lcb, DESTROYED %p\n", win);
< 		return TRUE;
< 	}
< 	return FALSE;
< }
< 
< /**
<  * window_full2:
<  * 	@title: #gchar* the title string
<  * 	@position: #gint the gtk window position GTK_WIN_POS_NONE, GTK_WIN_POS_CENTER, GTK_WIN_POS_MOUSE
<  * 	@borderwidth: #gint border width
<  * 	@close_func: #GCallback the callback function when closing the window
<  * 	@close_data: #gpointer data passed to the closefunc, or NULL to pass the widget pointer as close data
<  * @delete_on_escape: #gboolean if the escape key should close the dialog
<  * @transientforparent: #GtkWidget* with the window to set this transient for, or NULL
<  *
<  * Create new window with title, callback functions, some more settings
<  * and if needed set a callback so the window will be closed on escape press
<  * and set it if needed transient for another window
<  *
<  * the close_func should have the form 
<  * void close_func(GtkObject *object,gpointer user_data);
<  *
<  * Return value: #GtkWidget* pointer to created window
<  */
< GtkWidget *window_full2(const gchar * title, GtkWindowPosition position
< 			, gint borderwidth, GCallback close_func
< 			, gpointer close_data
< 			, gboolean delete_on_escape,
< 			GtkWidget *transientforparent)
< {
< 
< 	GtkWidget *returnwidget;
< 
< 	returnwidget = window_with_title(title, position, borderwidth);
< /*	g_signal_connect(G_OBJECT(returnwidget), "delete_event", close_func, close_data);*/
< 	/* use "destroy" and not "destroy_event", 'cause that doesn't work */
< 	if (close_data == NULL) close_data = returnwidget;
< 	g_signal_connect(G_OBJECT(returnwidget), "destroy", close_func, close_data);
< 	DEBUG_MSG("window_full, close_data=%p\n",close_data);
< 	if (transientforparent) {
< 		gtk_window_set_transient_for(GTK_WINDOW(returnwidget), GTK_WINDOW(transientforparent));
< 	}
< 	if (delete_on_escape) {
< 		g_signal_connect(G_OBJECT(returnwidget), "key_press_event", G_CALLBACK(window_full_key_press_event_lcb), returnwidget);
< 		/* for these windows it is also convenient if they destroy when their parent is destroyed */
< 		gtk_window_set_destroy_with_parent(GTK_WINDOW(returnwidget), TRUE);
< 	}
< 	DEBUG_MSG("window_full, return %p\n", returnwidget);
< 	return returnwidget;
< }
< /**
<  * textview_buffer_in_scrolwin:
<  * 	@textview: #GtkWidget** will be filled with the textview widget pointer
<  * 	@width: #gint the width of the scrolwin, -1 if default required
<  * 	@height: #gint the height of the scrolwin, -1 if default required
<  * 	@contents: #gchar* the initial contents of the textbox
<  * 	@wrapmode: #GtkWrapMode the wrapmode for the TextView GTK_WRAP_NONE,GTK_WRAP_CHAR,GTK_WRAP_WORD
<  *
<  * creates a textbuffer, a textview widget (stored in the textview pointer), 
<  * puts that inside a scrolwin, adds the content and sets the size and returns
<  * the scrolwin
<  *
<  * Return value: #GtkWidget* to the scolwin
<  */
< GtkWidget *textview_buffer_in_scrolwin(GtkWidget **textview, gint width, gint height, const gchar *contents, GtkWrapMode wrapmode) {
< 	GtkWidget *scrolwin;
< 	GtkTextBuffer *textbuf;
< 	
< 	textbuf = gtk_text_buffer_new(NULL);
< 	*textview = gtk_text_view_new_with_buffer(textbuf);
< 	gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(*textview), wrapmode);
< 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
< 	gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolwin), GTK_SHADOW_IN);
< 	gtk_container_add (GTK_CONTAINER (scrolwin), *textview);
< 	gtk_widget_set_size_request(scrolwin, width, height);
< 	if (contents) {
< 		gtk_text_buffer_set_text(textbuf, contents, -1);
< 	}
< 	return scrolwin;
< }
< 
< /**
<  * apply_font_style:
<  * 	@this_widget: #GtkWidget* the widget to apply the new fontstyle
<  * 	@fontstring: #gchar* the fontset which will be loaded
<  *
<  * 	Change the font of a widget with a certain font from a string
<  *
<  * Return value: #GtkWidget* to this_widget
<  */
< GtkWidget *apply_font_style(GtkWidget * this_widget, gchar * fontstring) {
< 	if (fontstring) {
< 		PangoFontDescription *font_desc;
< 		font_desc = pango_font_description_from_string(fontstring);
< 		gtk_widget_modify_font(this_widget, font_desc);
< 		pango_font_description_free(font_desc);
< 	}
< 	return this_widget;
< }
< 
< /**
<  * hbox_with_pix_and_text:
<  * 	@label: #const gchar* with the text
<  * 	@pixmap_type: #gint with a pixmap type known by new_pixmap() from pixmap.h
<  *
<  * constructs a hbox with a pixmap and text. The pixmap type should be known
<  * to the new_pixmap() function from pixmap.c
<  * This function is very useful to create a button with text and a pixmap
<  *
<  * Return value: #GtkWidget* to the hbox
<  */
< GtkWidget *hbox_with_pix_and_text(const gchar *label, gint bf_pixmaptype, gboolean w_mnemonic) {
< 	GtkWidget *hbox = gtk_hbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(hbox), new_pixmap(bf_pixmaptype), FALSE, FALSE, 1);
< 	gtk_box_pack_start(GTK_BOX(hbox), ((w_mnemonic) ? gtk_label_new_with_mnemonic(label) : gtk_label_new(label)), TRUE, TRUE, 1);
< 	gtk_widget_show_all(hbox);
< 	return hbox;
< }
< 
< GtkWidget *bf_allbuttons_backend(const gchar *label, gboolean w_mnemonic, gint bf_pixmaptype, GCallback func, gpointer func_data) {
< 	GtkWidget *button;
< 	if (bf_pixmaptype == -1) {
< 		/* there is no image needed, only text */
< 		if (w_mnemonic) {
< 			button = gtk_button_new_with_mnemonic(label);
< 		} else {
< 			button = gtk_button_new_with_label(label);
< 		}
< 	} else {
< 		/* there is an image needed */
< 		button = gtk_button_new();
< 		if (label) {
< 			/* both a pixmap and text */
< 			gtk_container_set_border_width(GTK_CONTAINER(button), 0);
< 			gtk_container_add(GTK_CONTAINER(button), hbox_with_pix_and_text(label, bf_pixmaptype, w_mnemonic));
< 		} else {
< 			/* only pixmap */
< 			gtk_container_add(GTK_CONTAINER(button), new_pixmap(bf_pixmaptype));
< 		}
< 	}
< 	GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
< 	g_signal_connect(G_OBJECT(button), "clicked", func, func_data);
< 	return button;
< }
< 
< /**
<  * bf_generic_button_with_image:
<  * @label: #const gchar* button string with '_' for the mnemonic, or NULL
<  * @pixmap_type: #gint image to display on button know to new_pixmap() from pixmap.c
<  * @func: #GCallback pointer to signal handler
<  * @func_data: #gpointer data for signal handler
<  *
<  * Create new button with an image and connect the "clicked" signal to func
<  * if the label is NULL there will be only an image in the button
<  *
<  * Return value: #GtkWidget* pointer to created button
<  */
< /* GtkWidget *bf_generic_button_with_image(const gchar *label, gint pixmap_type, GCallback func, gpointer func_data) {
<         GtkWidget *button;
< 
< 	button = gtk_button_new();
< 	gtk_container_set_border_width(GTK_CONTAINER(button), 0);
< 	if (label) {
< 		gtk_container_add(GTK_CONTAINER(button), hbox_with_pix_and_text(label, pixmap_type));
< 	} else {
< 		gtk_container_add(GTK_CONTAINER(button), new_pixmap(pixmap_type));
< 	}
< 	GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
< 	g_return_val_if_fail(button, NULL);
< 	g_signal_connect(G_OBJECT(button), "clicked", func, func_data);
< 	return button;
< } */
< 
< /**
<  * bf_generic_mnemonic_button:
<  * @Text: #const gchar* button string, using '_' for the mnemonic
<  * @func: #GCallback pointer to signal handler
<  * @func_data: #gpointer data for signal handler
<  *
<  * 	Create new button with mnemonic and connect the "clicked" signal to func
<  *
<  * Return value: pointer to created button
<  */
< /* GtkWidget *bf_generic_mnemonic_button(const gchar * Text, GCallback func, gpointer func_data) {
< 	GtkWidget *button;
< 
< 	button = gtk_button_new_with_mnemonic(Text);
< 	g_return_val_if_fail(button, NULL);
< 	GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
< 	g_signal_connect(G_OBJECT(button), "clicked", func, func_data);
< 	DEBUG_MSG("bf_generic_mnemonic_button, func_data=%p\n", func_data);
< 	return button;
< } */
< /**
<  * bf_gtkstock_button:
<  * @stock_id: #const gchar* wioth the GTK stock icon ID
<  * @func: #GCallback pointer to signal handler
<  * @func_data: #gpointer data for signal handler
<  *
<  * Create new button from the GTK stock icons
<  *
<  * Return value: pointer to created button
<  */
< GtkWidget *bf_gtkstock_button(const gchar * stock_id, GCallback func, gpointer func_data) {
< 	GtkWidget *button = gtk_button_new_from_stock(stock_id);
< 	GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
< 	g_signal_connect(G_OBJECT(button), "clicked", func, func_data);
< 	return button;
< }
< 
< /**
<  * bf_generic_frame_new:
<  * @label: #const gchar* label string. Set to NULL for no label
<  * @shadowtype: #GtkShadowType  border type
<  * @borderwidth: #gint outside border width
<  *
<  * create a generic frame with shadow type and border
<  *
<  * Return value: #GtkWidget* pointer to created frame
<  */
< GtkWidget *bf_generic_frame_new(const gchar *label, GtkShadowType shadowtype, gint borderwidth) {
<   GtkWidget *frame;
< 
<   frame = gtk_frame_new(label);
<   gtk_frame_set_shadow_type(GTK_FRAME(frame), shadowtype);
<   gtk_container_set_border_width(GTK_CONTAINER(frame), borderwidth);
<   
<   return frame;
< }
< 
< /**
<  * bf_mnemonic_label_tad_with_alignment:
<  * @labeltext: #const gchar* label string
<  * @m_widget: #GtkWidget* widget accessed by the label mnemonic
<  * @xalign: #gfloat label horizontal alignment
<  * @yalign: #gfloat label vertical alignment
<  * @table: #GtkWidget table label is packed into
<  * @left_attach: #gint column number to attach the left side of the label to
<  * @right_atach: #gint: column number to attach the right side of a label to
<  * @top_attach: #gint: row number to attach the top of a label to
<  * @bottom_attach: #gint: row number to attach the bottom of a label to 	
<  *
<  * 	create a label with a mnemonic, align it, and attach it to a table
<  *
<  * Return value: void
<  */
< void bf_mnemonic_label_tad_with_alignment(const gchar *labeltext, GtkWidget *m_widget,
< 						float xalign, gfloat yalign, GtkWidget *table, guint left_attach, 
< 						guint right_attach, guint top_attach, guint bottom_attach) {
< 	GtkWidget *label;
< 
< 	label = gtk_label_new_with_mnemonic(labeltext);
< 	gtk_misc_set_alignment(GTK_MISC(label), xalign, yalign);
< 	gtk_table_attach(GTK_TABLE(table), label, left_attach, right_attach, top_attach, bottom_attach, GTK_FILL, GTK_FILL, 0, 0);
<   
< 	if (m_widget != NULL) {
< 		if (GTK_IS_COMBO(m_widget)) {
< 			gtk_label_set_mnemonic_widget(GTK_LABEL(label), (GTK_COMBO(m_widget)->entry));
< 			gtk_entry_set_activates_default(GTK_ENTRY(GTK_COMBO(m_widget)->entry), TRUE);
< 		} else  if (GTK_IS_ENTRY(m_widget)) {
< 		    gtk_label_set_mnemonic_widget(GTK_LABEL(label), m_widget);
< 		    gtk_entry_set_activates_default(GTK_ENTRY(m_widget), TRUE);
< 		} else gtk_label_set_mnemonic_widget(GTK_LABEL(label), m_widget);
< 	}
< }
< 
< /**
<  * bf_label_with_markup:
<  * @labeltext: #const gchar* labeltext string
<  */
< GtkWidget *bf_label_with_markup(const gchar *labeltext) {
< 	GtkWidget *label = gtk_label_new(NULL);
< 	gtk_label_set_markup(GTK_LABEL(label), labeltext);
< 	return label;
< }
< /**
<  * bf_label_tad_with_markup:
<  * @labeltext: #const gchar* label string
<  * @xalign: #gfloat label horizontal alignment
<  * @yalign: #gfloat label vertical alignment
<  * @table: #GtkWidget* table label is packed into
<  * @left_attach: #guint column number to attach the left side of the label to
<  * @right_atach: #guint column number to attach the right side of a label to
<  * @top_attach: #guint row number to attach the top of a label to
<  * @bottom_attach: #guint row number to attach the bottom of a label to 	
<  *
<  *	create a label with markup, align it, and attach it to a table
<  * using the table defaults
<  *
<  * Return value: void
<  */
< void bf_label_tad_with_markup(const gchar *labeltext, gfloat xalign, gfloat yalign,
< 								GtkWidget *table, guint left_attach, guint right_attach, 
< 								guint top_attach, guint bottom_attach) {
< 	GtkWidget *label;
< 	label = bf_label_with_markup(labeltext);
< 	gtk_misc_set_alignment(GTK_MISC(label), xalign, yalign);
< 	gtk_table_attach_defaults(GTK_TABLE(table), label, left_attach, right_attach, top_attach, bottom_attach);	
< }
< #ifdef NOTYETUSED
< typedef struct {
< 	GtkWidget *win;
< 	GtkWidget *entry[10];
< 	gpointer data;
< } Tmultientrywidget;
< 
< static void multi_entry_destroy(GtkObject *object, Tmultientrywidget *mew) {
< 	g_free(mew);
< }
< 
< static void multi_entry_cancel_clicked(GtkWidget *widget, Tmultientrywidget *mew) {
< 	gtk_widget_destroy(mew->win);
< }
< 
< Tmultientrywidget *build_multi_entry_window(gchar *title,GCallback ok_func
< 			,gpointer data, const gchar **labelarr) {
< 	gint arrlen,i;
< 	GtkWidget *table,*hbox,*but;
< 
< 	arrlen = count_array(labelarr);
< 	if (arrlen >10) arrlen = 10;
< 	Tmultientrywidget *mew = g_new0(Tmultientrywidget,1);
< 	mew->data = data;
< 	mew->win = window_full2(title, GTK_WIN_POS_MOUSE, 10, multi_entry_destroy,mew, TRUE, NULL);
< 	table = gtk_table_new(arrlen+2,2,FALSE);
< 	gtk_table_set_row_spacings(GTK_TABLE(table),6);
< 	gtk_table_set_col_spacings(GTK_TABLE(table),6);
< 	gtk_container_add(GTK_CONTAINER(mew->win),table);
< 	for (i=0;i<arrlen;i++) {
< 		GtkWidget *label = gtk_label_new(labelarr[i]);
< 		gtk_table_attach_defaults(GTK_TABLE(table), label, 0, 1, i, i+1);
< 		mew->entry[i] = entry_with_text(NULL, 255);
< 		gtk_table_attach_defaults(GTK_TABLE(table), mew->entry[i], 1, 2, i, i+1);
< 	}
< 	gtk_table_attach_defaults(GTK_TABLE(table), gtk_hseparator_new(), 0, 2, i, i+1);
< 	hbox = gtk_hbutton_box_new();
< 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
< 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 12);
< 	but = bf_stock_cancel_button(G_CALLBACK(multi_entry_cancel_clicked), NULL);
< 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 0);
< 	but = bf_stock_ok_button(G_CALLBACK(ok_func), mew);
< 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 0);
< 	gtk_table_attach_defaults(GTK_TABLE(table), hbox, 0, 2, i+1, i+2);
< 	gtk_widget_show_all(mew->win);
< }
< #endif
< /**************************************************************************/
< /***********************  BUTTON DIALOG FUNCTIONS  ************************/
< /**************************************************************************/
< /*    If this code doesn't work, blame Christian <chris@tellefsen.net>    */
< 
< /* Emit a delete-event to the appropriate dialog, to detect a user bailing through escape. */
< static gboolean dialog_key_press_event_lcb(GtkWidget *widget,GdkEventKey *event,GtkWidget *dialog) {
< 	DEBUG_MSG("dialog_key_press_event_lcb, started, widget is %p and dialog is %p\n", widget, dialog);
< 	if (event->keyval == GDK_Escape) {
< 		DEBUG_MSG("dialog_key_press_event_lcb, emit delete_event on %p\n", dialog);
< 		/* g_signal_emit_by_name(G_OBJECT(dialog), "delete_event"); */
< 		gtk_widget_destroy(dialog);
< 		return TRUE;
< 	}
< 	return FALSE;
< }
< 
< /* This function is called from single_button_dialog_backend() and multiple_button_dialog_backend()
<  * The dialog passed is made HIG-compliant.
<  *
<  * A HiG-dialog is consists of a GtkDialog, with a 2-cell vbox. The top
<  * vbox contains an hbox, with an image and a label. The label has a primary
<  * (strong && larger) message and an additional, more descriptive message.
<  * It is not resizeable, has no title, placement is selected by the wm.
<  */
< void hig_dialog_backend (GtkDialog *dialog, gchar *primary, gchar *secondary, gchar *icon)
< {
< 	GtkWidget *vbox, *hbox, *image, *label;
< 	gchar *message;
< 	gchar *spanstart = "<span weight=\"bold\" size=\"larger\">";
< 	gchar *spanend = "</span>\n\n";
< 	gchar *msgend = "\n";
< 	
< 	gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);
< 	gtk_dialog_set_has_separator (GTK_DIALOG (dialog), FALSE);
< 
< 	vbox = GTK_DIALOG (dialog)->vbox;
< 	
< 	hbox = gtk_hbox_new (FALSE, 12);
< 	gtk_container_set_border_width (GTK_CONTAINER (hbox), 12);
< 	gtk_box_pack_start (GTK_BOX (vbox), hbox, TRUE, FALSE, 0);
< 
< 	if(icon) {
< 		image = gtk_image_new_from_stock (icon , GTK_ICON_SIZE_DIALOG); /* icon unknown ==> "broken image" displayed. */
< 		gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 0);
< 		gtk_misc_set_alignment (GTK_MISC (image), 0, 0);
< 	}
< 	
< 	if(secondary) { /* Creates label-content. */
< 		gchar *str1, *str2;
< 		str1 = xml_escape(primary);
< 		str2 = xml_escape(secondary);
< 		message = g_strconcat(spanstart, str1, spanend, str2, msgend, NULL);
< 	} else {
< 		gchar *str1;
< 		str1 = xml_escape(primary);
< 		message = g_strconcat(spanstart, str1, spanend, NULL);
< 	}
< 			
< 	label = gtk_label_new (message);
< 	g_free(message);
< 
< 	gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);
< 	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
< 	gtk_label_set_justify (GTK_LABEL (label), GTK_JUSTIFY_LEFT);
< 	gtk_label_set_line_wrap (GTK_LABEL (label), TRUE);
< }
< 
< /**
<  * multi_button_dialog_backend:
<  * @win: #GtkWidget* with the parent window for this dialog
<  * @primary: #gchar* containing primary dialog message.
<  * @secondary: #gchar* containing more explanatory message. Set to NULL if unused.
<  * @icon: #gchar* Your stock GTK image, i.e. GTK_STOCK_DIALOG_WARNING.
<  * @defval: #gint default index when user press ENTER.
<  * @cancelval: #gint: default index when user press ESCAPE. Should be something non-fatal. If this value is -1, the escape-button will be disabled.
<  * @buttons: #gchar** array of buttons. NULL-terminated!! Must contain at least one button.
<  *
<  * create a modal dialog with several buttons, returning the index of the clicked button
<  *
<  * Return value: #gint the index num of the button label which was clicked	so 0 for the first, 1 for the 2nd etc.
<  */
< gint multi_button_dialog_backend(GtkWidget *win, gchar *primary, gchar *secondary, gchar *icon, gint defval, gint cancelval, gchar **buttons) {
< 	GtkWidget *dialog;
< 	int i, retval;
< 
< 	dialog = gtk_dialog_new_with_buttons ("", /* Note that no title is being set. */
< 												GTK_WINDOW(win),
< 												GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
< 												*buttons, 0,
< 												NULL);
< 	DEBUG_MSG ("multi_button_dialog_backend: dialog=%p, primary=%s\n", dialog, primary);
< 	/* Add buttons. The index must be correct! */
< 	for (i = 1; *++buttons; i++) { /* Walk through the button-list until one reaches NULL. */
< 		DEBUG_MSG ("multi_button_dialog_backend: Adding button '%s', ID=%d\n", *buttons, i);
< 		gtk_dialog_add_button (GTK_DIALOG (dialog), *buttons, i);
< 	}
< 
< 	gtk_dialog_set_default_response (GTK_DIALOG (dialog), defval); /* enter-default*/
< 	if(cancelval != -1)/* enable escape ? */
< 		g_signal_connect(G_OBJECT(dialog), "key_press_event",
< 				G_CALLBACK(dialog_key_press_event_lcb), dialog); /* kill when escape is hit */
< 
< 	hig_dialog_backend (GTK_DIALOG (dialog), primary, secondary, icon);
< 	gtk_widget_show_all (dialog);
< 	retval = gtk_dialog_run (GTK_DIALOG (dialog));
< 	if (retval != GTK_RESPONSE_NONE) {
< 	    gtk_widget_destroy (dialog);
< 	}
< 
< 	DEBUG_MSG("multi_button_dialog_backend: got %d\n", retval);	
< 	return (retval == GTK_RESPONSE_DELETE_EVENT) ? cancelval : retval; /* When user hits escape -- give cancelval. */
< } 
< 
< /**
<  * single_button_dialog_backend:
<  * @primary #gchar* containing primary dialog message.
<  * @secondary #gchar* containing more explanatory message. Set to NULL if unused.
<  * @icon #gchar* Your stock GTK image, i.e. GTK_STOCK_DIALOG_WARNING.
<  * 
<  * Create and display a single-button message-dialog - HiG-style.
<  **/
< void single_button_dialog_backend(GtkWidget *win,gchar * primary, gchar * secondary, gchar * icon) {
< 	gchar *buttons[] = {GTK_STOCK_OK, NULL};
< 	multi_button_dialog_backend(win,primary, secondary, icon, 0, 0, buttons);
< }
< 
< /**
<  * error_dialog:
<  * @primary: #gchar* the primary error-description
<  * @secondary: #gchar* the secondary description of the error or NULL.
<  *
<  * 	Display an error dialog, Gnome HiG style
<  *
<  * Return value: void
<  */
< void error_dialog(GtkWidget *win,gchar * primary, gchar * secondary) {
< 	single_button_dialog_backend(win,primary, secondary, GTK_STOCK_DIALOG_ERROR);
< }
< 
< /**
<  * info_dialog:
<  * @primary: #gchar* the primary error-description
<  * @secondary: #gchar* the secondary description of the error or NULL.
<  *
<  * 	Display an informational dialog, Gnome HiG style
<  *
<  * Return value: void
<  */
< void info_dialog(GtkWidget *win,gchar * primary, gchar * secondary) {
< 	single_button_dialog_backend(win,primary, secondary, GTK_STOCK_DIALOG_INFO);
< }
< 
< /**
<  * warning_dialog:
<  * @primary: #gchar* the primary error-description
<  * @secondary: #gchar* the secondary description of the error or NULL.
<  *
<  * 	Display a warning dialog, Gnome HiG style
<  *
<  * Return value: void
<  */
< void warning_dialog(GtkWidget *win,gchar * primary, gchar * secondary) {
< 	single_button_dialog_backend(win,primary, secondary, GTK_STOCK_DIALOG_WARNING);
< }
< 
< /* multi_button_dialog and multi_stockbutton_dialog was here */
< 
< /**
<  * multi_error_dialog:
<  * @primary: #gchar* the primary error-description
<  * @secondary: #gchar* the secondary description of the error or NULL.
<  * @defval: #gint default index when user press ENTER.
<  * @cancelval: #gint: default index when user press ESCAPE. Should be something non-fatal. If this value is -1, the escape-button will be disabled.
<  * @buttons: #gchar** NULL terminated array of strings with button labels
<  *
<  * Create a modal error-dialog with several buttons, returning the index of the clicked button
<  *
<  * Return value: #gint the index num of the button label which was clicked	so 0 for the first, 1 for the 2nd etc.
<  */
< gint multi_error_dialog(GtkWidget *win,gchar *primary, gchar *secondary, gint defval, gint cancelval, gchar **buttons) {
< 	return multi_button_dialog_backend(win,primary, secondary, GTK_STOCK_DIALOG_ERROR, defval, cancelval, buttons);
< }
< 
< /**
<  * multi_warning_dialog:
<  * @primary: #gchar* the primary error-description
<  * @secondary: #gchar* the secondary description of the error or NULL.
<  * @defval: #gint default index when user press ENTER.
<  * @cancelval: #gint: default index when user press ESCAPE. Should be something non-fatal. If this value is -1, the escape-button will be disabled.
<  * @buttons: #gchar** NULL terminated array of strings with button labels
<  *
<  * Create a modal warning-dialog with several buttons, returning the index of the clicked button
<  *
<  * Return value: #gint the index num of the button label which was clicked	so 0 for the first, 1 for the 2nd etc.
<  */
< gint multi_warning_dialog(GtkWidget *win,gchar *primary, gchar *secondary, gint defval, gint cancelval, gchar **buttons) {
< 	return multi_button_dialog_backend(win,primary, secondary, GTK_STOCK_DIALOG_WARNING, defval, cancelval, buttons);
< }
<  
< /**
<  * multi_error_dialog:
<  * @primary: #gchar* the primary error-description
<  * @secondary: #gchar* the secondary description of the error or NULL.
<  * @defval: #gint default index when user press ENTER.
<  * @cancelval: #gint: default index when user press ESCAPE. Should be something non-fatal. If this value is -1, the escape-button will be disabled.
<  * @buttons: #gchar** NULL terminated array of strings with button labels
<  *
<  * Create a modal question-dialog with several buttons, returning the index of the clicked button
<  *
<  * Return value: #gint the index num of the button label which was clicked	so 0 for the first, 1 for the 2nd etc.
<  */
< gint multi_query_dialog(GtkWidget *win,gchar *primary, gchar *secondary, gint defval, gint cancelval, gchar **buttons) {
< 	return multi_button_dialog_backend(win,primary, secondary, GTK_STOCK_DIALOG_QUESTION, defval, cancelval, buttons);
< }
< 
< /************************************************************************/
< /*********************** PROGRESS-BAR FUNCTIONS *************************/
< /************************************************************************/
< /* Progress-bar-inspiration from the gtk-tutorial.. */
< 
< typedef struct _Tprogress {
< 	GtkWidget *bar;
< 	gboolean active; /* if FALSE, the bar is set to "confused-mode". */
< 	gboolean show_text; /* TRUE: String added to bar: text " " value " of  " maxvalue'*/
< 	gchar *text; /* Optional text to be displayed. */
< 	guint value; /* The current value. */
< 	guint maxvalue; /* The maximum value. Used to calculate a fraction between 0 and 1. */
< 	GtkWidget *owner; /* The widget to be destroyed when the bar is finished. */
< 	guint timer; /* keep track of the timer */
< 
< } Tprogress;
< 
< void progress_destroy(gpointer gp)
< {
< 	if(gp) {
< 		Tprogress *p = (Tprogress *) gp;
< 		/* bar is destroyed when owner is destroyed. */
< 		if(p->owner)
< 			gtk_widget_destroy (p->owner);
< 		else
< 			gtk_widget_destroy(p->bar);
< 			
< 		gtk_timeout_remove(p->timer);
< 		p->timer = 0;
< 		
< 		g_free(p);
< 	}
< }
< 
< static gboolean progress_update(gpointer data) {
< 	gchar *msg;
< 	Tprogress *p = (Tprogress *) data;
< 	gdouble frac = (gdouble) p->value / (gdouble) p->maxvalue;
< 	DEBUG_MSG("Entering: progress_update()\n");
< 
< 	gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (p->bar), frac);
< 	msg = g_strdup_printf (_("%d of %d"), p->value, p->maxvalue);
< 	gtk_progress_bar_set_text (GTK_PROGRESS_BAR (p->bar), msg);
< 	g_free (msg);
< 	
< 	if (p->value < p->maxvalue) {
< /*		flush_queue ();*/
< 		return TRUE; /* Yes! Call me again! GIMMI! */
< 	} else {
< 		/* We're done! Signal that we're maxed now. */
< 		return FALSE;
< 	}
< }
< 
< /**
<  * progress_set:
<  * @p The Tprogress struct assigned by a progress-creator. (i.e. progress_popup).
<  * @value a #guint between 0 and p->maxvalue.
<  *
<  * Set a new value for the progressbar-value. Does not actually update the progress-bar.
<  **/
< void progress_set(gpointer gp, guint value)
< {
< 	Tprogress *p = (Tprogress *) gp;
< 	p->value = value;
< }
< 
< /**
<  * progress_popup:
<  *
<  * Creates a popup containing a progress-bar. The dialog disappears when value = maxvalue.
<  * 'text' must be freeed after use!
<  *
<  * Returns: #gpointer camouflaged pointer to struct Tprogress, a data-structure passed to progress_update.
<  **/
< gpointer progress_popup(GtkWidget *win,gchar *title, guint maxvalue) {
< 	Tprogress *p;
< 	
< 	p = g_malloc (sizeof (Tprogress));
< 
< 	p->bar = gtk_progress_bar_new ();
< 	p->value = 0;
< 	p->maxvalue = maxvalue;
< 	
< 	
< 	/* other parameters */
< 	p->active = TRUE;
< 	p->show_text = TRUE;
< 	p->value = 0;
< 	p->maxvalue = maxvalue;
< 
< 	p->owner = gtk_dialog_new();
< 
< 	gtk_window_set_modal (GTK_WINDOW (p->owner), TRUE);
< 	gtk_window_set_transient_for (GTK_WINDOW (p->owner), GTK_WINDOW(win));
< 
< 
< 	/* Label, if applicable. Append pretty icon! */
< 	hig_dialog_backend(GTK_DIALOG (p->owner), title, NULL, GTK_STOCK_DIALOG_INFO);
< 
< 	gtk_box_pack_start (GTK_BOX (GTK_DIALOG (p->owner)->vbox),
<                         p->bar, TRUE, TRUE, 12);
< 
< 	p->timer = gtk_timeout_add (500, progress_update, p);
< 	gtk_widget_show_all (p->owner);
< 	
< 	return (gpointer) p;
< }
< 
< 
< /************************************************************************/
< /************************ file_but_* FUNCTIONS **************************/
< /************************************************************************/
< 
< typedef struct {
< 	GtkWidget *entry;
< 	Tbfwin *bfwin;
< 	gboolean fullpath;
< } Tfilebut;
< 
< static void file_but_clicked_lcb(GtkWidget * widget, Tfilebut *fb) {
< 	gchar *tmpstring=NULL, *tmp2string, *setfile;
< 	DEBUG_MSG("file_but_clicked_lcb, started, which_entry=%p\n",fb->entry);
< 	setfile = gtk_editable_get_chars(GTK_EDITABLE(GTK_ENTRY(fb->entry)),0,-1);
< 	/* if setfile is empty we should probably use the current document basedir ? right? */
< 	if (!setfile || strlen(setfile)==0) {
< 		if (fb->bfwin && fb->bfwin->current_document->filename && strlen(fb->bfwin->current_document->filename)) {
< 			if (setfile) g_free(setfile);
< 			setfile = path_get_dirname_with_ending_slash(fb->bfwin->current_document->filename);
< 		}
< 	} else if (setfile && strchr(setfile, '/') == NULL && fb->bfwin && fb->bfwin->current_document->filename) {
< 		/* if setfile is a relative name, we should try to make it a full path. relative names have 
< 		no slashes in the name */
< 		gchar *basedir, *oldsetfile;
< 		oldsetfile = setfile;
< 		basedir = path_get_dirname_with_ending_slash(fb->bfwin->current_document->filename);
< 		setfile = create_full_path(oldsetfile, basedir);
< 		g_free(oldsetfile);
< 		g_free(basedir);
< 	}
< 	
< #ifdef HAVE_ATLEAST_GTK_2_4
< 	{
< 		GtkWidget *dialog;
< 		dialog = file_chooser_dialog(NULL, _("Select File"), GTK_FILE_CHOOSER_ACTION_OPEN, setfile, FALSE, FALSE, NULL);
< 		gtk_window_set_transient_for(GTK_WINDOW(dialog),GTK_WINDOW(gtk_widget_get_toplevel(fb->entry)));
< 		if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
< 			tmp2string = gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(dialog));
< 			tmpstring = create_full_path(tmp2string, NULL);
< 			g_free(tmp2string);
< 		}
< 		gtk_widget_destroy(dialog);
< 	}
< #else
< 	tmpstring = return_file(setfile);
< #endif
< 	g_free(setfile);
< 	DEBUG_MSG("file_but_clicked_lcb, return_file returned %s\n",tmpstring);
< 	if (tmpstring) {
< 		if (!fb->fullpath && fb->bfwin) {
< 			if (fb->bfwin->current_document->filename != NULL) {
< 				tmp2string = create_relative_link_to(fb->bfwin->current_document->filename, tmpstring);
< 			} else {
< 				tmp2string = g_strdup(tmpstring);
< 			}
< 			g_free(tmpstring);
< 			tmpstring = tmp2string;
< 		}
< 		gtk_entry_set_text(GTK_ENTRY(fb->entry), tmpstring);
< /*	perhaps I break something by commenting-out this call, but otherwise the dialog is sometimes started
< 	again after the signal is emmitted
< 		gtk_signal_emit_by_name(GTK_OBJECT(which_entry), "activate");
< 		g_free(tmp2string); */
< 	}
< }
< 
< static void file_but_destroy(GtkObject *object, Tfilebut *fb) {
< 	g_free(fb);
< }
< /**
<  * file_but_new:
<  * @which_entry: #GtkWidget* GTK_ENTRY where to put the filename
<  * @win: #GtkWidget* the GTK_WINDOW where the button is placed
<  * @full_pathname: #gint 1 or 0, if you want the full path or a relative path
<  * #bfwin: #Tbfwin, only required if you want a relative pathname
<  *
<  *	Create new "open file" button, that will put the string into an entry
<  *
<  * Return value: #GtkWidget* pointer to file button
<  */
< GtkWidget *file_but_new(GtkWidget * which_entry, gint full_pathname, Tbfwin *bfwin) {
< 	GtkWidget *file_but;
< 	Tfilebut *fb;
< 
< 	fb = g_new(Tfilebut,1);
< 	fb->entry = which_entry;
< 	fb->bfwin = bfwin;
< 	fb->fullpath = full_pathname;
< 	file_but = gtk_button_new();
< 	g_signal_connect(G_OBJECT(file_but), "destroy", G_CALLBACK(file_but_destroy), fb);
< 	DEBUG_MSG("file_but_new, entry=%p, button=%p\n",which_entry,file_but);
< 	gtk_container_add(GTK_CONTAINER(file_but), hbox_with_pix_and_text(_("_Browse..."), 112,TRUE));
< 	g_signal_connect(G_OBJECT(file_but), "clicked", G_CALLBACK(file_but_clicked_lcb), fb);
< 	gtk_widget_show(file_but);
< 	return file_but;
< }
< 
< /************************************************************************/
< /************    FILE SELECTION FUNCTIONS  ******************************/
< /************************************************************************/
< 
< #ifdef HAVE_ATLEAST_GTK_2_4
< 
< static void file_chooser_set_current_dir(GtkWidget *dialog, const gchar *dir) {
< 	if (dir) {
< 		if (dir[0] == '/') gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog),dir);
< 		else gtk_file_chooser_set_current_folder_uri(GTK_FILE_CHOOSER(dialog),dir);
< 	}
< }
< 
< GtkWidget * file_chooser_dialog(Tbfwin *bfwin, gchar *title, GtkFileChooserAction action, 
<                                 gchar *set, gboolean localonly, gboolean multiple, const gchar *filter) {
< 	GtkWidget *dialog;
< /*	dialog = gtk_file_chooser_dialog_new_with_backend(title,bfwin ? GTK_WINDOW(bfwin->main_window) : NULL,
< 			action,"gnome-vfs",
< 			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
< 			(action == GTK_FILE_CHOOSER_ACTION_SAVE) ? GTK_STOCK_SAVE : GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
< 			NULL); */
< 	dialog = gtk_file_chooser_dialog_new(title,bfwin ? GTK_WINDOW(bfwin->main_window) : NULL, action,
<                 GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
<                 (action == GTK_FILE_CHOOSER_ACTION_SAVE) ? GTK_STOCK_SAVE : GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
<                 NULL);
< 	gtk_dialog_set_default_response (GTK_DIALOG(dialog), GTK_RESPONSE_ACCEPT);
< 	gtk_file_chooser_set_local_only (GTK_FILE_CHOOSER(dialog), localonly);
< 	gtk_file_chooser_set_select_multiple (GTK_FILE_CHOOSER(dialog), multiple);	
< 	
< 	if (set && strlen(set)) {
< 		DEBUG_MSG("file_chooser_dialog, set=%s,localonly=%d\n",set,localonly);
< 		if (localonly || strchr(set,':')==NULL) {
< 			gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog),set);
< 		} else {
< 			gtk_file_chooser_set_uri(GTK_FILE_CHOOSER(dialog),set);
< 		}
< 	} else if (!localonly && bfwin) { /* localonly is used for the project files */
< 		if (action == GTK_FILE_CHOOSER_ACTION_SAVE) {
< 			DEBUG_MSG("file_chooser_dialog, opendir=%s, savedir=%s\n",bfwin->session->opendir,bfwin->session->savedir);
< 			if (bfwin->session->savedir) file_chooser_set_current_dir(dialog,bfwin->session->savedir);
< 			else if (bfwin->session->opendir) file_chooser_set_current_dir(dialog,bfwin->session->opendir);
< 			else if (bfwin->project && bfwin->project->basedir) file_chooser_set_current_dir(dialog, bfwin->project->basedir);
< 			else file_chooser_set_current_dir(dialog, g_get_home_dir());
< 		} else {
< 			DEBUG_MSG("file_chooser_dialog, opendir=%s\n",bfwin->session->opendir);
< 			file_chooser_set_current_dir(dialog,bfwin->session->opendir);
< 		}
< 	}
< #ifdef DEBUG
< 	DEBUG_MSG("file_chooser_dialog, current_folder_uri=%s\n", gtk_file_chooser_get_current_folder_uri(GTK_FILE_CHOOSER(dialog)));
< #endif
< 
< /*	if (bfwin) {
< 		GList *tmplist;
< 		/ *tmplist = g_list_first(bfwin->session->recent_dirs);* /
< 		tmplist = g_list_first(main_v->recent_directories);
< 		DEBUG_MSG("file_chooser_dialog, session dir len=%d\n",g_list_length(bfwin->session->recent_dirs));
< 		while (tmplist) {
< 			GError *error=NULL;
< 			gtk_file_chooser_add_shortcut_folder_uri(GTK_FILE_CHOOSER(dialog),(gchar*)tmplist->data,&error);
< 			DEBUG_MSG("file_chooser_dialog, adding folder %s\n",(gchar*)tmplist->data);
< 			if (error) {
< 				DEBUG_MSG("file_chooser_dialog, ERROR adding dir %s: %s\n", (gchar*)tmplist->data, error->message);
< 				g_error_free(error);
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}*/
< 
< 	if (action == GTK_FILE_CHOOSER_ACTION_OPEN || action == GTK_FILE_CHOOSER_ACTION_SAVE){
< 		GList *tmplist;
< 		GtkFileFilter* ff;
< 		ff = gtk_file_filter_new();
< 		gtk_file_filter_set_name(ff,_("All files"));
< 		gtk_file_filter_add_pattern(ff, "*");
< 		gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), ff);
< 		if (filter == NULL)	gtk_file_chooser_set_filter(GTK_FILE_CHOOSER(dialog), ff);
< 		tmplist = g_list_first(main_v->filetypelist);
< 		while (tmplist) {
< 			gchar **tmp;
< 			Tfiletype *ft = (Tfiletype *)tmplist->data;
< 			if ((strcmp(ft->type, "objectfile") != 0) && ft->extensions && *ft->extensions) {
< 				ff = gtk_file_filter_new();
< 				gtk_file_filter_set_name(ff,ft->type);
< 				DEBUG_MSG("file_chooser_dialog, adding filter '%s'\n", ft->type);
< 				tmp = ft->extensions;
< 				while (*tmp) {
< 					gchar *pattern;
< 					pattern = g_strconcat("*", *tmp, NULL);
< 					gtk_file_filter_add_pattern(ff, pattern);
< 					DEBUG_MSG("file_chooser_dialog, adding pattern '%s' to '%s'\n", pattern, ft->type);
< 					g_free(pattern);
< 					tmp++;
< 				}
< 				gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), ff);
< 				if (filter && strcmp(filter, ft->type) == 0)	gtk_file_chooser_set_filter (GTK_FILE_CHOOSER (dialog), ff);
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 
< 	return dialog;
< }
< 
< #else
< typedef struct {
< 	gboolean select_dir;
< 	gint multipleselect;
< 	gchar *filename_to_return;
< 	GList *filenames_to_return;
< 	GtkWidget *fs;
< } Tfileselect;
< 
< static void fs_ok_clicked_lcb(GtkWidget * widget, Tfileselect *fileselect)
< {
< 	gchar *dirname, *selected_file;
< 
< 	selected_file = get_utf8filename_from_on_disk_encoding(gtk_file_selection_get_filename(GTK_FILE_SELECTION(fileselect->fs)));
< 
< 	if (g_file_test(selected_file, G_FILE_TEST_IS_DIR)) {
< 		DEBUG_MSG("fs_ok_clicked_lcb,file_is_dir said %s is a dir!!!!\n", selected_file);
< 		if (fileselect->select_dir) {
< 			fileselect->filename_to_return = g_path_get_dirname(selected_file);
< 			g_free(selected_file);
< 			gtk_main_quit();
< 			window_destroy(GTK_WIDGET(fileselect->fs));
< 			return;
< 		} else {
< 			dirname = ending_slash(selected_file);
< 			gtk_file_selection_set_filename(GTK_FILE_SELECTION(fileselect->fs), dirname);
< 			gtk_entry_set_text(GTK_ENTRY(GTK_FILE_SELECTION(fileselect->fs)->selection_entry), "");
< 			g_free(dirname);
< 			g_free(selected_file);
< 			return;
< 		}
< 	} else {
< 		DEBUG_MSG("fs_ok_clicked_lcb,file_is_dir said %s is NOT a dir.\n", selected_file);
< 	}
< 
< 	if (fileselect->multipleselect) {
< 		gchar **filenames, **orig;
< 		/* multiple files allowed --> scan trough the list for selections */
< 		orig = filenames = gtk_file_selection_get_selections(GTK_FILE_SELECTION(fileselect->fs));
< 		if (filenames) {
< 			while (*filenames) {
< 				fileselect->filenames_to_return = g_list_append(fileselect->filenames_to_return, get_utf8filename_from_on_disk_encoding(*filenames));
< 				filenames++;
< 			}
< 			g_strfreev(orig);
< 		}
< 	} else {
< 		/* NO multiple files allowed --> return just one file */
< 		if (fileselect->select_dir) {
< 			fileselect->filename_to_return = g_path_get_dirname(selected_file);
< 		} else {
< 				fileselect->filename_to_return = g_strdup(selected_file);
< 		}
< 	}
< 	if ((fileselect->multipleselect 
< 			&& (g_list_length(fileselect->filenames_to_return) < 1)) 
< 		|| (!fileselect->multipleselect 
< 			&& strlen(fileselect->filename_to_return) < 1)){
< /*		statusbar_message(_("No file to insert."), 2000);*/
< 	}
< 	
< 	g_free(selected_file);	
< 	gtk_main_quit();
< 	window_destroy(GTK_WIDGET(fileselect->fs));
< }
< 
< void close_modal_window_lcb(GtkWidget * widget, gpointer window)
< {
< 	DEBUG_MSG("close_modal_window_lcb, widget=%p, window=%p\n", widget, window);
< 	gtk_main_quit();
< 	window_destroy(window);
< }
< 
< static void fs_history_pulldown_activate_lcb(GtkWidget *menuitem,Tfileselect *fileselect) {
< 	const gchar *filename = gtk_entry_get_text(GTK_ENTRY(GTK_FILE_SELECTION(fileselect->fs)->selection_entry));
< 	gchar *dirname = ending_slash(gtk_label_get_text(GTK_LABEL(gtk_bin_get_child(GTK_BIN(menuitem)))));
< 	gchar *fullpath = g_strconcat(dirname, filename, NULL);
< 	g_free(dirname);
< 	gtk_file_selection_set_filename(GTK_FILE_SELECTION(fileselect->fs), fullpath);
< 	g_free(fullpath);
< }
< 
< static void fs_history_pulldown_changed(GtkOptionMenu *optionmenu,Tfileselect *fileselect) {
< 	GtkWidget *menuitem, *menu;
< 	GList *tmplist;
< 	DEBUG_MSG("fs_history_pulldown_changed\n");
< 	menu = gtk_option_menu_get_menu(GTK_OPTION_MENU(optionmenu));
< 	tmplist = g_list_first(main_v->recent_directories);
< 	while (tmplist) {
< 		menuitem = gtk_menu_item_new_with_label((gchar *)tmplist->data);
< 		g_signal_connect(G_OBJECT(menuitem),"activate",G_CALLBACK(fs_history_pulldown_activate_lcb),fileselect);
< 		gtk_widget_show(menuitem);
< 		gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< static void fileselectwin(gchar *setfile, Tfileselect *fileselect, gchar *title) {
< 
< 	fileselect->fs = gtk_file_selection_new(title);
< 	DEBUG_MSG("fileselectwin, started, fileselect->fs=%p\n", fileselect->fs);		
< 	gtk_file_selection_show_fileop_buttons(GTK_FILE_SELECTION(fileselect->fs));
< 	/*gtk_file_selection_hide_fileop_buttons(GTK_FILE_SELECTION(fileselect->fs));*/
< 	g_signal_connect(G_OBJECT(fileselect->fs), "destroy", G_CALLBACK(close_modal_window_lcb), fileselect->fs);
< 	g_signal_connect(G_OBJECT(GTK_FILE_SELECTION(fileselect->fs)->cancel_button),
< 					   "clicked", G_CALLBACK(close_modal_window_lcb), fileselect->fs);
< 	g_signal_connect(G_OBJECT(GTK_FILE_SELECTION(fileselect->fs)->ok_button), "clicked", G_CALLBACK(fs_ok_clicked_lcb), fileselect);
< 	g_signal_connect(G_OBJECT(GTK_FILE_SELECTION(fileselect->fs)->history_pulldown), "changed", G_CALLBACK(fs_history_pulldown_changed), fileselect);
< 
< 	if (fileselect->multipleselect) {
< 		gtk_file_selection_set_select_multiple(GTK_FILE_SELECTION(fileselect->fs), TRUE);
< 	}
< 	if (setfile) {
< 		gtk_file_selection_set_filename(GTK_FILE_SELECTION(fileselect->fs), setfile);
< 	}
< 	gtk_window_set_role(GTK_WINDOW(fileselect->fs), "fileselect");
< 
< 	gtk_widget_show(fileselect->fs);
< /*	gtk_grab_add(GTK_WIDGET(fileselect->fs));*/
< 	gtk_widget_realize(GTK_WIDGET(fileselect->fs));
< 	if (setfile) {
< 		/* this only has effect after the widget is shown */
< 		gtk_editable_select_region(GTK_EDITABLE(GTK_FILE_SELECTION(fileselect->fs)->selection_entry),0,-1);
< 	}
< 	
< 	/* When you closed the the file selector dialog focus always returned to the bluefish main window
< 	   changed to use gtk_widget_get_parent so focus returns to the dialog that opened the file selector
< 	*/
< 	DEBUG_MSG("gtk_widget_fet_parent returns %p\n",gtk_widget_get_parent(fileselect->fs));
< 	{
< 		GtkWidget *parent = gtk_widget_get_parent(fileselect->fs);
< 		if (parent) {
< 			gtk_window_set_transient_for(GTK_WINDOW(fileselect->fs), GTK_WINDOW(parent));
< 		}
< 	}
< }
< /**
<  * return_file_w_title:
<  * @setfile: #gchar* the file to intitially set the dialog with
<  * @title: #gchar* with the dialog title
<  *
<  * makes a modal dialog with title that will return a file
<  *
<  * Return value: #gchar* with the selected filename
<  */
< gchar *return_file_w_title(gchar * setfile, gchar *title) {
< 	Tfileselect fileselect={FALSE, 0, NULL, NULL, NULL};
< 
< 	fileselectwin(setfile, &fileselect, title);
< 	gtk_main();
< 	return fileselect.filename_to_return;
< }
< /**
<  * return_file:
<  * @setfile: #gchar* the file to intitially set the dialog with
<  *
<  * makes a modal dialog that will return a file
<  *
<  * Return value: #gchar* with the selected filename
<  */
< gchar *return_file(gchar * setfile) {
< 	return return_file_w_title(setfile, _("Select file"));
< }
< /**
<  * return_files_w_title:
<  * @setfile: #gchar* the file to intitially set the dialog with
<  * @title: #gchar* with the dialog title
<  *
<  * makes a modal dialog that will return multiple files
<  *
<  * Return value: #GList* containing a stringlist with all selected files
<  */
< GList *return_files_w_title(gchar * setfile, gchar *title) {
< 	Tfileselect fileselect={FALSE, 1, NULL, NULL, NULL};
< 	
< 	fileselectwin(setfile, &fileselect, title);
< 	gtk_main();
< 	return fileselect.filenames_to_return;
< }
< /**
<  * return_files:
<  * @setfile: #gchar* the file to intitially set the dialog with
<  *
<  * makes a modal dialog that will return multiple files
<  *
<  * Return value: #GList* containing a stringlist with all selected files
<  */
< GList *return_files(gchar * setfile) {
< 	return return_files_w_title(setfile, _("Select files"));
< }
< /**
<  * return_dir:
<  * @setdir: #gchar* the dir to intitially set the dialog with
<  * @title: #gchar* with the dialog title
<  *
<  * makes a modal dialog that will return a directory
<  *
<  * Return value: #gchar* with the selected directory
<  */
< gchar *return_dir(gchar *setdir, gchar *title) {
< 	Tfileselect fileselect={TRUE, 0, NULL, NULL, NULL};
< 
< 	fileselectwin(setdir, &fileselect, title);
< 	gtk_main();
< 	return fileselect.filename_to_return;
< }
< #endif /* HAVE_ATLEAST_GTK_2_4 */
< 
< /************************************************************************/
< 
< static void ungroupradoiitems(GtkWidget *menu) {
< 	GList *tmplist = g_list_first(GTK_MENU_SHELL(menu)->children);
< 	while (tmplist) {
< 		GtkWidget *sub;
< 		DEBUG_MSG("ungroupradiomenuitems, another item\n");
< 		if (GTK_IS_RADIO_MENU_ITEM(tmplist->data)) {
< 			DEBUG_MSG("%p is a radiomenu item, ungrouped!\n",tmplist->data);
< 			gtk_radio_menu_item_set_group(tmplist->data,NULL);
< 		}
< 		sub = gtk_menu_item_get_submenu(tmplist->data);
< 		if (sub) ungroupradoiitems(sub);
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< void destroy_disposable_menu_cb(GtkWidget *widget, GtkWidget *menu) {
< 	ungroupradoiitems(menu);
< 	gtk_widget_destroy(GTK_WIDGET(menu));
< }
< 
< 
< /***********************************************************************
<  * workarounds for gtk-2.0  
<  * these functions are not needed with gtk-2.2
<  */
< #ifndef HAVE_ATLEAST_GTK_2_2
< static GtkTreePath *gtktreepath_up_multi(GtkTreePath *path, gint num) {
< 	while (num > 0) {
< 		gtk_tree_path_up(path);
< 		num--;
< 	}
< 	return path;
< }
< 
< void gtktreepath_expand_to_root(GtkWidget *tree, const GtkTreePath *this_path) {
< 	gint num = gtk_tree_path_get_depth((GtkTreePath *)this_path);
< 	while (num >= 0) {
< 		GtkTreePath *path = gtk_tree_path_copy(this_path);
< 		path = gtktreepath_up_multi(path, num);
< /*		g_signal_handlers_block_matched(G_OBJECT(tree), G_SIGNAL_MATCH_FUNC,
< 					0, 0, NULL, row_expanded_lcb, NULL);*/
< 		gtk_tree_view_expand_row(GTK_TREE_VIEW(tree), path, FALSE);
< /*		g_signal_handlers_unblock_matched(G_OBJECT(tree), G_SIGNAL_MATCH_FUNC,
< 					0, 0, NULL, row_expanded_lcb, NULL);*/
< 		gtk_tree_path_free(path);
< 		num--;
< 	}
< }
< #endif /* ifndef HAVE_ATLEAST_GTK_2_2 */
< 
< /*****************************************
<  * workaround for gnome-vfs-2.0
<  * this is copied from gnome-vfs-utils.c
<  * Copyright (C) 1999 Free Software Foundation
<  * Copyright (C) 2000, 2001 Eazel, Inc.
<  */
< #ifdef HAVE_GNOME_VFS
< #ifndef HAVE_ATLEAST_GNOMEVFS_2_2
< #define READ_CHUNK_SIZE 8192
< GnomeVFSResult gnome_vfs_read_entire_file (const char *uri,int *file_size,char **file_contents){
< 	GnomeVFSResult result;
< 	GnomeVFSHandle *handle;
< 	char *buffer;
< 	GnomeVFSFileSize total_bytes_read;
< 	GnomeVFSFileSize bytes_read;
< 	*file_size = 0;
< 	*file_contents = NULL;
< 	result = gnome_vfs_open (&handle, uri, GNOME_VFS_OPEN_READ);
< 	if (result != GNOME_VFS_OK) {
< 		return result;
< 	}
< 	buffer = NULL;
< 	total_bytes_read = 0;
< 	do {
< 		buffer = g_realloc (buffer, total_bytes_read + READ_CHUNK_SIZE);
< 		result = gnome_vfs_read (handle,buffer + total_bytes_read,READ_CHUNK_SIZE,&bytes_read);
< 		if (result != GNOME_VFS_OK && result != GNOME_VFS_ERROR_EOF) {
< 			g_free (buffer);
< 			gnome_vfs_close (handle);
< 			return result;
< 		}
< 		if (total_bytes_read + bytes_read < total_bytes_read) {
< 			g_free (buffer);
< 			gnome_vfs_close (handle);
< 			return GNOME_VFS_ERROR_TOO_BIG;
< 		}
< 		total_bytes_read += bytes_read;
< 	} while (result == GNOME_VFS_OK);
< 	result = gnome_vfs_close (handle);
< 	if (result != GNOME_VFS_OK) {
< 		g_free (buffer);
< 		return result;
< 	}
< 	*file_size = total_bytes_read;
< 	*file_contents = g_realloc (buffer, total_bytes_read);
< 	return GNOME_VFS_OK;
< }			    
< #endif /* ifndef HAVE_ATLEAST_GNOMEVFS_2_2 */
< #endif /* HAVE_GNOME_VFS */
---
> /* Bluefish HTML Editor
>  * gtk_easy.c
>  *
>  * Copyright (C) 1999-2006 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> /* #define DEBUG */
> 
> #include <gtk/gtk.h>
> #include <gdk/gdkkeysyms.h>    /* GDK_Return */
> #include <stdlib.h>            /* strtod() */
> #include <string.h>            /* strlen() */
> 
> #include "bluefish.h"
> #include "gtk_easy.h"
> #include "bf_lib.h"
> #include "char_table.h"    /* xml_escape() */
> #include "gui.h"           /* statusbar_message() */
> #include "pixmap.h"
> 
> #ifdef WIN32
> #define DIRSTR "\\"
> #define DIRCHR 92
> #else
> #define DIRSTR "/"
> #define DIRCHR '/'
> #endif
> 
> /**
>  * flush_queue:
>  * 
>  * handles the gtk and gdk queue
>  * 
>  * Return value: void
>  **/
> void flush_queue(void) {
> 	while(g_main_context_pending(NULL)) {
> 		g_main_context_iteration (NULL, TRUE);
> 	}
> }
> /**
>  * widget_get_string_size:
>  * @widget: #GtkWidget* to put the string on
>  * @string: #ghcar* with the string
>  *
>  * This function will calculate the width in pixels from the
>  * string passed to it in string, using the font from widget
>  *
>  * Return value: #gint pixels
>  */
> gint widget_get_string_size(GtkWidget *widget, gchar *string) {
> 	PangoLayout *layout;
> 	gint retval = -1;
> 	layout = gtk_widget_create_pango_layout(widget,string);
> 	if (layout != NULL) {
> 		pango_layout_get_pixel_size(layout, &retval, NULL);
> 		g_object_unref(G_OBJECT (layout));
> 	}
> 	return retval;
> }
> 
> void widget_set_visible(GtkWidget *widget, gboolean visible) {
> 	if (visible) {
> 		gtk_widget_show(widget);
> 	} else {
> 		gtk_widget_hide(widget);	
> 	}
> }
> 
> /**
>  * window_destroy:
>  * @windowname: a #GtkWidget pointer to the window
>  * 
>  * Remove grab and signals and then destroy window
>  * 
>  * Return value: void
>  **/
> void window_destroy(GtkWidget * windowname) {
> 	DEBUG_MSG("window_destroy, windowname=%p, first the signal handlers\n", windowname);
> 	g_signal_handlers_destroy(G_OBJECT(windowname));
> 	DEBUG_MSG("window_destroy, then remove the grab\n");
> 	gtk_grab_remove(windowname);
> 	DEBUG_MSG("window_destroy, then destroy the widget\n");
> 	gtk_widget_destroy(windowname);
> 	DEBUG_MSG("window_destroy, done\n");
> }
> 
> /**
>  * window_close_by_widget_cb:
>  * 	@widget: #GtkWidget the parent window of this widget will be destroyed
>  * 	@data: gpointer, ignored
>  *
>  * 	destroy the toplevel window for widget
>  *
>  * Return value: void
>  */
> void window_close_by_widget_cb(GtkWidget * widget, gpointer data) {
> 	DEBUG_MSG("window_close_by_widget_cb, widget=%p\n", widget);
> 	window_destroy(gtk_widget_get_toplevel(widget));
> }
> 
> /**
>  * window_close_by_data_cb:
>  * 	@widget: #GtkWidget, ignored
>  * 	@data: #gpointer to a gtk-window which will be detroyed
>  *
>  * 	destroy a window using the gpointer data
>  *
>  * Return value: void
>  */
> void window_close_by_data_cb(GtkWidget * widget, gpointer data) {
> 	DEBUG_MSG("window_close_by_data_cb, data=%p\n", data);
> 	window_destroy(GTK_WIDGET(data));
> }
> 
> /**
>  * setup_toggle_item:
>  * 	@ifactory: #GtkItemFactory * the itemfactory where the toggle item is in defined
>  * 	@path: #gchar * the path in the itemfactory to find the toggle item
>  * 	@state: #gint the state to put it in (0 or 1)
>  * 
>  * 	change the setting of a toggle item in a menu to state
>  *
>  * Return value: void
>  */
> void setup_toggle_item(GtkItemFactory * ifactory, gchar * path, gint state) {
> 	GtkWidget *toggle;
> 	toggle = gtk_item_factory_get_widget(ifactory, path);
> 	if (!toggle) {
> 		g_print("warning, menuitem \"%s\" does NOT exist! check the translation!\n", path);
> 		return;
> 	}
> 	DEBUG_MSG("setting path %s to %d\n",path,state);
> 	if ((GTK_CHECK_MENU_ITEM(toggle)->active) && state == 0) {
> 		GTK_CHECK_MENU_ITEM(toggle)->active = state;
> 		return;
> 	}
> 	if ((!GTK_CHECK_MENU_ITEM(toggle)->active) && state == 1) {
> 		GTK_CHECK_MENU_ITEM(toggle)->active = state;
> 		return;
> 	}
> }
> 
> /**
>  * string_apply:
>  * @config_var: # gchar **, a pointer to a gchar pointer with where the content should be placed
>  * 	@entry: the entry #GtkWidget * to read
>  *
>  * 	free the old string in **config_var, and replaces it with the new string from entry
>  *
>  * Return value:	void
>  */
> void string_apply(gchar ** config_var, GtkWidget * entry)
> {
> 	gchar *tmpstring;
> 	DEBUG_MSG("string_apply, start\n");
> 
> 	tmpstring = gtk_editable_get_chars(GTK_EDITABLE(entry), 0, -1);
> 	DEBUG_MSG("string_apply, tmpstring(%p)=%s\n", tmpstring, tmpstring);
> 	if (tmpstring) {
> 		if (config_var != NULL) {
> 			g_free(*config_var);
> 		}
> 		*config_var = tmpstring;
> 	}
> #ifdef DEBUG
> 	else {
> 		DEBUG_MSG("string_apply, ***** tmpstring == NULL *****\n");
> 	}
> #endif
> }
> /**
>  * string_apply:
>  * @config_var: #gint*, a pointer to a gint with where the content should be placed
>  * 	@entry: the spinbutton or checkbox #GtkWidget * to read
>  * @is_checkbox: a gboolean, TRUE if entry is a checkbox
>  *
>  * 	sets the content from the widget to the variable pointed to by the config_var pointer
>  *
>  * Return value: void
>  */
> void integer_apply(gint *config_var, GtkWidget * widget, gboolean is_checkbox) {
> 	if (is_checkbox) {
> 		*config_var = (GTK_TOGGLE_BUTTON(widget)->active);
> 	} else {
> 		*config_var = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(widget));
> 	}
> 	DEBUG_MSG("integer_apply, config_var(%p)=%i\n", config_var, *config_var);
> }
> /**
>  * combo_with_popdown:
>  * 	@setstring: #gchar* to set in textbox, if NULL it will be set ""
>  * 	@which_list: #GList* to set in popdown widget
>  * 	@editable: #gint if the combo should be editable (1 or 0)
>  *
>  * 	Create new combo and preset some values
>  *
>  * Return value: #GtkWidget* pointer to created combo
>  */
> GtkWidget *combo_with_popdown(const gchar * setstring, GList * which_list, gint editable) {
> 	GtkWidget *returnwidget;
> 
> 	returnwidget = gtk_combo_new();
> 	gtk_combo_set_case_sensitive(GTK_COMBO(returnwidget),TRUE);
> 	if (which_list != NULL) {
> 		gtk_combo_set_popdown_strings(GTK_COMBO(returnwidget), which_list);
> 	}
> 	if (setstring != NULL) {
> 		gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(returnwidget)->entry), setstring);
> 	} else {
> 		gtk_entry_set_text(GTK_ENTRY(GTK_COMBO(returnwidget)->entry), "");
> 	}
> 	if (editable == 0) {
> 		gtk_editable_set_editable(GTK_EDITABLE(GTK_ENTRY(GTK_COMBO(returnwidget)->entry)), FALSE);
> 	}
> 	gtk_combo_disable_activate(GTK_COMBO(returnwidget));
> 	gtk_entry_set_activates_default (GTK_ENTRY (GTK_COMBO (returnwidget)->entry), TRUE);
> 	return returnwidget;
> }
> /**
>  * boxed_combo_with_popdown:
>  * 	@setstring: #gchar* to set in textbox, if NULL it will be set ""
>  * 	@which_list: #GList* to set in popdown widget
>  * 	@editable: #gint if the combo should be editable (1 or 0)
>  * @box: the #GtkWidget* box widget to add the combo to
>  *
>  * 	create a new combo with presets like in combo_with_popdown()
>  * and add it to the box
>  *
>  * Return value: #GtkWidget* pointer to created combo
>  */
> GtkWidget *boxed_combo_with_popdown(const gchar * setstring, GList * which_list, gint editable, GtkWidget *box) {
> 	GtkWidget *returnwidget;
> 	
> 	returnwidget = combo_with_popdown(setstring, which_list, editable);
> 	gtk_box_pack_start(GTK_BOX(box), returnwidget, TRUE, TRUE, 3);
> 	return returnwidget;
> }
> /**
>  * combo_with_popdown_sized:
>  * 	@setstring: #gchar* to set in textbox, if NULL it will be set ""
>  * 	@which_list: #GList* to set in popdown widget
>  * 	@editable: #gint if the combo should be editable (1 or 0)
>  * @width: #gint with the width in pixels the widget should be
>  *
>  * 	Create new combo and preset some values, with a horizontal size
>  *
>  * Return value: #GtkWidget* pointer to created combo
>  */
> GtkWidget *combo_with_popdown_sized(const gchar * setstring, GList * which_list, gint editable, gint width) {
> 	GtkWidget *returnwidget;
> 	
> 	returnwidget = combo_with_popdown(setstring, which_list, editable);
> 	gtk_widget_set_size_request(returnwidget, width , -1);
> 	return returnwidget;
> }
> 
> /**
>  * entry_with_text:
>  * 	@setstring: #const gchar* if not NULL set this text
>  * 	@max_lenght: #gint max. characters in the entry
>  *
>  * 	Create new entry with some preset values
>  *
>  * Return value: #GtkWidget* pointer to the new entry widget
>  */
> GtkWidget *entry_with_text(const gchar * setstring, gint max_lenght) {
> 	GtkWidget *returnwidget;
> 
> 	if (max_lenght) {
> 		returnwidget = gtk_entry_new_with_max_length(max_lenght);
> 	} else {
> 		returnwidget = gtk_entry_new();
> 	}
> 	if (setstring) {
> 		gtk_entry_set_text(GTK_ENTRY(returnwidget), setstring);
> 	}
> 	gtk_entry_set_activates_default(GTK_ENTRY(returnwidget), TRUE);
> 	return returnwidget;
> }
> /**
>  * boxed_entry_with_text:
>  * 	@setstring: #const gchar* if not NULL set this text
>  * 	@max_lenght: #gint max. characters in the entry
>  * @box: the #GtkWidget* box widget to add the entry to
>  *
>  * 	Create new entry with some preset values, and add it to a box
>  *
>  * Return value: #GtkWidget* pointer to the new entry widget
>  */
> GtkWidget *boxed_entry_with_text(const gchar * setstring, gint max_lenght, GtkWidget *box) {
> 	GtkWidget *returnwidget;
> 	
> 	returnwidget = entry_with_text(setstring, max_lenght);
> 	gtk_box_pack_start(GTK_BOX(box), returnwidget, TRUE, TRUE, 0);
> 	return returnwidget;
> 
> }
> /**
>  * boxed_full_entry:
>  * @labeltest: #const gchar * with the text for the label
>  * 	@setstring: #const gchar* if not NULL set this text
>  * 	@max_lenght: #gint max. characters in the entry
>  * @box: the #GtkWidget* box widget to add the entry to
>  *
>  * 	Create new entry with some preset values, and add together 
>  * with a label to a hbox, and add that hbox to
>  * the box pointer
>  *
>  * Return value: #GtkWidget* pointer to the new entry widget
>  */
> GtkWidget *boxed_full_entry(const gchar * labeltext, gchar * setstring,gint max_lenght, GtkWidget * box) {
> 	GtkWidget *hbox, *return_widget, *label;
> 
> 	hbox = gtk_hbox_new(FALSE,3);
> 	label = gtk_label_new_with_mnemonic(labeltext);
> 	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 3);
> 	return_widget = boxed_entry_with_text(setstring, max_lenght, hbox);
> 	gtk_label_set_mnemonic_widget(GTK_LABEL(label), return_widget);
> 	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 3);
> 
> 	return return_widget;
> }
> /**
>  * checkbut_with_value:
>  * @labeltest: #const gchar * with the text for the label
>  * 	@which_config_int: #gint whether or not to set the checkbutton active
>  *
>  * 	Create new checkbutton with some value
>  *
>  * Return value: #GtkWidget* pointer to the new checkbutton widget
>  */
> GtkWidget *checkbut_with_value(gchar *labeltext, gint which_config_int) {
> 	GtkWidget *returnwidget;
> 
> 	returnwidget = gtk_check_button_new_with_mnemonic(labeltext);
> 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(returnwidget), which_config_int);
> 	return returnwidget;
> }
> /**
>  * boxed_checkbut_with_value:
>  * @labeltest: #const gchar * with the text for the label
>  * 	@which_config_int: #gint whether or not to set the checkbutton active
>  * @box: the #GtkWidget* box widget to add the entry to
>  *
>  * 	Create new checkbutton with some value, and add it to box
>  *
>  * Return value: #GtkWidget* pointer to the new checkbutton widget
>  */
> GtkWidget *boxed_checkbut_with_value(gchar *labeltext, gint which_config_int, GtkWidget * box) {
> 	GtkWidget *returnwidget;
> 
> 	returnwidget = checkbut_with_value(labeltext, which_config_int);
> 	gtk_box_pack_start(GTK_BOX(box), returnwidget, FALSE, FALSE, 3);
> 	return returnwidget;
> }
> /**
>  * radiobut_with_value:
>  * @labeltest: #const gchar * with the text for the label
>  * 	@enabled: #gint if the radiobutton is enabled or not
>  * @prevbut: #GtkRadioButton* pointer to the first button or NULL if none
>  *
>  * 	Create new radiobutton with some value, and if there is a first button 
>  * for this group, add this button to that group
>  *
>  * Return value: #GtkWidget* pointer to the new radiobutton widget
>  */
> GtkWidget *radiobut_with_value(gchar *labeltext, gint enabled, GtkRadioButton *prevbut) {
> 	GtkWidget *returnwidget;
> 	GSList *group=NULL;
> 
> 	if (prevbut) {
> 		group = gtk_radio_button_group(prevbut);
> 	}	
> 	returnwidget = gtk_radio_button_new_with_mnemonic(group, labeltext);
> 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(returnwidget), enabled);
> 	return returnwidget;
> }
> /**
>  * boxed_radiobut_with_value:
>  * @labeltest: #const gchar * with the text for the label
>  * 	@enabled: #gint if the radiobutton is enabled or not
>  * @prevbut: #GtkRadioButton* pointer to the first button or NULL if none
>  * @box: the #GtkWidget* box widget to add the entry to
>  *
>  * 	Create new radiobutton with some value, and if there is a first button 
>  * for this group, add this button to that group, and this button to box
>  *
>  * Return value: #GtkWidget* pointer to the new radiobutton widget
>  */
> GtkWidget *boxed_radiobut_with_value(gchar *labeltext, gint enabled, GtkRadioButton *prevbut, GtkWidget *box) {
> 	GtkWidget *returnwidget;
> 
> 	returnwidget = radiobut_with_value(labeltext, enabled, prevbut);
> 	gtk_box_pack_start(GTK_BOX(box), returnwidget, FALSE, FALSE, 0);
> 	return returnwidget;
> }
> 
> static gint is_int(gfloat testval) {
> 	DEBUG_MSG("is_int, (int)testval=%d\n", (int)testval);
> 	if ((gfloat)(((int) testval) - ((gfloat) testval )) == 0) {
> 		DEBUG_MSG("is_int, %f int!\n", testval);
> 		return 1;
> 	} else {
> 		DEBUG_MSG("is_int, %f float!\n", testval);
> 		return 0;
> 	}
> }
> 
> /**
>  * spinbut_with_value:
>  * @value: #const gchar * with the value as string for the spinbut
>  * 	@lower: a #gfloat with the lower value for the range
>  * @upper: a #gfloat with the upper value for the range
>  * @step_increment: a #gfloat with the stepsize for the spinbutton
>  * @page_increment: a #gfloat with the pagesize (pgup/pgdn) for the spinbutton
>  *
>  * 	Create new spinbutton with the specified value and range
>  *
>  * Return value: #GtkWidget* pointer to the new spinbutton widget
>  */
> GtkWidget *spinbut_with_value(gchar *value, gfloat lower, gfloat upper, gfloat step_increment, gfloat page_increment) {
> 	GtkAdjustment *adj;
> 	GtkWidget *returnwidget;
> 	guint digits;
> 	double fvalue=0;
> 
> 	if (value) {
> 		fvalue = strtod(value, NULL);
> 	}
> 	adj = (GtkAdjustment *) gtk_adjustment_new((gfloat)fvalue, (gfloat)lower, (gfloat)upper, step_increment, page_increment, 0.0);
> 	digits = (is_int(lower) ? 0 : 2);
> 	returnwidget = gtk_spin_button_new(adj, step_increment, digits);
> /*	g_object_set(G_OBJECT(returnwidget), "numeric", TRUE, NULL);*/
> 	gtk_spin_button_set_numeric(GTK_SPIN_BUTTON(returnwidget), FALSE);
> 	gtk_spin_button_set_snap_to_ticks(GTK_SPIN_BUTTON(returnwidget), FALSE);
> /*	gtk_spin_button_set_update_policy(GTK_SPIN_BUTTON(returnwidget), GTK_UPDATE_IF_VALID);*/
> 	if (!value) {
> 		gtk_entry_set_text(GTK_ENTRY(GTK_SPIN_BUTTON(returnwidget)), "");
> 	}
> 	
> 	return returnwidget;
> }
> /* THIS ONE IS NEVERUSED
> GtkWidget *boxed_spinbut_with_value(gchar *value, gfloat lower, gfloat upper, gfloat step_increment, gfloat page_increment, GtkWidget *box) {
> 	GtkWidget *returnwidget;
> 	returnwidget = spinbut_with_value(value, lower, upper, step_increment, page_increment);
> 	gtk_box_pack_start(GTK_BOX(box), returnwidget, FALSE, FALSE, 0);
> 	return returnwidget;
> }
> */
> /**
>  * optionmenu_with_value:
>  * @options: a #gchar** NULL terminated array with option strings
>  * @curval: a #gint with the current selected item
>  *
>  * Create new popupmenu from options, and set the selected index from curval
>  *
>  * Return value: #GtkWidget* pointer to the new menu widget
>  * Created by: RubÃ©n Dorta
>  */
> 
> GtkWidget *optionmenu_with_value(gchar **options, gint curval) {
> 	GtkWidget *returnwidget;
> 	GtkWidget *menu, *menuitem;
> 	gchar **str;
> 
> 	returnwidget = gtk_option_menu_new();
> 	menu = gtk_menu_new();
> 	str = options;
> 
> 	while (*str) {
> 		DEBUG_MSG("prefs_optionmenu, adding %s to optionmenu\n", *str);
> 		menuitem = gtk_menu_item_new_with_label(_(*str));
> 		gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
> 		str++;
> 	}
> 
> 	gtk_option_menu_set_menu(GTK_OPTION_MENU(returnwidget), menu);
> 	gtk_option_menu_set_history(GTK_OPTION_MENU(returnwidget), curval);
> 	return returnwidget;
> }
> 
> /**
>  * boxed_optionmenu_with_value:
>  * @labeltext: a #const gchar* with the text for the label
>  * @curval: a #gint with the current selected item
>  * @box: a #GtkWidget* with the box to add this to
>  * @options: a #gchar** NULL terminated array with option strings
>  *
>  * Create a new horizontal box with a labeltext and a new popupmenu using the options array
>  * setting the selected index from curval
>  *
>  * Return value: #GtkWidget* pointer to the new menu widget
>  * Modified by: RubÃ©n Dorta
>  */
> 
> GtkWidget *boxed_optionmenu_with_value(const gchar *labeltext, gint curval, GtkWidget *box, gchar **options) {
> 	GtkWidget *returnwidget;
> 	GtkWidget *hbox;
> 
> 	hbox = gtk_hbox_new(FALSE,3);
> 	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 3);
> 	gtk_box_pack_start(GTK_BOX(hbox), gtk_label_new(labeltext), FALSE, FALSE, 3);
> 	returnwidget = optionmenu_with_value(options, curval);
> 	gtk_box_pack_start(GTK_BOX(hbox), returnwidget, FALSE, FALSE, 3);
> 	return returnwidget;
> }
> 
> /**
>  * window_with_title:
>  * 	@title: #gchar* the title string
>  * 	@position: the gtk window position
>  * 	@type: the gtk window type
>  *
>  * 	Create new window with title and some more settings
>  *
>  * Return value: #GtkWidget* pointer to created window
>  */
> GtkWidget *window_with_title(const gchar * title, GtkWindowPosition position, gint borderwidth) {
> 	GtkWidget *returnwidget;
> 
> 	returnwidget = gtk_window_new(GTK_WINDOW_TOPLEVEL);
> 	if (title) {
> 		gtk_window_set_title(GTK_WINDOW(returnwidget), title);
> 	}
> 	if (borderwidth) {
> 		gtk_container_set_border_width(GTK_CONTAINER(returnwidget), borderwidth);
> 	}
> 	if (position) {
> 		gtk_window_set_position(GTK_WINDOW(returnwidget), position);
> 	}
> #ifdef DEBUG
> 	 else {
> 		g_print("window_with_title, **NOT** setting position!!\n");
> 	}
> #endif
> 	return returnwidget;
> }
> /* GtkWindowPosition can be 
> GTK_WIN_POS_NONE
> GTK_WIN_POS_CENTER
> GTK_WIN_POS_MOUSE */
> 
> static gboolean window_full_key_press_event_lcb(GtkWidget *widget,GdkEventKey *event,GtkWidget *win) {
> 	DEBUG_MSG("window_full_key_press_event_lcb, started\n");
> 	if (event->keyval == GDK_Escape) {
> 		DEBUG_MSG("window_full_key_press_event_lcb, emit delete_event on %p\n", win);
> /*		g_signal_emit_by_name(G_OBJECT(win), "delete_event");*/
> 		gtk_widget_destroy(win);
> 		DEBUG_MSG("window_full_key_press_event_lcb, DESTROYED %p\n", win);
> 		return TRUE;
> 	}
> 	return FALSE;
> }
> 
> /**
>  * window_full2:
>  * 	@title: #gchar* the title string
>  * 	@position: #gint the gtk window position GTK_WIN_POS_NONE, GTK_WIN_POS_CENTER, GTK_WIN_POS_MOUSE
>  * 	@borderwidth: #gint border width
>  * 	@close_func: #GCallback the callback function when closing the window
>  * 	@close_data: #gpointer data passed to the closefunc, or NULL to pass the widget pointer as close data
>  * @delete_on_escape: #gboolean if the escape key should close the dialog
>  * @transientforparent: #GtkWidget* with the window to set this transient for, or NULL
>  *
>  * Create new window with title, callback functions, some more settings
>  * and if needed set a callback so the window will be closed on escape press
>  * and set it if needed transient for another window
>  *
>  * the close_func should have the form 
>  * void close_func(GtkObject *object,gpointer user_data);
>  *
>  * Return value: #GtkWidget* pointer to created window
>  */
> GtkWidget *window_full2(const gchar * title, GtkWindowPosition position
> 			, gint borderwidth, GCallback close_func
> 			, gpointer close_data
> 			, gboolean delete_on_escape,
> 			GtkWidget *transientforparent)
> {
> 
> 	GtkWidget *returnwidget;
> 
> 	returnwidget = window_with_title(title, position, borderwidth);
> /*	g_signal_connect(G_OBJECT(returnwidget), "delete_event", close_func, close_data);*/
> 	/* use "destroy" and not "destroy_event", 'cause that doesn't work */
> 	if (close_data == NULL) close_data = returnwidget;
> 	g_signal_connect(G_OBJECT(returnwidget), "destroy", close_func, close_data);
> 	DEBUG_MSG("window_full, close_data=%p\n",close_data);
> 	if (transientforparent) {
> 		gtk_window_set_transient_for(GTK_WINDOW(returnwidget), GTK_WINDOW(transientforparent));
> 	}
> 	if (delete_on_escape) {
> 		g_signal_connect(G_OBJECT(returnwidget), "key_press_event", G_CALLBACK(window_full_key_press_event_lcb), returnwidget);
> 		/* for these windows it is also convenient if they destroy when their parent is destroyed */
> 		gtk_window_set_destroy_with_parent(GTK_WINDOW(returnwidget), TRUE);
> 	}
> 	DEBUG_MSG("window_full, return %p\n", returnwidget);
> 	return returnwidget;
> }
> /**
>  * textview_buffer_in_scrolwin:
>  * 	@textview: #GtkWidget** will be filled with the textview widget pointer
>  * 	@width: #gint the width of the scrolwin, -1 if default required
>  * 	@height: #gint the height of the scrolwin, -1 if default required
>  * 	@contents: #gchar* the initial contents of the textbox
>  * 	@wrapmode: #GtkWrapMode the wrapmode for the TextView GTK_WRAP_NONE,GTK_WRAP_CHAR,GTK_WRAP_WORD
>  *
>  * creates a textbuffer, a textview widget (stored in the textview pointer), 
>  * puts that inside a scrolwin, adds the content and sets the size and returns
>  * the scrolwin
>  *
>  * Return value: #GtkWidget* to the scolwin
>  */
> GtkWidget *textview_buffer_in_scrolwin(GtkWidget **textview, gint width, gint height, const gchar *contents, GtkWrapMode wrapmode) {
> 	GtkWidget *scrolwin;
> 	GtkTextBuffer *textbuf;
> 	
> 	textbuf = gtk_text_buffer_new(NULL);
> 	*textview = gtk_text_view_new_with_buffer(textbuf);
> 	gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(*textview), wrapmode);
> 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
> 	gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolwin), GTK_SHADOW_IN);
> 	gtk_container_add (GTK_CONTAINER (scrolwin), *textview);
> 	gtk_widget_set_size_request(scrolwin, width, height);
> 	if (contents) {
> 		gtk_text_buffer_set_text(textbuf, contents, -1);
> 	}
> 	return scrolwin;
> }
> 
> /**
>  * apply_font_style:
>  * 	@this_widget: #GtkWidget* the widget to apply the new fontstyle
>  * 	@fontstring: #gchar* the fontset which will be loaded
>  *
>  * 	Change the font of a widget with a certain font from a string
>  *
>  * Return value: #GtkWidget* to this_widget
>  */
> GtkWidget *apply_font_style(GtkWidget * this_widget, gchar * fontstring) {
> 	if (fontstring) {
> 		PangoFontDescription *font_desc;
> 		font_desc = pango_font_description_from_string(fontstring);
> 		gtk_widget_modify_font(this_widget, font_desc);
> 		pango_font_description_free(font_desc);
> 	}
> 	return this_widget;
> }
> 
> /**
>  * hbox_with_pix_and_text:
>  * 	@label: #const gchar* with the text
>  * 	@pixmap_type: #gint with a pixmap type known by new_pixmap() from pixmap.h
>  *
>  * constructs a hbox with a pixmap and text. The pixmap type should be known
>  * to the new_pixmap() function from pixmap.c
>  * This function is very useful to create a button with text and a pixmap
>  *
>  * Return value: #GtkWidget* to the hbox
>  */
> GtkWidget *hbox_with_pix_and_text(const gchar *label, gint bf_pixmaptype, gboolean w_mnemonic) {
> 	GtkWidget *hbox = gtk_hbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(hbox), new_pixmap(bf_pixmaptype), FALSE, FALSE, 1);
> 	gtk_box_pack_start(GTK_BOX(hbox), ((w_mnemonic) ? gtk_label_new_with_mnemonic(label) : gtk_label_new(label)), TRUE, TRUE, 1);
> 	gtk_widget_show_all(hbox);
> 	return hbox;
> }
> 
> GtkWidget *bf_allbuttons_backend(const gchar *label, gboolean w_mnemonic, gint bf_pixmaptype, GCallback func, gpointer func_data) {
> 	GtkWidget *button;
> 	if (bf_pixmaptype == -1) {
> 		/* there is no image needed, only text */
> 		if (w_mnemonic) {
> 			button = gtk_button_new_with_mnemonic(label);
> 		} else {
> 			button = gtk_button_new_with_label(label);
> 		}
> 	} else {
> 		/* there is an image needed */
> 		button = gtk_button_new();
> 		if (label) {
> 			/* both a pixmap and text */
> 			gtk_container_set_border_width(GTK_CONTAINER(button), 0);
> 			gtk_container_add(GTK_CONTAINER(button), hbox_with_pix_and_text(label, bf_pixmaptype, w_mnemonic));
> 		} else {
> 			/* only pixmap */
> 			gtk_container_add(GTK_CONTAINER(button), new_pixmap(bf_pixmaptype));
> 		}
> 	}
> 	GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
> 	g_signal_connect(G_OBJECT(button), "clicked", func, func_data);
> 	return button;
> }
> 
> /**
>  * bf_generic_button_with_image:
>  * @label: #const gchar* button string with '_' for the mnemonic, or NULL
>  * @pixmap_type: #gint image to display on button know to new_pixmap() from pixmap.c
>  * @func: #GCallback pointer to signal handler
>  * @func_data: #gpointer data for signal handler
>  *
>  * Create new button with an image and connect the "clicked" signal to func
>  * if the label is NULL there will be only an image in the button
>  *
>  * Return value: #GtkWidget* pointer to created button
>  */
> /* GtkWidget *bf_generic_button_with_image(const gchar *label, gint pixmap_type, GCallback func, gpointer func_data) {
>         GtkWidget *button;
> 
> 	button = gtk_button_new();
> 	gtk_container_set_border_width(GTK_CONTAINER(button), 0);
> 	if (label) {
> 		gtk_container_add(GTK_CONTAINER(button), hbox_with_pix_and_text(label, pixmap_type));
> 	} else {
> 		gtk_container_add(GTK_CONTAINER(button), new_pixmap(pixmap_type));
> 	}
> 	GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
> 	g_return_val_if_fail(button, NULL);
> 	g_signal_connect(G_OBJECT(button), "clicked", func, func_data);
> 	return button;
> } */
> 
> /**
>  * bf_generic_mnemonic_button:
>  * @Text: #const gchar* button string, using '_' for the mnemonic
>  * @func: #GCallback pointer to signal handler
>  * @func_data: #gpointer data for signal handler
>  *
>  * 	Create new button with mnemonic and connect the "clicked" signal to func
>  *
>  * Return value: pointer to created button
>  */
> /* GtkWidget *bf_generic_mnemonic_button(const gchar * Text, GCallback func, gpointer func_data) {
> 	GtkWidget *button;
> 
> 	button = gtk_button_new_with_mnemonic(Text);
> 	g_return_val_if_fail(button, NULL);
> 	GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
> 	g_signal_connect(G_OBJECT(button), "clicked", func, func_data);
> 	DEBUG_MSG("bf_generic_mnemonic_button, func_data=%p\n", func_data);
> 	return button;
> } */
> /**
>  * bf_gtkstock_button:
>  * @stock_id: #const gchar* wioth the GTK stock icon ID
>  * @func: #GCallback pointer to signal handler
>  * @func_data: #gpointer data for signal handler
>  *
>  * Create new button from the GTK stock icons
>  *
>  * Return value: pointer to created button
>  */
> GtkWidget *bf_gtkstock_button(const gchar * stock_id, GCallback func, gpointer func_data) {
> 	GtkWidget *button = gtk_button_new_from_stock(stock_id);
> 	GTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);
> 	g_signal_connect(G_OBJECT(button), "clicked", func, func_data);
> 	return button;
> }
> 
> /**
>  * bf_generic_frame_new:
>  * @label: #const gchar* label string. Set to NULL for no label
>  * @shadowtype: #GtkShadowType  border type
>  * @borderwidth: #gint outside border width
>  *
>  * create a generic frame with shadow type and border
>  *
>  * Return value: #GtkWidget* pointer to created frame
>  */
> GtkWidget *bf_generic_frame_new(const gchar *label, GtkShadowType shadowtype, gint borderwidth) {
>   GtkWidget *frame;
> 
>   frame = gtk_frame_new(label);
>   gtk_frame_set_shadow_type(GTK_FRAME(frame), shadowtype);
>   gtk_container_set_border_width(GTK_CONTAINER(frame), borderwidth);
>   
>   return frame;
> }
> 
> /**
>  * bf_mnemonic_label_tad_with_alignment:
>  * @labeltext: #const gchar* label string
>  * @m_widget: #GtkWidget* widget accessed by the label mnemonic
>  * @xalign: #gfloat label horizontal alignment
>  * @yalign: #gfloat label vertical alignment
>  * @table: #GtkWidget table label is packed into
>  * @left_attach: #gint column number to attach the left side of the label to
>  * @right_atach: #gint: column number to attach the right side of a label to
>  * @top_attach: #gint: row number to attach the top of a label to
>  * @bottom_attach: #gint: row number to attach the bottom of a label to 	
>  *
>  * 	create a label with a mnemonic, align it, and attach it to a table
>  *
>  * Return value: void
>  */
> void bf_mnemonic_label_tad_with_alignment(const gchar *labeltext, GtkWidget *m_widget,
> 						float xalign, gfloat yalign, GtkWidget *table, guint left_attach, 
> 						guint right_attach, guint top_attach, guint bottom_attach) {
> 	GtkWidget *label;
> 
> 	label = gtk_label_new_with_mnemonic(labeltext);
> 	gtk_misc_set_alignment(GTK_MISC(label), xalign, yalign);
> 	gtk_table_attach(GTK_TABLE(table), label, left_attach, right_attach, top_attach, bottom_attach, GTK_FILL, GTK_FILL, 0, 0);
>   
> 	if (m_widget != NULL) {
> 		if (GTK_IS_COMBO(m_widget)) {
> 			gtk_label_set_mnemonic_widget(GTK_LABEL(label), (GTK_COMBO(m_widget)->entry));
> 			gtk_entry_set_activates_default(GTK_ENTRY(GTK_COMBO(m_widget)->entry), TRUE);
> 		} else  if (GTK_IS_ENTRY(m_widget)) {
> 		    gtk_label_set_mnemonic_widget(GTK_LABEL(label), m_widget);
> 		    gtk_entry_set_activates_default(GTK_ENTRY(m_widget), TRUE);
> 		} else gtk_label_set_mnemonic_widget(GTK_LABEL(label), m_widget);
> 	}
> }
> 
> /**
>  * bf_label_with_markup:
>  * @labeltext: #const gchar* labeltext string
>  */
> GtkWidget *bf_label_with_markup(const gchar *labeltext) {
> 	GtkWidget *label = gtk_label_new(NULL);
> 	gtk_label_set_markup(GTK_LABEL(label), labeltext);
> 	return label;
> }
> /**
>  * bf_label_tad_with_markup:
>  * @labeltext: #const gchar* label string
>  * @xalign: #gfloat label horizontal alignment
>  * @yalign: #gfloat label vertical alignment
>  * @table: #GtkWidget* table label is packed into
>  * @left_attach: #guint column number to attach the left side of the label to
>  * @right_atach: #guint column number to attach the right side of a label to
>  * @top_attach: #guint row number to attach the top of a label to
>  * @bottom_attach: #guint row number to attach the bottom of a label to 	
>  *
>  *	create a label with markup, align it, and attach it to a table
>  * using the table defaults
>  *
>  * Return value: void
>  */
> void bf_label_tad_with_markup(const gchar *labeltext, gfloat xalign, gfloat yalign,
> 								GtkWidget *table, guint left_attach, guint right_attach, 
> 								guint top_attach, guint bottom_attach) {
> 	GtkWidget *label;
> 	label = bf_label_with_markup(labeltext);
> 	gtk_misc_set_alignment(GTK_MISC(label), xalign, yalign);
> 	gtk_table_attach_defaults(GTK_TABLE(table), label, left_attach, right_attach, top_attach, bottom_attach);	
> }
> #ifdef NOTYETUSED
> typedef struct {
> 	GtkWidget *win;
> 	GtkWidget *entry[10];
> 	gpointer data;
> } Tmultientrywidget;
> 
> static void multi_entry_destroy(GtkObject *object, Tmultientrywidget *mew) {
> 	g_free(mew);
> }
> 
> static void multi_entry_cancel_clicked(GtkWidget *widget, Tmultientrywidget *mew) {
> 	gtk_widget_destroy(mew->win);
> }
> 
> Tmultientrywidget *build_multi_entry_window(gchar *title,GCallback ok_func
> 			,gpointer data, const gchar **labelarr) {
> 	gint arrlen,i;
> 	GtkWidget *table,*hbox,*but;
> 
> 	arrlen = count_array(labelarr);
> 	if (arrlen >10) arrlen = 10;
> 	Tmultientrywidget *mew = g_new0(Tmultientrywidget,1);
> 	mew->data = data;
> 	mew->win = window_full2(title, GTK_WIN_POS_MOUSE, 10, multi_entry_destroy,mew, TRUE, NULL);
> 	table = gtk_table_new(arrlen+2,2,FALSE);
> 	gtk_table_set_row_spacings(GTK_TABLE(table),6);
> 	gtk_table_set_col_spacings(GTK_TABLE(table),6);
> 	gtk_container_add(GTK_CONTAINER(mew->win),table);
> 	for (i=0;i<arrlen;i++) {
> 		GtkWidget *label = gtk_label_new(labelarr[i]);
> 		gtk_table_attach_defaults(GTK_TABLE(table), label, 0, 1, i, i+1);
> 		mew->entry[i] = entry_with_text(NULL, 255);
> 		gtk_table_attach_defaults(GTK_TABLE(table), mew->entry[i], 1, 2, i, i+1);
> 	}
> 	gtk_table_attach_defaults(GTK_TABLE(table), gtk_hseparator_new(), 0, 2, i, i+1);
> 	hbox = gtk_hbutton_box_new();
> 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
> 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 12);
> 	but = bf_stock_cancel_button(G_CALLBACK(multi_entry_cancel_clicked), NULL);
> 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 0);
> 	but = bf_stock_ok_button(G_CALLBACK(ok_func), mew);
> 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 0);
> 	gtk_table_attach_defaults(GTK_TABLE(table), hbox, 0, 2, i+1, i+2);
> 	gtk_widget_show_all(mew->win);
> }
> #endif
> /**************************************************************************/
> /***********************  BUTTON DIALOG FUNCTIONS  ************************/
> /**************************************************************************/
> /*    If this code doesn't work, blame Christian <chris@tellefsen.net>    */
> 
> /* Emit a delete-event to the appropriate dialog, to detect a user bailing through escape. */
> static gboolean dialog_key_press_event_lcb(GtkWidget *widget,GdkEventKey *event,GtkWidget *dialog) {
> 	DEBUG_MSG("dialog_key_press_event_lcb, started, widget is %p and dialog is %p\n", widget, dialog);
> 	if (event->keyval == GDK_Escape) {
> 		DEBUG_MSG("dialog_key_press_event_lcb, emit delete_event on %p\n", dialog);
> 		/* g_signal_emit_by_name(G_OBJECT(dialog), "delete_event"); */
> 		gtk_widget_destroy(dialog);
> 		return TRUE;
> 	}
> 	return FALSE;
> }
> 
> /* This function is called from single_button_dialog_backend() and multiple_button_dialog_backend()
>  * The dialog passed is made HIG-compliant.
>  *
>  * A HiG-dialog is consists of a GtkDialog, with a 2-cell vbox. The top
>  * vbox contains an hbox, with an image and a label. The label has a primary
>  * (strong && larger) message and an additional, more descriptive message.
>  * It is not resizeable, has no title, placement is selected by the wm.
>  */
> void hig_dialog_backend (GtkDialog *dialog, gchar *primary, gchar *secondary, gchar *icon)
> {
> 	GtkWidget *vbox, *hbox, *image, *label;
> 	gchar *message;
> 	gchar *spanstart = "<span weight=\"bold\" size=\"larger\">";
> 	gchar *spanend = "</span>\n\n";
> 	gchar *msgend = "\n";
> 	
> 	gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);
> 	gtk_dialog_set_has_separator (GTK_DIALOG (dialog), FALSE);
> 
> 	vbox = GTK_DIALOG (dialog)->vbox;
> 	
> 	hbox = gtk_hbox_new (FALSE, 12);
> 	gtk_container_set_border_width (GTK_CONTAINER (hbox), 12);
> 	gtk_box_pack_start (GTK_BOX (vbox), hbox, TRUE, FALSE, 0);
> 
> 	if(icon) {
> 		image = gtk_image_new_from_stock (icon , GTK_ICON_SIZE_DIALOG); /* icon unknown ==> "broken image" displayed. */
> 		gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 0);
> 		gtk_misc_set_alignment (GTK_MISC (image), 0, 0);
> 	}
> 	
> 	if(secondary) { /* Creates label-content. */
> 		gchar *str1, *str2;
> 		str1 = xml_escape(primary);
> 		str2 = xml_escape(secondary);
> 		message = g_strconcat(spanstart, str1, spanend, str2, msgend, NULL);
> 	} else {
> 		gchar *str1;
> 		str1 = xml_escape(primary);
> 		message = g_strconcat(spanstart, str1, spanend, NULL);
> 	}
> 			
> 	label = gtk_label_new (message);
> 	g_free(message);
> 
> 	gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);
> 	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
> 	gtk_label_set_justify (GTK_LABEL (label), GTK_JUSTIFY_LEFT);
> 	gtk_label_set_line_wrap (GTK_LABEL (label), TRUE);
> }
> 
> /**
>  * multi_button_dialog_backend:
>  * @win: #GtkWidget* with the parent window for this dialog
>  * @primary: #gchar* containing primary dialog message.
>  * @secondary: #gchar* containing more explanatory message. Set to NULL if unused.
>  * @icon: #gchar* Your stock GTK image, i.e. GTK_STOCK_DIALOG_WARNING.
>  * @defval: #gint default index when user press ENTER.
>  * @cancelval: #gint: default index when user press ESCAPE. Should be something non-fatal. If this value is -1, the escape-button will be disabled.
>  * @buttons: #gchar** array of buttons. NULL-terminated!! Must contain at least one button.
>  *
>  * create a modal dialog with several buttons, returning the index of the clicked button
>  *
>  * Return value: #gint the index num of the button label which was clicked	so 0 for the first, 1 for the 2nd etc.
>  */
> gint multi_button_dialog_backend(GtkWidget *win, gchar *primary, gchar *secondary, gchar *icon, gint defval, gint cancelval, gchar **buttons) {
> 	GtkWidget *dialog;
> 	int i, retval;
> 
> 	dialog = gtk_dialog_new_with_buttons ("", /* Note that no title is being set. */
> 												GTK_WINDOW(win),
> 												GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
> 												*buttons, 0,
> 												NULL);
> 	DEBUG_MSG ("multi_button_dialog_backend: dialog=%p, primary=%s\n", dialog, primary);
> 	/* Add buttons. The index must be correct! */
> 	for (i = 1; *++buttons; i++) { /* Walk through the button-list until one reaches NULL. */
> 		DEBUG_MSG ("multi_button_dialog_backend: Adding button '%s', ID=%d\n", *buttons, i);
> 		gtk_dialog_add_button (GTK_DIALOG (dialog), *buttons, i);
> 	}
> 
> 	gtk_dialog_set_default_response (GTK_DIALOG (dialog), defval); /* enter-default*/
> 	if(cancelval != -1)/* enable escape ? */
> 		g_signal_connect(G_OBJECT(dialog), "key_press_event",
> 				G_CALLBACK(dialog_key_press_event_lcb), dialog); /* kill when escape is hit */
> 
> 	hig_dialog_backend (GTK_DIALOG (dialog), primary, secondary, icon);
> 	gtk_widget_show_all (dialog);
> 	retval = gtk_dialog_run (GTK_DIALOG (dialog));
> 	if (retval != GTK_RESPONSE_NONE) {
> 	    gtk_widget_destroy (dialog);
> 	}
> 
> 	DEBUG_MSG("multi_button_dialog_backend: got %d\n", retval);	
> 	return (retval == GTK_RESPONSE_DELETE_EVENT) ? cancelval : retval; /* When user hits escape -- give cancelval. */
> } 
> 
> /**
>  * single_button_dialog_backend:
>  * @primary #gchar* containing primary dialog message.
>  * @secondary #gchar* containing more explanatory message. Set to NULL if unused.
>  * @icon #gchar* Your stock GTK image, i.e. GTK_STOCK_DIALOG_WARNING.
>  * 
>  * Create and display a single-button message-dialog - HiG-style.
>  **/
> void single_button_dialog_backend(GtkWidget *win,gchar * primary, gchar * secondary, gchar * icon) {
> 	gchar *buttons[] = {GTK_STOCK_OK, NULL};
> 	multi_button_dialog_backend(win,primary, secondary, icon, 0, 0, buttons);
> }
> 
> /**
>  * error_dialog:
>  * @primary: #gchar* the primary error-description
>  * @secondary: #gchar* the secondary description of the error or NULL.
>  *
>  * 	Display an error dialog, Gnome HiG style
>  *
>  * Return value: void
>  */
> void error_dialog(GtkWidget *win,gchar * primary, gchar * secondary) {
> 	single_button_dialog_backend(win,primary, secondary, GTK_STOCK_DIALOG_ERROR);
> }
> 
> /**
>  * info_dialog:
>  * @primary: #gchar* the primary error-description
>  * @secondary: #gchar* the secondary description of the error or NULL.
>  *
>  * 	Display an informational dialog, Gnome HiG style
>  *
>  * Return value: void
>  */
> void info_dialog(GtkWidget *win,gchar * primary, gchar * secondary) {
> 	single_button_dialog_backend(win,primary, secondary, GTK_STOCK_DIALOG_INFO);
> }
> 
> /**
>  * warning_dialog:
>  * @primary: #gchar* the primary error-description
>  * @secondary: #gchar* the secondary description of the error or NULL.
>  *
>  * 	Display a warning dialog, Gnome HiG style
>  *
>  * Return value: void
>  */
> void warning_dialog(GtkWidget *win,gchar * primary, gchar * secondary) {
> 	single_button_dialog_backend(win,primary, secondary, GTK_STOCK_DIALOG_WARNING);
> }
> 
> /* multi_button_dialog and multi_stockbutton_dialog was here */
> 
> /**
>  * multi_error_dialog:
>  * @primary: #gchar* the primary error-description
>  * @secondary: #gchar* the secondary description of the error or NULL.
>  * @defval: #gint default index when user press ENTER.
>  * @cancelval: #gint: default index when user press ESCAPE. Should be something non-fatal. If this value is -1, the escape-button will be disabled.
>  * @buttons: #gchar** NULL terminated array of strings with button labels
>  *
>  * Create a modal error-dialog with several buttons, returning the index of the clicked button
>  *
>  * Return value: #gint the index num of the button label which was clicked	so 0 for the first, 1 for the 2nd etc.
>  */
> gint multi_error_dialog(GtkWidget *win,gchar *primary, gchar *secondary, gint defval, gint cancelval, gchar **buttons) {
> 	return multi_button_dialog_backend(win,primary, secondary, GTK_STOCK_DIALOG_ERROR, defval, cancelval, buttons);
> }
> 
> /**
>  * multi_warning_dialog:
>  * @primary: #gchar* the primary error-description
>  * @secondary: #gchar* the secondary description of the error or NULL.
>  * @defval: #gint default index when user press ENTER.
>  * @cancelval: #gint: default index when user press ESCAPE. Should be something non-fatal. If this value is -1, the escape-button will be disabled.
>  * @buttons: #gchar** NULL terminated array of strings with button labels
>  *
>  * Create a modal warning-dialog with several buttons, returning the index of the clicked button
>  *
>  * Return value: #gint the index num of the button label which was clicked	so 0 for the first, 1 for the 2nd etc.
>  */
> gint multi_warning_dialog(GtkWidget *win,gchar *primary, gchar *secondary, gint defval, gint cancelval, gchar **buttons) {
> 	return multi_button_dialog_backend(win,primary, secondary, GTK_STOCK_DIALOG_WARNING, defval, cancelval, buttons);
> }
>  
> /**
>  * multi_error_dialog:
>  * @primary: #gchar* the primary error-description
>  * @secondary: #gchar* the secondary description of the error or NULL.
>  * @defval: #gint default index when user press ENTER.
>  * @cancelval: #gint: default index when user press ESCAPE. Should be something non-fatal. If this value is -1, the escape-button will be disabled.
>  * @buttons: #gchar** NULL terminated array of strings with button labels
>  *
>  * Create a modal question-dialog with several buttons, returning the index of the clicked button
>  *
>  * Return value: #gint the index num of the button label which was clicked	so 0 for the first, 1 for the 2nd etc.
>  */
> gint multi_query_dialog(GtkWidget *win,gchar *primary, gchar *secondary, gint defval, gint cancelval, gchar **buttons) {
> 	return multi_button_dialog_backend(win,primary, secondary, GTK_STOCK_DIALOG_QUESTION, defval, cancelval, buttons);
> }
> 
> /************************************************************************/
> /*********************** PROGRESS-BAR FUNCTIONS *************************/
> /************************************************************************/
> /* Progress-bar-inspiration from the gtk-tutorial.. */
> 
> typedef struct _Tprogress {
> 	GtkWidget *bar;
> 	gboolean active; /* if FALSE, the bar is set to "confused-mode". */
> 	gboolean show_text; /* TRUE: String added to bar: text " " value " of  " maxvalue'*/
> 	gchar *text; /* Optional text to be displayed. */
> 	guint value; /* The current value. */
> 	guint maxvalue; /* The maximum value. Used to calculate a fraction between 0 and 1. */
> 	GtkWidget *owner; /* The widget to be destroyed when the bar is finished. */
> 	guint timer; /* keep track of the timer */
> 
> } Tprogress;
> 
> void progress_destroy(gpointer gp)
> {
> 	if(gp) {
> 		Tprogress *p = (Tprogress *) gp;
> 		/* bar is destroyed when owner is destroyed. */
> 		if(p->owner)
> 			gtk_widget_destroy (p->owner);
> 		else
> 			gtk_widget_destroy(p->bar);
> 			
> 		gtk_timeout_remove(p->timer);
> 		p->timer = 0;
> 		
> 		g_free(p);
> 	}
> }
> 
> static gboolean progress_update(gpointer data) {
> 	gchar *msg;
> 	Tprogress *p = (Tprogress *) data;
> 	gdouble frac = (gdouble) p->value / (gdouble) p->maxvalue;
> 	DEBUG_MSG("Entering: progress_update()\n");
> 
> 	gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (p->bar), frac);
> 	msg = g_strdup_printf (_("%d of %d"), p->value, p->maxvalue);
> 	gtk_progress_bar_set_text (GTK_PROGRESS_BAR (p->bar), msg);
> 	g_free (msg);
> 	
> 	if (p->value < p->maxvalue) {
> /*		flush_queue ();*/
> 		return TRUE; /* Yes! Call me again! GIMMI! */
> 	} else {
> 		/* We're done! Signal that we're maxed now. */
> 		return FALSE;
> 	}
> }
> 
> /**
>  * progress_set:
>  * @p The Tprogress struct assigned by a progress-creator. (i.e. progress_popup).
>  * @value a #guint between 0 and p->maxvalue.
>  *
>  * Set a new value for the progressbar-value. Does not actually update the progress-bar.
>  **/
> void progress_set(gpointer gp, guint value)
> {
> 	Tprogress *p = (Tprogress *) gp;
> 	p->value = value;
> }
> 
> /**
>  * progress_popup:
>  *
>  * Creates a popup containing a progress-bar. The dialog disappears when value = maxvalue.
>  * 'text' must be freeed after use!
>  *
>  * Returns: #gpointer camouflaged pointer to struct Tprogress, a data-structure passed to progress_update.
>  **/
> gpointer progress_popup(GtkWidget *win,gchar *title, guint maxvalue) {
> 	Tprogress *p;
> 	
> 	p = g_malloc (sizeof (Tprogress));
> 
> 	p->bar = gtk_progress_bar_new ();
> 	p->value = 0;
> 	p->maxvalue = maxvalue;
> 	
> 	
> 	/* other parameters */
> 	p->active = TRUE;
> 	p->show_text = TRUE;
> 	p->value = 0;
> 	p->maxvalue = maxvalue;
> 
> 	p->owner = gtk_dialog_new();
> 
> 	gtk_window_set_modal (GTK_WINDOW (p->owner), TRUE);
> 	gtk_window_set_transient_for (GTK_WINDOW (p->owner), GTK_WINDOW(win));
> 
> 
> 	/* Label, if applicable. Append pretty icon! */
> 	hig_dialog_backend(GTK_DIALOG (p->owner), title, NULL, GTK_STOCK_DIALOG_INFO);
> 
> 	gtk_box_pack_start (GTK_BOX (GTK_DIALOG (p->owner)->vbox),
>                         p->bar, TRUE, TRUE, 12);
> 
> 	p->timer = gtk_timeout_add (500, progress_update, p);
> 	gtk_widget_show_all (p->owner);
> 	
> 	return (gpointer) p;
> }
> 
> 
> /************************************************************************/
> /************************ file_but_* FUNCTIONS **************************/
> /************************************************************************/
> 
> typedef struct {
> 	GtkWidget *entry;
> 	Tbfwin *bfwin;
> 	gboolean fullpath;
> } Tfilebut;
> 
> static void file_but_clicked_lcb(GtkWidget * widget, Tfilebut *fb) {
> 	gchar *tmpstring=NULL, *tmp2string, *setfile;
> 	DEBUG_MSG("file_but_clicked_lcb, started, which_entry=%p\n",fb->entry);
> 	setfile = gtk_editable_get_chars(GTK_EDITABLE(GTK_ENTRY(fb->entry)),0,-1);
> 	/* if setfile is empty we should probably use the current document basedir ? right? */
> 	if (!setfile || strlen(setfile)==0) {
> 		if (fb->bfwin && fb->bfwin->current_document->filename && strlen(fb->bfwin->current_document->filename)) {
> 			if (setfile) g_free(setfile);
> 			setfile = path_get_dirname_with_ending_slash(fb->bfwin->current_document->filename);
> 		}
> 	} else if (setfile && strchr(setfile, '/') == NULL && fb->bfwin && fb->bfwin->current_document->filename) {
> 		/* if setfile is a relative name, we should try to make it a full path. relative names have 
> 		no slashes in the name */
> 		gchar *basedir, *oldsetfile;
> 		oldsetfile = setfile;
> 		basedir = path_get_dirname_with_ending_slash(fb->bfwin->current_document->filename);
> 		setfile = create_full_path(oldsetfile, basedir);
> 		g_free(oldsetfile);
> 		g_free(basedir);
> 	}
> 	
> #ifdef HAVE_ATLEAST_GTK_2_4
> 	{
> 		GtkWidget *dialog;
> 		dialog = file_chooser_dialog(NULL, _("Select File"), GTK_FILE_CHOOSER_ACTION_OPEN, setfile, FALSE, FALSE, NULL);
> 		gtk_window_set_transient_for(GTK_WINDOW(dialog),GTK_WINDOW(gtk_widget_get_toplevel(fb->entry)));
> 		if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
> 			tmp2string = gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(dialog));
> 			tmpstring = create_full_path(tmp2string, NULL);
> 			g_free(tmp2string);
> 		}
> 		gtk_widget_destroy(dialog);
> 	}
> #else
> 	tmpstring = return_file(setfile);
> #endif
> 	g_free(setfile);
> 	DEBUG_MSG("file_but_clicked_lcb, return_file returned %s\n",tmpstring);
> 	if (tmpstring) {
> 		if (!fb->fullpath && fb->bfwin) {
> 			if (fb->bfwin->current_document->filename != NULL) {
> 				tmp2string = create_relative_link_to(fb->bfwin->current_document->filename, tmpstring);
> 			} else {
> 				tmp2string = g_strdup(tmpstring);
> 			}
> 			g_free(tmpstring);
> 			tmpstring = tmp2string;
> 		}
> 		gtk_entry_set_text(GTK_ENTRY(fb->entry), tmpstring);
> /*	perhaps I break something by commenting-out this call, but otherwise the dialog is sometimes started
> 	again after the signal is emmitted
> 		gtk_signal_emit_by_name(GTK_OBJECT(which_entry), "activate");
> 		g_free(tmp2string); */
> 	}
> }
> 
> static void file_but_destroy(GtkObject *object, Tfilebut *fb) {
> 	g_free(fb);
> }
> /**
>  * file_but_new:
>  * @which_entry: #GtkWidget* GTK_ENTRY where to put the filename
>  * @win: #GtkWidget* the GTK_WINDOW where the button is placed
>  * @full_pathname: #gint 1 or 0, if you want the full path or a relative path
>  * #bfwin: #Tbfwin, only required if you want a relative pathname
>  *
>  *	Create new "open file" button, that will put the string into an entry
>  *
>  * Return value: #GtkWidget* pointer to file button
>  */
> GtkWidget *file_but_new(GtkWidget * which_entry, gint full_pathname, Tbfwin *bfwin) {
> 	GtkWidget *file_but;
> 	Tfilebut *fb;
> 
> 	fb = g_new(Tfilebut,1);
> 	fb->entry = which_entry;
> 	fb->bfwin = bfwin;
> 	fb->fullpath = full_pathname;
> 	file_but = gtk_button_new();
> 	g_signal_connect(G_OBJECT(file_but), "destroy", G_CALLBACK(file_but_destroy), fb);
> 	DEBUG_MSG("file_but_new, entry=%p, button=%p\n",which_entry,file_but);
> 	gtk_container_add(GTK_CONTAINER(file_but), hbox_with_pix_and_text(_("_Browse..."), 112,TRUE));
> 	g_signal_connect(G_OBJECT(file_but), "clicked", G_CALLBACK(file_but_clicked_lcb), fb);
> 	gtk_widget_show(file_but);
> 	return file_but;
> }
> 
> /************************************************************************/
> /************    FILE SELECTION FUNCTIONS  ******************************/
> /************************************************************************/
> 
> #ifdef HAVE_ATLEAST_GTK_2_4
> 
> static void file_chooser_set_current_dir(GtkWidget *dialog, const gchar *dir) {
> 	if (dir) {
> 		if (dir[0] == '/') gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog),dir);
> 		else gtk_file_chooser_set_current_folder_uri(GTK_FILE_CHOOSER(dialog),dir);
> 	}
> }
> 
> GtkWidget * file_chooser_dialog(Tbfwin *bfwin, gchar *title, GtkFileChooserAction action, 
>                                 gchar *set, gboolean localonly, gboolean multiple, const gchar *filter) {
> 	GtkWidget *dialog;
> /*	dialog = gtk_file_chooser_dialog_new_with_backend(title,bfwin ? GTK_WINDOW(bfwin->main_window) : NULL,
> 			action,"gnome-vfs",
> 			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
> 			(action == GTK_FILE_CHOOSER_ACTION_SAVE) ? GTK_STOCK_SAVE : GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
> 			NULL); */
> 	dialog = gtk_file_chooser_dialog_new(title,bfwin ? GTK_WINDOW(bfwin->main_window) : NULL, action,
>                 GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
>                 (action == GTK_FILE_CHOOSER_ACTION_SAVE) ? GTK_STOCK_SAVE : GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
>                 NULL);
> 	gtk_dialog_set_default_response (GTK_DIALOG(dialog), GTK_RESPONSE_ACCEPT);
> 	gtk_file_chooser_set_local_only (GTK_FILE_CHOOSER(dialog), localonly);
> 	gtk_file_chooser_set_select_multiple (GTK_FILE_CHOOSER(dialog), multiple);	
> 	
> 	if (set && strlen(set)) {
> 		DEBUG_MSG("file_chooser_dialog, set=%s,localonly=%d\n",set,localonly);
> 		if (localonly || strchr(set,':')==NULL) {
> 			gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dialog),set);
> 		} else {
> 			gtk_file_chooser_set_uri(GTK_FILE_CHOOSER(dialog),set);
> 		}
> 	} else if (!localonly && bfwin) { /* localonly is used for the project files */
> 		if (action == GTK_FILE_CHOOSER_ACTION_SAVE) {
> 			DEBUG_MSG("file_chooser_dialog, opendir=%s, savedir=%s\n",bfwin->session->opendir,bfwin->session->savedir);
> 			if (bfwin->session->savedir) file_chooser_set_current_dir(dialog,bfwin->session->savedir);
> 			else if (bfwin->session->opendir) file_chooser_set_current_dir(dialog,bfwin->session->opendir);
> 			else if (bfwin->project && bfwin->project->basedir) file_chooser_set_current_dir(dialog, bfwin->project->basedir);
> 			else file_chooser_set_current_dir(dialog, g_get_home_dir());
> 		} else {
> 			DEBUG_MSG("file_chooser_dialog, opendir=%s\n",bfwin->session->opendir);
> 			file_chooser_set_current_dir(dialog,bfwin->session->opendir);
> 		}
> 	}
> #ifdef DEBUG
> 	DEBUG_MSG("file_chooser_dialog, current_folder_uri=%s\n", gtk_file_chooser_get_current_folder_uri(GTK_FILE_CHOOSER(dialog)));
> #endif
> 
> /*	if (bfwin) {
> 		GList *tmplist;
> 		/ *tmplist = g_list_first(bfwin->session->recent_dirs);* /
> 		tmplist = g_list_first(main_v->recent_directories);
> 		DEBUG_MSG("file_chooser_dialog, session dir len=%d\n",g_list_length(bfwin->session->recent_dirs));
> 		while (tmplist) {
> 			GError *error=NULL;
> 			gtk_file_chooser_add_shortcut_folder_uri(GTK_FILE_CHOOSER(dialog),(gchar*)tmplist->data,&error);
> 			DEBUG_MSG("file_chooser_dialog, adding folder %s\n",(gchar*)tmplist->data);
> 			if (error) {
> 				DEBUG_MSG("file_chooser_dialog, ERROR adding dir %s: %s\n", (gchar*)tmplist->data, error->message);
> 				g_error_free(error);
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}*/
> 
> 	if (action == GTK_FILE_CHOOSER_ACTION_OPEN || action == GTK_FILE_CHOOSER_ACTION_SAVE){
> 		GList *tmplist;
> 		GtkFileFilter* ff;
> 		ff = gtk_file_filter_new();
> 		gtk_file_filter_set_name(ff,_("All files"));
> 		gtk_file_filter_add_pattern(ff, "*");
> 		gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), ff);
> 		if (filter == NULL)	gtk_file_chooser_set_filter(GTK_FILE_CHOOSER(dialog), ff);
> 		tmplist = g_list_first(main_v->filetypelist);
> 		while (tmplist) {
> 			gchar **tmp;
> 			Tfiletype *ft = (Tfiletype *)tmplist->data;
> 			if ((strcmp(ft->type, "objectfile") != 0) && ft->extensions && *ft->extensions) {
> 				ff = gtk_file_filter_new();
> 				gtk_file_filter_set_name(ff,ft->type);
> 				DEBUG_MSG("file_chooser_dialog, adding filter '%s'\n", ft->type);
> 				tmp = ft->extensions;
> 				while (*tmp) {
> 					gchar *pattern;
> 					pattern = g_strconcat("*", *tmp, NULL);
> 					gtk_file_filter_add_pattern(ff, pattern);
> 					DEBUG_MSG("file_chooser_dialog, adding pattern '%s' to '%s'\n", pattern, ft->type);
> 					g_free(pattern);
> 					tmp++;
> 				}
> 				gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), ff);
> 				if (filter && strcmp(filter, ft->type) == 0)	gtk_file_chooser_set_filter (GTK_FILE_CHOOSER (dialog), ff);
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 
> 	return dialog;
> }
> 
> #else
> typedef struct {
> 	gboolean select_dir;
> 	gint multipleselect;
> 	gchar *filename_to_return;
> 	GList *filenames_to_return;
> 	GtkWidget *fs;
> } Tfileselect;
> 
> static void fs_ok_clicked_lcb(GtkWidget * widget, Tfileselect *fileselect)
> {
> 	gchar *dirname, *selected_file;
> 
> 	selected_file = get_utf8filename_from_on_disk_encoding(gtk_file_selection_get_filename(GTK_FILE_SELECTION(fileselect->fs)));
> 
> 	if (g_file_test(selected_file, G_FILE_TEST_IS_DIR)) {
> 		DEBUG_MSG("fs_ok_clicked_lcb,file_is_dir said %s is a dir!!!!\n", selected_file);
> 		if (fileselect->select_dir) {
> 			fileselect->filename_to_return = g_path_get_dirname(selected_file);
> 			g_free(selected_file);
> 			gtk_main_quit();
> 			window_destroy(GTK_WIDGET(fileselect->fs));
> 			return;
> 		} else {
> 			dirname = ending_slash(selected_file);
> 			gtk_file_selection_set_filename(GTK_FILE_SELECTION(fileselect->fs), dirname);
> 			gtk_entry_set_text(GTK_ENTRY(GTK_FILE_SELECTION(fileselect->fs)->selection_entry), "");
> 			g_free(dirname);
> 			g_free(selected_file);
> 			return;
> 		}
> 	} else {
> 		DEBUG_MSG("fs_ok_clicked_lcb,file_is_dir said %s is NOT a dir.\n", selected_file);
> 	}
> 
> 	if (fileselect->multipleselect) {
> 		gchar **filenames, **orig;
> 		/* multiple files allowed --> scan trough the list for selections */
> 		orig = filenames = gtk_file_selection_get_selections(GTK_FILE_SELECTION(fileselect->fs));
> 		if (filenames) {
> 			while (*filenames) {
> 				fileselect->filenames_to_return = g_list_append(fileselect->filenames_to_return, get_utf8filename_from_on_disk_encoding(*filenames));
> 				filenames++;
> 			}
> 			g_strfreev(orig);
> 		}
> 	} else {
> 		/* NO multiple files allowed --> return just one file */
> 		if (fileselect->select_dir) {
> 			fileselect->filename_to_return = g_path_get_dirname(selected_file);
> 		} else {
> 				fileselect->filename_to_return = g_strdup(selected_file);
> 		}
> 	}
> 	if ((fileselect->multipleselect 
> 			&& (g_list_length(fileselect->filenames_to_return) < 1)) 
> 		|| (!fileselect->multipleselect 
> 			&& strlen(fileselect->filename_to_return) < 1)){
> /*		statusbar_message(_("No file to insert."), 2000);*/
> 	}
> 	
> 	g_free(selected_file);	
> 	gtk_main_quit();
> 	window_destroy(GTK_WIDGET(fileselect->fs));
> }
> 
> void close_modal_window_lcb(GtkWidget * widget, gpointer window)
> {
> 	DEBUG_MSG("close_modal_window_lcb, widget=%p, window=%p\n", widget, window);
> 	gtk_main_quit();
> 	window_destroy(window);
> }
> 
> static void fs_history_pulldown_activate_lcb(GtkWidget *menuitem,Tfileselect *fileselect) {
> 	const gchar *filename = gtk_entry_get_text(GTK_ENTRY(GTK_FILE_SELECTION(fileselect->fs)->selection_entry));
> 	gchar *dirname = ending_slash(gtk_label_get_text(GTK_LABEL(gtk_bin_get_child(GTK_BIN(menuitem)))));
> 	gchar *fullpath = g_strconcat(dirname, filename, NULL);
> 	g_free(dirname);
> 	gtk_file_selection_set_filename(GTK_FILE_SELECTION(fileselect->fs), fullpath);
> 	g_free(fullpath);
> }
> 
> static void fs_history_pulldown_changed(GtkOptionMenu *optionmenu,Tfileselect *fileselect) {
> 	GtkWidget *menuitem, *menu;
> 	GList *tmplist;
> 	DEBUG_MSG("fs_history_pulldown_changed\n");
> 	menu = gtk_option_menu_get_menu(GTK_OPTION_MENU(optionmenu));
> 	tmplist = g_list_first(main_v->recent_directories);
> 	while (tmplist) {
> 		menuitem = gtk_menu_item_new_with_label((gchar *)tmplist->data);
> 		g_signal_connect(G_OBJECT(menuitem),"activate",G_CALLBACK(fs_history_pulldown_activate_lcb),fileselect);
> 		gtk_widget_show(menuitem);
> 		gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> static void fileselectwin(gchar *setfile, Tfileselect *fileselect, gchar *title) {
> 
> 	fileselect->fs = gtk_file_selection_new(title);
> 	DEBUG_MSG("fileselectwin, started, fileselect->fs=%p\n", fileselect->fs);		
> 	gtk_file_selection_show_fileop_buttons(GTK_FILE_SELECTION(fileselect->fs));
> 	/*gtk_file_selection_hide_fileop_buttons(GTK_FILE_SELECTION(fileselect->fs));*/
> 	g_signal_connect(G_OBJECT(fileselect->fs), "destroy", G_CALLBACK(close_modal_window_lcb), fileselect->fs);
> 	g_signal_connect(G_OBJECT(GTK_FILE_SELECTION(fileselect->fs)->cancel_button),
> 					   "clicked", G_CALLBACK(close_modal_window_lcb), fileselect->fs);
> 	g_signal_connect(G_OBJECT(GTK_FILE_SELECTION(fileselect->fs)->ok_button), "clicked", G_CALLBACK(fs_ok_clicked_lcb), fileselect);
> 	g_signal_connect(G_OBJECT(GTK_FILE_SELECTION(fileselect->fs)->history_pulldown), "changed", G_CALLBACK(fs_history_pulldown_changed), fileselect);
> 
> 	if (fileselect->multipleselect) {
> 		gtk_file_selection_set_select_multiple(GTK_FILE_SELECTION(fileselect->fs), TRUE);
> 	}
> 	if (setfile) {
> 		gtk_file_selection_set_filename(GTK_FILE_SELECTION(fileselect->fs), setfile);
> 	}
> 	gtk_window_set_role(GTK_WINDOW(fileselect->fs), "fileselect");
> 
> 	gtk_widget_show(fileselect->fs);
> /*	gtk_grab_add(GTK_WIDGET(fileselect->fs));*/
> 	gtk_widget_realize(GTK_WIDGET(fileselect->fs));
> 	if (setfile) {
> 		/* this only has effect after the widget is shown */
> 		gtk_editable_select_region(GTK_EDITABLE(GTK_FILE_SELECTION(fileselect->fs)->selection_entry),0,-1);
> 	}
> 	
> 	/* When you closed the the file selector dialog focus always returned to the bluefish main window
> 	   changed to use gtk_widget_get_parent so focus returns to the dialog that opened the file selector
> 	*/
> 	DEBUG_MSG("gtk_widget_fet_parent returns %p\n",gtk_widget_get_parent(fileselect->fs));
> 	{
> 		GtkWidget *parent = gtk_widget_get_parent(fileselect->fs);
> 		if (parent) {
> 			gtk_window_set_transient_for(GTK_WINDOW(fileselect->fs), GTK_WINDOW(parent));
> 		}
> 	}
> }
> /**
>  * return_file_w_title:
>  * @setfile: #gchar* the file to intitially set the dialog with
>  * @title: #gchar* with the dialog title
>  *
>  * makes a modal dialog with title that will return a file
>  *
>  * Return value: #gchar* with the selected filename
>  */
> gchar *return_file_w_title(gchar * setfile, gchar *title) {
> 	Tfileselect fileselect={FALSE, 0, NULL, NULL, NULL};
> 
> 	fileselectwin(setfile, &fileselect, title);
> 	gtk_main();
> 	return fileselect.filename_to_return;
> }
> /**
>  * return_file:
>  * @setfile: #gchar* the file to intitially set the dialog with
>  *
>  * makes a modal dialog that will return a file
>  *
>  * Return value: #gchar* with the selected filename
>  */
> gchar *return_file(gchar * setfile) {
> 	return return_file_w_title(setfile, _("Select file"));
> }
> /**
>  * return_files_w_title:
>  * @setfile: #gchar* the file to intitially set the dialog with
>  * @title: #gchar* with the dialog title
>  *
>  * makes a modal dialog that will return multiple files
>  *
>  * Return value: #GList* containing a stringlist with all selected files
>  */
> GList *return_files_w_title(gchar * setfile, gchar *title) {
> 	Tfileselect fileselect={FALSE, 1, NULL, NULL, NULL};
> 	
> 	fileselectwin(setfile, &fileselect, title);
> 	gtk_main();
> 	return fileselect.filenames_to_return;
> }
> /**
>  * return_files:
>  * @setfile: #gchar* the file to intitially set the dialog with
>  *
>  * makes a modal dialog that will return multiple files
>  *
>  * Return value: #GList* containing a stringlist with all selected files
>  */
> GList *return_files(gchar * setfile) {
> 	return return_files_w_title(setfile, _("Select files"));
> }
> /**
>  * return_dir:
>  * @setdir: #gchar* the dir to intitially set the dialog with
>  * @title: #gchar* with the dialog title
>  *
>  * makes a modal dialog that will return a directory
>  *
>  * Return value: #gchar* with the selected directory
>  */
> gchar *return_dir(gchar *setdir, gchar *title) {
> 	Tfileselect fileselect={TRUE, 0, NULL, NULL, NULL};
> 
> 	fileselectwin(setdir, &fileselect, title);
> 	gtk_main();
> 	return fileselect.filename_to_return;
> }
> #endif /* HAVE_ATLEAST_GTK_2_4 */
> 
> /************************************************************************/
> 
> static void ungroupradoiitems(GtkWidget *menu) {
> 	GList *tmplist = g_list_first(GTK_MENU_SHELL(menu)->children);
> 	while (tmplist) {
> 		GtkWidget *sub;
> 		DEBUG_MSG("ungroupradiomenuitems, another item\n");
> 		if (GTK_IS_RADIO_MENU_ITEM(tmplist->data)) {
> 			DEBUG_MSG("%p is a radiomenu item, ungrouped!\n",tmplist->data);
> 			gtk_radio_menu_item_set_group(tmplist->data,NULL);
> 		}
> 		sub = gtk_menu_item_get_submenu(tmplist->data);
> 		if (sub) ungroupradoiitems(sub);
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> void destroy_disposable_menu_cb(GtkWidget *widget, GtkWidget *menu) {
> 	ungroupradoiitems(menu);
> 	gtk_widget_destroy(GTK_WIDGET(menu));
> }
> 
> 
> /***********************************************************************
>  * workarounds for gtk-2.0  
>  * these functions are not needed with gtk-2.2
>  */
> #ifndef HAVE_ATLEAST_GTK_2_2
> static GtkTreePath *gtktreepath_up_multi(GtkTreePath *path, gint num) {
> 	while (num > 0) {
> 		gtk_tree_path_up(path);
> 		num--;
> 	}
> 	return path;
> }
> 
> void gtktreepath_expand_to_root(GtkWidget *tree, const GtkTreePath *this_path) {
> 	gint num = gtk_tree_path_get_depth((GtkTreePath *)this_path);
> 	while (num >= 0) {
> 		GtkTreePath *path = gtk_tree_path_copy(this_path);
> 		path = gtktreepath_up_multi(path, num);
> /*		g_signal_handlers_block_matched(G_OBJECT(tree), G_SIGNAL_MATCH_FUNC,
> 					0, 0, NULL, row_expanded_lcb, NULL);*/
> 		gtk_tree_view_expand_row(GTK_TREE_VIEW(tree), path, FALSE);
> /*		g_signal_handlers_unblock_matched(G_OBJECT(tree), G_SIGNAL_MATCH_FUNC,
> 					0, 0, NULL, row_expanded_lcb, NULL);*/
> 		gtk_tree_path_free(path);
> 		num--;
> 	}
> }
> #endif /* ifndef HAVE_ATLEAST_GTK_2_2 */
> 
> /*****************************************
>  * workaround for gnome-vfs-2.0
>  * this is copied from gnome-vfs-utils.c
>  * Copyright (C) 1999 Free Software Foundation
>  * Copyright (C) 2000, 2001 Eazel, Inc.
>  */
> #ifdef HAVE_GNOME_VFS
> #ifndef HAVE_ATLEAST_GNOMEVFS_2_2
> #define READ_CHUNK_SIZE 8192
> GnomeVFSResult gnome_vfs_read_entire_file (const char *uri,int *file_size,char **file_contents){
> 	GnomeVFSResult result;
> 	GnomeVFSHandle *handle;
> 	char *buffer;
> 	GnomeVFSFileSize total_bytes_read;
> 	GnomeVFSFileSize bytes_read;
> 	*file_size = 0;
> 	*file_contents = NULL;
> 	result = gnome_vfs_open (&handle, uri, GNOME_VFS_OPEN_READ);
> 	if (result != GNOME_VFS_OK) {
> 		return result;
> 	}
> 	buffer = NULL;
> 	total_bytes_read = 0;
> 	do {
> 		buffer = g_realloc (buffer, total_bytes_read + READ_CHUNK_SIZE);
> 		result = gnome_vfs_read (handle,buffer + total_bytes_read,READ_CHUNK_SIZE,&bytes_read);
> 		if (result != GNOME_VFS_OK && result != GNOME_VFS_ERROR_EOF) {
> 			g_free (buffer);
> 			gnome_vfs_close (handle);
> 			return result;
> 		}
> 		if (total_bytes_read + bytes_read < total_bytes_read) {
> 			g_free (buffer);
> 			gnome_vfs_close (handle);
> 			return GNOME_VFS_ERROR_TOO_BIG;
> 		}
> 		total_bytes_read += bytes_read;
> 	} while (result == GNOME_VFS_OK);
> 	result = gnome_vfs_close (handle);
> 	if (result != GNOME_VFS_OK) {
> 		g_free (buffer);
> 		return result;
> 	}
> 	*file_size = total_bytes_read;
> 	*file_contents = g_realloc (buffer, total_bytes_read);
> 	return GNOME_VFS_OK;
> }			    
> #endif /* ifndef HAVE_ATLEAST_GNOMEVFS_2_2 */
> #endif /* HAVE_GNOME_VFS */
1,1771c1,1767
< /* Bluefish HTML Editor
<  * gui.c - the main GUI
<  *
<  * Copyright (C) 2002-2006 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< /* #define DEBUG */
< 
< #include <gtk/gtk.h>
< #include <stdlib.h>    /* exit() on Solaris */
< #include <string.h>    /* strchr() */
< #include <time.h>      /* nanosleep() */
< #include <unistd.h>    /* exit() */
< 
< #include "config.h"
< 
< #include "bluefish.h"
< #include "gui.h"
< #include "bf_lib.h"        /* get_int_from_string() */
< #include "bookmark.h"
< #include "document.h"      /* file_new_cb() */
< #include "filebrowser.h"
< #include "fref.h"
< #include "gtk_easy.h"
< #include "html.h"
< #include "html2.h"
< #include "html_form.h"
< #include "html_table.h"
< #include "image.h"
< #include "menu.h"          /* menu_create_main(), recent_menu_init() */
< #include "outputbox.h"     /* init_outputbox() */
< #include "pixmap.h"        /* new_pixmap(); */
< #include "preferences.h"   /* open_preferences_cb */
< #include "project.h"
< #include "snr2.h"          /* search_cb, replace_cb */
< #include "stringlist.h"
< #include "undo_redo.h"     /* undo_cb() redo_cb() etc. */
< #include "wizards.h"
< 
< #ifdef HAVE_ATLEAST_GTK_2_4
< #include "quickstart.h"
< #endif /* HAVE_ATLEAST_GTK_2_4 */
< 
< #ifdef HAVE_LIBASPELL
< #include "bfspell.h"
< #endif /* HAVE_LIBASPELL */
< 
< typedef struct {
< 	GtkWidget *window;
< 	GtkWidget *label;
< } Tsplashscreen;
< 
< /******************************/
< /* global vars for this module */
< /******************************/
< #ifndef NOSPLASH
< static Tsplashscreen splashscreen;
< #endif
< /**************************/
< /* start of the functions */
< /**************************/
< 
< /**
<  * notebook_hide:
<  *
<  * Hides the notebook. Used when loading a large amount of files, to avoid
<  * slowing things down. Shows a "Stand by..." label instead..
<  *
<  * Return value: void
<  **/
< void notebook_hide(Tbfwin *bfwin) {
< 	gtk_widget_hide (bfwin->notebook);
< 	gtk_widget_show (bfwin->notebook_fake);
< }
< 
< /**
<  * notebook_show:
<  *
<  * Shows the notebook, after a notebook_hide() has been called.
<  *
<  * Return value: void
<  **/
< void notebook_show(Tbfwin *bfwin) {
< 	gtk_widget_hide (bfwin->notebook_fake);
< 	gtk_widget_show (bfwin->notebook);	
< }
< 
< void notebook_changed(Tbfwin *bfwin, gint newpage) {
< 	gint cur = newpage;
< 	gint doclistlen;
< 	DEBUG_MSG("notebook_changed, doclistlen=%d, newpage=%d, notebook_curpage=%d, last_notebook_page=%d, curdoc=%p\n"
< 			,g_list_length(bfwin->documentlist)
< 			,newpage
< 			,gtk_notebook_get_current_page(GTK_NOTEBOOK(bfwin->notebook))
< 			,bfwin->last_notebook_page
< 			,bfwin->current_document
< 			);
< 	if (newpage == -1) {
< 		/* this returns -1 if there is no current page */
< 		cur = gtk_notebook_get_current_page(GTK_NOTEBOOK(bfwin->notebook));
< 	}
< 	if ((bfwin->last_notebook_page == cur) 
< 		&& (bfwin->current_document != NULL)
< 		&& (bfwin->current_document == g_list_nth_data(bfwin->documentlist, cur))) {
< 		DEBUG_MSG("notebook_changed, NOT CHANGED cur=%d, documentlist[cur]==current_document (=%p), RETURNING\n",cur,bfwin->current_document);
< 		return;
< 	}
< 	doclistlen = g_list_length(bfwin->documentlist);
< 	if (cur == -1) {
< 		if (doclistlen > 0) {
< 			DEBUG_MSG("notebook_changed, WEIRD 1 cur=%d, but doclistlen=%d RETURNING\n",cur,doclistlen);
< 			bfwin->last_notebook_page = -2;
< 			return;
< 		}
< 	}
< 	if (doclistlen == 0) {
< 		DEBUG_MSG("notebook_changed, doclistlen=%d, before doc_new()!\n",doclistlen);
< 		bfwin->current_document = doc_new(bfwin,TRUE);
< 		bfwin->last_notebook_page = 1;
< 		DEBUG_MSG("notebook_changed, after doc_new(), returning\n");
< 		return;
< 	}
< 	/* if the documentlist has length 1, cur should not be larger then 0, if 2, cur should not be larger then 1, etc.*/
< 	if (cur >= doclistlen) {
< 		DEBUG_MSG("notebook_changed, DOCALREADYCLOSED, cur=%d, doclistlen=%d, RETURNING\n", cur, doclistlen);
< 		bfwin->last_notebook_page = -2;
< 		return;
< 	}
< 	bfwin->current_document = g_list_nth_data(bfwin->documentlist, cur);
< 	if (bfwin->current_document == NULL) {
< 		DEBUG_MSG("notebook_changed, WEIRD 2, doclist[%d] == NULL, RETURNING\n",cur);
< 		return;
< 	}
< 	DEBUG_MSG("notebook_changed, current_document=%p\n",bfwin->current_document);
< 	bfwin->last_notebook_page = cur;
< 	/* now we flush the queue first, so that we don't call doc_activate 
< 	on _this_ document if the user has another close click in the queue */
< 	flush_queue();
< 
< 	doc_activate(bfwin->current_document);
< /*	bmark_adjust_visible(bfwin);*/
< }
< 
< gboolean switch_to_document_by_index(Tbfwin *bfwin,gint index) {
< 	if (index >= 0) {
< 		gtk_notebook_set_current_page(GTK_NOTEBOOK(bfwin->notebook), (index));
< /*		notebook_changed();*/
< 		return TRUE;
< 	}
< 	return FALSE;
< }
< 
< gboolean switch_to_document_by_pointer(Tbfwin *bfwin,Tdocument *document) {
< 	gint index;
< 
< 	index = g_list_index(bfwin->documentlist, document);
< 	return switch_to_document_by_index(bfwin,index);
< }
< 
< gboolean switch_to_document_by_filename(Tbfwin *bfwin,gchar *filename) {
< 	gint index;
< 
< 	index = documentlist_return_index_from_filename(bfwin->documentlist,filename);
< 	return switch_to_document_by_index(bfwin,index);
< }
< 
< 
< static void notebook_switch_page_lcb(GtkWidget *notebook,GtkNotebookPage *page,gint page_num,Tbfwin *bfwin) {
< 	DEBUG_MSG("notebook_switch_page_lcb, page=%d\n", page_num);
< 	notebook_changed(bfwin,page_num);
< }
< 
< void gui_notebook_switch(Tbfwin *bfwin,guint action,GtkWidget *widget) {
< 	switch (action) {
< 		case 1: gtk_notebook_prev_page(GTK_NOTEBOOK(bfwin->notebook));
< 		break;
< 		case 2: gtk_notebook_next_page(GTK_NOTEBOOK(bfwin->notebook));
< 		break;
< 		case 3: gtk_notebook_set_current_page(GTK_NOTEBOOK(bfwin->notebook), 0);
< 		break;
< 		case 4: gtk_notebook_set_current_page(GTK_NOTEBOOK(bfwin->notebook), -1);
< 	}
< }
< 
< static void left_panel_notify_position_lcb(GObject *object,GParamSpec *pspec,gpointer data){
< 	gint position;
< 	g_object_get(object, pspec->name, &position, NULL);
< 	DEBUG_MSG("left_panel_notify_position_lcb, new position=%d\n", position);
< 	if (main_v->props.restore_dimensions) {
< 		if (main_v->props.left_panel_left) {
< 			main_v->props.left_panel_width = position;
< 		} else {
< 			main_v->props.left_panel_width = main_v->globses.main_window_w - position;
< 		}
< 	}
< }
< 
< GtkWidget *left_panel_build(Tbfwin *bfwin) {
< 	GtkWidget *fileb;
< 	GtkWidget *left_notebook = gtk_notebook_new();
< 	GtkWidget *fref;
< 	GtkWidget *bmarks;
< 	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(left_notebook),main_v->props.leftpanel_tabposition);
< 	gtk_notebook_set_show_tabs(GTK_NOTEBOOK(left_notebook), TRUE);
< 	gtk_notebook_set_show_border(GTK_NOTEBOOK(left_notebook), FALSE);
< 	gtk_notebook_set_tab_hborder(GTK_NOTEBOOK(left_notebook), 0);
< 	gtk_notebook_set_tab_vborder(GTK_NOTEBOOK(left_notebook), 0);
< 	gtk_notebook_popup_enable(GTK_NOTEBOOK(left_notebook));
< 	fileb = filebrowser_init(bfwin);
< 	fref = fref_gui(bfwin);
< 	bmarks = bmark_gui(bfwin);
< 	gtk_notebook_append_page_menu(GTK_NOTEBOOK(left_notebook),fileb,new_pixmap(105),gtk_label_new(_("Filebrowser")));
< 	gtk_notebook_append_page_menu(GTK_NOTEBOOK(left_notebook),fref,new_pixmap(106),gtk_label_new(_("Function reference")));
< 	gtk_notebook_append_page_menu(GTK_NOTEBOOK(left_notebook),bmarks,new_pixmap(104),gtk_label_new(_("Bookmarks")));
< 	gtk_widget_show_all(left_notebook);
< 	gtk_notebook_set_current_page(GTK_NOTEBOOK(left_notebook),0);
< 	return left_notebook;
< }
< 
< /**
<  * if there is a left panel, this function will rebuild all widgets
<  */
< void left_panel_rebuild(Tbfwin *bfwin) {
< 	if (bfwin->hpane) {
< 		DEBUG_MSG("left_panel_rebuild, destroying widgets\n");
< 		gtk_widget_destroy(bfwin->leftpanel_notebook);
< 		DEBUG_MSG("left_panel_rebuild, cleanup\n");
< 		filebrowser_cleanup(bfwin);
< 		fref_cleanup(bfwin);
< 		bmark_cleanup(bfwin);
< 		DEBUG_MSG("left_panel_rebuild, re-init\n");
< 		bfwin->leftpanel_notebook = left_panel_build(bfwin);
< 		if (main_v->props.left_panel_left) {
< 			gtk_paned_add1(GTK_PANED(bfwin->hpane), bfwin->leftpanel_notebook);
< 		} else {
< 			gtk_paned_add2(GTK_PANED(bfwin->hpane), bfwin->leftpanel_notebook);
< 		}
< 		gtk_widget_show_all(bfwin->leftpanel_notebook);
< 	}
< }
< 
< void left_panel_show_hide_toggle(Tbfwin *bfwin,gboolean first_time, gboolean show, gboolean sync_menu) {
< 	if (sync_menu) {
< 		DEBUG_MSG("left_panel_show_hide_toggle, trying to sync menu\n");
< 		setup_toggle_item_from_widget(bfwin->menubar, "/View/View Sidebar", show);
< 	}
< 	if (!first_time && ((show && bfwin->hpane) || (!show && bfwin->hpane == NULL))) {
< 		DEBUG_MSG("left_panel_show_hide_toggle, retrurning!!, show=%d, bfwin->hpane=%p, first_time=%d\n",show,bfwin->hpane,first_time);
< 		return;
< 	} 
< 
< 	if (!first_time) {
< 		gtk_widget_ref(bfwin->notebook_box);
< 		if (show) {
< 			gtk_container_remove(GTK_CONTAINER(bfwin->middlebox), bfwin->notebook_box);
< 		} else {
< 			gtk_container_remove(GTK_CONTAINER(bfwin->hpane), bfwin->notebook_box);
< 			gtk_widget_destroy(bfwin->hpane);
< 			filebrowser_cleanup(bfwin);
< 			fref_cleanup(bfwin);
< 			bmark_cleanup(bfwin); 
< 		}
< 	}
< 	if (show) {
< 		bfwin->hpane = gtk_hpaned_new();
< 		if (main_v->props.left_panel_left) {
< 			DEBUG_MSG("set paned position to %d (left)\n",main_v->props.left_panel_width);
< 			gtk_paned_set_position(GTK_PANED(bfwin->hpane), main_v->props.left_panel_width);
< 		} else {
< 			DEBUG_MSG("set paned position to %d (right)\n",main_v->globses.main_window_w - main_v->props.left_panel_width);
< 			gtk_paned_set_position(GTK_PANED(bfwin->hpane), main_v->globses.main_window_w - main_v->props.left_panel_width);
< 		}
< 		g_signal_connect(G_OBJECT(bfwin->hpane),"notify::position",G_CALLBACK(left_panel_notify_position_lcb), NULL);
< 		bfwin->leftpanel_notebook = left_panel_build(bfwin);
< 		gtk_paned_add1(GTK_PANED(bfwin->hpane), main_v->props.left_panel_left ? bfwin->leftpanel_notebook : bfwin->notebook_box);
< 		gtk_paned_add2(GTK_PANED(bfwin->hpane), main_v->props.left_panel_left ? bfwin->notebook_box : bfwin->leftpanel_notebook);
< 		gtk_box_pack_start(GTK_BOX(bfwin->middlebox), bfwin->hpane, TRUE, TRUE, 0);
< 		gtk_widget_show(bfwin->hpane);
< 	} else {
< 		bfwin->hpane = NULL;
< 		bfwin->leftpanel_notebook = NULL;
< 		gtk_box_pack_start(GTK_BOX(bfwin->middlebox), bfwin->notebook_box, TRUE, TRUE, 0);
< 	}
< 	if (!first_time) {
< 		gtk_widget_unref(bfwin->notebook_box);
< 	}
< }
< 
< void gui_set_title(Tbfwin *bfwin, Tdocument *doc) {
< 	gchar *title, *prfilepart;
< 	const gchar *tablabel;
< 	tablabel = gtk_label_get_text(GTK_LABEL(doc->tab_label));
< 	if (bfwin->project) {
< 		prfilepart = g_strconcat(bfwin->project->name," - ",tablabel,NULL);
< 	} else {
< 		prfilepart = g_strdup(tablabel);
< 	}
< 	title = g_strconcat(prfilepart, " - Bluefish "VERSION,NULL);
< 	gtk_window_set_title(GTK_WINDOW(bfwin->main_window),title);
< 	/*rename_window_entry_in_all_windows(bfwin, title);*/
< 	g_free(title);
< 	g_free(prfilepart);
< }
< 
< void gui_apply_settings(Tbfwin *bfwin) {
< 	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(bfwin->notebook),main_v->props.document_tabposition);
< 	/* We don't want to set the tab position if the left panel is hidden */
< 	if (bfwin->leftpanel_notebook) {
< 		gtk_notebook_set_tab_pos(GTK_NOTEBOOK(bfwin->leftpanel_notebook),main_v->props.leftpanel_tabposition);
< 
< 		/* check if the left panel needs to move over to the right */
< 		if (main_v->props.left_panel_left && bfwin->leftpanel_notebook == GTK_PANED(bfwin->hpane)->child1) {
< 			DEBUG_MSG("gui_apply_settings, left panel is on the right location\n");
< 		} else {
< 			left_panel_show_hide_toggle(bfwin,FALSE, FALSE, FALSE);
< 			left_panel_show_hide_toggle(bfwin,FALSE, TRUE, FALSE);
< 		}
< 	}
< }
< 
< typedef struct {
< 	const gchar *ident;
< 	void (*func)();
< 	gint pixmaptype;
< 	const gchar *tooltiptext;
< } Ttoolbaritem;
< 
< typedef struct {
< 	Ttoolbaritem *tbitem;
< 	GtkWidget *button;
< 	Tbfwin *bfwin;
< }Tquickbaritem;
< 
< static void bold_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 1, NULL);
< }
< static void italic_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 2, NULL);
< }
< static void paragraph_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 5, NULL);
< }
< static void break_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 6, NULL);
< }
< static void breakclear_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 41, NULL);
< }
< static void nbsp_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 7, NULL);
< }
< static void center_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 8, NULL);
< }
< static void rightjustify_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 9, NULL);
< }
< static void comment_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 10, NULL);
< }
< static void fontsizeplus1_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 11, NULL);
< }
< static void fontsizeminus1_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 12, NULL);
< }
< static void preformatted_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 13, NULL);
< }
< static void subscript_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 14, NULL);
< }
< static void superscript_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 15, NULL);
< }
< static void strong_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 16, NULL);
< }
< static void emphasis_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 17, NULL);
< }
< static void heading1_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 18, NULL);
< }
< static void heading2_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 19, NULL);
< }
< static void heading3_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 20, NULL);
< }
< static void heading4_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 21, NULL);
< }
< static void heading5_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 22, NULL);
< }
< static void heading6_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 23, NULL);
< }
< static void table_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 24, NULL);
< }
< static void tablerow_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 25, NULL);
< }
< static void tableheader_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 26, NULL);
< }
< static void tabledata_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 27, NULL);
< }
< static void tablecaption_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 28, NULL);
< }
< static void frameset_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 29, NULL);
< }
< static void frame_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 30, NULL);
< }
< static void noframes_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 31, NULL);
< }
< static void target_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 32, NULL);
< }
< static void unorderedlist_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 33, NULL);
< }
< static void orderedlist_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 34, NULL);
< }
< static void listitem_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 35, NULL);
< }
< static void definitionlist_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 36, NULL);
< }
< static void definitionterm_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 37, NULL);
< }
< static void definition_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 38, NULL);
< }
< static void style_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 42, NULL);
< }
< static void dfn_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 48, NULL);
< }
< static void code_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 49, NULL);
< }
< static void samp_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 50, NULL);
< }
< static void kbd_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 51, NULL);
< }
< static void var_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 52, NULL);
< }
< static void cite_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 53, NULL);
< }
< static void abbr_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 54, NULL);
< }
< static void acronym_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	general_html_menu_cb(bfwin, 55, NULL);
< }
< 
< static void quickstart_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< #ifdef HAVE_ATLEAST_GTK_2_4
< 	quickstart_dialog_new(bfwin);
< #else
< 	quickstart_dialog(bfwin,NULL);
< #endif
< }
< static void body_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	body_dialog(bfwin,NULL);
< }
< static void quickanchor_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	DEBUG_MSG("quickanchor_clicked_lcb, calling quickanchor_dialog with bfwin=%p and data=NULL\n",bfwin);
< 	quickanchor_dialog(bfwin, NULL);
< }
< static void quickrule_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	quickrule_dialog(bfwin,NULL);
< }
< static void email_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	email_dialog(bfwin,NULL);
< }
< static void fontdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	font_dialog(bfwin,NULL);
< }
< static void basefont_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	basefont_dialog(bfwin,NULL);
< }
< static void framesetdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	frameset_dialog(bfwin,NULL);
< }
< static void framedialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	frame_dialog(bfwin,NULL);
< }
< static void quicklist_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	quicklist_dialog(bfwin,NULL);
< }
< static void link_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	linkdialog_dialog(bfwin,NULL,linkdialog_mode_css);
< }
< static void formdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	formdialog_dialog(bfwin,NULL);
< }
< static void inputbuttondialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	inputdialog_dialog(bfwin, NULL, "submit");
< }
< static void textdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	inputdialog_dialog(bfwin, NULL, "text");
< }
< static void hiddendialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	inputdialog_dialog(bfwin, NULL, "hidden");
< }
< static void textareadialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	textareadialog_dialog(bfwin,NULL);
< }
< static void radiodialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	inputdialog_dialog(bfwin, NULL, "radio");
< }
< static void checkdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	inputdialog_dialog(bfwin, NULL, "checkbox");
< }
< static void selectdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	selectdialog_dialog(bfwin,NULL);
< }
< static void optiondialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	optiondialog_dialog(bfwin,NULL);
< }
< static void optgroupdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	optgroupdialog_dialog(bfwin,NULL);
< }
< static void buttondialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	buttondialog_dialog(bfwin,NULL);
< }
< static void image_insert_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	image_insert_dialog(bfwin,NULL);
< }
< static void thumbnail_insert_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	thumbnail_insert_dialog(bfwin);
< }
< static void multi_thumbnail_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	multi_thumbnail_dialog(bfwin);
< }
< static void tabledialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	tabledialog_dialog(bfwin,NULL);
< }
< static void tablerowdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	tablerowdialog_dialog(bfwin,NULL);
< }
< static void tableheaddialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	tableheaddialog_dialog(bfwin,NULL);
< }
< static void tabledatadialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	tabledatadialog_dialog(bfwin,NULL);
< }
< static void tablewizard_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	tablewizard_dialog(bfwin);
< }
< static void framewizard_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	framewizard_dialog(bfwin);
< }
< static void span_dialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	span_dialog(bfwin,NULL);
< }
< static void div_dialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	div_dialog(bfwin,NULL);
< }
< 
< 
< static Ttoolbaritem tbi[] = {
< 	{"quickstart...", quickstart_clicked_lcb,13 , N_("QuickStart...")},
< 	{"body...", body_clicked_lcb, 14, N_("Body...")},
< 	{"bold", bold_clicked_lcb,  15, N_("Bold")},
< 	{"italic", italic_clicked_lcb,  16, N_("Italic")},
< 	{"paragraph", paragraph_clicked_lcb,  19, N_("Paragraph")},
< 	{"break", break_clicked_lcb,  20, N_("Break")},
< 	{"breakclear", breakclear_clicked_lcb,  21, N_("Break and clear")},
< 	{"nbsp", nbsp_clicked_lcb,  22, N_("Non-breaking space")},
< 	{"", NULL, 0, NULL}, /* spacing */
< 	{"anchor...", quickanchor_clicked_lcb,23 , N_("Anchor...")},
< 	{"rule...", quickrule_clicked_lcb, 24, N_("Rule...")},
< 	{"center", center_clicked_lcb,  28, N_("Center")},
< 	{"rightjustify", rightjustify_clicked_lcb,  29, N_("Right Justify")},
< 	{"comment", comment_clicked_lcb, 30 , N_("Comment")},
< 	{"email...", email_clicked_lcb, 31, N_("E-mail...")},
< 	{"font...",fontdialog_clicked_lcb , 32, N_("Font...")},
< 	{"basefont...", basefont_clicked_lcb, 33, N_("Base Font Size...")},
< 	{"", NULL, 0, NULL}, /* spacing */
< 	{"fontsize+1", fontsizeplus1_clicked_lcb, 34 , N_("Font Size +1")},
< 	{"fontsize-1", fontsizeminus1_clicked_lcb,  35, N_("Font Size -1")},
< 	{"preformatted", preformatted_clicked_lcb,  36, N_("Preformatted Text")},
< 	{"subscript", subscript_clicked_lcb,  37, N_("Subscript")},
< 	{"superscript", superscript_clicked_lcb,  38, N_("Superscript")},
< 	{"strong", strong_clicked_lcb,  15, N_("Strong")},
< 	{"emphasis", emphasis_clicked_lcb,  16, N_("Emphasis")},
< 	{"", NULL, 0, NULL}, /* spacing */
< 	{"heading1", heading1_clicked_lcb,  39, N_("Heading 1")},
< 	{"heading2", heading2_clicked_lcb,  40, N_("Heading 2")},
< 	{"heading3", heading3_clicked_lcb,  41, N_("Heading 3")},
< 	{"heading4", heading4_clicked_lcb,  42, N_("Heading 4")},
< 	{"heading5", heading5_clicked_lcb,  43, N_("Heading 5")},
< 	{"heading6", heading6_clicked_lcb,  44, N_("Heading 6")},
< 	{"tablewizard...",tablewizard_clicked_lcb, 45, N_("Table Wizard...")},
< 	{"", NULL, 0, NULL}, /* spacing */
< 	{"table...",tabledialog_clicked_lcb, 46, N_("Table...")},
< 	{"tablerow...", tablerowdialog_clicked_lcb, 47, N_("Table Row...")},
< 	{"tableheader...", tableheaddialog_clicked_lcb, 48, N_("Table Header...")},
< 	{"tabledata...", tabledatadialog_clicked_lcb, 49, N_("Table Data...")},
< 	{"", NULL, 0, NULL}, /* spacing */
< 	{"table", table_clicked_lcb,  50, N_("Table")},
< 	{"tablerow", tablerow_clicked_lcb,  51, N_("Table Row")},
< 	{"tableheader", tableheader_clicked_lcb,  52, N_("Table Header")},
< 	{"tabledata", tabledata_clicked_lcb,  53, N_("Table Data")},
< 	{"tablecaption", tablecaption_clicked_lcb,  54, N_("Table Caption")},
< 	{"framewizard...",framewizard_clicked_lcb , 55, N_("Frame Wizard...")},
< 	{"", NULL, 0, NULL}, /* spacing */
< 	{"frameset...", framesetdialog_clicked_lcb,56 , N_("Frameset...")},
< 	{"frame...",framedialog_clicked_lcb , 57, N_("Frame...")},
< 	{"", NULL, 0, NULL}, /* spacing */
< 	{"frameset", frameset_clicked_lcb, 58 , N_("Frameset")},
< 	{"frame", frame_clicked_lcb,  59, N_("Frame")},
< 	{"noframes", noframes_clicked_lcb,  60, N_("Noframes")},
< 	{"target", target_clicked_lcb,  61, N_("Target")},
< 	{"form...",formdialog_clicked_lcb , 62, N_("Form...")},
< 	{"inputbutton...", inputbuttondialog_clicked_lcb, 63, N_("Input Button...")},
< 	{"text...",textdialog_clicked_lcb , 65, N_("Input Text...")},
< 	{"hidden...", hiddendialog_clicked_lcb, 66, N_("Input Hidden...")},
< 	{"textarea...",textareadialog_clicked_lcb , 67, N_("Textarea...")},
< 	{"radiobutton...", radiodialog_clicked_lcb, 68, N_("Input Radio Button...")},
< 	{"checkbox...", checkdialog_clicked_lcb, 69, N_("Input Check Box...")},
< 	{"select...", selectdialog_clicked_lcb, 70, N_("Select...")},
< 	{"option...",optiondialog_clicked_lcb , 71, N_("Option...")},
< 	{"optiongroup...", optgroupdialog_clicked_lcb, 72, N_("Option group...")},
< 	{"button...", buttondialog_clicked_lcb, 63, N_("Button...")},
< 	{"quicklist...", quicklist_clicked_lcb, 73, N_("Quick List...")},
< 	{"unorderedlist", unorderedlist_clicked_lcb,  74, N_("Unordered List")},
< 	{"orderedlist", orderedlist_clicked_lcb,  75, N_("Ordered List")},
< 	{"listitem", listitem_clicked_lcb,  76, N_("List Item")},
< 	{"definitionlist", definitionlist_clicked_lcb,  77, N_("Definition List")},
< 	{"definitionterm", definitionterm_clicked_lcb,  78, N_("Definition Term")},
< 	{"definition", definition_clicked_lcb,  79, N_("Definition")},
< 	{"createstylesheet...", new_css_dialog, 85, N_("Create stylesheet...")},
< 	{"span...", span_dialog_clicked_lcb,86 , N_("Span...")},
< 	{"div...",div_dialog_clicked_lcb,87 , N_("Div...")},
< 	{"style", style_clicked_lcb, 89, N_("Style")},
< 	{"linkstylesheet...", link_clicked_lcb,90 , N_("Link to stylesheet...")},
< 	{"image...", image_insert_clicked_lcb, 25, N_("Insert image...")},
< 	{"thumbnail...", thumbnail_insert_clicked_lcb, 26, N_("Insert thumbnail...")},
< 	{"mthumbnail...", multi_thumbnail_clicked_lcb, 27, N_("Multi thumbnail...")},
< 	{"dfn", dfn_clicked_lcb,  93, N_("Definition")},
< 	{"code", code_clicked_lcb,  94, N_("Code")},
< 	{"samp", samp_clicked_lcb,  95, N_("Sample")},
< 	{"kbd", kbd_clicked_lcb,  96, N_("Keyboard")},
< 	{"var", var_clicked_lcb,  97, N_("Variable")},
< 	{"cite", cite_clicked_lcb,  98, N_("Citation")},
< 	{"abbr", abbr_clicked_lcb,  99, N_("Abbreviation")},
< 	{"acronym", acronym_clicked_lcb,  100, N_("Acronym")},
< 	{"", NULL, 0, NULL} /* spacing */
< };
< 
< static void html_toolbar_remove_from_quickbar_lcb(GtkMenuItem *menuitem, Ttoolbaritem *tbitem) {
< 	GList *bfwlist;
< 	main_v->globses.quickbar_items = remove_from_stringlist(main_v->globses.quickbar_items, tbitem->ident);
< 	bfwlist = g_list_first(main_v->bfwinlist);
< 	while (bfwlist) {
< 		Tquickbaritem *qbi=NULL;
< 		Tbfwin *bfwin = BFWIN(bfwlist->data);
< 		GList *tmplist  = g_list_first(bfwin->toolbar_quickbar_children);
< 		while (tmplist) {
< 			qbi = tmplist->data;
< 			if (qbi->tbitem == tbitem) {
< 				break;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		if (qbi) {
< 			gtk_widget_hide(qbi->button);
< 			gtk_widget_destroy(qbi->button);
< 			g_free(qbi);
< 		}
< 		bfwlist = g_list_next(bfwlist);
< 	}
< }
< 
< /* return the position in the quickbar GList of a tool bar item */
< gint get_quickbar_item_position(Ttoolbaritem *tbitem) {
< 	GList *tmplist, *winlist = g_list_first(main_v->bfwinlist);
< 	gint pos = 0;
< 	tmplist  = g_list_first(BFWIN(winlist->data)->toolbar_quickbar_children);
< 
< 	while (tmplist) {
< 		Tquickbaritem *qbi;
< 		qbi = tmplist->data;
< 		if (qbi->tbitem == tbitem) {
< 			DEBUG_MSG("get_quickbar_item_position, quickbar item is at %d\n", pos);
< 			return pos;
< 		}
< 		pos += 1;
< 		tmplist = g_list_next(tmplist);
< 	}
< 	DEBUG_MSG("get_quickbar_item_position, not found, return -1!\n");
< 	return -1;
< }
< 
< static gboolean html_toolbar_quickbar_item_button_press_lcb(GtkWidget *widget,GdkEventButton *bevent,Ttoolbaritem *tbitem);
< 
< static void html_toolbar_quickbar_switch(Ttoolbaritem *tbitem, gboolean moveright) {
< 	gint pos;
< 
< 	/* first we look for the current location of this item */	
< 	pos = get_quickbar_item_position(tbitem);
< 	DEBUG_MSG("html_toolbar_quickbar_switch, found item %s at pos=%d, config list length=%d\n",tbitem->ident,pos,g_list_length(main_v->globses.quickbar_items));
< 	if (pos >= 0) {
< 		GList *tmp1, *tmp2, *tmplist;
< 		/* then we move this item to the new place in the config list */
< 		tmp1 = g_list_nth(main_v->globses.quickbar_items, pos);
< 		if (!tmp1) {
< 			DEBUG_MSG("html_toolbar_quickbar_switch, nothing found in config list at pos=%d, RETURN\n",pos);
< 			return;
< 		}
< 		tmp2 = (moveright) ? g_list_next(tmp1) : g_list_previous(tmp1);
< 		if (!tmp2) {
< 			DEBUG_MSG("html_toolbar_quickbar_switch, no tmp2 found, moveright=%d, list length=%d RETURN\n",moveright,g_list_length(main_v->globses.quickbar_items));
< 			return;
< 		}
< 		list_switch_order(tmp1, tmp2);
< 		DEBUG_MSG("html_toolbar_quickbar_switch, after list_switch_order, list length=%d\n",g_list_length(main_v->globses.quickbar_items));
< 		
< 		/* now switch the widgets in every window that has a quickbar */
< 		tmplist = g_list_first(main_v->bfwinlist);
< 		while (tmplist) {
< 			Tbfwin *bfwin = BFWIN(tmplist->data);
< 			DEBUG_MSG("html_toolbar_quickbar_switch, checking bfwin=%p\n",bfwin);
< 			if (bfwin->toolbar_quickbar && bfwin->toolbar_quickbar_children) {
< 				Tquickbaritem *qbi1;
< 				DEBUG_MSG("retrieving quickbaritem from pos %d\n",pos);
< 				tmp1 = g_list_nth(bfwin->toolbar_quickbar_children, pos);
< 				tmp2 = (moveright) ? g_list_next(tmp1) : g_list_previous(tmp1);
< 				qbi1 = (Tquickbaritem *)tmp1->data;
< 				list_switch_order(tmp1, tmp2);
< 				DEBUG_MSG("html_toolbar_quickbar_switch, quickbaritem %p has tbitem %s\n",qbi1, qbi1->tbitem->ident);
< 				/* I don't know why the next bit of code doesn't work... bug in gtk? */
< 				/*g_object_ref(G_OBJECT(qbi1->button));
< 				DEBUG_MSG("html_toolbar_quickbar_switch, detaching widget!, button=%p, button->parent=%p, toolbar=%p\n",qbi1->button,qbi1->button->parent,bfwin->toolbar_quickbar);
< 				gtk_container_remove(GTK_CONTAINER(bfwin->toolbar_quickbar),qbi1->button);
< 				DEBUG_MSG("html_toolbar_quickbar_switch, attaching widget at pos %d\n",(moveright)?pos+1:pos-1);
< 				gtk_toolbar_insert_widget(GTK_TOOLBAR(bfwin->toolbar_quickbar),qbi1->button,
< 							_(qbi1->tbitem->tooltiptext),"",(moveright)?pos+1:pos-1);
< 				g_object_unref(G_OBJECT(qbi1->button));
< 				*/
< 				/* this workaround bit of code removes (and thus destroys) the button and creates a new identical button on the new location */
< 				DEBUG_MSG("html_toolbar_quickbar_switch, about to destroy button,(toolbar has %d children)\n",g_list_length(GTK_TOOLBAR(bfwin->toolbar_quickbar)->children));
< 				gtk_container_remove(GTK_CONTAINER(bfwin->toolbar_quickbar),qbi1->button);
< 				DEBUG_MSG("html_toolbar_quickbar_switch, inserting widget at pos %d (toolbar has %d children)\n",(moveright)?pos+1:pos-1, g_list_length(GTK_TOOLBAR(bfwin->toolbar_quickbar)->children));
< 				qbi1->button = gtk_toolbar_insert_item(GTK_TOOLBAR(bfwin->toolbar_quickbar), NULL, _(qbi1->tbitem->tooltiptext),
< 							"", new_pixmap(qbi1->tbitem->pixmaptype), G_CALLBACK(qbi1->tbitem->func), bfwin, (moveright)?pos+1:pos-1);
< 				g_signal_connect(qbi1->button, "button-press-event", G_CALLBACK(html_toolbar_quickbar_item_button_press_lcb), tbitem);
< 				gtk_widget_show(qbi1->button);
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		
< 	}
< }
< 
< static void html_toolbar_quickbar_move_left_lcb(GtkMenuItem *menuitem, Ttoolbaritem *tbitem) {
< 	html_toolbar_quickbar_switch(tbitem, FALSE);
< /*	GList *winlist = g_list_first(main_v->bfwinlist); 
< 	DEBUG_MSG("moving tbitem %p left on quickbars\n", tbitem);
< 	while (winlist) {
< 		GList *tmplist;
< 		gint pos;
< 		Tbfwin *bfwin = BFWIN(winlist->data);
< 		Tquickbaritem *qbi;
< 
< 		pos = get_quickbar_item_position(tbitem);
< 		tmplist = g_list_nth(bfwin->toolbar_quickbar_children, pos);
< 		qbi = tmplist->data;
< 
< 		if (qbi) {
< 			if (pos) { / * pos > 0 * /
< 				gtk_widget_destroy(qbi->button);
< 			}
< 			g_free(qbi);
< 		}
< 		
< 		if (pos) {
< 			GList *other;
< 			qbi = g_new(Tquickbaritem,1);
< 			qbi->button = gtk_toolbar_insert_item(GTK_TOOLBAR(bfwin->toolbar_quickbar), NULL, _(tbitem->tooltiptext),
< 							"", new_pixmap(tbitem->pixmaptype), G_CALLBACK(tbitem->func), bfwin, pos-1);
< 			g_signal_connect(qbi->button, "button-press-event", G_CALLBACK(html_toolbar_quickbar_item_button_press_lcb), tbitem);
< 			gtk_widget_show(qbi->button);
< 			qbi->tbitem = tbitem;
< 			
< 			other = g_list_previous(tmplist);
< 			list_switch_order(tmplist, other);
< 			
< 			tmplist = g_list_nth(main_v->globses.quickbar_items, pos);
< 			other = g_list_previous(tmplist);
< 			list_switch_order(tmplist, other);
< 			g_list_free(tmplist);
< 			g_list_free(other);
< 		}
< 		winlist = g_list_next(winlist);
< 	}
< 	 we don't create this list here so we don't need to free it!!
< 	g_list_free(winlist);*/
< }
< 
< static void html_toolbar_quickbar_move_right_lcb(GtkMenuItem *menuitem, Ttoolbaritem *tbitem) {
< 	html_toolbar_quickbar_switch(tbitem, TRUE);
< /*	GList *winlist = g_list_first(main_v->bfwinlist); 
< 	DEBUG_MSG("moving tbitem %p right on quickbars\n", tbitem);
< 	while (winlist) {
< 		gint pos;
< 		GList *tmplist, *other;
< 		Tbfwin *bfwin = BFWIN(winlist->data);
< 		Tquickbaritem *qbi;
< 		pos = get_quickbar_item_position(tbitem);
< 		tmplist = g_list_nth(bfwin->toolbar_quickbar_children, pos);
< 		qbi = tmplist->data;
< 
< 		if (qbi) {
< 			gtk_widget_hide(qbi->button);
< 			gtk_widget_destroy(qbi->button);
< 			g_free(qbi);
< 		}
< 		
< 		qbi = g_new(Tquickbaritem,1);
< 		qbi->button = gtk_toolbar_insert_item(GTK_TOOLBAR(bfwin->toolbar_quickbar), NULL, _(tbitem->tooltiptext),
< 							"", new_pixmap(tbitem->pixmaptype), G_CALLBACK(tbitem->func), bfwin, pos+1);
< 		g_signal_connect(qbi->button, "button-press-event", G_CALLBACK(html_toolbar_quickbar_item_button_press_lcb), tbitem);
< 		gtk_widget_show(qbi->button);
< 		qbi->tbitem = tbitem;
< 		
< 		other = g_list_next(tmplist);
< 		list_switch_order(tmplist, other);
< 			
< 		tmplist = g_list_nth(main_v->globses.quickbar_items, pos);
< 		other = g_list_next(tmplist);
< 		list_switch_order(tmplist, other);
< 		g_list_free(tmplist);
< 		g_list_free(other);
< 		
< 		winlist = g_list_next(winlist);
< 	}
< 	/ * g_list_free(winlist); */
< }
< 
< static gboolean html_toolbar_quickbar_item_button_press_lcb(GtkWidget *widget,GdkEventButton *bevent,Ttoolbaritem *tbitem) {
< 	if (bevent->button == 3) {
< 		GtkWidget *menu = gtk_menu_new ();
< 		GtkWidget *menuitem = gtk_menu_item_new_with_label(_("Remove from quickbar"));
< 		GtkWidget *itemleft = gtk_menu_item_new_with_label(_("Move Left"));
< 		GtkWidget *itemright = gtk_menu_item_new_with_label(_("Move Right"));
< 		GtkWidget *sep = gtk_separator_menu_item_new();
< 		DEBUG_MSG("popup for tbitem %p\n", tbitem);
< 		g_signal_connect(G_OBJECT(menuitem), "activate", G_CALLBACK(html_toolbar_remove_from_quickbar_lcb), tbitem);
< 		g_signal_connect(G_OBJECT(itemleft), "activate", G_CALLBACK(html_toolbar_quickbar_move_left_lcb), tbitem);
< 		g_signal_connect(G_OBJECT(itemright), "activate", G_CALLBACK(html_toolbar_quickbar_move_right_lcb), tbitem);
< 		gtk_menu_append(GTK_MENU(menu), itemleft);
< 		gtk_menu_append(GTK_MENU(menu), itemright);
< 		gtk_menu_append(GTK_MENU(menu), sep);
< 		gtk_menu_append(GTK_MENU(menu), menuitem);
< 		gtk_widget_show_all (menu);
< 		gtk_menu_popup (GTK_MENU (menu), NULL, NULL,
< 			  NULL, widget, 0, gtk_get_current_event_time ());
< 		return TRUE;
< 	}
< 	return FALSE;
< }
< 
< static void html_toolbar_add_to_quickbar_lcb(GtkMenuItem *menuitem, Ttoolbaritem *tbitem) {
< 	GList *tmplist = g_list_first(main_v->bfwinlist);
< 	DEBUG_MSG("adding tbitem %p to quickbars\n", tbitem);
< 	main_v->globses.quickbar_items = add_to_stringlist(main_v->globses.quickbar_items, tbitem->ident);
< 	while (tmplist) {
< 		Tquickbaritem *qbi;
< 		Tbfwin *bfwin = BFWIN(tmplist->data);
< 		qbi = g_new(Tquickbaritem,1);
< 		qbi->button = gtk_toolbar_append_item(GTK_TOOLBAR(bfwin->toolbar_quickbar), NULL, _(tbitem->tooltiptext),
< 							"", new_pixmap(tbitem->pixmaptype), G_CALLBACK(tbitem->func), bfwin);
< 		g_signal_connect(qbi->button, "button-press-event", G_CALLBACK(html_toolbar_quickbar_item_button_press_lcb), tbitem);
< 		gtk_widget_show(qbi->button);
< 		qbi->tbitem = tbitem;
< 		bfwin->toolbar_quickbar_children = g_list_append(bfwin->toolbar_quickbar_children, qbi);
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< static gboolean html_toolbar_item_button_press_lcb(GtkWidget *widget,GdkEventButton *bevent,Ttoolbaritem *tbitem) {
< 	DEBUG_MSG("html_toolbar_item_button_press_lcb, button=%d\n", bevent->button);
< 	if (bevent->button == 3) {
< 		GtkWidget *menu = gtk_menu_new ();
< 		GtkWidget *menuitem = gtk_menu_item_new_with_label(_("Add to quickbar"));
< 		DEBUG_MSG("popup for tbitem %p\n", tbitem);
< 		g_signal_connect(G_OBJECT(menuitem), "activate", G_CALLBACK(html_toolbar_add_to_quickbar_lcb), tbitem);
< 		gtk_menu_append(GTK_MENU(menu), menuitem);
< 		gtk_widget_show_all (menu);
< 		gtk_menu_popup (GTK_MENU (menu), NULL, NULL,
< 			  NULL, widget, 0, gtk_get_current_event_time ());
< 		return TRUE;
< 	}
< 	return FALSE;
< }
< 
< static void html_toolbar_add_items(Tbfwin *bfwin, GtkWidget *html_toolbar, Ttoolbaritem *tbi, gint from, gint to) {
< 	gint i;
< 	GtkWidget *item;
< 	for (i=from;i<=to;i++) {
< 		if (tbi[i].func == NULL) {
< 			gtk_toolbar_append_space(GTK_TOOLBAR(html_toolbar));
< 		} else {
< 			item = gtk_toolbar_append_item(GTK_TOOLBAR(html_toolbar), NULL, _(tbi[i].tooltiptext),
< 						NULL, new_pixmap(tbi[i].pixmaptype), G_CALLBACK(tbi[i].func), bfwin);
< 			g_signal_connect(item, "button-press-event", G_CALLBACK(html_toolbar_item_button_press_lcb), &tbi[i]);
< 			DEBUG_MSG("adding tbitem %p to html_toolbar\n", &tbi[i]);
< 		}
< 	}
< }
< 
< static void html_toolbar_add_items_to_submenu(Tbfwin *bfwin, GtkWidget *html_toolbar, Ttoolbaritem *tbi, gint from, gint to, gchar *menulabel, gint menupix) {
< 	GtkWidget *menu_bar, *sub_menu, *menu_item, *pixmap;
< 	GtkTooltips *tooltips;
< 	gint i;
< 	
< 	tooltips = gtk_tooltips_new();	
< 	sub_menu = gtk_menu_new();
< 	for (i=from;i<=to;i++) {
< 		if (tbi[i].func == NULL) {
< 			gtk_toolbar_append_space(GTK_TOOLBAR(html_toolbar));
< 		} else {
< 			menu_item = gtk_menu_item_new();
< 			gtk_tooltips_set_tip(GTK_TOOLTIPS(tooltips), menu_item, _(tbi[i].tooltiptext), NULL);
< 			gtk_container_add(GTK_CONTAINER(menu_item), new_pixmap(tbi[i].pixmaptype));
< 			g_signal_connect(GTK_OBJECT(menu_item), "activate", G_CALLBACK(tbi[i].func), bfwin);
< 			g_signal_connect(menu_item, "button-press-event", G_CALLBACK(html_toolbar_item_button_press_lcb), &tbi[i]);
< 			gtk_menu_append(GTK_MENU(sub_menu), menu_item);
< 		}
< 	}
< 	menu_bar = gtk_menu_bar_new();
< 	menu_item = gtk_menu_item_new();
< 	gtk_container_add(GTK_CONTAINER(menu_item),new_pixmap(menupix));
< 	gtk_menu_item_set_submenu(GTK_MENU_ITEM(menu_item), sub_menu);
< 	gtk_menu_bar_append(GTK_MENU_BAR(menu_bar), menu_item);
< 	pixmap = new_pixmap(menupix);
< 	gtk_toolbar_append_element(GTK_TOOLBAR(html_toolbar),GTK_TOOLBAR_CHILD_WIDGET,menu_bar,NULL,menulabel,NULL,pixmap,NULL,NULL);
< 	gtk_object_sink(GTK_OBJECT(pixmap));
< }
< 
< void make_html_toolbar(Tbfwin *bfwin) {
< /*
<  * every item with a ... in the tooltip brings up a dialog, every item
<  * without the ... in the tooltip will directly insert html code
<  *
<  */
< 	GtkWidget *html_toolbar, *html_notebook;
< 
< 	DEBUG_MSG("make_html_toolbar, started\n");
< 	html_notebook = gtk_notebook_new();
< 	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(html_notebook), GTK_POS_TOP);
< 	gtk_notebook_set_show_tabs(GTK_NOTEBOOK(html_notebook), TRUE);
< 	gtk_notebook_set_show_border(GTK_NOTEBOOK(html_notebook), TRUE);
< 	gtk_container_add(GTK_CONTAINER(bfwin->html_toolbar_hb), html_notebook);
< 
< 	bfwin->toolbar_quickbar = gtk_toolbar_new();
< 	gtk_toolbar_set_style(GTK_TOOLBAR(bfwin->toolbar_quickbar), GTK_TOOLBAR_ICONS);
< 	DEBUG_MSG("make_html_toolbar, creating quickbar\n");
< 	{
< 		GList *tmplist;
< 		gint i, numitems=(sizeof(tbi)/sizeof(Ttoolbaritem));
< 		tmplist = g_list_first(main_v->globses.quickbar_items);
< 		while (tmplist) {
< 			gchar *tmpstr = tmplist->data;
< 			DEBUG_MSG("make_html_toolbar, searching for %s\n", tmpstr);
< 			for (i=0;i<numitems;i++) {
< 				if (strcmp(tbi[i].ident, tmpstr)==0) {
< 					Tquickbaritem *qbi = g_new(Tquickbaritem,1);
< 					qbi->button = gtk_toolbar_append_item(GTK_TOOLBAR(bfwin->toolbar_quickbar), NULL, _(tbi[i].tooltiptext),
< 						"", new_pixmap(tbi[i].pixmaptype), G_CALLBACK(tbi[i].func), bfwin);
< 					g_signal_connect(qbi->button, "button-press-event", G_CALLBACK(html_toolbar_quickbar_item_button_press_lcb), &tbi[i]);
< 					qbi->tbitem = &tbi[i];
< 					bfwin->toolbar_quickbar_children = g_list_append(bfwin->toolbar_quickbar_children, qbi);
< 					DEBUG_MSG("make_html_toolbar, appended %s as quickbaritem %p to quickbar %p\n",qbi->tbitem->ident, qbi,bfwin->toolbar_quickbar);
< 					break;
< 				}
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), bfwin->toolbar_quickbar, gtk_label_new(_(" Quick bar ")));
< 
< 	html_toolbar = gtk_toolbar_new();
< 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
< 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 0, 14);
< 	html_toolbar_add_items_to_submenu(bfwin,html_toolbar, tbi, 26, 31, _("Heading"), 91);
< 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 76, 78);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" Standard bar ")));
< 
< 	html_toolbar = gtk_toolbar_new();
< 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
< 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 15, 25);
< 	html_toolbar_add_items_to_submenu(bfwin,html_toolbar, tbi, 79, 86, _("Context formatting"), 103);
< 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 25, 31);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" Fonts ")));
< 
< 	html_toolbar = gtk_toolbar_new();
< 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
< 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 32, 43);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" Tables ")));
< 
< 	html_toolbar = gtk_toolbar_new();
< 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
< 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 44, 52);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" Frames ")));
< 
< 	html_toolbar = gtk_toolbar_new();
< 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
< 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 53, 63);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" Forms ")));
< 
< 	html_toolbar = gtk_toolbar_new();
< 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
< 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 64, 70);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" List ")));
< 
< 	html_toolbar = gtk_toolbar_new();
< 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
< 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 71, 73);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" CSS ")));
< 
< 	gtk_widget_show_all(html_notebook);
< 	
< 	if (main_v->globses.quickbar_items == NULL) {
< 		gtk_notebook_set_current_page (GTK_NOTEBOOK (html_notebook), 1);
< 	}
< }
< 
< static void doc_indent_lcb(GtkWidget *wid,Tbfwin *bfwin) {
< 	if (bfwin->current_document) {
< 		doc_indent_selection(bfwin->current_document,0);
< 	}
< }
< static void doc_unindent_lcb(GtkWidget *wid,Tbfwin *bfwin) {
< 	if (bfwin->current_document) {
< 		doc_indent_selection(bfwin->current_document,1);
< 	}
< }
< 	
< 
< 
< void make_main_toolbar(Tbfwin *bfwin) {
< 	GtkWidget *toolbar = gtk_toolbar_new ();
< 	DEBUG_MSG("make_main_toolbar, started\n");
< 	gtk_toolbar_set_orientation (GTK_TOOLBAR (toolbar), GTK_ORIENTATION_HORIZONTAL);
< 	gtk_toolbar_set_style (GTK_TOOLBAR (toolbar), GTK_TOOLBAR_ICONS);
< 	gtk_toolbar_set_icon_size (GTK_TOOLBAR (toolbar), GTK_ICON_SIZE_LARGE_TOOLBAR);
< 	gtk_container_add (GTK_CONTAINER(bfwin->main_toolbar_hb), toolbar);
< 
< 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_NEW, _("New"),
< 								"", G_CALLBACK(file_new_cb), bfwin, -1);
< 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_OPEN, _("Open..."),
< 								"", G_CALLBACK(file_open_cb), bfwin, -1);
< 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_SAVE, _("Save"),
< 								"", G_CALLBACK(file_save_cb), bfwin, -1);
< 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_SAVE_AS, _("Save As..."),	
< 								"", G_CALLBACK(file_save_as_cb), bfwin, -1);
< 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_CLOSE, _("Close"),	
< 								"", G_CALLBACK(file_close_cb), bfwin, -1);		
< 	gtk_toolbar_append_space (GTK_TOOLBAR (toolbar));
< 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_CUT, _("Cut"),	
< 								"", G_CALLBACK(edit_cut_cb), bfwin, -1);
< 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_COPY, _("Copy"),	
< 								"", G_CALLBACK(edit_copy_cb), bfwin, -1);
< 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_PASTE, _("Paste"),	
< 								"", G_CALLBACK(edit_paste_cb), bfwin, -1);
< 	gtk_toolbar_append_space (GTK_TOOLBAR (toolbar));								
< 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_FIND, _("Find..."),	
< 								"", G_CALLBACK(search_cb), bfwin, -1);
< 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_FIND_AND_REPLACE, _("Replace..."),	
< 								"", G_CALLBACK(replace_cb), bfwin, -1);
< 	gtk_toolbar_append_space (GTK_TOOLBAR (toolbar));								
< 	bfwin->toolbar_undo = gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_UNDO, _("Undo"),	
< 								"", G_CALLBACK(undo_cb), bfwin, -1);
< 	bfwin->toolbar_redo = gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_REDO, _("Redo"),	
< 								"", G_CALLBACK(redo_cb), bfwin, -1);
< 	gtk_toolbar_append_space (GTK_TOOLBAR(toolbar));
< #ifdef HAVE_ATLEAST_GTK_2_4
<    gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_UNINDENT, _("Shift Left"), 
<                         "", G_CALLBACK (doc_unindent_lcb), bfwin, -1);
<    gtk_toolbar_insert_stock (GTK_TOOLBAR( toolbar), GTK_STOCK_INDENT, _("Shift Right"),
<                         "", G_CALLBACK (doc_indent_lcb), bfwin, -1);
< #else
< 	gtk_toolbar_append_item(GTK_TOOLBAR(toolbar), NULL, _("Shift Left"),
<                         "", new_pixmap(111), G_CALLBACK(doc_unindent_lcb), bfwin);
< 	gtk_toolbar_append_item(GTK_TOOLBAR(toolbar), NULL, _("Shift Right"),
<                         "", new_pixmap(110), G_CALLBACK(doc_indent_lcb), bfwin);
< #endif
< /*
< 	gtk_toolbar_append_item(GTK_TOOLBAR(toolbar), NULL, _("Print..."), "",
< 							new_pixmap(015), G_CALLBACK(file_print_cb), NULL);*/
< #ifdef HAVE_LIBASPELL
< 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_SPELL_CHECK, _("Spellcheck..."),
< 							"", G_CALLBACK(spell_check_cb), bfwin, -1);
< #endif /* HAVE_LIBASPELL */
< 
< 	gtk_toolbar_append_item(GTK_TOOLBAR(toolbar), NULL,
< 							_("View in browser"), "",
< 							new_pixmap(102), G_CALLBACK(browser_toolbar_cb), bfwin);
< 	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
< 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_PREFERENCES, _("Preferences..."),	
< 								"", G_CALLBACK(open_preferences_cb), NULL, -1);	
< 
< 	gtk_widget_show_all(toolbar);
< }
< 
< void gui_set_undo_redo_widgets(Tbfwin *bfwin, gboolean undo, gboolean redo) {
< 	if (GTK_WIDGET_VISIBLE(bfwin->main_toolbar_hb)) {
< 		gtk_widget_set_sensitive(bfwin->toolbar_redo, redo);
< 		gtk_widget_set_sensitive(bfwin->toolbar_undo, undo);
< 	}
< 	
< 	menuitem_set_sensitive(bfwin->menubar, "/Edit/Undo", undo);
< 	menuitem_set_sensitive(bfwin->menubar, "/Edit/Undo All", undo);
< 	menuitem_set_sensitive(bfwin->menubar, "/Edit/Redo", redo);
< 	menuitem_set_sensitive(bfwin->menubar, "/Edit/Redo All", redo);
< }
< 
< void gui_set_document_widgets(Tdocument *doc) {
< 	GtkItemFactory *tmp1 = gtk_item_factory_from_widget(BFWIN(doc->bfwin)->menubar);
< 	setup_toggle_item(tmp1,("/Document/Highlight Syntax"), (doc->highlightstate && doc->hl->highlightlist != NULL));
< 	/*gtk_widget_set_sensitive(gtk_item_factory_get_widget(tmp1,_("/Document/Highlight Syntax")), (doc->hl->highlightlist != NULL));*/
< 	gui_set_undo_redo_widgets(doc->bfwin, doc_has_undo_list(doc), doc_has_redo_list(doc));
< 	setup_toggle_item(gtk_item_factory_from_widget(BFWIN(doc->bfwin)->menubar),"/Document/Wrap", doc->wrapstate);
< 	setup_toggle_item(gtk_item_factory_from_widget(BFWIN(doc->bfwin)->menubar),"/Document/Line Numbers", doc->linenumberstate);
< 	setup_toggle_item(gtk_item_factory_from_widget(BFWIN(doc->bfwin)->menubar),"/Document/Auto Close HTML tags", doc->autoclosingtag);
< 	menu_current_document_set_toggle_wo_activate(BFWIN(doc->bfwin),doc->hl, doc->encoding);
< }
< 
< void gui_notebook_bind_signals(Tbfwin *bfwin) {
< 	bfwin->notebook_switch_signal = g_signal_connect_after(G_OBJECT(bfwin->notebook),"switch-page",G_CALLBACK(notebook_switch_page_lcb), bfwin);
< }
< 
< void gui_notebook_unbind_signals(Tbfwin *bfwin) {
< if (bfwin->notebook_switch_signal != 0) {
< 		g_signal_handler_disconnect(G_OBJECT(bfwin->notebook),bfwin->notebook_switch_signal);
< 		bfwin->notebook_switch_signal = 0;
< 	}
< }
< 
< static gboolean gui_main_window_configure_event_lcb(GtkWidget *widget,GdkEvent *revent,Tbfwin *bfwin) {
< 	if (main_v->props.restore_dimensions) {
< 		if (revent->type == GDK_CONFIGURE) {
< 			GdkEventConfigure *event = (GdkEventConfigure *)revent;
< 			if (main_v->globses.main_window_w > 0 ) {
< 				main_v->globses.main_window_w = event->width;
< 				main_v->globses.main_window_h = event->height;
< 				DEBUG_MSG("gui_main_window_configure_event_lcb, width=%d, height=%d\n",main_v->globses.main_window_w,main_v->globses.main_window_h);
< 			}
< 		} else if (revent->type == GDK_WINDOW_STATE) {
< 			GdkEventWindowState *event = (GdkEventWindowState *)revent;
< 			if (event->new_window_state == GDK_WINDOW_STATE_MAXIMIZED && main_v->globses.main_window_w > 0) {
< 				main_v->globses.main_window_w = -1 * main_v->globses.main_window_w; /* negative means it is maximized !! */
< 				DEBUG_MSG("gui_main_window_configure_event_lcb, maximized!! width=%d\n",main_v->globses.main_window_w);
< 			} else if (event->new_window_state != GDK_WINDOW_STATE_MAXIMIZED && main_v->globses.main_window_w < 0) {
< 				main_v->globses.main_window_w = -1 * main_v->globses.main_window_w; /* make it positive again */
< 				DEBUG_MSG("gui_main_window_configure_event_lcb, NOT-maximized, width=%d\n",main_v->globses.main_window_w);
< 			}
< 		}
< 	}
< 	return FALSE;
< }
< 
< enum {
< TARGET_URI_LIST,
< TARGET_STRING
< } Tdnd_types;
< static void main_win_on_drag_data_lcb(GtkWidget * widget, GdkDragContext * context
< 			, gint x, gint y, GtkSelectionData * data
< 			, guint info, guint time, Tbfwin *bfwin) {
< 	gchar *filename, *url;
< 	int mode = 0;
< 	gint url_is_local;
< 
< 	if ((data->length == 0) || (data->format != 8) || ((info != TARGET_STRING) && (info != TARGET_URI_LIST))) {
< 		DEBUG_MSG("on_drag_data_cb, currently unknown DnD object, need to do string comparision\n");
< 		gtk_drag_finish(context, FALSE, TRUE, time);
< 		return;
< 	}
< 
< 	/* netscape sends URL's labelled as string */
< 	if (info == TARGET_STRING) {
< 		gchar *stringdata = g_strndup((gchar *)data->data, data->length);
< 		if (strchr(stringdata, ':')) {
< 			DEBUG_MSG("on_drag_data_cb, TARGET_STRING contains :, so it's probably an URL\n");
< 			info = TARGET_URI_LIST;
< 		}
< 		g_free(stringdata);
< 	}
< 
< 	/* construct both filename and url from the given data */
< 	if (info == TARGET_STRING) {
< 		filename = g_strndup((gchar *)data->data, data->length);
< 		filename = trunc_on_char(trunc_on_char(filename, '\n'), '\r');
< 		url = g_strconcat("file:", filename, NULL);
< 		url_is_local = 1;
< 		DEBUG_MSG("on_drag_data_cb, TARGET_STRING, url=%s\n",url);
< 	} else { /* TARGET_UTI_LIST*/
< 		gchar *tmp2;
< 		gint len;
< 
< 		url = g_strndup((gchar *)data->data, data->length);
< 		url = trunc_on_char(trunc_on_char(url, '\n'), '\r');
< 		if (strncmp(url, "file://", 7) == 0) {
< 			filename = g_strdup(url+7);
< 			url_is_local = 1;
< 			DEBUG_MSG("on_drag_data_cb, TARGET_URI_LIST, url=%s, filename=%s\n",url,filename);
< 		} else {
< 			len = strlen(url);
< 			tmp2 = strrchr(url, '#');
< 			if (tmp2) {
< 				len -= strlen(tmp2);
< 			}
< 			filename = g_strndup(url, len);
< 			url_is_local = 0;
< 			DEBUG_MSG("on_drag_data_cb, TARGET_URI_LIST, url=%s\n",url);
< 		}
< 	}
< 	
< 	DEBUG_MSG("on_drag_data_cb, filename='%s', url='%s'\n", filename, url);
< 	if (g_str_has_suffix (url_is_local ? filename : url, ".bfproject")) {
< 	    project_open_from_file(bfwin, url_is_local ? filename : url);
< 	} else {
< 	    doc_new_with_file(bfwin,url_is_local ? filename : url, FALSE, FALSE);
< 	}
< 
< 	gtk_drag_finish(context, TRUE, (mode == GDK_ACTION_COPY), time);
< 	g_free(filename);
< 	g_free(url);
< }
< 
< void gui_bfwin_cleanup(Tbfwin *bfwin) {
< 	GList *tmplist;
< 	/* call all cleanup functions here */
< 	/*remove_window_entry_from_all_windows(bfwin);*/
< 	
< 	/* all documents have to be freed for this window */
< 	tmplist = g_list_first(bfwin->documentlist);
< 	DEBUG_MSG("gui_bfwin_cleanup, have %d documents in window %p\n",g_list_length(bfwin->documentlist),bfwin);
< 	while (tmplist) {
< 		DEBUG_MSG("gui_bfwin_cleanup closing doc=%p\n",tmplist->data);
< 		doc_destroy(DOCUMENT(tmplist->data), TRUE);
< 		/* no this is not an indefinite loop, because the documents remove themselves
< 		from the documentlist, we remove the top document untill there are no documents
< 		left */
< 		tmplist = g_list_first(bfwin->documentlist);
< 	}
< 	
< 	bmark_cleanup(bfwin);
< }
< 
< void main_window_destroy_lcb(GtkWidget *widget,Tbfwin *bfwin) {
< 	DEBUG_MSG("main_window_destroy_lcb, started\n");
< 	DEBUG_MSG("main_window_destroy_lcb, will hide the window now\n");
< 	gtk_widget_hide(bfwin->main_window);
< 	main_v->bfwinlist = g_list_remove(main_v->bfwinlist, bfwin);
< 	DEBUG_MSG("main_window_destroy_lcb, bfwin(%p) is removed from bfwinlist\n",bfwin);
< 	gui_bfwin_cleanup(bfwin);
< 	DEBUG_MSG("main_window_destroy_lcb, will destroy the window now\n");
< 	gtk_widget_destroy(bfwin->main_window);
< 	g_free(bfwin);
< 	DEBUG_MSG("main_window_destroy_lcb, bfwin is free'ed\n");
< 	if (NULL == main_v->bfwinlist) {
< 		bluefish_exit_request();
< 	}
< }
< gboolean main_window_delete_event_lcb(GtkWidget *widget,GdkEvent *event,Tbfwin *bfwin) {
< 	/* If you return FALSE in the "delete_event" signal handler,
< 	 * GTK will emit the "destroy" signal. Returning TRUE means
< 	 * you don't want the window to be destroyed.
< 	 * This is useful for popping up 'are you sure you want to quit?'
< 	 * type dialogs. */
< 	DEBUG_MSG("main_window_delete_event_lcb, started\n");
< 	if (bfwin->project) {
< 		return !project_save_and_close(bfwin);
< 	} else {
< 		if (bfwin->documentlist && test_docs_modified(bfwin->documentlist)) {
< 			DEBUG_MSG("main_window_delete_event_lcb, we have changed documents!\n");
< 			bfwin_close_all_documents(bfwin, TRUE);
< 			if (bfwin->documentlist && test_docs_modified(bfwin->documentlist)) {
< 				DEBUG_MSG("main_window_delete_event_lcb, we STILL have changed documents!?!\n");
< 				/* if there are still documents modified we should cancel the closing */
< 				return TRUE;
< 			}
< 		} else {
< 			/* no changed documents, but there might be changed bookmarks */
< 			bmark_store_all(bfwin);
< 		}
< 	}
< 	return FALSE;
< }
< 
< void gui_create_main(Tbfwin *bfwin, GList *filenames) {
< 	GtkWidget *vbox;
< 	DEBUG_MSG("gui_create_main, bfwin=%p, bfwin->bookmarkstore=%p\n",bfwin,bfwin->bookmarkstore);
< 	bfwin->main_window = window_full2(_("New Bluefish Window"), GTK_WIN_POS_CENTER, 0, G_CALLBACK(main_window_destroy_lcb), bfwin, FALSE, NULL);
< 	gtk_window_set_role(GTK_WINDOW(bfwin->main_window), "bluefish");
< 	if (main_v->globses.main_window_w > 0) {
< 		gtk_window_set_default_size(GTK_WINDOW(bfwin->main_window), main_v->globses.main_window_w, main_v->globses.main_window_h);
< 	} else {
< 		gtk_window_set_default_size(GTK_WINDOW(bfwin->main_window), main_v->globses.main_window_w * -1, main_v->globses.main_window_h);
< 		gtk_window_maximize(GTK_WINDOW(bfwin->main_window));
< 	}
< 	g_signal_connect(G_OBJECT(bfwin->main_window), "delete_event", G_CALLBACK(main_window_delete_event_lcb), bfwin);
< 	g_signal_connect(G_OBJECT(bfwin->main_window), "configure-event", G_CALLBACK(gui_main_window_configure_event_lcb), bfwin);
< 	g_signal_connect(G_OBJECT(bfwin->main_window), "window-state-event", G_CALLBACK(gui_main_window_configure_event_lcb), bfwin);
< 
< 	vbox = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(bfwin->main_window), vbox);
< 	gtk_widget_show(vbox);
< 
< 	/* first a menubar */
< 	DEBUG_MSG("gui_create_main, starting menu_create_main\n");
< 	menu_create_main(bfwin, vbox);
< 	DEBUG_MSG("gui_create_main, starting recent_menu\n");
< 	recent_menu_init(bfwin);
< 	DEBUG_MSG("gui_create_main, starting external-encoding_menu\n");
< 	external_menu_rebuild(bfwin);
< 	encoding_menu_rebuild(bfwin);
< 	snr2_init(bfwin);
< /*	add_window_entry_to_all_windows(bfwin);
< 	add_allwindows_entries_to_window(bfwin);*/
< 	/* then the toolbars */
< 	{
< 		DEBUG_MSG("gui_create_main, creating handles for all menu/toolbars\n");
< 		bfwin->main_toolbar_hb = gtk_handle_box_new();
< 		gtk_box_pack_start(GTK_BOX(vbox), bfwin->main_toolbar_hb, FALSE, FALSE, 0);
< 		bfwin->html_toolbar_hb = gtk_handle_box_new();
< 		gtk_box_pack_start(GTK_BOX(vbox), bfwin->html_toolbar_hb, FALSE, FALSE, 0);
< 		bfwin->custom_menu_hb = gtk_handle_box_new();
< 		gtk_box_pack_start(GTK_BOX(vbox), bfwin->custom_menu_hb, FALSE, FALSE, 0);
< 
< 		if (bfwin->session->view_main_toolbar) {
< 			make_main_toolbar(bfwin);
< 			gtk_widget_show(bfwin->main_toolbar_hb);
< 		}
< 		if (bfwin->session->view_html_toolbar) {
< 			make_html_toolbar(bfwin);
< 			gtk_widget_show(bfwin->html_toolbar_hb);
< 		}
< 		if (bfwin->session->view_custom_menu) {
< 			make_cust_menubar(bfwin,bfwin->custom_menu_hb);
< 			gtk_widget_show(bfwin->custom_menu_hb);
< 		}
< 	}
< 	
< 	/* then the work area */
< 	bfwin->middlebox = gtk_hbox_new(TRUE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox), bfwin->middlebox, TRUE, TRUE, 0);
< 	gtk_widget_show(bfwin->middlebox);
< 
< 	/* Fake-label (for notebook_hide() and _show() ;) */
< 	bfwin->notebook_fake = gtk_label_new(_("Stand by..."));
< 	
< 	/* notebook with the text widget in there */
< 	bfwin->notebook = gtk_notebook_new();
< 	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(bfwin->notebook),main_v->props.document_tabposition);
< 	gtk_notebook_set_show_tabs(GTK_NOTEBOOK(bfwin->notebook), TRUE);
< 	gtk_notebook_set_show_border(GTK_NOTEBOOK(bfwin->notebook), FALSE);
< 	gtk_notebook_set_tab_hborder(GTK_NOTEBOOK(bfwin->notebook), 0);
< 	gtk_notebook_set_tab_vborder(GTK_NOTEBOOK(bfwin->notebook), 0);
< 	gtk_notebook_popup_enable(GTK_NOTEBOOK(bfwin->notebook));
< 
< 	/* Add notebook and its fake friend to their common hbox. */
< 	bfwin->notebook_box = gtk_hbox_new (TRUE, 0);
< 	gtk_box_pack_start(GTK_BOX(bfwin->notebook_box), bfwin->notebook, TRUE, TRUE, 0);
< 	gtk_box_pack_start(GTK_BOX(bfwin->notebook_box), bfwin->notebook_fake, TRUE, TRUE, 0);
< 
< 	/* output_box */
< 	init_output_box(bfwin, vbox);
< 
< 	left_panel_show_hide_toggle(bfwin,TRUE, (bfwin->session->view_left_panel), FALSE);
< 
< 	/* finally the statusbar */
< 	{
< 		GtkWidget *hbox;
< 		gint onecharwidth;
< 		hbox = gtk_hbox_new(FALSE,0);
< 		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
< 		bfwin->statusbar = gtk_statusbar_new();
< 		gtk_statusbar_set_has_resize_grip(GTK_STATUSBAR(bfwin->statusbar), FALSE);
< 		gtk_box_pack_start(GTK_BOX(hbox), bfwin->statusbar, TRUE, TRUE, 0);
< 		bfwin->statusbar_lncol = gtk_statusbar_new();
< 		gtk_statusbar_set_has_resize_grip(GTK_STATUSBAR(bfwin->statusbar_lncol), FALSE);
< 		gtk_box_pack_start(GTK_BOX(hbox), bfwin->statusbar_lncol, FALSE, FALSE, 0);
< 		/* I hope the 'w' is an average width character */
< 		onecharwidth = widget_get_string_size(bfwin->statusbar_lncol, "w");
< 		gtk_widget_set_size_request(GTK_WIDGET(bfwin->statusbar_lncol), 17*onecharwidth, -1);
< 		bfwin->statusbar_insovr = gtk_statusbar_new();
< 		gtk_statusbar_set_has_resize_grip(GTK_STATUSBAR(bfwin->statusbar_insovr), FALSE);
< 		gtk_box_pack_start(GTK_BOX(hbox), bfwin->statusbar_insovr, FALSE, FALSE, 0);
< 		gtk_widget_set_size_request(GTK_WIDGET(bfwin->statusbar_insovr), onecharwidth * 4, -1);
< 		bfwin->statusbar_editmode = gtk_statusbar_new();
< 		gtk_box_pack_start(GTK_BOX(hbox), bfwin->statusbar_editmode, FALSE, FALSE, 0);
< 		gtk_widget_set_size_request(GTK_WIDGET(bfwin->statusbar_editmode), onecharwidth * 25, -1);
< 		gtk_widget_show_all(hbox);
< 	}
< 	/* We have to know when the notebook changes */
< 	gui_notebook_bind_signals(bfwin);
< 	
< 	/* everything is ready - we can start loading documents */
< 	/* start to open an empty doc */
< 	file_new_cb(NULL, bfwin);
< 	if (filenames) {
< 		DEBUG_MSG("gui_create_main, we have filenames, load them\n");
< 		docs_new_from_files(bfwin,filenames,(bfwin->project != NULL));
< 	}
< 
< 	gtk_notebook_set_current_page(GTK_NOTEBOOK(bfwin->notebook), 0);
< 	gtk_notebook_set_scrollable(GTK_NOTEBOOK(bfwin->notebook), TRUE);
< 	/* don't use show_all since some widgets are and should be hidden */
< 	gtk_widget_show(bfwin->notebook);
< 	gtk_widget_show (bfwin->notebook_box);
< 
< 	{
< 		/* drag n drop support */
< 		const GtkTargetEntry drag_dest_types[] = {
< 			{"text/uri-list", 0, TARGET_URI_LIST },
< 			{"STRING", 0, TARGET_STRING},
< 		};
< 		gtk_drag_dest_set(bfwin->main_window, (GTK_DEST_DEFAULT_ALL)
< 				,drag_dest_types, 2
< 				,(GDK_ACTION_DEFAULT | GDK_ACTION_COPY | GDK_ACTION_MOVE |
< 				GDK_ACTION_LINK | GDK_ACTION_PRIVATE | GDK_ACTION_ASK));
< 		g_signal_connect(G_OBJECT(bfwin->main_window), "drag_data_received", G_CALLBACK(main_win_on_drag_data_lcb), bfwin);
< 	}
< }
< 
< void gui_show_main(Tbfwin *bfwin) {
< 	/* show all */
< 	DEBUG_MSG("gui_show_main, before show\n");
< 	/* don't use show_all since some widgets are and should be hidden */
< 	gtk_widget_show(bfwin->main_window);
< 	flush_queue();
< 	doc_scroll_to_cursor(bfwin->current_document);
< /*	if ((bfwin->project && bfwin->project->view_left_panel) || (!bfwin->project && main_v->props.view_left_panel)) {
< 		filebrowser_scroll_initial(bfwin);
< 	}*/
< }
< /***********************/
< /* statusbar functions */
< /***********************/
< typedef struct {
< 	gint message_id;
< 	Tbfwin *bfwin;
< } Tstatusbar_remove;
< 
< static gint statusbar_remove(gpointer sr) {
< 	gtk_statusbar_remove(GTK_STATUSBAR(((Tstatusbar_remove *)sr)->bfwin->statusbar), 0, ((Tstatusbar_remove *)sr)->message_id);
< 	g_free(sr);
< 	return FALSE;
< }
< 
< void statusbar_message(Tbfwin *bfwin,gchar *message, gint time) {
< 	if (bfwin->statusbar) {
< 		Tstatusbar_remove *sr = g_new(Tstatusbar_remove,1);
< 		sr->bfwin = bfwin;
< 		sr->message_id = gtk_statusbar_push(GTK_STATUSBAR(bfwin->statusbar), 0, message);
< 		gtk_timeout_add(time, statusbar_remove, sr);
< 	}
< }
< 
< 
< /***********************/
< /* GOTO line functions */
< /***********************/
< 
< typedef struct {
< 	GtkWidget *win;
< 	GtkWidget *entry;
< 	GtkWidget *check;
< 	Tbfwin *bfwin;
< } Tgotoline;
< 
< static void tgl_destroy_lcb(GtkWidget * widget, Tgotoline *tgl) {
< 	window_destroy(tgl->win);
< 	g_free(tgl);
< }
< 
< static void tgl_ok_clicked_lcb(GtkWidget * widget, Tgotoline *tgl)
< {
< 	gchar *linestr;
< 	gint linenum;
< 
< 	linestr = gtk_editable_get_chars(GTK_EDITABLE(tgl->entry), 0, -1);
< 	linenum = get_int_from_string(linestr);
< 	DEBUG_MSG("tgl_ok_clicked_lcb, going to line %d (linestr=%s)\n", linenum, linestr);
< 	g_free(linestr);
< 	
< 	if (linenum > 0) {
< 		doc_select_line(tgl->bfwin->current_document, linenum, TRUE);
< 	}
< 
< 	if (GTK_TOGGLE_BUTTON(tgl->check)->active) {
< 		if (linenum > 0) {
< 			gchar *new_text;
< 			gint position=0;
< 			gtk_editable_delete_text (GTK_EDITABLE(tgl->entry), 0, -1);
< 			new_text = g_strdup_printf("%d", linenum);
< 			gtk_editable_insert_text(GTK_EDITABLE(tgl->entry),new_text,strlen(new_text),&position);
< 			g_free(new_text);
< 		}
< 	} else {
< 		tgl_destroy_lcb(NULL, tgl);
< 	}
< 
< }
< 
< static void tgl_fromsel_clicked_lcb(GtkWidget * widget, Tgotoline *tgl) {
< 	gchar *string;
< 	GtkClipboard* cb;
< 
< 	cb = gtk_clipboard_get(GDK_SELECTION_PRIMARY);
< 	string = gtk_clipboard_wait_for_text(cb);
< 	if (string) {
< 		gtk_entry_set_text(GTK_ENTRY(tgl->entry), string);
< 	}
< 	tgl_ok_clicked_lcb(widget, tgl);
< }
< 
< static void tgl_cancel_clicked_lcb(GtkWidget *widget, gpointer data) {
< 	tgl_destroy_lcb(NULL, data);
< }
< 
< void tgl_enter_lcb (GtkWidget *widget, gpointer ud) {
<      Tgotoline *tgl;
<      tgl = ud;
<      tgl_ok_clicked_lcb (widget, tgl);
< }
< 
< void go_to_line_win_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
< 	Tgotoline *tgl;
< 	GtkWidget *but1, *vbox, *hbox, *label;
< 	
< 	tgl = g_new(Tgotoline, 1);
< 	tgl->bfwin = bfwin;
< 	tgl->win = window_full(_("Goto line"), GTK_WIN_POS_MOUSE
< 						  ,12, G_CALLBACK(tgl_destroy_lcb), tgl, TRUE);
< 	vbox = gtk_vbox_new(FALSE, 12);
< 	gtk_container_add(GTK_CONTAINER(tgl->win), vbox);
< 
< 	hbox = gtk_hbox_new(FALSE, 12);
< 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
< 
< 	label = gtk_label_new_with_mnemonic(_("_Line number:"));
< 	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
< 
< 	tgl->entry = boxed_entry_with_text(NULL, 20, hbox);
< 	gtk_label_set_mnemonic_widget(GTK_LABEL(label), tgl->entry); /* mnemonic for label */
< 
< 	but1 = bf_generic_mnemonic_button(_("From _selection"), G_CALLBACK(tgl_fromsel_clicked_lcb), tgl);
< 	gtk_box_pack_start(GTK_BOX(hbox), but1, FALSE, FALSE, 0);
< 
< 	tgl->check = boxed_checkbut_with_value(_("Keep _dialog"), 0, vbox);
< 	
< 	gtk_box_pack_start(GTK_BOX(vbox), gtk_hseparator_new(), TRUE, TRUE, 0);
< 	
< 	hbox = gtk_hbutton_box_new();
< 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
< 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 12);
< 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);	
< 	
< 	but1 = bf_stock_cancel_button(G_CALLBACK(tgl_cancel_clicked_lcb), tgl);
< 	gtk_box_pack_start(GTK_BOX(hbox), but1, FALSE, FALSE, 0);
< 	gtk_widget_grab_focus (tgl->entry);
< 
< 	but1 = bf_stock_ok_button(G_CALLBACK(tgl_ok_clicked_lcb), tgl);
< 	gtk_box_pack_start(GTK_BOX(hbox), but1, FALSE, FALSE, 0);
< 	gtk_window_set_default(GTK_WINDOW(tgl->win), but1);
< 
< 	gtk_widget_show_all(tgl->win);
< }
< 
< void go_to_line_from_selection_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
< 	gchar *string;
< 	GtkClipboard* cb;
< 	gint linenum;
< 
< 	cb = gtk_clipboard_get(GDK_SELECTION_PRIMARY);
< 	string = gtk_clipboard_wait_for_text(cb);
< 	if (string) {
< 		linenum = get_int_from_string(string);
< 		if (linenum > 0) {
< 			doc_select_line(bfwin->current_document, linenum, TRUE);
< 		}
< 	}
< }
< 
< #ifndef NOSPLASH
< 
< void splash_screen_set_label(gchar *label) {
< 	/* static struct timespec const req = { 0, 10000000}; */
< #ifdef DEBUG
< 	g_print("Setting splash label to %s\n", label);
< #endif
< 	gtk_label_set(GTK_LABEL(splashscreen.label),label);
< 	flush_queue();
< 	/* nanosleep(&req, NULL); */
< }
< 
< GtkWidget *start_splash_screen() {
< 	/* static struct timespec const req = { 0, 100000000}; */
< 	GtkWidget *image, *vbox;
< 	GdkColor color;
< 
< 	splashscreen.window = window_with_title(CURRENT_VERSION_NAME, GTK_WIN_POS_CENTER_ALWAYS, 0);
< 	gtk_window_set_decorated(GTK_WINDOW(splashscreen.window), FALSE);
< 	gtk_window_set_role(GTK_WINDOW(splashscreen.window), "splash");
< 	gtk_window_set_resizable(GTK_WINDOW(splashscreen.window),FALSE);
< 	color.red = 65535;
< 	color.blue = 65535;
< 	color.green = 65535;
< 	gtk_widget_modify_bg(splashscreen.window, GTK_STATE_NORMAL,&color);
< 
< 
< 	vbox = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(splashscreen.window), vbox);
< 	gtk_widget_show(vbox);
< 	splashscreen.label = gtk_label_new(_("starting bluefish"));
< 	gtk_box_pack_end(GTK_BOX(vbox),splashscreen.label , FALSE, FALSE, 0);
< 	gtk_widget_show(splashscreen.label);
< 	{
< 		GError *error=NULL;
< #ifdef WIN32
< 		GdkPixbuf* pixbuf= gdk_pixbuf_new_from_file(BLUEFISH_PNG_PATH,&error);
< #else
< 		GdkPixbuf* pixbuf= gdk_pixbuf_new_from_file(BLUEFISH_SPLASH_FILENAME,&error);
< #endif /* WIN32 */		
< 		if (error) {
< 			g_print("ERROR while loading splash screen: %s\n", error->message);
< 			g_error_free(error);
< 		} else if (pixbuf) {
< 			image = gtk_image_new_from_pixbuf(pixbuf);
< 			gtk_box_pack_end(GTK_BOX(vbox), image, FALSE, FALSE, 0);
< 			g_object_unref(pixbuf);
< 			gtk_widget_show(image);
< 		}
< 	}
< 
< 	gtk_widget_show(splashscreen.window);
< 	flush_queue();
< 	DEBUG_MSG("start_splash_screen, should be visible\n");
< 	/* nanosleep(&req, NULL); */
< 	return splashscreen.window;
< }
< #endif /* #ifndef NOSPLASH */
< 
< void gui_set_html_toolbar_visible(Tbfwin *bfwin, gboolean visible, gboolean sync_menu) {
< 	if (sync_menu) {
< 		DEBUG_MSG("gui_set_html_toolbar_visible, trying to sync menu\n");
< 		setup_toggle_item_from_widget(bfwin->menubar, "/View/View HTML Toolbar", visible);
< 	}
< 	if (gtk_container_children(GTK_CONTAINER(bfwin->html_toolbar_hb)) == NULL) {
< 		make_html_toolbar(bfwin);
< 	}
< 	widget_set_visible(bfwin->html_toolbar_hb,visible);
< }
< void gui_set_main_toolbar_visible(Tbfwin *bfwin, gboolean visible, gboolean sync_menu) {
< 	if (sync_menu) {
< 		DEBUG_MSG("gui_set_main_toolbar_visible, trying to sync menu\n");
< 		setup_toggle_item_from_widget(bfwin->menubar, "/View/View Main Toolbar", visible);
< 	}
< 	if (gtk_container_children(GTK_CONTAINER(bfwin->main_toolbar_hb)) == NULL) {
< 		make_main_toolbar(bfwin);
< 	}
< 	widget_set_visible(bfwin->main_toolbar_hb,visible);
< }
< void gui_set_custom_menu_visible(Tbfwin *bfwin, gboolean visible, gboolean sync_menu) {
< 	if (sync_menu) {
< 		DEBUG_MSG("gui_set_custom_menu_visible, trying to sync menu\n");
< 		setup_toggle_item_from_widget(bfwin->menubar, "/View/View Custom Menu", visible);
< 	}
< 	if (gtk_container_children(GTK_CONTAINER(bfwin->custom_menu_hb)) == NULL) {
< 		make_cust_menubar(bfwin,bfwin->custom_menu_hb);
< 	}
< 	widget_set_visible(bfwin->custom_menu_hb,visible);
< }
< 
< void gui_toggle_hidewidget_cb(Tbfwin *bfwin,guint action,GtkWidget *widget) {
< 	gboolean active = GTK_CHECK_MENU_ITEM(widget)->active;
< 	DEBUG_MSG("gui_toggle_hidewidget_cb, action=%d, active=%d\n",action,active);
< 	switch (action) {
< 	case 1:
< 		bfwin->session->view_main_toolbar = active;
< 		gui_set_main_toolbar_visible(bfwin, active, FALSE);
< 	break;
< 	case 2:
< 		bfwin->session->view_html_toolbar = active;
< 		gui_set_html_toolbar_visible(bfwin, active, FALSE);
< 	break;
< 	case 3:
< 		bfwin->session->view_custom_menu = active;
< 		gui_set_custom_menu_visible(bfwin, active, FALSE);
< 	break;
< 	case 4:
< 		bfwin->session->view_left_panel = active;
< 		left_panel_show_hide_toggle(bfwin,FALSE, active, FALSE);
< 	break;
< 	default:
< 		g_print("gui_toggle_hidewidget_cb should NEVER be called with action %d\n", action);
< 		exit(1);
< 	break;
< 	}
< }
< 
< Tbfwin *gui_new_window(GList *filenames, Tproject *project) {
< 	Tbfwin *bfwin = g_new0(Tbfwin,1);
< 	bfwin->bmark_files = NULL; /* Oskar */
< 	if (project) {
< 		bfwin->project = project;
< 		bfwin->session = project->session;
< 		bfwin->bookmarkstore = project->bookmarkstore;
< 		DEBUG_MSG("gui_new_window, bfwin=%p, bfwin->bookmarkstore=%p (from project %p)\n",bfwin,bfwin->bookmarkstore,project);
< 	} else {
< 		bfwin->session = main_v->session;
< 		bfwin->bookmarkstore = main_v->bookmarkstore;
< 		DEBUG_MSG("gui_new_window, bfwin=%p, bfwin->bookmarkstore=%p (from main_v)\n",bfwin,bfwin->bookmarkstore);
< 	}
< 	gui_create_main(bfwin,filenames);
< 	/* never comment this out again Jim! */
< 	main_v->bfwinlist = g_list_append(main_v->bfwinlist, bfwin);
< 	gui_show_main(bfwin);
< 	return bfwin;
< }
< 
< void gui_window_menu_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
< 	switch (callback_action) {
< 		case 1:
< 			gui_new_window(NULL, NULL);
< 		break;
< 		case 2: /* close the window */
< 			if (main_window_delete_event_lcb(NULL, NULL, bfwin) == FALSE) {
< 				gtk_widget_destroy(bfwin->main_window);
< 			}
< 		break;
< 	}
< }
---
> /* Bluefish HTML Editor
>  * gui.c - the main GUI
>  *
>  * Copyright (C) 2002-2006 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> /* #define DEBUG */
> 
> #include <gtk/gtk.h>
> #include <stdlib.h>    /* exit() on Solaris */
> #include <string.h>    /* strchr() */
> #include <time.h>      /* nanosleep() */
> #include <unistd.h>    /* exit() */
> 
> #include "config.h"
> 
> #include "bluefish.h"
> #include "gui.h"
> #include "bf_lib.h"        /* get_int_from_string() */
> #include "bookmark.h"
> #include "document.h"      /* file_new_cb() */
> #include "filebrowser.h"
> #include "fref.h"
> #include "gtk_easy.h"
> #include "html.h"
> #include "html2.h"
> #include "html_form.h"
> #include "html_table.h"
> #include "image.h"
> #include "menu.h"          /* menu_create_main(), recent_menu_init() */
> #include "outputbox.h"     /* init_outputbox() */
> #include "pixmap.h"        /* new_pixmap(); */
> #include "preferences.h"   /* open_preferences_cb */
> #include "project.h"
> #include "snr2.h"          /* search_cb, replace_cb */
> #include "stringlist.h"
> #include "undo_redo.h"     /* undo_cb() redo_cb() etc. */
> #include "wizards.h"
> 
> #ifdef HAVE_ATLEAST_GTK_2_4
> #include "quickstart.h"
> #endif /* HAVE_ATLEAST_GTK_2_4 */
> 
> #ifdef HAVE_LIBASPELL
> #include "bfspell.h"
> #endif /* HAVE_LIBASPELL */
> 
> typedef struct {
> 	GtkWidget *window;
> 	GtkWidget *label;
> } Tsplashscreen;
> 
> /******************************/
> /* global vars for this module */
> /******************************/
> #ifndef NOSPLASH
> static Tsplashscreen splashscreen;
> #endif
> /**************************/
> /* start of the functions */
> /**************************/
> 
> /**
>  * notebook_hide:
>  *
>  * Hides the notebook. Used when loading a large amount of files, to avoid
>  * slowing things down. Shows a "Stand by..." label instead..
>  *
>  * Return value: void
>  **/
> void notebook_hide(Tbfwin *bfwin) {
> 	gtk_widget_hide (bfwin->notebook);
> 	gtk_widget_show (bfwin->notebook_fake);
> }
> 
> /**
>  * notebook_show:
>  *
>  * Shows the notebook, after a notebook_hide() has been called.
>  *
>  * Return value: void
>  **/
> void notebook_show(Tbfwin *bfwin) {
> 	gtk_widget_hide (bfwin->notebook_fake);
> 	gtk_widget_show (bfwin->notebook);	
> }
> 
> void notebook_changed(Tbfwin *bfwin, gint newpage) {
> 	gint cur = newpage;
> 	gint doclistlen;
> 	DEBUG_MSG("notebook_changed, doclistlen=%d, newpage=%d, notebook_curpage=%d, last_notebook_page=%d, curdoc=%p\n"
> 			,g_list_length(bfwin->documentlist)
> 			,newpage
> 			,gtk_notebook_get_current_page(GTK_NOTEBOOK(bfwin->notebook))
> 			,bfwin->last_notebook_page
> 			,bfwin->current_document
> 			);
> 	if (newpage == -1) {
> 		/* this returns -1 if there is no current page */
> 		cur = gtk_notebook_get_current_page(GTK_NOTEBOOK(bfwin->notebook));
> 	}
> 	if ((bfwin->last_notebook_page == cur) 
> 		&& (bfwin->current_document != NULL)
> 		&& (bfwin->current_document == g_list_nth_data(bfwin->documentlist, cur))) {
> 		DEBUG_MSG("notebook_changed, NOT CHANGED cur=%d, documentlist[cur]==current_document (=%p), RETURNING\n",cur,bfwin->current_document);
> 		return;
> 	}
> 	doclistlen = g_list_length(bfwin->documentlist);
> 	if (cur == -1) {
> 		if (doclistlen > 0) {
> 			DEBUG_MSG("notebook_changed, WEIRD 1 cur=%d, but doclistlen=%d RETURNING\n",cur,doclistlen);
> 			bfwin->last_notebook_page = -2;
> 			return;
> 		}
> 	}
> 	if (doclistlen == 0) {
> 		DEBUG_MSG("notebook_changed, doclistlen=%d, before doc_new()!\n",doclistlen);
> 		bfwin->current_document = doc_new(bfwin,TRUE);
> 		bfwin->last_notebook_page = 1;
> 		DEBUG_MSG("notebook_changed, after doc_new(), returning\n");
> 		return;
> 	}
> 	/* if the documentlist has length 1, cur should not be larger then 0, if 2, cur should not be larger then 1, etc.*/
> 	if (cur >= doclistlen) {
> 		DEBUG_MSG("notebook_changed, DOCALREADYCLOSED, cur=%d, doclistlen=%d, RETURNING\n", cur, doclistlen);
> 		bfwin->last_notebook_page = -2;
> 		return;
> 	}
> 	bfwin->current_document = g_list_nth_data(bfwin->documentlist, cur);
> 	if (bfwin->current_document == NULL) {
> 		DEBUG_MSG("notebook_changed, WEIRD 2, doclist[%d] == NULL, RETURNING\n",cur);
> 		return;
> 	}
> 	DEBUG_MSG("notebook_changed, current_document=%p\n",bfwin->current_document);
> 	bfwin->last_notebook_page = cur;
> 	/* now we flush the queue first, so that we don't call doc_activate 
> 	on _this_ document if the user has another close click in the queue */
> 	flush_queue();
> 
> 	doc_activate(bfwin->current_document);
> /*	bmark_adjust_visible(bfwin);*/
> }
> 
> gboolean switch_to_document_by_index(Tbfwin *bfwin,gint index) {
> 	if (index >= 0) {
> 		gtk_notebook_set_current_page(GTK_NOTEBOOK(bfwin->notebook), (index));
> /*		notebook_changed();*/
> 		return TRUE;
> 	}
> 	return FALSE;
> }
> 
> gboolean switch_to_document_by_pointer(Tbfwin *bfwin,Tdocument *document) {
> 	gint index;
> 
> 	index = g_list_index(bfwin->documentlist, document);
> 	return switch_to_document_by_index(bfwin,index);
> }
> 
> gboolean switch_to_document_by_filename(Tbfwin *bfwin,gchar *filename) {
> 	gint index;
> 
> 	index = documentlist_return_index_from_filename(bfwin->documentlist,filename);
> 	return switch_to_document_by_index(bfwin,index);
> }
> 
> 
> static void notebook_switch_page_lcb(GtkWidget *notebook,GtkNotebookPage *page,gint page_num,Tbfwin *bfwin) {
> 	DEBUG_MSG("notebook_switch_page_lcb, page=%d\n", page_num);
> 	notebook_changed(bfwin,page_num);
> }
> 
> void gui_notebook_switch(Tbfwin *bfwin,guint action,GtkWidget *widget) {
> 	switch (action) {
> 		case 1: gtk_notebook_prev_page(GTK_NOTEBOOK(bfwin->notebook));
> 		break;
> 		case 2: gtk_notebook_next_page(GTK_NOTEBOOK(bfwin->notebook));
> 		break;
> 		case 3: gtk_notebook_set_current_page(GTK_NOTEBOOK(bfwin->notebook), 0);
> 		break;
> 		case 4: gtk_notebook_set_current_page(GTK_NOTEBOOK(bfwin->notebook), -1);
> 	}
> }
> 
> static void left_panel_notify_position_lcb(GObject *object,GParamSpec *pspec,gpointer data){
> 	gint position;
> 	g_object_get(object, pspec->name, &position, NULL);
> 	DEBUG_MSG("left_panel_notify_position_lcb, new position=%d\n", position);
> 	if (main_v->props.restore_dimensions) {
> 		if (main_v->props.left_panel_left) {
> 			main_v->props.left_panel_width = position;
> 		} else {
> 			main_v->props.left_panel_width = main_v->globses.main_window_w - position;
> 		}
> 	}
> }
> 
> GtkWidget *left_panel_build(Tbfwin *bfwin) {
> 	GtkWidget *fileb;
> 	GtkWidget *left_notebook = gtk_notebook_new();
> 	GtkWidget *fref;
> 	GtkWidget *bmarks;
> 	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(left_notebook),main_v->props.leftpanel_tabposition);
> 	gtk_notebook_set_show_tabs(GTK_NOTEBOOK(left_notebook), TRUE);
> 	gtk_notebook_set_show_border(GTK_NOTEBOOK(left_notebook), FALSE);
> 	gtk_notebook_set_tab_hborder(GTK_NOTEBOOK(left_notebook), 0);
> 	gtk_notebook_set_tab_vborder(GTK_NOTEBOOK(left_notebook), 0);
> 	gtk_notebook_popup_enable(GTK_NOTEBOOK(left_notebook));
> 	fileb = filebrowser_init(bfwin);
> 	fref = fref_gui(bfwin);
> 	bmarks = bmark_gui(bfwin);
> 	gtk_notebook_append_page_menu(GTK_NOTEBOOK(left_notebook),fileb,new_pixmap(105),gtk_label_new(_("Filebrowser")));
> 	gtk_notebook_append_page_menu(GTK_NOTEBOOK(left_notebook),fref,new_pixmap(106),gtk_label_new(_("Function reference")));
> 	gtk_notebook_append_page_menu(GTK_NOTEBOOK(left_notebook),bmarks,new_pixmap(104),gtk_label_new(_("Bookmarks")));
> 	gtk_widget_show_all(left_notebook);
> 	gtk_notebook_set_current_page(GTK_NOTEBOOK(left_notebook),0);
> 	return left_notebook;
> }
> 
> /**
>  * if there is a left panel, this function will rebuild all widgets
>  */
> void left_panel_rebuild(Tbfwin *bfwin) {
> 	if (bfwin->hpane) {
> 		DEBUG_MSG("left_panel_rebuild, destroying widgets\n");
> 		gtk_widget_destroy(bfwin->leftpanel_notebook);
> 		DEBUG_MSG("left_panel_rebuild, cleanup\n");
> 		filebrowser_cleanup(bfwin);
> 		fref_cleanup(bfwin);
> 		bmark_cleanup(bfwin);
> 		DEBUG_MSG("left_panel_rebuild, re-init\n");
> 		bfwin->leftpanel_notebook = left_panel_build(bfwin);
> 		if (main_v->props.left_panel_left) {
> 			gtk_paned_add1(GTK_PANED(bfwin->hpane), bfwin->leftpanel_notebook);
> 		} else {
> 			gtk_paned_add2(GTK_PANED(bfwin->hpane), bfwin->leftpanel_notebook);
> 		}
> 		gtk_widget_show_all(bfwin->leftpanel_notebook);
> 	}
> }
> 
> void left_panel_show_hide_toggle(Tbfwin *bfwin,gboolean first_time, gboolean show, gboolean sync_menu) {
> 	if (sync_menu) {
> 		DEBUG_MSG("left_panel_show_hide_toggle, trying to sync menu\n");
> 		setup_toggle_item_from_widget(bfwin->menubar, "/View/View Sidebar", show);
> 	}
> 	if (!first_time && ((show && bfwin->hpane) || (!show && bfwin->hpane == NULL))) {
> 		DEBUG_MSG("left_panel_show_hide_toggle, retrurning!!, show=%d, bfwin->hpane=%p, first_time=%d\n",show,bfwin->hpane,first_time);
> 		return;
> 	} 
> 
> 	if (!first_time) {
> 		gtk_widget_ref(bfwin->notebook_box);
> 		if (show) {
> 			gtk_container_remove(GTK_CONTAINER(bfwin->middlebox), bfwin->notebook_box);
> 		} else {
> 			gtk_container_remove(GTK_CONTAINER(bfwin->hpane), bfwin->notebook_box);
> 			gtk_widget_destroy(bfwin->hpane);
> 			filebrowser_cleanup(bfwin);
> 			fref_cleanup(bfwin);
> 			bmark_cleanup(bfwin); 
> 		}
> 	}
> 	if (show) {
> 		bfwin->hpane = gtk_hpaned_new();
> 		if (main_v->props.left_panel_left) {
> 			DEBUG_MSG("set paned position to %d (left)\n",main_v->props.left_panel_width);
> 			gtk_paned_set_position(GTK_PANED(bfwin->hpane), main_v->props.left_panel_width);
> 		} else {
> 			DEBUG_MSG("set paned position to %d (right)\n",main_v->globses.main_window_w - main_v->props.left_panel_width);
> 			gtk_paned_set_position(GTK_PANED(bfwin->hpane), main_v->globses.main_window_w - main_v->props.left_panel_width);
> 		}
> 		g_signal_connect(G_OBJECT(bfwin->hpane),"notify::position",G_CALLBACK(left_panel_notify_position_lcb), NULL);
> 		bfwin->leftpanel_notebook = left_panel_build(bfwin);
> 		gtk_paned_add1(GTK_PANED(bfwin->hpane), main_v->props.left_panel_left ? bfwin->leftpanel_notebook : bfwin->notebook_box);
> 		gtk_paned_add2(GTK_PANED(bfwin->hpane), main_v->props.left_panel_left ? bfwin->notebook_box : bfwin->leftpanel_notebook);
> 		gtk_box_pack_start(GTK_BOX(bfwin->middlebox), bfwin->hpane, TRUE, TRUE, 0);
> 		gtk_widget_show(bfwin->hpane);
> 	} else {
> 		bfwin->hpane = NULL;
> 		bfwin->leftpanel_notebook = NULL;
> 		gtk_box_pack_start(GTK_BOX(bfwin->middlebox), bfwin->notebook_box, TRUE, TRUE, 0);
> 	}
> 	if (!first_time) {
> 		gtk_widget_unref(bfwin->notebook_box);
> 	}
> }
> 
> void gui_set_title(Tbfwin *bfwin, Tdocument *doc) {
> 	gchar *title, *prfilepart;
> 	const gchar *tablabel;
> 	tablabel = gtk_label_get_text(GTK_LABEL(doc->tab_label));
> 	if (bfwin->project) {
> 		prfilepart = g_strconcat(bfwin->project->name," - ",tablabel,NULL);
> 	} else {
> 		prfilepart = g_strdup(tablabel);
> 	}
> 	title = g_strconcat(prfilepart, " - Bluefish "VERSION,NULL);
> 	gtk_window_set_title(GTK_WINDOW(bfwin->main_window),title);
> 	/*rename_window_entry_in_all_windows(bfwin, title);*/
> 	g_free(title);
> 	g_free(prfilepart);
> }
> 
> void gui_apply_settings(Tbfwin *bfwin) {
> 	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(bfwin->notebook),main_v->props.document_tabposition);
> 	/* We don't want to set the tab position if the left panel is hidden */
> 	if (bfwin->leftpanel_notebook) {
> 		gtk_notebook_set_tab_pos(GTK_NOTEBOOK(bfwin->leftpanel_notebook),main_v->props.leftpanel_tabposition);
> 
> 		/* check if the left panel needs to move over to the right */
> 		if (main_v->props.left_panel_left && bfwin->leftpanel_notebook == GTK_PANED(bfwin->hpane)->child1) {
> 			DEBUG_MSG("gui_apply_settings, left panel is on the right location\n");
> 		} else {
> 			left_panel_show_hide_toggle(bfwin,FALSE, FALSE, FALSE);
> 			left_panel_show_hide_toggle(bfwin,FALSE, TRUE, FALSE);
> 		}
> 	}
> }
> 
> typedef struct {
> 	const gchar *ident;
> 	void (*func)();
> 	gint pixmaptype;
> 	const gchar *tooltiptext;
> } Ttoolbaritem;
> 
> typedef struct {
> 	Ttoolbaritem *tbitem;
> 	GtkWidget *button;
> 	Tbfwin *bfwin;
> }Tquickbaritem;
> 
> static void bold_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 1, NULL);
> }
> static void italic_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 2, NULL);
> }
> static void paragraph_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 5, NULL);
> }
> static void break_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 6, NULL);
> }
> static void breakclear_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 41, NULL);
> }
> static void nbsp_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 7, NULL);
> }
> static void center_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 8, NULL);
> }
> static void rightjustify_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 9, NULL);
> }
> static void comment_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 10, NULL);
> }
> static void fontsizeplus1_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 11, NULL);
> }
> static void fontsizeminus1_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 12, NULL);
> }
> static void preformatted_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 13, NULL);
> }
> static void subscript_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 14, NULL);
> }
> static void superscript_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 15, NULL);
> }
> static void strong_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 16, NULL);
> }
> static void emphasis_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 17, NULL);
> }
> static void heading1_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 18, NULL);
> }
> static void heading2_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 19, NULL);
> }
> static void heading3_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 20, NULL);
> }
> static void heading4_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 21, NULL);
> }
> static void heading5_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 22, NULL);
> }
> static void heading6_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 23, NULL);
> }
> static void table_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 24, NULL);
> }
> static void tablerow_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 25, NULL);
> }
> static void tableheader_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 26, NULL);
> }
> static void tabledata_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 27, NULL);
> }
> static void tablecaption_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 28, NULL);
> }
> static void frameset_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 29, NULL);
> }
> static void frame_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 30, NULL);
> }
> static void noframes_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 31, NULL);
> }
> static void target_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 32, NULL);
> }
> static void unorderedlist_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 33, NULL);
> }
> static void orderedlist_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 34, NULL);
> }
> static void listitem_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 35, NULL);
> }
> static void definitionlist_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 36, NULL);
> }
> static void definitionterm_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 37, NULL);
> }
> static void definition_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 38, NULL);
> }
> static void style_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 42, NULL);
> }
> static void dfn_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 48, NULL);
> }
> static void code_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 49, NULL);
> }
> static void samp_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 50, NULL);
> }
> static void kbd_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 51, NULL);
> }
> static void var_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 52, NULL);
> }
> static void cite_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 53, NULL);
> }
> static void abbr_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 54, NULL);
> }
> static void acronym_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	general_html_menu_cb(bfwin, 55, NULL);
> }
> 
> static void quickstart_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> #ifdef HAVE_ATLEAST_GTK_2_4
> 	quickstart_dialog_new(bfwin);
> #else
> 	quickstart_dialog(bfwin,NULL);
> #endif
> }
> static void body_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	body_dialog(bfwin,NULL);
> }
> static void quickanchor_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	DEBUG_MSG("quickanchor_clicked_lcb, calling quickanchor_dialog with bfwin=%p and data=NULL\n",bfwin);
> 	quickanchor_dialog(bfwin, NULL);
> }
> static void quickrule_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	quickrule_dialog(bfwin,NULL);
> }
> static void email_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	email_dialog(bfwin,NULL);
> }
> static void fontdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	font_dialog(bfwin,NULL);
> }
> static void basefont_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	basefont_dialog(bfwin,NULL);
> }
> static void framesetdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	frameset_dialog(bfwin,NULL);
> }
> static void framedialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	frame_dialog(bfwin,NULL);
> }
> static void quicklist_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	quicklist_dialog(bfwin,NULL);
> }
> static void link_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	linkdialog_dialog(bfwin,NULL,linkdialog_mode_css);
> }
> static void formdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	formdialog_dialog(bfwin,NULL);
> }
> static void inputbuttondialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	inputdialog_dialog(bfwin, NULL, "submit");
> }
> static void textdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	inputdialog_dialog(bfwin, NULL, "text");
> }
> static void hiddendialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	inputdialog_dialog(bfwin, NULL, "hidden");
> }
> static void textareadialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	textareadialog_dialog(bfwin,NULL);
> }
> static void radiodialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	inputdialog_dialog(bfwin, NULL, "radio");
> }
> static void checkdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	inputdialog_dialog(bfwin, NULL, "checkbox");
> }
> static void selectdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	selectdialog_dialog(bfwin,NULL);
> }
> static void optiondialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	optiondialog_dialog(bfwin,NULL);
> }
> static void optgroupdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	optgroupdialog_dialog(bfwin,NULL);
> }
> static void buttondialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	buttondialog_dialog(bfwin,NULL);
> }
> static void image_insert_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	image_insert_dialog(bfwin,NULL);
> }
> static void thumbnail_insert_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	thumbnail_insert_dialog(bfwin);
> }
> static void multi_thumbnail_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	multi_thumbnail_dialog(bfwin);
> }
> static void tabledialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	tabledialog_dialog(bfwin,NULL);
> }
> static void tablerowdialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	tablerowdialog_dialog(bfwin,NULL);
> }
> static void tableheaddialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	tableheaddialog_dialog(bfwin,NULL);
> }
> static void tabledatadialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	tabledatadialog_dialog(bfwin,NULL);
> }
> static void tablewizard_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	tablewizard_dialog(bfwin);
> }
> static void framewizard_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	framewizard_dialog(bfwin);
> }
> static void span_dialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	span_dialog(bfwin,NULL);
> }
> static void div_dialog_clicked_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	div_dialog(bfwin,NULL);
> }
> 
> 
> static Ttoolbaritem tbi[] = {
> 	{"quickstart...", quickstart_clicked_lcb,13 , N_("QuickStart...")},
> 	{"body...", body_clicked_lcb, 14, N_("Body...")},
> 	{"bold", bold_clicked_lcb,  15, N_("Bold")},
> 	{"italic", italic_clicked_lcb,  16, N_("Italic")},
> 	{"paragraph", paragraph_clicked_lcb,  19, N_("Paragraph")},
> 	{"break", break_clicked_lcb,  20, N_("Break")},
> 	{"breakclear", breakclear_clicked_lcb,  21, N_("Break and clear")},
> 	{"nbsp", nbsp_clicked_lcb,  22, N_("Non-breaking space")},
> 	{"", NULL, 0, NULL}, /* spacing */
> 	{"anchor...", quickanchor_clicked_lcb,23 , N_("Anchor...")},
> 	{"rule...", quickrule_clicked_lcb, 24, N_("Rule...")},
> 	{"center", center_clicked_lcb,  28, N_("Center")},
> 	{"rightjustify", rightjustify_clicked_lcb,  29, N_("Right Justify")},
> 	{"comment", comment_clicked_lcb, 30 , N_("Comment")},
> 	{"email...", email_clicked_lcb, 31, N_("E-mail...")},
> 	{"font...",fontdialog_clicked_lcb , 32, N_("Font...")},
> 	{"basefont...", basefont_clicked_lcb, 33, N_("Base Font Size...")},
> 	{"", NULL, 0, NULL}, /* spacing */
> 	{"fontsize+1", fontsizeplus1_clicked_lcb, 34 , N_("Font Size +1")},
> 	{"fontsize-1", fontsizeminus1_clicked_lcb,  35, N_("Font Size -1")},
> 	{"preformatted", preformatted_clicked_lcb,  36, N_("Preformatted Text")},
> 	{"subscript", subscript_clicked_lcb,  37, N_("Subscript")},
> 	{"superscript", superscript_clicked_lcb,  38, N_("Superscript")},
> 	{"strong", strong_clicked_lcb,  15, N_("Strong")},
> 	{"emphasis", emphasis_clicked_lcb,  16, N_("Emphasis")},
> 	{"", NULL, 0, NULL}, /* spacing */
> 	{"heading1", heading1_clicked_lcb,  39, N_("Heading 1")},
> 	{"heading2", heading2_clicked_lcb,  40, N_("Heading 2")},
> 	{"heading3", heading3_clicked_lcb,  41, N_("Heading 3")},
> 	{"heading4", heading4_clicked_lcb,  42, N_("Heading 4")},
> 	{"heading5", heading5_clicked_lcb,  43, N_("Heading 5")},
> 	{"heading6", heading6_clicked_lcb,  44, N_("Heading 6")},
> 	{"tablewizard...",tablewizard_clicked_lcb, 45, N_("Table Wizard...")},
> 	{"", NULL, 0, NULL}, /* spacing */
> 	{"table...",tabledialog_clicked_lcb, 46, N_("Table...")},
> 	{"tablerow...", tablerowdialog_clicked_lcb, 47, N_("Table Row...")},
> 	{"tableheader...", tableheaddialog_clicked_lcb, 48, N_("Table Header...")},
> 	{"tabledata...", tabledatadialog_clicked_lcb, 49, N_("Table Data...")},
> 	{"", NULL, 0, NULL}, /* spacing */
> 	{"table", table_clicked_lcb,  50, N_("Table")},
> 	{"tablerow", tablerow_clicked_lcb,  51, N_("Table Row")},
> 	{"tableheader", tableheader_clicked_lcb,  52, N_("Table Header")},
> 	{"tabledata", tabledata_clicked_lcb,  53, N_("Table Data")},
> 	{"tablecaption", tablecaption_clicked_lcb,  54, N_("Table Caption")},
> 	{"framewizard...",framewizard_clicked_lcb , 55, N_("Frame Wizard...")},
> 	{"", NULL, 0, NULL}, /* spacing */
> 	{"frameset...", framesetdialog_clicked_lcb,56 , N_("Frameset...")},
> 	{"frame...",framedialog_clicked_lcb , 57, N_("Frame...")},
> 	{"", NULL, 0, NULL}, /* spacing */
> 	{"frameset", frameset_clicked_lcb, 58 , N_("Frameset")},
> 	{"frame", frame_clicked_lcb,  59, N_("Frame")},
> 	{"noframes", noframes_clicked_lcb,  60, N_("Noframes")},
> 	{"target", target_clicked_lcb,  61, N_("Target")},
> 	{"form...",formdialog_clicked_lcb , 62, N_("Form...")},
> 	{"inputbutton...", inputbuttondialog_clicked_lcb, 63, N_("Input Button...")},
> 	{"text...",textdialog_clicked_lcb , 65, N_("Input Text...")},
> 	{"hidden...", hiddendialog_clicked_lcb, 66, N_("Input Hidden...")},
> 	{"textarea...",textareadialog_clicked_lcb , 67, N_("Textarea...")},
> 	{"radiobutton...", radiodialog_clicked_lcb, 68, N_("Input Radio Button...")},
> 	{"checkbox...", checkdialog_clicked_lcb, 69, N_("Input Check Box...")},
> 	{"select...", selectdialog_clicked_lcb, 70, N_("Select...")},
> 	{"option...",optiondialog_clicked_lcb , 71, N_("Option...")},
> 	{"optiongroup...", optgroupdialog_clicked_lcb, 72, N_("Option group...")},
> 	{"button...", buttondialog_clicked_lcb, 63, N_("Button...")},
> 	{"quicklist...", quicklist_clicked_lcb, 73, N_("Quick List...")},
> 	{"unorderedlist", unorderedlist_clicked_lcb,  74, N_("Unordered List")},
> 	{"orderedlist", orderedlist_clicked_lcb,  75, N_("Ordered List")},
> 	{"listitem", listitem_clicked_lcb,  76, N_("List Item")},
> 	{"definitionlist", definitionlist_clicked_lcb,  77, N_("Definition List")},
> 	{"definitionterm", definitionterm_clicked_lcb,  78, N_("Definition Term")},
> 	{"definition", definition_clicked_lcb,  79, N_("Definition")},
> 	{"createstylesheet...", new_css_dialog, 85, N_("Create stylesheet...")},
> 	{"span...", span_dialog_clicked_lcb,86 , N_("Span...")},
> 	{"div...",div_dialog_clicked_lcb,87 , N_("Div...")},
> 	{"style", style_clicked_lcb, 89, N_("Style")},
> 	{"linkstylesheet...", link_clicked_lcb,90 , N_("Link to stylesheet...")},
> 	{"image...", image_insert_clicked_lcb, 25, N_("Insert image...")},
> 	{"thumbnail...", thumbnail_insert_clicked_lcb, 26, N_("Insert thumbnail...")},
> 	{"mthumbnail...", multi_thumbnail_clicked_lcb, 27, N_("Multi thumbnail...")},
> 	{"dfn", dfn_clicked_lcb,  93, N_("Definition")},
> 	{"code", code_clicked_lcb,  94, N_("Code")},
> 	{"samp", samp_clicked_lcb,  95, N_("Sample")},
> 	{"kbd", kbd_clicked_lcb,  96, N_("Keyboard")},
> 	{"var", var_clicked_lcb,  97, N_("Variable")},
> 	{"cite", cite_clicked_lcb,  98, N_("Citation")},
> 	{"abbr", abbr_clicked_lcb,  99, N_("Abbreviation")},
> 	{"acronym", acronym_clicked_lcb,  100, N_("Acronym")},
> 	{"", NULL, 0, NULL} /* spacing */
> };
> 
> static void html_toolbar_remove_from_quickbar_lcb(GtkMenuItem *menuitem, Ttoolbaritem *tbitem) {
> 	GList *bfwlist;
> 	main_v->globses.quickbar_items = remove_from_stringlist(main_v->globses.quickbar_items, tbitem->ident);
> 	bfwlist = g_list_first(main_v->bfwinlist);
> 	while (bfwlist) {
> 		Tquickbaritem *qbi=NULL;
> 		Tbfwin *bfwin = BFWIN(bfwlist->data);
> 		GList *tmplist  = g_list_first(bfwin->toolbar_quickbar_children);
> 		while (tmplist) {
> 			qbi = tmplist->data;
> 			if (qbi->tbitem == tbitem) {
> 				break;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		if (qbi) {
> 			gtk_widget_hide(qbi->button);
> 			gtk_widget_destroy(qbi->button);
> 			g_free(qbi);
> 		}
> 		bfwlist = g_list_next(bfwlist);
> 	}
> }
> 
> /* return the position in the quickbar GList of a tool bar item */
> gint get_quickbar_item_position(Ttoolbaritem *tbitem) {
> 	GList *tmplist, *winlist = g_list_first(main_v->bfwinlist);
> 	gint pos = 0;
> 	tmplist  = g_list_first(BFWIN(winlist->data)->toolbar_quickbar_children);
> 
> 	while (tmplist) {
> 		Tquickbaritem *qbi;
> 		qbi = tmplist->data;
> 		if (qbi->tbitem == tbitem) {
> 			DEBUG_MSG("get_quickbar_item_position, quickbar item is at %d\n", pos);
> 			return pos;
> 		}
> 		pos += 1;
> 		tmplist = g_list_next(tmplist);
> 	}
> 	DEBUG_MSG("get_quickbar_item_position, not found, return -1!\n");
> 	return -1;
> }
> 
> static gboolean html_toolbar_quickbar_item_button_press_lcb(GtkWidget *widget,GdkEventButton *bevent,Ttoolbaritem *tbitem);
> 
> static void html_toolbar_quickbar_switch(Ttoolbaritem *tbitem, gboolean moveright) {
> 	gint pos;
> 
> 	/* first we look for the current location of this item */	
> 	pos = get_quickbar_item_position(tbitem);
> 	DEBUG_MSG("html_toolbar_quickbar_switch, found item %s at pos=%d, config list length=%d\n",tbitem->ident,pos,g_list_length(main_v->globses.quickbar_items));
> 	if (pos >= 0) {
> 		GList *tmp1, *tmp2, *tmplist;
> 		/* then we move this item to the new place in the config list */
> 		tmp1 = g_list_nth(main_v->globses.quickbar_items, pos);
> 		if (!tmp1) {
> 			DEBUG_MSG("html_toolbar_quickbar_switch, nothing found in config list at pos=%d, RETURN\n",pos);
> 			return;
> 		}
> 		tmp2 = (moveright) ? g_list_next(tmp1) : g_list_previous(tmp1);
> 		if (!tmp2) {
> 			DEBUG_MSG("html_toolbar_quickbar_switch, no tmp2 found, moveright=%d, list length=%d RETURN\n",moveright,g_list_length(main_v->globses.quickbar_items));
> 			return;
> 		}
> 		list_switch_order(tmp1, tmp2);
> 		DEBUG_MSG("html_toolbar_quickbar_switch, after list_switch_order, list length=%d\n",g_list_length(main_v->globses.quickbar_items));
> 		
> 		/* now switch the widgets in every window that has a quickbar */
> 		tmplist = g_list_first(main_v->bfwinlist);
> 		while (tmplist) {
> 			Tbfwin *bfwin = BFWIN(tmplist->data);
> 			DEBUG_MSG("html_toolbar_quickbar_switch, checking bfwin=%p\n",bfwin);
> 			if (bfwin->toolbar_quickbar && bfwin->toolbar_quickbar_children) {
> 				Tquickbaritem *qbi1;
> 				DEBUG_MSG("retrieving quickbaritem from pos %d\n",pos);
> 				tmp1 = g_list_nth(bfwin->toolbar_quickbar_children, pos);
> 				tmp2 = (moveright) ? g_list_next(tmp1) : g_list_previous(tmp1);
> 				qbi1 = (Tquickbaritem *)tmp1->data;
> 				list_switch_order(tmp1, tmp2);
> 				DEBUG_MSG("html_toolbar_quickbar_switch, quickbaritem %p has tbitem %s\n",qbi1, qbi1->tbitem->ident);
> 				/* I don't know why the next bit of code doesn't work... bug in gtk? */
> 				/*g_object_ref(G_OBJECT(qbi1->button));
> 				DEBUG_MSG("html_toolbar_quickbar_switch, detaching widget!, button=%p, button->parent=%p, toolbar=%p\n",qbi1->button,qbi1->button->parent,bfwin->toolbar_quickbar);
> 				gtk_container_remove(GTK_CONTAINER(bfwin->toolbar_quickbar),qbi1->button);
> 				DEBUG_MSG("html_toolbar_quickbar_switch, attaching widget at pos %d\n",(moveright)?pos+1:pos-1);
> 				gtk_toolbar_insert_widget(GTK_TOOLBAR(bfwin->toolbar_quickbar),qbi1->button,
> 							_(qbi1->tbitem->tooltiptext),"",(moveright)?pos+1:pos-1);
> 				g_object_unref(G_OBJECT(qbi1->button));
> 				*/
> 				/* this workaround bit of code removes (and thus destroys) the button and creates a new identical button on the new location */
> 				DEBUG_MSG("html_toolbar_quickbar_switch, about to destroy button,(toolbar has %d children)\n",g_list_length(GTK_TOOLBAR(bfwin->toolbar_quickbar)->children));
> 				gtk_container_remove(GTK_CONTAINER(bfwin->toolbar_quickbar),qbi1->button);
> 				DEBUG_MSG("html_toolbar_quickbar_switch, inserting widget at pos %d (toolbar has %d children)\n",(moveright)?pos+1:pos-1, g_list_length(GTK_TOOLBAR(bfwin->toolbar_quickbar)->children));
> 				qbi1->button = gtk_toolbar_insert_item(GTK_TOOLBAR(bfwin->toolbar_quickbar), NULL, _(qbi1->tbitem->tooltiptext),
> 							"", new_pixmap(qbi1->tbitem->pixmaptype), G_CALLBACK(qbi1->tbitem->func), bfwin, (moveright)?pos+1:pos-1);
> 				g_signal_connect(qbi1->button, "button-press-event", G_CALLBACK(html_toolbar_quickbar_item_button_press_lcb), tbitem);
> 				gtk_widget_show(qbi1->button);
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		
> 	}
> }
> 
> static void html_toolbar_quickbar_move_left_lcb(GtkMenuItem *menuitem, Ttoolbaritem *tbitem) {
> 	html_toolbar_quickbar_switch(tbitem, FALSE);
> /*	GList *winlist = g_list_first(main_v->bfwinlist); 
> 	DEBUG_MSG("moving tbitem %p left on quickbars\n", tbitem);
> 	while (winlist) {
> 		GList *tmplist;
> 		gint pos;
> 		Tbfwin *bfwin = BFWIN(winlist->data);
> 		Tquickbaritem *qbi;
> 
> 		pos = get_quickbar_item_position(tbitem);
> 		tmplist = g_list_nth(bfwin->toolbar_quickbar_children, pos);
> 		qbi = tmplist->data;
> 
> 		if (qbi) {
> 			if (pos) { / * pos > 0 * /
> 				gtk_widget_destroy(qbi->button);
> 			}
> 			g_free(qbi);
> 		}
> 		
> 		if (pos) {
> 			GList *other;
> 			qbi = g_new(Tquickbaritem,1);
> 			qbi->button = gtk_toolbar_insert_item(GTK_TOOLBAR(bfwin->toolbar_quickbar), NULL, _(tbitem->tooltiptext),
> 							"", new_pixmap(tbitem->pixmaptype), G_CALLBACK(tbitem->func), bfwin, pos-1);
> 			g_signal_connect(qbi->button, "button-press-event", G_CALLBACK(html_toolbar_quickbar_item_button_press_lcb), tbitem);
> 			gtk_widget_show(qbi->button);
> 			qbi->tbitem = tbitem;
> 			
> 			other = g_list_previous(tmplist);
> 			list_switch_order(tmplist, other);
> 			
> 			tmplist = g_list_nth(main_v->globses.quickbar_items, pos);
> 			other = g_list_previous(tmplist);
> 			list_switch_order(tmplist, other);
> 			g_list_free(tmplist);
> 			g_list_free(other);
> 		}
> 		winlist = g_list_next(winlist);
> 	}
> 	 we don't create this list here so we don't need to free it!!
> 	g_list_free(winlist);*/
> }
> 
> static void html_toolbar_quickbar_move_right_lcb(GtkMenuItem *menuitem, Ttoolbaritem *tbitem) {
> 	html_toolbar_quickbar_switch(tbitem, TRUE);
> /*	GList *winlist = g_list_first(main_v->bfwinlist); 
> 	DEBUG_MSG("moving tbitem %p right on quickbars\n", tbitem);
> 	while (winlist) {
> 		gint pos;
> 		GList *tmplist, *other;
> 		Tbfwin *bfwin = BFWIN(winlist->data);
> 		Tquickbaritem *qbi;
> 		pos = get_quickbar_item_position(tbitem);
> 		tmplist = g_list_nth(bfwin->toolbar_quickbar_children, pos);
> 		qbi = tmplist->data;
> 
> 		if (qbi) {
> 			gtk_widget_hide(qbi->button);
> 			gtk_widget_destroy(qbi->button);
> 			g_free(qbi);
> 		}
> 		
> 		qbi = g_new(Tquickbaritem,1);
> 		qbi->button = gtk_toolbar_insert_item(GTK_TOOLBAR(bfwin->toolbar_quickbar), NULL, _(tbitem->tooltiptext),
> 							"", new_pixmap(tbitem->pixmaptype), G_CALLBACK(tbitem->func), bfwin, pos+1);
> 		g_signal_connect(qbi->button, "button-press-event", G_CALLBACK(html_toolbar_quickbar_item_button_press_lcb), tbitem);
> 		gtk_widget_show(qbi->button);
> 		qbi->tbitem = tbitem;
> 		
> 		other = g_list_next(tmplist);
> 		list_switch_order(tmplist, other);
> 			
> 		tmplist = g_list_nth(main_v->globses.quickbar_items, pos);
> 		other = g_list_next(tmplist);
> 		list_switch_order(tmplist, other);
> 		g_list_free(tmplist);
> 		g_list_free(other);
> 		
> 		winlist = g_list_next(winlist);
> 	}
> 	/ * g_list_free(winlist); */
> }
> 
> static gboolean html_toolbar_quickbar_item_button_press_lcb(GtkWidget *widget,GdkEventButton *bevent,Ttoolbaritem *tbitem) {
> 	if (bevent->button == 3) {
> 		GtkWidget *menu = gtk_menu_new ();
> 		GtkWidget *menuitem = gtk_menu_item_new_with_label(_("Remove from quickbar"));
> 		GtkWidget *itemleft = gtk_menu_item_new_with_label(_("Move Left"));
> 		GtkWidget *itemright = gtk_menu_item_new_with_label(_("Move Right"));
> 		GtkWidget *sep = gtk_separator_menu_item_new();
> 		DEBUG_MSG("popup for tbitem %p\n", tbitem);
> 		g_signal_connect(G_OBJECT(menuitem), "activate", G_CALLBACK(html_toolbar_remove_from_quickbar_lcb), tbitem);
> 		g_signal_connect(G_OBJECT(itemleft), "activate", G_CALLBACK(html_toolbar_quickbar_move_left_lcb), tbitem);
> 		g_signal_connect(G_OBJECT(itemright), "activate", G_CALLBACK(html_toolbar_quickbar_move_right_lcb), tbitem);
> 		gtk_menu_append(GTK_MENU(menu), itemleft);
> 		gtk_menu_append(GTK_MENU(menu), itemright);
> 		gtk_menu_append(GTK_MENU(menu), sep);
> 		gtk_menu_append(GTK_MENU(menu), menuitem);
> 		gtk_widget_show_all (menu);
> 		gtk_menu_popup (GTK_MENU (menu), NULL, NULL,
> 			  NULL, widget, 0, gtk_get_current_event_time ());
> 		return TRUE;
> 	}
> 	return FALSE;
> }
> 
> static void html_toolbar_add_to_quickbar_lcb(GtkMenuItem *menuitem, Ttoolbaritem *tbitem) {
> 	GList *tmplist = g_list_first(main_v->bfwinlist);
> 	DEBUG_MSG("adding tbitem %p to quickbars\n", tbitem);
> 	main_v->globses.quickbar_items = add_to_stringlist(main_v->globses.quickbar_items, tbitem->ident);
> 	while (tmplist) {
> 		Tquickbaritem *qbi;
> 		Tbfwin *bfwin = BFWIN(tmplist->data);
> 		qbi = g_new(Tquickbaritem,1);
> 		qbi->button = gtk_toolbar_append_item(GTK_TOOLBAR(bfwin->toolbar_quickbar), NULL, _(tbitem->tooltiptext),
> 							"", new_pixmap(tbitem->pixmaptype), G_CALLBACK(tbitem->func), bfwin);
> 		g_signal_connect(qbi->button, "button-press-event", G_CALLBACK(html_toolbar_quickbar_item_button_press_lcb), tbitem);
> 		gtk_widget_show(qbi->button);
> 		qbi->tbitem = tbitem;
> 		bfwin->toolbar_quickbar_children = g_list_append(bfwin->toolbar_quickbar_children, qbi);
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> static gboolean html_toolbar_item_button_press_lcb(GtkWidget *widget,GdkEventButton *bevent,Ttoolbaritem *tbitem) {
> 	DEBUG_MSG("html_toolbar_item_button_press_lcb, button=%d\n", bevent->button);
> 	if (bevent->button == 3) {
> 		GtkWidget *menu = gtk_menu_new ();
> 		GtkWidget *menuitem = gtk_menu_item_new_with_label(_("Add to quickbar"));
> 		DEBUG_MSG("popup for tbitem %p\n", tbitem);
> 		g_signal_connect(G_OBJECT(menuitem), "activate", G_CALLBACK(html_toolbar_add_to_quickbar_lcb), tbitem);
> 		gtk_menu_append(GTK_MENU(menu), menuitem);
> 		gtk_widget_show_all (menu);
> 		gtk_menu_popup (GTK_MENU (menu), NULL, NULL,
> 			  NULL, widget, 0, gtk_get_current_event_time ());
> 		return TRUE;
> 	}
> 	return FALSE;
> }
> 
> static void html_toolbar_add_items(Tbfwin *bfwin, GtkWidget *html_toolbar, Ttoolbaritem *tbi, gint from, gint to) {
> 	gint i;
> 	GtkWidget *item;
> 	for (i=from;i<=to;i++) {
> 		if (tbi[i].func == NULL) {
> 			gtk_toolbar_append_space(GTK_TOOLBAR(html_toolbar));
> 		} else {
> 			item = gtk_toolbar_append_item(GTK_TOOLBAR(html_toolbar), NULL, _(tbi[i].tooltiptext),
> 						NULL, new_pixmap(tbi[i].pixmaptype), G_CALLBACK(tbi[i].func), bfwin);
> 			g_signal_connect(item, "button-press-event", G_CALLBACK(html_toolbar_item_button_press_lcb), &tbi[i]);
> 			DEBUG_MSG("adding tbitem %p to html_toolbar\n", &tbi[i]);
> 		}
> 	}
> }
> 
> static void html_toolbar_add_items_to_submenu(Tbfwin *bfwin, GtkWidget *html_toolbar, Ttoolbaritem *tbi, gint from, gint to, gchar *menulabel, gint menupix) {
> 	GtkWidget *menu_bar, *sub_menu, *menu_item, *pixmap;
> 	GtkTooltips *tooltips;
> 	gint i;
> 	
> 	tooltips = gtk_tooltips_new();	
> 	sub_menu = gtk_menu_new();
> 	for (i=from;i<=to;i++) {
> 		if (tbi[i].func == NULL) {
> 			gtk_toolbar_append_space(GTK_TOOLBAR(html_toolbar));
> 		} else {
> 			menu_item = gtk_menu_item_new();
> 			gtk_tooltips_set_tip(GTK_TOOLTIPS(tooltips), menu_item, _(tbi[i].tooltiptext), NULL);
> 			gtk_container_add(GTK_CONTAINER(menu_item), new_pixmap(tbi[i].pixmaptype));
> 			g_signal_connect(GTK_OBJECT(menu_item), "activate", G_CALLBACK(tbi[i].func), bfwin);
> 			g_signal_connect(menu_item, "button-press-event", G_CALLBACK(html_toolbar_item_button_press_lcb), &tbi[i]);
> 			gtk_menu_append(GTK_MENU(sub_menu), menu_item);
> 		}
> 	}
> 	menu_bar = gtk_menu_bar_new();
> 	menu_item = gtk_menu_item_new();
> 	gtk_container_add(GTK_CONTAINER(menu_item),new_pixmap(menupix));
> 	gtk_menu_item_set_submenu(GTK_MENU_ITEM(menu_item), sub_menu);
> 	gtk_menu_bar_append(GTK_MENU_BAR(menu_bar), menu_item);
> 	pixmap = new_pixmap(menupix);
> 	gtk_toolbar_append_element(GTK_TOOLBAR(html_toolbar),GTK_TOOLBAR_CHILD_WIDGET,menu_bar,NULL,menulabel,NULL,pixmap,NULL,NULL);
> 	gtk_object_sink(GTK_OBJECT(pixmap));
> }
> 
> void make_html_toolbar(Tbfwin *bfwin) {
> /*
>  * every item with a ... in the tooltip brings up a dialog, every item
>  * without the ... in the tooltip will directly insert html code
>  *
>  */
> 	GtkWidget *html_toolbar, *html_notebook;
> 
> 	DEBUG_MSG("make_html_toolbar, started\n");
> 	html_notebook = gtk_notebook_new();
> 	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(html_notebook), GTK_POS_TOP);
> 	gtk_notebook_set_show_tabs(GTK_NOTEBOOK(html_notebook), TRUE);
> 	gtk_notebook_set_show_border(GTK_NOTEBOOK(html_notebook), TRUE);
> 	gtk_container_add(GTK_CONTAINER(bfwin->html_toolbar_hb), html_notebook);
> 
> 	bfwin->toolbar_quickbar = gtk_toolbar_new();
> 	gtk_toolbar_set_style(GTK_TOOLBAR(bfwin->toolbar_quickbar), GTK_TOOLBAR_ICONS);
> 	DEBUG_MSG("make_html_toolbar, creating quickbar\n");
> 	{
> 		GList *tmplist;
> 		gint i, numitems=(sizeof(tbi)/sizeof(Ttoolbaritem));
> 		tmplist = g_list_first(main_v->globses.quickbar_items);
> 		while (tmplist) {
> 			gchar *tmpstr = tmplist->data;
> 			DEBUG_MSG("make_html_toolbar, searching for %s\n", tmpstr);
> 			for (i=0;i<numitems;i++) {
> 				if (strcmp(tbi[i].ident, tmpstr)==0) {
> 					Tquickbaritem *qbi = g_new(Tquickbaritem,1);
> 					qbi->button = gtk_toolbar_append_item(GTK_TOOLBAR(bfwin->toolbar_quickbar), NULL, _(tbi[i].tooltiptext),
> 						"", new_pixmap(tbi[i].pixmaptype), G_CALLBACK(tbi[i].func), bfwin);
> 					g_signal_connect(qbi->button, "button-press-event", G_CALLBACK(html_toolbar_quickbar_item_button_press_lcb), &tbi[i]);
> 					qbi->tbitem = &tbi[i];
> 					bfwin->toolbar_quickbar_children = g_list_append(bfwin->toolbar_quickbar_children, qbi);
> 					DEBUG_MSG("make_html_toolbar, appended %s as quickbaritem %p to quickbar %p\n",qbi->tbitem->ident, qbi,bfwin->toolbar_quickbar);
> 					break;
> 				}
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), bfwin->toolbar_quickbar, gtk_label_new(_(" Quick bar ")));
> 
> 	html_toolbar = gtk_toolbar_new();
> 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
> 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 0, 14);
> 	html_toolbar_add_items_to_submenu(bfwin,html_toolbar, tbi, 26, 31, _("Heading"), 91);
> 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 76, 78);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" Standard bar ")));
> 
> 	html_toolbar = gtk_toolbar_new();
> 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
> 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 15, 25);
> 	html_toolbar_add_items_to_submenu(bfwin,html_toolbar, tbi, 79, 86, _("Context formatting"), 103);
> 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 25, 31);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" Fonts ")));
> 
> 	html_toolbar = gtk_toolbar_new();
> 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
> 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 32, 43);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" Tables ")));
> 
> 	html_toolbar = gtk_toolbar_new();
> 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
> 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 44, 52);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" Frames ")));
> 
> 	html_toolbar = gtk_toolbar_new();
> 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
> 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 53, 63);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" Forms ")));
> 
> 	html_toolbar = gtk_toolbar_new();
> 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
> 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 64, 70);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" List ")));
> 
> 	html_toolbar = gtk_toolbar_new();
> 	gtk_toolbar_set_style(GTK_TOOLBAR(html_toolbar), GTK_TOOLBAR_ICONS);
> 	html_toolbar_add_items(bfwin,html_toolbar, tbi, 71, 73);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(html_notebook), html_toolbar, gtk_label_new(_(" CSS ")));
> 
> 	gtk_widget_show_all(html_notebook);
> 	
> 	if (main_v->globses.quickbar_items == NULL) {
> 		gtk_notebook_set_current_page (GTK_NOTEBOOK (html_notebook), 1);
> 	}
> }
> 
> static void doc_indent_lcb(GtkWidget *wid,Tbfwin *bfwin) {
> 	if (bfwin->current_document) {
> 		doc_indent_selection(bfwin->current_document,0);
> 	}
> }
> static void doc_unindent_lcb(GtkWidget *wid,Tbfwin *bfwin) {
> 	if (bfwin->current_document) {
> 		doc_indent_selection(bfwin->current_document,1);
> 	}
> }
> 	
> 
> 
> void make_main_toolbar(Tbfwin *bfwin) {
> 	GtkWidget *toolbar = gtk_toolbar_new ();
> 	DEBUG_MSG("make_main_toolbar, started\n");
> 	gtk_toolbar_set_orientation (GTK_TOOLBAR (toolbar), GTK_ORIENTATION_HORIZONTAL);
> 	gtk_toolbar_set_style (GTK_TOOLBAR (toolbar), GTK_TOOLBAR_ICONS);
> 	gtk_toolbar_set_icon_size (GTK_TOOLBAR (toolbar), GTK_ICON_SIZE_LARGE_TOOLBAR);
> 	gtk_container_add (GTK_CONTAINER(bfwin->main_toolbar_hb), toolbar);
> 
> 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_NEW, _("New"),
> 								"", G_CALLBACK(file_new_cb), bfwin, -1);
> 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_OPEN, _("Open..."),
> 								"", G_CALLBACK(file_open_cb), bfwin, -1);
> 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_SAVE, _("Save"),
> 								"", G_CALLBACK(file_save_cb), bfwin, -1);
> 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_SAVE_AS, _("Save As..."),	
> 								"", G_CALLBACK(file_save_as_cb), bfwin, -1);
> 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_CLOSE, _("Close"),	
> 								"", G_CALLBACK(file_close_cb), bfwin, -1);		
> 	gtk_toolbar_append_space (GTK_TOOLBAR (toolbar));
> 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_CUT, _("Cut"),	
> 								"", G_CALLBACK(edit_cut_cb), bfwin, -1);
> 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_COPY, _("Copy"),	
> 								"", G_CALLBACK(edit_copy_cb), bfwin, -1);
> 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_PASTE, _("Paste"),	
> 								"", G_CALLBACK(edit_paste_cb), bfwin, -1);
> 	gtk_toolbar_append_space (GTK_TOOLBAR (toolbar));								
> 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_FIND, _("Find..."),	
> 								"", G_CALLBACK(search_cb), bfwin, -1);
> 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_FIND_AND_REPLACE, _("Replace..."),	
> 								"", G_CALLBACK(replace_cb), bfwin, -1);
> 	gtk_toolbar_append_space (GTK_TOOLBAR (toolbar));								
> 	bfwin->toolbar_undo = gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_UNDO, _("Undo"),	
> 								"", G_CALLBACK(undo_cb), bfwin, -1);
> 	bfwin->toolbar_redo = gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_REDO, _("Redo"),	
> 								"", G_CALLBACK(redo_cb), bfwin, -1);
> 	gtk_toolbar_append_space (GTK_TOOLBAR(toolbar));
> #ifdef HAVE_ATLEAST_GTK_2_4
>    gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_UNINDENT, _("Shift Left"), 
>                         "", G_CALLBACK (doc_unindent_lcb), bfwin, -1);
>    gtk_toolbar_insert_stock (GTK_TOOLBAR( toolbar), GTK_STOCK_INDENT, _("Shift Right"),
>                         "", G_CALLBACK (doc_indent_lcb), bfwin, -1);
> #else
> 	gtk_toolbar_append_item(GTK_TOOLBAR(toolbar), NULL, _("Shift Left"),
>                         "", new_pixmap(111), G_CALLBACK(doc_unindent_lcb), bfwin);
> 	gtk_toolbar_append_item(GTK_TOOLBAR(toolbar), NULL, _("Shift Right"),
>                         "", new_pixmap(110), G_CALLBACK(doc_indent_lcb), bfwin);
> #endif
> /*
> 	gtk_toolbar_append_item(GTK_TOOLBAR(toolbar), NULL, _("Print..."), "",
> 							new_pixmap(015), G_CALLBACK(file_print_cb), NULL);*/
> #ifdef HAVE_LIBASPELL
> 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_SPELL_CHECK, _("Spellcheck..."),
> 							"", G_CALLBACK(spell_check_cb), bfwin, -1);
> #endif /* HAVE_LIBASPELL */
> 
> 	gtk_toolbar_append_item(GTK_TOOLBAR(toolbar), NULL,
> 							_("View in browser"), "",
> 							new_pixmap(102), G_CALLBACK(browser_toolbar_cb), bfwin);
> 	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
> 	gtk_toolbar_insert_stock (GTK_TOOLBAR (toolbar), GTK_STOCK_PREFERENCES, _("Preferences..."),	
> 								"", G_CALLBACK(open_preferences_cb), NULL, -1);	
> 
> 	gtk_widget_show_all(toolbar);
> }
> 
> void gui_set_undo_redo_widgets(Tbfwin *bfwin, gboolean undo, gboolean redo) {
> 	if (GTK_WIDGET_VISIBLE(bfwin->main_toolbar_hb)) {
> 		gtk_widget_set_sensitive(bfwin->toolbar_redo, redo);
> 		gtk_widget_set_sensitive(bfwin->toolbar_undo, undo);
> 	}
> 	
> 	menuitem_set_sensitive(bfwin->menubar, "/Edit/Undo", undo);
> 	menuitem_set_sensitive(bfwin->menubar, "/Edit/Undo All", undo);
> 	menuitem_set_sensitive(bfwin->menubar, "/Edit/Redo", redo);
> 	menuitem_set_sensitive(bfwin->menubar, "/Edit/Redo All", redo);
> }
> 
> void gui_set_document_widgets(Tdocument *doc) {
> 	GtkItemFactory *tmp1 = gtk_item_factory_from_widget(BFWIN(doc->bfwin)->menubar);
> 	setup_toggle_item(tmp1,("/Document/Highlight Syntax"), (doc->highlightstate && doc->hl->highlightlist != NULL));
> 	/*gtk_widget_set_sensitive(gtk_item_factory_get_widget(tmp1,_("/Document/Highlight Syntax")), (doc->hl->highlightlist != NULL));*/
> 	gui_set_undo_redo_widgets(doc->bfwin, doc_has_undo_list(doc), doc_has_redo_list(doc));
> 	setup_toggle_item(gtk_item_factory_from_widget(BFWIN(doc->bfwin)->menubar),"/Document/Wrap", doc->wrapstate);
> 	setup_toggle_item(gtk_item_factory_from_widget(BFWIN(doc->bfwin)->menubar),"/Document/Line Numbers", doc->linenumberstate);
> 	setup_toggle_item(gtk_item_factory_from_widget(BFWIN(doc->bfwin)->menubar),"/Document/Auto Close HTML tags", doc->autoclosingtag);
> 	menu_current_document_set_toggle_wo_activate(BFWIN(doc->bfwin),doc->hl, doc->encoding);
> }
> 
> void gui_notebook_bind_signals(Tbfwin *bfwin) {
> 	bfwin->notebook_switch_signal = g_signal_connect_after(G_OBJECT(bfwin->notebook),"switch-page",G_CALLBACK(notebook_switch_page_lcb), bfwin);
> }
> 
> void gui_notebook_unbind_signals(Tbfwin *bfwin) {
> if (bfwin->notebook_switch_signal != 0) {
> 		g_signal_handler_disconnect(G_OBJECT(bfwin->notebook),bfwin->notebook_switch_signal);
> 		bfwin->notebook_switch_signal = 0;
> 	}
> }
> 
> static gboolean gui_main_window_configure_event_lcb(GtkWidget *widget,GdkEvent *revent,Tbfwin *bfwin) {
> 	if (main_v->props.restore_dimensions) {
> 		if (revent->type == GDK_CONFIGURE) {
> 			GdkEventConfigure *event = (GdkEventConfigure *)revent;
> 			if (main_v->globses.main_window_w > 0 ) {
> 				main_v->globses.main_window_w = event->width;
> 				main_v->globses.main_window_h = event->height;
> 				DEBUG_MSG("gui_main_window_configure_event_lcb, width=%d, height=%d\n",main_v->globses.main_window_w,main_v->globses.main_window_h);
> 			}
> 		} else if (revent->type == GDK_WINDOW_STATE) {
> 			GdkEventWindowState *event = (GdkEventWindowState *)revent;
> 			if (event->new_window_state == GDK_WINDOW_STATE_MAXIMIZED && main_v->globses.main_window_w > 0) {
> 				main_v->globses.main_window_w = -1 * main_v->globses.main_window_w; /* negative means it is maximized !! */
> 				DEBUG_MSG("gui_main_window_configure_event_lcb, maximized!! width=%d\n",main_v->globses.main_window_w);
> 			} else if (event->new_window_state != GDK_WINDOW_STATE_MAXIMIZED && main_v->globses.main_window_w < 0) {
> 				main_v->globses.main_window_w = -1 * main_v->globses.main_window_w; /* make it positive again */
> 				DEBUG_MSG("gui_main_window_configure_event_lcb, NOT-maximized, width=%d\n",main_v->globses.main_window_w);
> 			}
> 		}
> 	}
> 	return FALSE;
> }
> 
> enum {
> TARGET_URI_LIST,
> TARGET_STRING
> } Tdnd_types;
> static void main_win_on_drag_data_lcb(GtkWidget * widget, GdkDragContext * context
> 			, gint x, gint y, GtkSelectionData * data
> 			, guint info, guint time, Tbfwin *bfwin) {
> 	gchar *filename, *url;
> 	int mode = 0;
> 	gint url_is_local;
> 
> 	if ((data->length == 0) || (data->format != 8) || ((info != TARGET_STRING) && (info != TARGET_URI_LIST))) {
> 		DEBUG_MSG("on_drag_data_cb, currently unknown DnD object, need to do string comparision\n");
> 		gtk_drag_finish(context, FALSE, TRUE, time);
> 		return;
> 	}
> 
> 	/* netscape sends URL's labelled as string */
> 	if (info == TARGET_STRING) {
> 		gchar *stringdata = g_strndup((gchar *)data->data, data->length);
> 		if (strchr(stringdata, ':')) {
> 			DEBUG_MSG("on_drag_data_cb, TARGET_STRING contains :, so it's probably an URL\n");
> 			info = TARGET_URI_LIST;
> 		}
> 		g_free(stringdata);
> 	}
> 
> 	/* construct both filename and url from the given data */
> 	if (info == TARGET_STRING) {
> 		filename = g_strndup((gchar *)data->data, data->length);
> 		filename = trunc_on_char(trunc_on_char(filename, '\n'), '\r');
> 		url = g_strconcat("file:", filename, NULL);
> 		url_is_local = 1;
> 		DEBUG_MSG("on_drag_data_cb, TARGET_STRING, url=%s\n",url);
> 	} else { /* TARGET_UTI_LIST*/
> 		gchar *tmp2;
> 		gint len;
> 
> 		url = g_strndup((gchar *)data->data, data->length);
> 		url = trunc_on_char(trunc_on_char(url, '\n'), '\r');
> 		if (strncmp(url, "file://", 7) == 0) {
> 			filename = g_strdup(url+7);
> 			url_is_local = 1;
> 			DEBUG_MSG("on_drag_data_cb, TARGET_URI_LIST, url=%s, filename=%s\n",url,filename);
> 		} else {
> 			len = strlen(url);
> 			tmp2 = strrchr(url, '#');
> 			if (tmp2) {
> 				len -= strlen(tmp2);
> 			}
> 			filename = g_strndup(url, len);
> 			url_is_local = 0;
> 			DEBUG_MSG("on_drag_data_cb, TARGET_URI_LIST, url=%s\n",url);
> 		}
> 	}
> 	
> 	DEBUG_MSG("on_drag_data_cb, filename='%s', url='%s'\n", filename, url);
> 	if (g_str_has_suffix (url_is_local ? filename : url, ".bfproject")) {
> 	    project_open_from_file(bfwin, url_is_local ? filename : url);
> 	} else {
> 	    doc_new_with_file(bfwin,url_is_local ? filename : url, FALSE, FALSE);
> 	}
> 
> 	gtk_drag_finish(context, TRUE, (mode == GDK_ACTION_COPY), time);
> 	g_free(filename);
> 	g_free(url);
> }
> 
> void gui_bfwin_cleanup(Tbfwin *bfwin) {
> 	GList *tmplist;
> 	/* call all cleanup functions here */
> 	/*remove_window_entry_from_all_windows(bfwin);*/
> 	
> 	/* all documents have to be freed for this window */
> 	tmplist = g_list_first(bfwin->documentlist);
> 	DEBUG_MSG("gui_bfwin_cleanup, have %d documents in window %p\n",g_list_length(bfwin->documentlist),bfwin);
> 	while (tmplist) {
> 		DEBUG_MSG("gui_bfwin_cleanup closing doc=%p\n",tmplist->data);
> 		doc_destroy(DOCUMENT(tmplist->data), TRUE);
> 		/* no this is not an indefinite loop, because the documents remove themselves
> 		from the documentlist, we remove the top document untill there are no documents
> 		left */
> 		tmplist = g_list_first(bfwin->documentlist);
> 	}
> 	
> 	bmark_cleanup(bfwin);
> }
> 
> void main_window_destroy_lcb(GtkWidget *widget,Tbfwin *bfwin) {
> 	DEBUG_MSG("main_window_destroy_lcb, started\n");
> 	DEBUG_MSG("main_window_destroy_lcb, will hide the window now\n");
> 	gtk_widget_hide(bfwin->main_window);
> 	main_v->bfwinlist = g_list_remove(main_v->bfwinlist, bfwin);
> 	DEBUG_MSG("main_window_destroy_lcb, bfwin(%p) is removed from bfwinlist\n",bfwin);
> 	gui_bfwin_cleanup(bfwin);
> 	DEBUG_MSG("main_window_destroy_lcb, will destroy the window now\n");
> 	gtk_widget_destroy(bfwin->main_window);
> 	g_free(bfwin);
> 	DEBUG_MSG("main_window_destroy_lcb, bfwin is free'ed\n");
> 	if (NULL == main_v->bfwinlist) {
> 		bluefish_exit_request();
> 	}
> }
> gboolean main_window_delete_event_lcb(GtkWidget *widget,GdkEvent *event,Tbfwin *bfwin) {
> 	/* If you return FALSE in the "delete_event" signal handler,
> 	 * GTK will emit the "destroy" signal. Returning TRUE means
> 	 * you don't want the window to be destroyed.
> 	 * This is useful for popping up 'are you sure you want to quit?'
> 	 * type dialogs. */
> 	DEBUG_MSG("main_window_delete_event_lcb, started\n");
> 	if (bfwin->project) {
> 		return !project_save_and_close(bfwin);
> 	} else {
> 		if (bfwin->documentlist && test_docs_modified(bfwin->documentlist)) {
> 			DEBUG_MSG("main_window_delete_event_lcb, we have changed documents!\n");
> 			bfwin_close_all_documents(bfwin, TRUE);
> 			if (bfwin->documentlist && test_docs_modified(bfwin->documentlist)) {
> 				DEBUG_MSG("main_window_delete_event_lcb, we STILL have changed documents!?!\n");
> 				/* if there are still documents modified we should cancel the closing */
> 				return TRUE;
> 			}
> 		} else {
> 			/* no changed documents, but there might be changed bookmarks */
> 			bmark_store_all(bfwin);
> 		}
> 	}
> 	return FALSE;
> }
> 
> void gui_create_main(Tbfwin *bfwin, GList *filenames) {
> 	GtkWidget *vbox;
> 	DEBUG_MSG("gui_create_main, bfwin=%p, bfwin->bookmarkstore=%p\n",bfwin,bfwin->bookmarkstore);
> 	bfwin->main_window = window_full2(_("New Bluefish Window"), GTK_WIN_POS_CENTER, 0, G_CALLBACK(main_window_destroy_lcb), bfwin, FALSE, NULL);
> 	gtk_window_set_role(GTK_WINDOW(bfwin->main_window), "bluefish");
> 	if (main_v->globses.main_window_w > 0) {
> 		gtk_window_set_default_size(GTK_WINDOW(bfwin->main_window), main_v->globses.main_window_w, main_v->globses.main_window_h);
> 	} else {
> 		gtk_window_set_default_size(GTK_WINDOW(bfwin->main_window), main_v->globses.main_window_w * -1, main_v->globses.main_window_h);
> 		gtk_window_maximize(GTK_WINDOW(bfwin->main_window));
> 	}
> 	g_signal_connect(G_OBJECT(bfwin->main_window), "delete_event", G_CALLBACK(main_window_delete_event_lcb), bfwin);
> 	g_signal_connect(G_OBJECT(bfwin->main_window), "configure-event", G_CALLBACK(gui_main_window_configure_event_lcb), bfwin);
> 	g_signal_connect(G_OBJECT(bfwin->main_window), "window-state-event", G_CALLBACK(gui_main_window_configure_event_lcb), bfwin);
> 
> 	vbox = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(bfwin->main_window), vbox);
> 	gtk_widget_show(vbox);
> 
> 	/* first a menubar */
> 	DEBUG_MSG("gui_create_main, starting menu_create_main\n");
> 	menu_create_main(bfwin, vbox);
> 	DEBUG_MSG("gui_create_main, starting recent_menu\n");
> 	recent_menu_init(bfwin);
> 	DEBUG_MSG("gui_create_main, starting external-encoding_menu\n");
> 	external_menu_rebuild(bfwin);
> 	encoding_menu_rebuild(bfwin);
> 	snr2_init(bfwin);
> /*	add_window_entry_to_all_windows(bfwin);
> 	add_allwindows_entries_to_window(bfwin);*/
> 	/* then the toolbars */
> 	{
> 		DEBUG_MSG("gui_create_main, creating handles for all menu/toolbars\n");
> 		bfwin->main_toolbar_hb = gtk_handle_box_new();
> 		gtk_box_pack_start(GTK_BOX(vbox), bfwin->main_toolbar_hb, FALSE, FALSE, 0);
> 		bfwin->html_toolbar_hb = gtk_handle_box_new();
> 		gtk_box_pack_start(GTK_BOX(vbox), bfwin->html_toolbar_hb, FALSE, FALSE, 0);
> 		bfwin->custom_menu_hb = gtk_handle_box_new();
> 		gtk_box_pack_start(GTK_BOX(vbox), bfwin->custom_menu_hb, FALSE, FALSE, 0);
> 
> 		if (bfwin->session->view_main_toolbar) {
> 			make_main_toolbar(bfwin);
> 			gtk_widget_show(bfwin->main_toolbar_hb);
> 		}
> 		if (bfwin->session->view_html_toolbar) {
> 			make_html_toolbar(bfwin);
> 			gtk_widget_show(bfwin->html_toolbar_hb);
> 		}
> 		if (bfwin->session->view_custom_menu) {
> 			make_cust_menubar(bfwin,bfwin->custom_menu_hb);
> 			gtk_widget_show(bfwin->custom_menu_hb);
> 		}
> 	}
> 	
> 	/* then the work area */
> 	bfwin->middlebox = gtk_hbox_new(TRUE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox), bfwin->middlebox, TRUE, TRUE, 0);
> 	gtk_widget_show(bfwin->middlebox);
> 
> 	/* Fake-label (for notebook_hide() and _show() ;) */
> 	bfwin->notebook_fake = gtk_label_new(_("Stand by..."));
> 	
> 	/* notebook with the text widget in there */
> 	bfwin->notebook = gtk_notebook_new();
> 	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(bfwin->notebook),main_v->props.document_tabposition);
> 	gtk_notebook_set_show_tabs(GTK_NOTEBOOK(bfwin->notebook), TRUE);
> 	gtk_notebook_set_show_border(GTK_NOTEBOOK(bfwin->notebook), FALSE);
> 	gtk_notebook_set_tab_hborder(GTK_NOTEBOOK(bfwin->notebook), 0);
> 	gtk_notebook_set_tab_vborder(GTK_NOTEBOOK(bfwin->notebook), 0);
> 	gtk_notebook_popup_enable(GTK_NOTEBOOK(bfwin->notebook));
> 
> 	/* Add notebook and its fake friend to their common hbox. */
> 	bfwin->notebook_box = gtk_hbox_new (TRUE, 0);
> 	gtk_box_pack_start(GTK_BOX(bfwin->notebook_box), bfwin->notebook, TRUE, TRUE, 0);
> 	gtk_box_pack_start(GTK_BOX(bfwin->notebook_box), bfwin->notebook_fake, TRUE, TRUE, 0);
> 
> 	/* output_box */
> 	init_output_box(bfwin, vbox);
> 
> 	left_panel_show_hide_toggle(bfwin,TRUE, (bfwin->session->view_left_panel), FALSE);
> 
> 	/* finally the statusbar */
> 	{
> 		GtkWidget *hbox;
> 		gint onecharwidth;
> 		hbox = gtk_hbox_new(FALSE,0);
> 		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
> 		bfwin->statusbar = gtk_statusbar_new();
> 		gtk_statusbar_set_has_resize_grip(GTK_STATUSBAR(bfwin->statusbar), FALSE);
> 		gtk_box_pack_start(GTK_BOX(hbox), bfwin->statusbar, TRUE, TRUE, 0);
> 		bfwin->statusbar_lncol = gtk_statusbar_new();
> 		gtk_statusbar_set_has_resize_grip(GTK_STATUSBAR(bfwin->statusbar_lncol), FALSE);
> 		gtk_box_pack_start(GTK_BOX(hbox), bfwin->statusbar_lncol, FALSE, FALSE, 0);
> 		/* I hope the 'w' is an average width character */
> 		onecharwidth = widget_get_string_size(bfwin->statusbar_lncol, "w");
> 		gtk_widget_set_size_request(GTK_WIDGET(bfwin->statusbar_lncol), 17*onecharwidth, -1);
> 		bfwin->statusbar_insovr = gtk_statusbar_new();
> 		gtk_statusbar_set_has_resize_grip(GTK_STATUSBAR(bfwin->statusbar_insovr), FALSE);
> 		gtk_box_pack_start(GTK_BOX(hbox), bfwin->statusbar_insovr, FALSE, FALSE, 0);
> 		gtk_widget_set_size_request(GTK_WIDGET(bfwin->statusbar_insovr), onecharwidth * 4, -1);
> 		bfwin->statusbar_editmode = gtk_statusbar_new();
> 		gtk_box_pack_start(GTK_BOX(hbox), bfwin->statusbar_editmode, FALSE, FALSE, 0);
> 		gtk_widget_set_size_request(GTK_WIDGET(bfwin->statusbar_editmode), onecharwidth * 25, -1);
> 		gtk_widget_show_all(hbox);
> 	}
> 	/* We have to know when the notebook changes */
> 	gui_notebook_bind_signals(bfwin);
> 	
> 	/* everything is ready - we can start loading documents */
> 	/* start to open an empty doc */
> 	file_new_cb(NULL, bfwin);
> 	if (filenames) {
> 		DEBUG_MSG("gui_create_main, we have filenames, load them\n");
> 		docs_new_from_files(bfwin,filenames,(bfwin->project != NULL));
> 	}
> 
> 	gtk_notebook_set_current_page(GTK_NOTEBOOK(bfwin->notebook), 0);
> 	gtk_notebook_set_scrollable(GTK_NOTEBOOK(bfwin->notebook), TRUE);
> 	/* don't use show_all since some widgets are and should be hidden */
> 	gtk_widget_show(bfwin->notebook);
> 	gtk_widget_show (bfwin->notebook_box);
> 
> 	{
> 		/* drag n drop support */
> 		const GtkTargetEntry drag_dest_types[] = {
> 			{"text/uri-list", 0, TARGET_URI_LIST },
> 			{"STRING", 0, TARGET_STRING},
> 		};
> 		gtk_drag_dest_set(bfwin->main_window, (GTK_DEST_DEFAULT_ALL)
> 				,drag_dest_types, 2
> 				,(GDK_ACTION_DEFAULT | GDK_ACTION_COPY | GDK_ACTION_MOVE |
> 				GDK_ACTION_LINK | GDK_ACTION_PRIVATE | GDK_ACTION_ASK));
> 		g_signal_connect(G_OBJECT(bfwin->main_window), "drag_data_received", G_CALLBACK(main_win_on_drag_data_lcb), bfwin);
> 	}
> }
> 
> void gui_show_main(Tbfwin *bfwin) {
> 	/* show all */
> 	DEBUG_MSG("gui_show_main, before show\n");
> 	/* don't use show_all since some widgets are and should be hidden */
> 	gtk_widget_show(bfwin->main_window);
> 	flush_queue();
> 	doc_scroll_to_cursor(bfwin->current_document);
> /*	if ((bfwin->project && bfwin->project->view_left_panel) || (!bfwin->project && main_v->props.view_left_panel)) {
> 		filebrowser_scroll_initial(bfwin);
> 	}*/
> }
> /***********************/
> /* statusbar functions */
> /***********************/
> typedef struct {
> 	gint message_id;
> 	Tbfwin *bfwin;
> } Tstatusbar_remove;
> 
> static gint statusbar_remove(gpointer sr) {
> 	gtk_statusbar_remove(GTK_STATUSBAR(((Tstatusbar_remove *)sr)->bfwin->statusbar), 0, ((Tstatusbar_remove *)sr)->message_id);
> 	g_free(sr);
> 	return FALSE;
> }
> 
> void statusbar_message(Tbfwin *bfwin,gchar *message, gint time) {
> 	if (bfwin->statusbar) {
> 		Tstatusbar_remove *sr = g_new(Tstatusbar_remove,1);
> 		sr->bfwin = bfwin;
> 		sr->message_id = gtk_statusbar_push(GTK_STATUSBAR(bfwin->statusbar), 0, message);
> 		gtk_timeout_add(time, statusbar_remove, sr);
> 	}
> }
> 
> 
> /***********************/
> /* GOTO line functions */
> /***********************/
> 
> typedef struct {
> 	GtkWidget *win;
> 	GtkWidget *entry;
> 	GtkWidget *check;
> 	Tbfwin *bfwin;
> } Tgotoline;
> 
> static void tgl_destroy_lcb(GtkWidget * widget, Tgotoline *tgl) {
> 	window_destroy(tgl->win);
> 	g_free(tgl);
> }
> 
> static void tgl_ok_clicked_lcb(GtkWidget * widget, Tgotoline *tgl)
> {
> 	gchar *linestr;
> 	gint linenum;
> 
> 	linestr = gtk_editable_get_chars(GTK_EDITABLE(tgl->entry), 0, -1);
> 	linenum = get_int_from_string(linestr);
> 	DEBUG_MSG("tgl_ok_clicked_lcb, going to line %d (linestr=%s)\n", linenum, linestr);
> 	g_free(linestr);
> 	
> 	if (linenum > 0) {
> 		doc_select_line(tgl->bfwin->current_document, linenum, TRUE);
> 	}
> 
> 	if (GTK_TOGGLE_BUTTON(tgl->check)->active) {
> 		if (linenum > 0) {
> 			gchar *new_text;
> 			gint position=0;
> 			gtk_editable_delete_text (GTK_EDITABLE(tgl->entry), 0, -1);
> 			new_text = g_strdup_printf("%d", linenum);
> 			gtk_editable_insert_text(GTK_EDITABLE(tgl->entry),new_text,strlen(new_text),&position);
> 			g_free(new_text);
> 		}
> 	} else {
> 		tgl_destroy_lcb(NULL, tgl);
> 	}
> 
> }
> 
> static void tgl_fromsel_clicked_lcb(GtkWidget * widget, Tgotoline *tgl) {
> 	gchar *string;
> 	GtkClipboard* cb;
> 
> 	cb = gtk_clipboard_get(GDK_SELECTION_PRIMARY);
> 	string = gtk_clipboard_wait_for_text(cb);
> 	if (string) {
> 		gtk_entry_set_text(GTK_ENTRY(tgl->entry), string);
> 	}
> 	tgl_ok_clicked_lcb(widget, tgl);
> }
> 
> static void tgl_cancel_clicked_lcb(GtkWidget *widget, gpointer data) {
> 	tgl_destroy_lcb(NULL, data);
> }
> 
> void tgl_enter_lcb (GtkWidget *widget, gpointer ud) {
>      Tgotoline *tgl;
>      tgl = ud;
>      tgl_ok_clicked_lcb (widget, tgl);
> }
> 
> void go_to_line_win_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
> 	Tgotoline *tgl;
> 	GtkWidget *but1, *vbox, *hbox, *label;
> 	
> 	tgl = g_new(Tgotoline, 1);
> 	tgl->bfwin = bfwin;
> 	tgl->win = window_full(_("Goto line"), GTK_WIN_POS_MOUSE
> 						  ,12, G_CALLBACK(tgl_destroy_lcb), tgl, TRUE);
> 	vbox = gtk_vbox_new(FALSE, 12);
> 	gtk_container_add(GTK_CONTAINER(tgl->win), vbox);
> 
> 	hbox = gtk_hbox_new(FALSE, 12);
> 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
> 
> 	label = gtk_label_new_with_mnemonic(_("_Line number:"));
> 	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
> 
> 	tgl->entry = boxed_entry_with_text(NULL, 20, hbox);
> 	gtk_label_set_mnemonic_widget(GTK_LABEL(label), tgl->entry); /* mnemonic for label */
> 
> 	but1 = bf_generic_mnemonic_button(_("From _selection"), G_CALLBACK(tgl_fromsel_clicked_lcb), tgl);
> 	gtk_box_pack_start(GTK_BOX(hbox), but1, FALSE, FALSE, 0);
> 
> 	tgl->check = boxed_checkbut_with_value(_("Keep _dialog"), 0, vbox);
> 	
> 	gtk_box_pack_start(GTK_BOX(vbox), gtk_hseparator_new(), TRUE, TRUE, 0);
> 	
> 	hbox = gtk_hbutton_box_new();
> 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
> 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 12);
> 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);	
> 	
> 	but1 = bf_stock_cancel_button(G_CALLBACK(tgl_cancel_clicked_lcb), tgl);
> 	gtk_box_pack_start(GTK_BOX(hbox), but1, FALSE, FALSE, 0);
> 	gtk_widget_grab_focus (tgl->entry);
> 
> 	but1 = bf_stock_ok_button(G_CALLBACK(tgl_ok_clicked_lcb), tgl);
> 	gtk_box_pack_start(GTK_BOX(hbox), but1, FALSE, FALSE, 0);
> 	gtk_window_set_default(GTK_WINDOW(tgl->win), but1);
> 
> 	gtk_widget_show_all(tgl->win);
> }
> 
> void go_to_line_from_selection_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
> 	gchar *string;
> 	GtkClipboard* cb;
> 	gint linenum;
> 
> 	cb = gtk_clipboard_get(GDK_SELECTION_PRIMARY);
> 	string = gtk_clipboard_wait_for_text(cb);
> 	if (string) {
> 		linenum = get_int_from_string(string);
> 		if (linenum > 0) {
> 			doc_select_line(bfwin->current_document, linenum, TRUE);
> 		}
> 	}
> }
> 
> #ifndef NOSPLASH
> 
> void splash_screen_set_label(gchar *label) {
> 	static struct timespec const req = { 0, 10000000};
> #ifdef DEBUG
> 	g_print("Setting splash label to %s\n", label);
> #endif
> 	gtk_label_set(GTK_LABEL(splashscreen.label),label);
> 	flush_queue();
> 	nanosleep(&req, NULL);
> }
> 
> GtkWidget *start_splash_screen() {
> 	static struct timespec const req = { 0, 100000000};
> 	GtkWidget *image, *vbox;
> 	GdkColor color;
> 
> 	splashscreen.window = window_with_title(CURRENT_VERSION_NAME, GTK_WIN_POS_CENTER_ALWAYS, 0);
> 	gtk_window_set_decorated(GTK_WINDOW(splashscreen.window), FALSE);
> 	gtk_window_set_role(GTK_WINDOW(splashscreen.window), "splash");
> 	gtk_window_set_resizable(GTK_WINDOW(splashscreen.window),FALSE);
> 	color.red = 65535;
> 	color.blue = 65535;
> 	color.green = 65535;
> 	gtk_widget_modify_bg(splashscreen.window, GTK_STATE_NORMAL,&color);
> 
> 
> 	vbox = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(splashscreen.window), vbox);
> 	gtk_widget_show(vbox);
> 	splashscreen.label = gtk_label_new(_("starting bluefish"));
> 	gtk_box_pack_end(GTK_BOX(vbox),splashscreen.label , FALSE, FALSE, 0);
> 	gtk_widget_show(splashscreen.label);
> 	{
> 		GError *error=NULL;
> 		GdkPixbuf* pixbuf= gdk_pixbuf_new_from_file(BLUEFISH_SPLASH_FILENAME,&error);
> 		if (error) {
> 			g_print("ERROR while loading splash screen: %s\n", error->message);
> 			g_error_free(error);
> 		} else if (pixbuf) {
> 			image = gtk_image_new_from_pixbuf(pixbuf);
> 			gtk_box_pack_end(GTK_BOX(vbox), image, FALSE, FALSE, 0);
> 			g_object_unref(pixbuf);
> 			gtk_widget_show(image);
> 		}
> 	}
> 
> 	gtk_widget_show(splashscreen.window);
> 	flush_queue();
> 	DEBUG_MSG("start_splash_screen, should be visible\n");
> 	nanosleep(&req, NULL);
> 	return splashscreen.window;
> }
> #endif /* #ifndef NOSPLASH */
> 
> void gui_set_html_toolbar_visible(Tbfwin *bfwin, gboolean visible, gboolean sync_menu) {
> 	if (sync_menu) {
> 		DEBUG_MSG("gui_set_html_toolbar_visible, trying to sync menu\n");
> 		setup_toggle_item_from_widget(bfwin->menubar, "/View/View HTML Toolbar", visible);
> 	}
> 	if (gtk_container_children(GTK_CONTAINER(bfwin->html_toolbar_hb)) == NULL) {
> 		make_html_toolbar(bfwin);
> 	}
> 	widget_set_visible(bfwin->html_toolbar_hb,visible);
> }
> void gui_set_main_toolbar_visible(Tbfwin *bfwin, gboolean visible, gboolean sync_menu) {
> 	if (sync_menu) {
> 		DEBUG_MSG("gui_set_main_toolbar_visible, trying to sync menu\n");
> 		setup_toggle_item_from_widget(bfwin->menubar, "/View/View Main Toolbar", visible);
> 	}
> 	if (gtk_container_children(GTK_CONTAINER(bfwin->main_toolbar_hb)) == NULL) {
> 		make_main_toolbar(bfwin);
> 	}
> 	widget_set_visible(bfwin->main_toolbar_hb,visible);
> }
> void gui_set_custom_menu_visible(Tbfwin *bfwin, gboolean visible, gboolean sync_menu) {
> 	if (sync_menu) {
> 		DEBUG_MSG("gui_set_custom_menu_visible, trying to sync menu\n");
> 		setup_toggle_item_from_widget(bfwin->menubar, "/View/View Custom Menu", visible);
> 	}
> 	if (gtk_container_children(GTK_CONTAINER(bfwin->custom_menu_hb)) == NULL) {
> 		make_cust_menubar(bfwin,bfwin->custom_menu_hb);
> 	}
> 	widget_set_visible(bfwin->custom_menu_hb,visible);
> }
> 
> void gui_toggle_hidewidget_cb(Tbfwin *bfwin,guint action,GtkWidget *widget) {
> 	gboolean active = GTK_CHECK_MENU_ITEM(widget)->active;
> 	DEBUG_MSG("gui_toggle_hidewidget_cb, action=%d, active=%d\n",action,active);
> 	switch (action) {
> 	case 1:
> 		bfwin->session->view_main_toolbar = active;
> 		gui_set_main_toolbar_visible(bfwin, active, FALSE);
> 	break;
> 	case 2:
> 		bfwin->session->view_html_toolbar = active;
> 		gui_set_html_toolbar_visible(bfwin, active, FALSE);
> 	break;
> 	case 3:
> 		bfwin->session->view_custom_menu = active;
> 		gui_set_custom_menu_visible(bfwin, active, FALSE);
> 	break;
> 	case 4:
> 		bfwin->session->view_left_panel = active;
> 		left_panel_show_hide_toggle(bfwin,FALSE, active, FALSE);
> 	break;
> 	default:
> 		g_print("gui_toggle_hidewidget_cb should NEVER be called with action %d\n", action);
> 		exit(1);
> 	break;
> 	}
> }
> 
> Tbfwin *gui_new_window(GList *filenames, Tproject *project) {
> 	Tbfwin *bfwin = g_new0(Tbfwin,1);
> 	bfwin->bmark_files = NULL; /* Oskar */
> 	if (project) {
> 		bfwin->project = project;
> 		bfwin->session = project->session;
> 		bfwin->bookmarkstore = project->bookmarkstore;
> 		DEBUG_MSG("gui_new_window, bfwin=%p, bfwin->bookmarkstore=%p (from project %p)\n",bfwin,bfwin->bookmarkstore,project);
> 	} else {
> 		bfwin->session = main_v->session;
> 		bfwin->bookmarkstore = main_v->bookmarkstore;
> 		DEBUG_MSG("gui_new_window, bfwin=%p, bfwin->bookmarkstore=%p (from main_v)\n",bfwin,bfwin->bookmarkstore);
> 	}
> 	gui_create_main(bfwin,filenames);
> 	/* never comment this out again Jim! */
> 	main_v->bfwinlist = g_list_append(main_v->bfwinlist, bfwin);
> 	gui_show_main(bfwin);
> 	return bfwin;
> }
> 
> void gui_window_menu_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
> 	switch (callback_action) {
> 		case 1:
> 			gui_new_window(NULL, NULL);
> 		break;
> 		case 2: /* close the window */
> 			if (main_window_delete_event_lcb(NULL, NULL, bfwin) == FALSE) {
> 				gtk_widget_destroy(bfwin->main_window);
> 			}
> 		break;
> 	}
> }
1,1595c1,1595
< /* Bluefish HTML Editor
<  * highlight.c - the syntax highlighting with perl compatible regular expressions
<  *
<  * Copyright (C) 2002-2005 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< /*
<  * indenting is done with
<  * indent --line-length 100 --k-and-r-style --tab-size 4 -bbo --ignore-newlines highlight.c
<  */
< 
< /* #define HL_TIMING
< #define HL_DEBUG 
< #define DEBUG */
< 
< /* #ifdef DEBUG
< #define DEVELOPMENT
< #endif
<  */
< #ifdef HL_TIMING /* some overall profiling information, not per pattern, but per type of code , interesting to bluefish programmers*/
< #include <sys/times.h>
< #include <unistd.h>
< #endif
< 
< #include <gtk/gtk.h>
< #include <sys/types.h>    /* _before_ regex.h for freeBSD */
< #include <pcre.h>         /* pcre_*() */
< 
< #ifdef HAVE_PCRE_UTF8 
< #ifndef PCRE_UTF8         /* for compatibility with older libpcre's */
< #define PCRE_UTF8 0
< #endif /* PCRE_UTF8 */
< #endif /* HAVE_PCRE_UTF8 */
< 
< #include <string.h>       /* strerror() */
< #include <stdlib.h>       /* atoi() */
< 
< #include "config.h"       /* HL_PROFILING might be defined there */
< 
< #ifdef HL_PROFILING       /* per pattern profiling information, interesting for users making a new pattern */
< #include <sys/times.h>
< #include <unistd.h>
< #endif
< 
< #include "bluefish.h"
< #include "bf_lib.h"       /* filename_test_extensions() */
< #include "document.h"     /* doc_get_chars() */
< #include "gtk_easy.h"     /* error_dialog() */
< #include "highlight.h"
< #include "menu.h"         /* menu_current_document_set_toggle_wo_activate */
< #include "rcfile.h"       /* array_from_arglist() */
< #include "stringlist.h"   /* count_array() */
< 
< #define MIN_OVECTOR 9     /* the minimum size for the ovector */
< #define MAX_OVECTOR 30    /* should be a multiple of three for pcre_exec(), 
<                              and at maximum 2/3 of this size can really be used for substrings */
< 
< typedef struct {
< 	pcre *pcre;
< 	pcre_extra *pcre_e;
< } Treg;
< 
< typedef struct {
< 	gchar *name;
< 	GtkTextTag *tag;
< } Thlstyle;
< 
< typedef struct {
< 	Treg reg1;
< 	Treg reg2;
< 	gint numsub;
< 	gint mode;
< 	GList *childs;
< 	GtkTextTag *tag;
< #ifdef HL_PROFILING
< 	gint runcount;
< 	gint applycount;
< 	struct tms tms1;
< 	struct tms tms2;
< 	glong total_ms;
< #endif
< 	int *ovector;
< 	gint ovector_size;
< 	gboolean is_match;
< } Tpattern;
< 
< #define PATTERN(var) ((Tpattern *)(var))
< 
< /* 
< proposed improvement (for speedup, but also simplicity):
< 	-add the int ovector[MAX_OVECTOR]; and gboolean is_match; fields to Tpattern
< 	-use the pcre_fullinfo() function to find the minimum required ovector[] length (remind the 3X!!)
< 	and if there are no child-patterns that need a subpattern we use the minimum
< 	-the results from a subpattern search are now automatically stored, improving the success ratio
< 	for applying/matching*100% as in the profiling information
< 	-the Tpatmatch structure is not needed anymore, also the start of applylevel() where this 
< 	structure is initialized is now more simple
< */
< 
< 
< typedef struct {
< 	gchar *filetype;
< 	gchar *name;
< 	gchar *parentmatch;
< 	pcre *pcre;
< 	Tpattern *pat;
< } Tmetapattern; /* mostly used during compiling since it contains some more meta-info about the pattern */
< 
< typedef struct {
< 	GtkTextTagTable *tagtable; /* this one should ultimately move to Tfiletype, so every set would have it's own tagtable, but there is currently no way to switch a document to a new tagtable */
< 	GList *all_highlight_patterns; /* contains Tmetapattern, not Tpattern !! */
< #ifdef HL_PROFILING
< 	struct tms tms1; /* start time for profiling info */
< 	struct tms tms2; /* stop time for profiling info */
< #endif
< } Thighlight;
< 
< /*typedef struct {
< 	int ovector[MAX_OVECTOR];
< 	gboolean is_match;
< 	Tpattern *pat;
< } Tpatmatch;*/
< 
< /***************************************************************
< how it works:
< 
< -types:
< 	1 - a start pattern and an end pattern
< 	2 - a pattern that defines the complete match
< 	3 - a sub-pattern , this must be a child pattern for type 2
< 
< -matching
<    all top-level patterns are matched, a matching table is formed
< 	with all the start positions for every type, the lowest start 
< 	position is the pattern where we start.
< 	for this pattern we crate a new matching table with all the start 
< 	values AND the end value for the parent pattern. If the parent 
< 	pattern is type 2 or 3 this value is fixed, and no pattern or 
< 	child-pattern can go beyond that value, if the parent is type 1 
< 	the end value is re-evaluated once another pattern has gone beyond
< 	it's value.
< 	Once a match is found, the text is tagged with the right style, and
< ***************************************************************/
< 
< /*********************************/
< /* global vars for this module   */
< /*********************************/
< static Thighlight highlight;
< 
< /*********************************/
< /* debugging                     */
< /*********************************/
< #ifdef DEBUG
< 
< static void print_meta_for_pattern(Tpattern *pat) {
< 	GList *tmplist = g_list_first(highlight.all_highlight_patterns);
< 	while (tmplist) {
< 		if (((Tmetapattern *)tmplist->data)->pat == pat) {
< /*			g_print("pattern %p: filetype=%s, name=%s, num_childs=%d, numsub=%d, mode=%d\n", pat, ((Tmetapattern *)tmplist->data)->filetype, ((Tmetapattern *)tmplist->data)->name, g_list_length(pat->childs), pat->numsub, pat->mode);*/
< 			g_print("pattern %p: name=%s\n",pat,((Tmetapattern *)tmplist->data)->name);
< 			return;
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< static Tmetapattern *get_metapattern_from_tag(GtkTextTag *tag) {
< 	GList *tmplist = g_list_first(highlight.all_highlight_patterns);
< 	while (tmplist) {
< 		if (((Tmetapattern *)tmplist->data)->pat->tag == tag) {
< 			return ((Tmetapattern *)tmplist->data);
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return NULL;
< }
< 
< static void print_meta_for_tag(GtkTextTag *tag) {
< 	Tmetapattern *mpat = get_metapattern_from_tag(tag);
< 	if (mpat) {
< 		g_print("tag %p: filetype=%s, name=%s, num_childs=%d\n", tag, mpat->filetype, mpat->name, g_list_length(mpat->pat->childs));
< 	}
< }
< 
< static char *get_metaname_from_tag(GtkTextTag *tag) {
< 	Tmetapattern *mpat = get_metapattern_from_tag(tag);
< 	if (mpat) {
< 		return mpat->name;
< 	}
< 	return "";
< }
< 
< /*
< because the gtk functions crash in one case, I tries these, and that works!
< */
< static gboolean my_own_iter_backward_to_tag_toggle(GtkTextIter *iter,GtkTextTag *tag) {
< 	while (gtk_text_iter_backward_char(iter)) {
< 		if (gtk_text_iter_toggles_tag(iter, tag))	return TRUE;
< 	}
< 	return FALSE;
< }
< static gboolean my_own_iter_forward_to_tag_toggle(GtkTextIter *iter,GtkTextTag *tag) {
< 	while (gtk_text_iter_forward_char(iter)) {
< 		if (gtk_text_iter_toggles_tag(iter, tag))	return TRUE;
< 	}
< 	return FALSE;
< }
< #endif /* DEBUG */
< 
< #ifdef HL_PROFILING
< static void hl_profiling_reset(Tdocument *doc) {
< 	/* reset all patterns for the current filetype */
< 	GList *tmplist = g_list_first(highlight.all_highlight_patterns);
< 	while (tmplist){
< 		Tmetapattern *mpat = (Tmetapattern *)tmplist->data;
< 		if (strcmp(mpat->filetype, doc->hl->type)==0) {
< 			mpat->pat->runcount = 0;
< 			mpat->pat->applycount = 0;
< 			mpat->pat->total_ms = 0;
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	times(&highlight.tms1);
< }
< 
< static void hl_profiling_tagstart(Tpattern *pat) {
< 	times(&pat->tms1);
< 	pat->runcount++;
< }
< 
< static void hl_profiling_tagstop(Tpattern *pat) {
< 	times(&pat->tms2);
< 	pat->total_ms += (glong) (double) ((pat->tms2.tms_utime - pat->tms1.tms_utime) * 1000 / sysconf(_SC_CLK_TCK));
< }
< 
< static void hl_profiling_tagapply(Tpattern *pat) {
< 	pat->applycount++;
< }
< 
< static void hl_profiling_print(Tdocument *doc) {
< 	GList *tmplist;
< 	glong tot_ms;
< 	/* print results for all patterns for the current filetype */
< 	times(&highlight.tms2);
< 	tot_ms = (glong) (double) ((highlight.tms2.tms_utime - highlight.tms1.tms_utime) * 1000 / sysconf(_SC_CLK_TCK));
< 	g_print("PROFILING: total time %ld ms\n", tot_ms);
< 	tmplist = g_list_first(highlight.all_highlight_patterns);
< 	while (tmplist){
< 		Tmetapattern *mpat = (Tmetapattern *)tmplist->data;
< 		if (strcmp(mpat->filetype, doc->hl->type)==0) {
< 			g_print("PROFILING: patterns %s ran %d times, %d times successful (%d%%), and was matching %ld ms\n", mpat->name, mpat->pat->runcount, mpat->pat->applycount,(int)(100.0*mpat->pat->applycount/mpat->pat->runcount),mpat->pat->total_ms);
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	g_print("-- -- -- -- -- --\n");
< }
< 
< #endif /* HL_PROFILING */
< 
< #ifdef HL_TIMING
< typedef struct {
< 	struct tms tms1;
< 	struct tms tms2;
< 	glong total_ms;
< 	gint numtimes;
< }Ttiming;
< #define TIMING_TEXTBUF 0
< #define TIMING_PCRE_EXEC 1
< #define TIMING_TOTAL 2
< #define TIMING_UTF8 3
< #define TIMING_UTF8_INV 4
< #define TIMING_TEXTBUF_ITER 5
< #define TIMING_TEXTBUF_TAG 6
< #define TIMING_LINE_HIGHLIGHTING 7
< #define TIMING_NUM 8
< static Ttiming timing[TIMING_NUM];
< static void timing_init() {
< 	gint i;
< 	for (i=0;i<TIMING_NUM;i++){
< 		timing[i].total_ms = 0;
< 		timing[i].numtimes = 0;
< 	}
< }
< static void timing_start(gint id) {
< 	times(&timing[id].tms1);
< }
< static void timing_stop(gint id) {
< 	times(&timing[id].tms2);
< 	timing[id].numtimes++;
< 	timing[id].total_ms += (int) (double) ((timing[id].tms2.tms_utime - timing[id].tms1.tms_utime) * 1000.0 / sysconf(_SC_CLK_TCK));
< }
< #endif /* HL_TIMING */
< 
< 
< /*********************************/
< /* initializing the highlighting */
< /*********************************/
< 
< static void highlight_error(gboolean gui_errors, gchar *str1, gchar *str2) {
< 	if (gui_errors) {
< 		error_dialog(NULL,str1, str2);
< 	} else {
< 		gchar *message = g_strconcat(str1, ", ", str2, "\n", NULL);
< 		g_print(message);
< 		g_free(message);
< 	}
< }
< 
< static void compile_pattern(gboolean gui_errors, gchar *filetype, gchar *name, gint case_insens
< 			, gchar *pat1, gchar *pat2, gint mode, gchar *parentmatch
< 			, gchar *fgcolor, gchar *bgcolor, gint weight, gint style) {
< 	/*
< 	 * test if the pattern is correct 
< 	 */
< 	if (!name || strlen(name) == 0) {
< 		g_print("error compiling nameless pattern: name is not set\n");
< 		return;
< 	}
< 	switch (mode) {
< 	case 1:
< 		if (!(pat1 && pat2 && strlen(pat1) && strlen(pat2))) {
< 			g_print("error compiling pattern '%s' for mode 1: some pattern(s) missing\n", name);
< 			return;
< 		}
< 		break;
< 	case 2:
< 		if (!(pat1 && strlen(pat1))) {
< 			g_print("error compiling pattern '%s' for mode 2: pattern missing\n", name);
< 			return;
< 		}
< 		break;
< 	case 3:
< 		if (!(pat1 && strlen(pat1) && atoi(pat1) > 0 && atoi(pat1) < MAX_OVECTOR)) {
< 			g_print("error compiling pattern '%s' for mode 3: sub-pattern number missing, too large or incorrect\n", name);
< 			return;
< 		}
< 		break;
< 	default:
< 		g_print("error compiling pattern '%s', mode %d unknown\n", name, mode);
< 		return;
< 		break;
< 	}
< 
< 	{
< 		Tmetapattern *mpat;
< 		Tpattern *pat = g_new0(Tpattern, 1);
< 		pat->mode = mode;
< 		if (mode == 1 || mode ==2) {
< 			const char *err=NULL;
< 			int erroffset=0;
< 			DEBUG_MSG("compiling pat1 '%s'\n", pat1);
< #ifdef HAVE_PCRE_UTF8
< 			if (main_v->props.highlight_utf8)
< 				pat->reg1.pcre = pcre_compile(pat1,
< 					(case_insens) ? PCRE_UTF8|PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL : PCRE_UTF8|PCRE_MULTILINE|PCRE_DOTALL,
< 					&err,&erroffset,NULL);
< 			else
< 				pat->reg1.pcre = pcre_compile(pat1,
< 					(case_insens) ? PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL : PCRE_MULTILINE|PCRE_DOTALL,
< 					&err,&erroffset,NULL);
< #else
< 			pat->reg1.pcre = pcre_compile(pat1,
< 				(case_insens) ? PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL : PCRE_MULTILINE|PCRE_DOTALL,
< 				&err,&erroffset,NULL);
< #endif /* HAVE_PCRE_UTF8 */
< 			if (err) {
< 				gchar *str1, *str2;
< 				str1 = g_strconcat(_("Syntax highlighting error for "),filetype," - ",name,NULL);
< 				str2 = g_strdup_printf(_("compiling pattern '%s': %s at offset %d"), pat1, err, erroffset);
< 				highlight_error(gui_errors, str1, str2);
< 				g_free(str1);
< 				g_free(str2);
< 				g_free(pat);
< 				return;
< 			} else {
< 				DEBUG_MSG("result: pat->reg1.pcre=%p\n", pat->reg1.pcre);
< 				pat->reg1.pcre_e = pcre_study(pat->reg1.pcre,0,&err);
< 				if (err) {
< 					gchar *str1, *str2;
< 					str1 = g_strconcat(_("Syntax highlighting error for "),filetype," - ",name,NULL);
< 					str2 = g_strdup_printf(_("studying pattern '%s': %s"), pat1, err);
< 					highlight_error(gui_errors, str1, str2);
< 					g_free(str1);
< 					g_free(str2);
< 					pcre_free(pat->reg1.pcre);
< 					g_free(pat);
< 					return;
< 				} else {
< 					if (pcre_fullinfo(pat->reg1.pcre,pat->reg1.pcre_e,PCRE_INFO_CAPTURECOUNT,&pat->ovector_size)!=0) {
< 						g_print("Error for %s - %s, gettting info for pattern '%s'\n", filetype, name, pat1);
< 					}
< 					if (pat->ovector_size > MAX_OVECTOR) pat->ovector_size = MAX_OVECTOR;
< 					if (pat->ovector_size < MIN_OVECTOR) pat->ovector_size = MIN_OVECTOR;
< 					pat->ovector = g_malloc((pat->ovector_size+1)*3*sizeof(int));
< 				}
< 			}
< 		}
< 		if (mode == 1) {
< 			const char *err=NULL;
< 			int erroffset=0;
< 			DEBUG_MSG("compiling pat2 '%s'\n", pat2);
< #ifdef HAVE_PCRE_UTF8
< 			if (main_v->props.highlight_utf8)
< 				pat->reg2.pcre = pcre_compile(pat2,
< 					(case_insens) ? PCRE_UTF8|PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL : PCRE_UTF8|PCRE_MULTILINE|PCRE_DOTALL,
< 					&err,&erroffset,NULL);
< 			else
< 				pat->reg2.pcre = pcre_compile(pat2,
< 					(case_insens) ? PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL : PCRE_MULTILINE|PCRE_DOTALL,
< 					&err,&erroffset,NULL);			
< #else
< 			pat->reg2.pcre = pcre_compile(pat2,
< 				(case_insens) ? PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL : PCRE_MULTILINE|PCRE_DOTALL,
< 				&err,&erroffset,NULL);
< #endif /* HAVE_PCRE_UTF8 */
< 			if (err) {
< 				gchar *str1, *str2;
< 				str1 = g_strconcat(_("Syntax highlighting error for "),filetype," - ",name,NULL);
< 				str2 = g_strdup_printf(_("compiling 2nd pattern '%s': %s at offset %d"), pat2, err, erroffset);
< 				highlight_error(gui_errors, str1, str2);
< 				g_free(str1);
< 				g_free(str2);
< 				pcre_free(pat->reg1.pcre);
< 				g_free(pat->ovector);
< 				g_free(pat);
< 				return;
< 			}
< 			DEBUG_MSG("result: pat->reg2.pcre=%p\n", pat->reg2.pcre);
< 			pat->reg2.pcre_e = pcre_study(pat->reg2.pcre,0,&err);
< 			if (err) {
< 				gchar *str1, *str2;
< 				str1 = g_strconcat(_("Syntax highlighting error for "),filetype," - ",name,NULL);
< 				str2 = g_strdup_printf(_("studying 2nd pattern '%s': %s"), pat2, err);
< 				highlight_error(gui_errors, str1, str2);
< 				g_free(str1);
< 				g_free(str2);
< 				pcre_free(pat->reg1.pcre);
< 				pcre_free(pat->reg2.pcre);
< 				g_free(pat->ovector);
< 				g_free(pat);
< 				return;
< 			}
< 		}
< 		if (mode == 3) {
< 			pat->numsub = atoi(pat1);
< 			pat->ovector_size = 3;
< 			pat->ovector = g_malloc((pat->ovector_size+1)*3*sizeof(int));
< 		}
< 
< 		pat->tag = gtk_text_tag_new(NULL);
< 		if (strlen(fgcolor)) {
< 			g_object_set(pat->tag, "foreground", fgcolor, NULL);
< 		}
< 		if (strlen(bgcolor)) {
< 			g_object_set(pat->tag, "background", bgcolor, NULL);
< 		}
< 		if (weight > 0) {
< 			if (1 == weight) {
< 				g_object_set(pat->tag, "weight", PANGO_WEIGHT_NORMAL, NULL);
< 			} else {
< 				g_object_set(pat->tag, "weight", PANGO_WEIGHT_BOLD, NULL);
< 			}
< 		}
< 		if (style > 0) {
< 			if (1 == style) {
< 				g_object_set(pat->tag, "style", PANGO_STYLE_NORMAL, NULL);
< 			} else {
< 				g_object_set(pat->tag, "style", PANGO_STYLE_ITALIC, NULL);
< 			}
< 		}
< 		DEBUG_MSG("adding tag %p to table %p\n", pat->tag, highlight.tagtable);
< 		gtk_text_tag_table_add(highlight.tagtable, pat->tag);
< 		/* this might fix a memory leak reported by Jim Hayward <jimhayward@linuxexperience.com> Fri, 13 Aug 2004 14:45:23 -0700 */
< 		g_object_unref(pat->tag);
< 		/* from the documentation:
< 			When adding a tag to a tag table, it will be assigned the highest priority in the table by 
< 			default; so normally the precedence of a set of tags is the order in which they were added 
< 			to the table.
< 			so the order of the styles in the list will be the order in the tagtable */
< 		
< 		mpat = g_new(Tmetapattern, 1);
< 		mpat->pat = pat;			
< 		mpat->name = g_strdup(name);
< 		if (strlen(parentmatch)) {
< 			mpat->parentmatch = g_strdup(parentmatch);
< 		} else {
< 			mpat->parentmatch = g_strdup("^top$");
< 		}
< 		mpat->filetype = g_strdup(filetype);
< 		DEBUG_MSG("adding mpat %s (%p) to list %p\n", mpat->name, mpat, highlight.all_highlight_patterns);
< 		highlight.all_highlight_patterns = g_list_append(highlight.all_highlight_patterns, mpat);
< 		DEBUG_MSG("finished compiling pattern %s and added it to the list\n", mpat->name);
< 	}
< }
< 
< static void add_patterns_to_parent(GList **list, gchar *filetype, gchar *name) {
< 	GList *tmplist = g_list_first(highlight.all_highlight_patterns);
< 	while (tmplist) {
< 		Tmetapattern *mpat = (Tmetapattern *)tmplist->data;
< 		if (strcmp(filetype, mpat->filetype)==0) {
< 			int ovector[9];
< 			if (pcre_exec(mpat->pcre,NULL, name,strlen(name),0,0,ovector,9) > 0) {
< 				*list = g_list_append(*list, mpat->pat);
< 			}
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< /*
<  * if gui_errors is set, we can send a popup with an error message,
<  * else (during startup) we use g_print()
<  */
< void filetype_highlighting_rebuild(gboolean gui_errors) {
< 	GList *tmplist;
< 	GList *alldoclist;
< 	
< 	alldoclist = return_allwindows_documentlist();
< 	/* remove filetypes from documents, but to reconnect them 
< 	again after the rebuild, we temporary put a string with 
< 	the filetype on that pointer */
< 	if (alldoclist) {
< 		tmplist = g_list_first(alldoclist);
< 		while (tmplist) {
< 			Tdocument *thisdoc = (Tdocument *)tmplist->data;
< 			if (thisdoc->hl) {
< 				DEBUG_MSG("doc %p has type %p named %s\n", thisdoc, thisdoc->hl, thisdoc->hl->type);
< 				DEBUG_MSG("disconnected document %p from filetype %s\n", thisdoc, thisdoc->hl->type);
< 				thisdoc->hl = (gpointer)g_strdup(thisdoc->hl->type);
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 
< 	/* first remove the menu widgets, and delete the filetype structs */
< 	DEBUG_MSG("filetype_highlighting_rebuild, testing for filetypelist existance\n");
< 	filetype_menus_empty();
< 	tmplist = g_list_first(main_v->filetypelist);
< 	while (tmplist) {
< 		Tfiletype *filetype = (Tfiletype *)tmplist->data;
< 		g_free(filetype->type);
< 		g_strfreev(filetype->extensions);
< 		g_free(filetype->update_chars);
< 		if (filetype->icon) {
< 			g_object_unref(filetype->icon);
< 		}
< 		g_free(filetype->content_regex);
< 		/* the highlightpatterns are freed separately, see below */
< 		g_free(filetype);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	g_list_free(main_v->filetypelist);
< 	main_v->filetypelist = NULL;
< 
< 	DEBUG_MSG("filetype_highlighting_rebuild, testing for metapattern existence\n");
< 	if (highlight.all_highlight_patterns) {
< 		tmplist = g_list_first(highlight.all_highlight_patterns);
< 		while (tmplist) {
< 			Tmetapattern *mpat = tmplist->data;
< 			pcre_free(mpat->pat->reg1.pcre);
< 			pcre_free(mpat->pat->reg1.pcre_e);
< 			pcre_free(mpat->pat->reg2.pcre);
< 			pcre_free(mpat->pat->reg2.pcre_e);
< 			g_free(mpat->pat->ovector);
< 			gtk_text_tag_table_remove(highlight.tagtable,mpat->pat->tag);
< 			g_free(mpat->pat);
< 			g_free(mpat->name);
< 			g_free(mpat->parentmatch);
< 			g_free(mpat->filetype);
< 			g_free(mpat);
< 			tmplist = g_list_next(tmplist);
< 		}
< 		g_list_free(highlight.all_highlight_patterns);
< 		highlight.all_highlight_patterns = NULL;
< 	}
< 
< 
< 	DEBUG_MSG("filetype_highlighting_rebuild, rebuilding the filetype list\n");
< 	/* now rebuild the filetype list */
< 	tmplist = g_list_first(main_v->props.filetypes);
< 	while (tmplist) {
< 		gint arrcount;
< 		gchar **strarr;
< 		Tfiletype *filetype;
< 		strarr = (gchar **) tmplist->data;
< 		arrcount = count_array(strarr);
< 		if (arrcount >= 7) {
< 			filetype = g_new(Tfiletype, 1);
< 			filetype->editable = (strarr[4][0] != '0');
< 			filetype->content_regex = g_strdup(strarr[5]);
< 			filetype->type = g_strdup(strarr[0]);
< 			filetype->autoclosingtag = atoi(strarr[6]);
< 			DEBUG_MSG("extensions for %s loaded from %s\n", strarr[0], strarr[1]);
< 			filetype->extensions = g_strsplit(strarr[1], ":", 127);
< 			filetype->update_chars = g_strdup(strarr[2]);
< 			if (strlen(strarr[3])){
< 				GError *error=NULL;
< 				filetype->icon = gdk_pixbuf_new_from_file(strarr[3], &error);
< 				if (error != NULL) {
< 					/* Report error to user, and free error */
< 					g_print("ERROR while loading icon: %s\n", error->message);
< 					g_error_free(error);
< 					filetype->icon = NULL;
< 				}
< 			} else {
< 				filetype->icon = NULL;
< 			}
< 			filetype->highlightlist = NULL;
< 			main_v->filetypelist = g_list_append(main_v->filetypelist, filetype);
< 		}
< #ifdef DEBUG
< 		else {
< 			DEBUG_MSG("filetype_list_rebuild, filetype needs 4 params in array\n");
< 		}
< #endif
< 		tmplist = g_list_next(tmplist);
< 	}
< 
< 	DEBUG_MSG("filetype_highlighting_rebuild, compile configpatterns into metapatterns\n");
< 	/* now compile the patterns in metapatterns, they should come from the configfile */
< 	tmplist = g_list_first(main_v->props.highlight_patterns);
< 	while (tmplist) {
< 		gchar **strarr;
< 		strarr = (gchar **) tmplist->data;
< 		if (count_array(strarr) == 11) {
< 			compile_pattern(gui_errors, strarr[0], strarr[1], atoi(strarr[2]), strarr[3], strarr[4], atoi(strarr[5]), strarr[6]
< 				, strarr[7], strarr[8], atoi(strarr[9]), atoi(strarr[10]));
< 		}
< #ifdef DEBUG		
< 		else {
< 			g_print("filetype_list_rebuild, pattern %s does NOT have 11 parameters in array\n", strarr[0]);
< 		}
< #endif
< 		tmplist = g_list_next(tmplist);
< 	}
< 
< 	/* now start adding the patterns to the right filetype and the right pattern using the meta-info */
< 	
< 	/* first compile the parentmatch pattern */
< 	tmplist = g_list_first(highlight.all_highlight_patterns);
< 	DEBUG_MSG("filetype_highlighting_rebuild, compile parentmatch pattern\n");
< 	while (tmplist) {
< 		const char *err=NULL;
< 		int erroffset=0;
< 		Tmetapattern *mpat = (Tmetapattern *)tmplist->data;
< #ifdef HAVE_PCRE_UTF8		
< 		mpat->pcre = pcre_compile(mpat->parentmatch, PCRE_UTF8, &err, &erroffset,NULL);
< #else
< 		mpat->pcre = pcre_compile(mpat->parentmatch, 0, &err, &erroffset,NULL);
< #endif
< 		if (err) {
< 			g_print("error compiling parentmatch %s at %d\n", err, erroffset);
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	/* now match the top-level patterns */
< 	tmplist = g_list_first(main_v->filetypelist);
< 	DEBUG_MSG("filetype_highlighting_rebuild, match toplevel patterns\n");
< 	while (tmplist) {
< 		Tfiletype *filetype = (Tfiletype *)tmplist->data;
< 		add_patterns_to_parent(&filetype->highlightlist, filetype->type, "top");
< 		tmplist = g_list_next(tmplist);
< 	}
< 	/* now match the rest of the patterns */
< 	DEBUG_MSG("filetype_highlighting_rebuild, match rest of the patterns\n");
< 	tmplist = g_list_first(highlight.all_highlight_patterns);
< 	while (tmplist) {
< 		Tmetapattern *mpat = (Tmetapattern *)tmplist->data;
< 		add_patterns_to_parent(&mpat->pat->childs, mpat->filetype, mpat->name);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	/* free the parentmatch pattern now */
< 	DEBUG_MSG("filetype_highlighting_rebuild, free-ing mpat->pcre\n");
< 	tmplist = g_list_first(highlight.all_highlight_patterns);
< 	while (tmplist) {
< 		Tmetapattern *mpat = (Tmetapattern *)tmplist->data;
< 		pcre_free(mpat->pcre);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	
< 
< 	/* now we have finished the rebuilding of the filetypes, we 
< 	have to connect all the documents with their filetypes again, we 
< 	stored the name of the filetype temporary in the place of the Tfiletype,
< 	undo that now */
< 	if (alldoclist) {
< 		tmplist = g_list_first(alldoclist);
< 		while (tmplist) {
< 			if (((Tdocument *)tmplist->data)->hl) {
< 				gchar *tmpstr = (gchar *)((Tdocument *)tmplist->data)->hl;
< 				((Tdocument *)tmplist->data)->hl = get_filetype_by_name(tmpstr);
< 				DEBUG_MSG("reconnecting document %p to filetype %s\n", tmplist->data, tmpstr);
< 				g_free(tmpstr);
< 				((Tdocument *)tmplist->data)->need_highlighting = TRUE;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	g_list_free(alldoclist);
< }
< 
< void hl_init() {
< 	/* init main_v->filetypelist, the first set is the defaultset */
< 	highlight.all_highlight_patterns = NULL; 
< 	highlight.tagtable = gtk_text_tag_table_new();
< 
< 	filetype_highlighting_rebuild(FALSE);
< }
< 
< /**************************************/
< /* end of initialisation code         */
< /**************************************/
< 
< /*****************************/
< /* applying the highlighting */
< /*****************************/
< 
< static void patmatch_init_run(GList *level) {
< 	GList *tmplist = g_list_first(level);
< 	while (tmplist) {
< 		Tpattern * pat = (Tpattern *)tmplist->data;
< 		memset(pat->ovector,0,sizeof(pat->ovector));
< 		pat->is_match = FALSE;
< 		patmatch_init_run(pat->childs);
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< /**
<  * patmatch_rematch:
<  * @is_parentmatch: #gboolean if we search for the end pattern from (a mode 1) parent
<  * @pat: #Tpattern* the pattern
<  * @offset: #gint where to start the search, in bytes
<  * @buf: #gchar* the buffer we work on
<  * @to: #gint with the end location where to stop searching in the buffer
<  * @parentpat: #Tpattern with the parent pattern, needed for a mode 3 subpattern
<  */
< static void patmatch_rematch(gboolean is_parentmatch, Tpattern *pat, gint offset, gchar *buf, gint to, Tpattern *parentpat) {
< #ifdef DEVELOPMENT
< 	if (to < offset) {
< 		DEBUG_MSG("patmatch_rematch: impossible, to < offset, to=%d, offset=%d\n", to, offset);
< 		DEBUG_MSG("is_parentmatch=%d, pat=%p, offset=%d, to=%d, parentpat=%p\n", is_parentmatch, pat, offset, to, parentpat);
< 		exit(23);
< 	}
< 	if (!pat) {
< 		g_print("no pattern, BUG, exiting!\n");
< 		exit(32);
< 	}
< #endif
< #ifdef DEBUG
< 	if ((to-offset) < 20) {
< 		gchar *tmp = g_strndup(&buf[offset],to-offset);
< 		DEBUG_MSG("patmatch_rematch, searching offset=%d,to=%d, len=%d '%s' with pat ",offset,to,to-offset,tmp);
< 		g_free(tmp);
< 	} else {
< 		DEBUG_MSG("patmatch_rematch, searching offset=%d,to=%d, len=%d with pat ",offset,to, to-offset);
< 	}
< 	print_meta_for_pattern(pat);
< #endif
< 	if (is_parentmatch) {
< #ifdef HL_PROFILING
< 		hl_profiling_tagstart(pat);
< #endif
< 	
< #ifdef HL_TIMING
< 		timing_start(TIMING_PCRE_EXEC);
< #endif
< 		/* probably 'length' refers to the total buffer length, so if we want to stop at 'to', we need to pass 'to' as length*/
< 		pat->is_match = pcre_exec(pat->reg2.pcre, pat->reg2.pcre_e, buf, to, offset, 0, pat->ovector, pat->ovector_size);
< #ifdef HL_TIMING
< 		timing_stop(TIMING_PCRE_EXEC);
< #endif
< #ifdef HL_PROFILING
< 		hl_profiling_tagstop(pat);
< #endif
< 	} else {
< 		if (pat->mode == 3) {
< #ifdef DEBUG
< 			DEBUG_MSG("patmatch_rematch, getting value from  parentpat->ovector[%d]\n", pat->numsub*2+1);
< 			if ((pat->numsub*2+1) >= MAX_OVECTOR || (pat->numsub*2+1) >=parentpat->ovector_size) {
< 				DEBUG_MSG("wanted subpattern is out of bounds!!, parentpat->ovector_size=%d\n", parentpat->ovector_size);
< 			} else {
< 				DEBUG_MSG("parentpat=%p with ovector_size=%d,requested ovector segment=%d\n",parentpat,parentpat->ovector_size,pat->numsub*2+1);
< 			}
< #endif
< #ifdef HL_PROFILING
< 			hl_profiling_tagstart(pat);
< #endif
< 			pat->ovector[0] = parentpat->ovector[pat->numsub*2];
< 			pat->ovector[1] = parentpat->ovector[pat->numsub*2+1];
< 			pat->is_match = TRUE;
< #ifdef HL_PROFILING
< 			hl_profiling_tagstop(pat);
< #endif
< 		} else {
< #ifdef HL_PROFILING
< 			hl_profiling_tagstart(pat);
< #endif
< #ifdef HL_TIMING
< 			timing_start(TIMING_PCRE_EXEC);
< #endif
< 			/* probably 'length' refers to the total buffer length, so if we want to stop at 'to', we need to pass 'to' as length*/
< 			pat->is_match = pcre_exec(pat->reg1.pcre, pat->reg1.pcre_e, buf, to, offset, 0, pat->ovector, pat->ovector_size);
< 			if (pat->is_match == -1) {
< 				pat->ovector[0] = to;
< 				pat->ovector[1] = to;
< 			}
< #ifdef HL_TIMING
< 			timing_stop(TIMING_PCRE_EXEC);
< #endif
< #ifdef HL_PROFILING
< 			hl_profiling_tagstop(pat);
< #endif
< 		}
< 	}
< #ifdef DEVELOPMENT
< 	if (pat->ovector[1] > to) {
< 		g_print("BUG: patmatch_rematch,end > to, setting ovector[1] to to (=%d)\n", to);
< 		/*pat->ovector[1] = to;*/
< 		exit(567);
< 	}
< #endif
< }
< 
< static void applystyle(Tdocument *doc, gchar *buf, guint buf_char_offset, gint so, gint eo, Tpattern *pat) {
< 	GtkTextIter itstart, itend;
< 	gint istart, iend;
< 	guint char_start, char_end, byte_char_diff_start;
< 
< #ifdef DEBUG
< 	{
< 		gchar *tmp;
< 		DEBUG_MSG("applystyle, coloring from so=%d to eo=%d", so, eo);
< 		tmp = g_strndup(&buf[so],eo-so);
< 		DEBUG_MSG("'%s'\n", tmp);
< 		g_free(tmp);
< 	}
< #endif
< #ifdef HL_PROFILING
< 	hl_profiling_tagapply(pat);
< #endif
< 
< #ifdef HL_TIMING
< 	timing_start(TIMING_UTF8);
< #endif
< 	char_start = utf8_byteoffset_to_charsoffset_cached(buf, so);
< 	char_end = utf8_byteoffset_to_charsoffset_cached(buf, eo);
< 	byte_char_diff_start = so-char_start;
< #ifdef HL_TIMING
< 	timing_stop(TIMING_UTF8);
< #endif
< 	istart = char_start+buf_char_offset;
< 	iend = char_end+buf_char_offset;
< #ifdef HL_DEBUG1
< 	DEBUG_MSG("applystyle, byte_char_diff=%d\n", byte_char_diff_start);
< 	DEBUG_MSG("applystyle, coloring from %d to %d\n", istart, iend);
< #endif
< #ifdef HL_TIMING
< 	timing_start(TIMING_TEXTBUF);
< #endif
< 
< #ifdef HL_TIMING
< 	timing_start(TIMING_TEXTBUF_ITER);
< #endif
< 	gtk_text_buffer_get_iter_at_offset(doc->buffer, &itstart, istart);
< 	gtk_text_buffer_get_iter_at_offset(doc->buffer, &itend, iend);
< #ifdef HL_TIMING
< 	timing_stop(TIMING_TEXTBUF_ITER);
< #endif
< #ifdef HL_TIMING
< 	timing_start(TIMING_TEXTBUF_TAG);
< #endif
< 	gtk_text_buffer_apply_tag(doc->buffer, pat->tag, &itstart, &itend);
< #ifdef HL_TIMING
< 	timing_stop(TIMING_TEXTBUF_TAG);
< #endif
< #ifdef HL_TIMING
< 	timing_stop(TIMING_TEXTBUF);
< #endif
< }
< 
< /* applylevel(Tdocument * doc, gchar * buf, guint buf_char_offset, gint offset, gint length, Tpatmatch *parentmatch, GList *childs_list)
<  * doc: the document
<  * buf: the buffer with all characters to apply the highlighting to
<  * buf_char_offset: the character offset of the first char of the buffer 
<  * offset: the byte offset where we start in the buffer
<  * to: the byte offset where we stop the search for this level
<  * parentmatch: if there is a parent with mode 1 we have to search for the end together with it's children
<  * childs_list: a list of Tpattern that needs to be applied in this region
<  *
<  * if childs_list is NULL, it MUST BE a parent with mode 1 match!
<  * this not checked in the code for performance reasons!
<  */
< 
< static void applylevel(Tdocument * doc, gchar * buf, guint buf_char_offset, gint offset, const gint to, Tpattern *parentpat, GList *childs_list) {
< 	gint parent_mode1_start=offset;
< 	gint parent_mode1_offset=offset;
< #ifdef DEVELOPMENT
< 	if (offset >= to ) {
< 		DEBUG_MSG("applylevel, impossible start, offset >= to, offset=%d, to=%d\n", offset, to);
< 		exit(24);
< 	}
< 	
< 	if (!childs_list && (!parentpat || parentpat->mode != 1)) {
< 		g_print("applylevel: BUG, no child list, but also no mode 1 parent pattern!");
< 		exit(31);
< 	}
< #endif
< 	if (parentpat && parentpat->mode == 1) {
< 		/* before any patmatch_rematch, this has the end of the start pattern */
< 		parent_mode1_offset = parentpat->ovector[1];
< 	}
< 	DEBUG_MSG("applylevel, started with offset=%d, to=%d, len=%d\n", offset, to, to - offset);
< 	if (!childs_list) {
< 		/* we assume the parent is mode 1, IF NOT we are called with INVALID ARGUMENTS */
< 		patmatch_rematch(TRUE, parentpat, offset > parent_mode1_offset ? offset : parent_mode1_offset, buf, to, parentpat);
< 		if (parentpat->is_match<1) {
< 			DEBUG_MSG("no childs list, mode 1 parent has no match, set matching to 'to'=%d\n", to);
< 			parentpat->ovector[1] = to;
< 			parentpat->is_match = 1;
< 		}
< 		applystyle(doc, buf,buf_char_offset, offset, parentpat->ovector[1], parentpat);
< 		DEBUG_MSG("no childs list, mode 1 parent is applied, returning\n");
< 		return;
< 	} else {
< 		GList *tmplist;
< 		Tpattern *lowest_pm = NULL;
< 		tmplist = g_list_first(childs_list);
< 		while (tmplist) {
< 			/* check if we need to match the pattern */
< 			if (PATTERN(tmplist->data)->ovector[0] <= offset) {
< 				DEBUG_MSG("1, rematching pattern %p, ovector[0]=%d, offset=%d\n",PATTERN(tmplist->data),PATTERN(tmplist->data)->ovector[0], offset);
< 				patmatch_rematch(FALSE, PATTERN(tmplist->data), offset, buf, to, parentpat);
< #ifdef DEVELOPMENT
< 				if (PATTERN(tmplist->data)->ovector[1] > to) {
< 					g_print("BUG: PATTERN(tmplist->data)->ovector[1] > to\n");
< 					exit(321);
< 				}
< #endif
< 			}
< #ifdef DEBUG
< 			else {
< 				DEBUG_MSG("1 not rematching pattern %p, ovector[0]=%d, offset=%d, pattern ",PATTERN(tmplist->data), PATTERN(tmplist->data)->ovector[0], offset);
< 				print_meta_for_pattern(PATTERN(tmplist->data));
< 			}
< #endif
< 			if ((PATTERN(tmplist->data)->is_match > 0) && (PATTERN(tmplist->data)->ovector[1]<=to) &&(lowest_pm == NULL || (lowest_pm->ovector[0] > PATTERN(tmplist->data)->ovector[0]))) {
< 				lowest_pm = PATTERN(tmplist->data);
< #ifdef DEBUG
< 				DEBUG_MSG("1 new lowest_pm=%p, pat->is_match=%d, start=%d, pattern=",lowest_pm,PATTERN(tmplist->data)->is_match, PATTERN(tmplist->data)->ovector[0]);
< 				print_meta_for_pattern(lowest_pm);
< #endif
< 			}
< #ifdef DEBUG
< 			else {
< 				DEBUG_MSG("1 pat %p is NOT the lowest pm with is_match=%d and ovector[0]=%d\n", PATTERN(tmplist->data), PATTERN(tmplist->data)->is_match, PATTERN(tmplist->data)->ovector[0]);
< 			}
< #endif
< 			tmplist = g_list_next(tmplist);
< 		}
< 		if (parentpat && parentpat->mode == 1) {
< 			/* the end of the parent pattern needs matching too */
< 			DEBUG_MSG("matching the parent-end with offset %d\n", offset > parent_mode1_start ? offset : parent_mode1_start);
< 			patmatch_rematch(TRUE, parentpat, offset > parent_mode1_offset ? offset : parent_mode1_offset, buf, to, parentpat);
< 			if (parentpat->is_match <=0) {
< 				DEBUG_MSG("mode 1 parent has no match, matching to=%d\n", to);
< 				parentpat->ovector[1] = to;
< 				parentpat->ovector[0] = to;
< 				parentpat->is_match = 1;
< 			}
< #ifdef DEVELOPMENT
< 			if (parentpat->ovector[1] > to) {
< 				g_print("BUG: parentpat->ovector[1] > to\n");
< 				exit(765);
< 			}
< #endif
< 			if ((lowest_pm == NULL || (lowest_pm->ovector[0] > parentpat->ovector[0]))) {
< 				lowest_pm = parentpat;
< 				DEBUG_MSG("3 lowest_pm=%p (parentpat!!), parentpat->is_match=%d, start=%d\n",lowest_pm,parentpat->is_match, parentpat->ovector[0]);
< 			}
< #ifdef DEBUG
< 			else {
< 				DEBUG_MSG("3 (parent!!) is NOT the lowest pm with is_match=%d and ovector[0]=%d\n", parentpat->is_match, parentpat->ovector[0]);
< 			}
< #endif
< 		}
< #ifdef DEVELOPMENT
< 		if (offset > to ) {
< 			g_print("BUG: applylevel, impossible before applying, offset > to, offset=%d, to=%d\n", offset, to);
< 			g_print("lowest_pm->mode=%d, lowest_pm->childs=%p\n",lowest_pm->mode,lowest_pm->childs);
< 			exit(24);
< 		}
< #endif
< 
< 		/* apply the lowest match */
< 		while (lowest_pm != NULL) {
< 			if (lowest_pm == parentpat) {
< #ifdef DEBUG
< 				DEBUG_MSG("*apply: offset=%d, lowest_pm=%p with ovector=%d, ovector[1]=%d\n", offset, lowest_pm, parentpat->ovector[0],parentpat->ovector[1]);
< #endif
< 				/* apply the parent, and return from this level */
< 				applystyle(doc, buf,buf_char_offset, parent_mode1_start, parentpat->ovector[1], parentpat);
< 				lowest_pm = NULL; /* makes us return */
< 			} else {
< #ifdef DEBUG
< 				DEBUG_MSG("*apply:a child is the lowest match, offset=%d, lowest_pm=%p with start=%d and ovector[1]=%d ", offset, lowest_pm, lowest_pm->ovector[0],lowest_pm->ovector[1]);
< 				print_meta_for_pattern(lowest_pm);
< #endif
< 				switch (lowest_pm->mode) {
< 				case 1:
< 					/* if mode==1 the style is applied within the applylevel for the children because the end is not yet 
< 					known, the end is set in ovector[1] after applylevel for the children is finished */
< 					applylevel(doc, buf,buf_char_offset, lowest_pm->ovector[0], to, lowest_pm, lowest_pm->childs);
< 					offset = lowest_pm->ovector[1];
< 				break;
< 				case 2:
< 					/* ovector[0] and ovector[1] are both offsets in the buffer matched by the entire pattern */
< 					applystyle(doc, buf,buf_char_offset, lowest_pm->ovector[0], lowest_pm->ovector[1], lowest_pm);
< 					if (lowest_pm->childs) applylevel(doc, buf,buf_char_offset, lowest_pm->ovector[0], lowest_pm->ovector[1], lowest_pm, lowest_pm->childs);
< 					offset = lowest_pm->ovector[1];
< 				break;
< 				case 3:
< 					applystyle(doc, buf,buf_char_offset, lowest_pm->ovector[0], lowest_pm->ovector[1], lowest_pm);
< 					if (lowest_pm->childs) applylevel(doc, buf,buf_char_offset, lowest_pm->ovector[0], lowest_pm->ovector[1], lowest_pm, lowest_pm->childs);
< 					offset = lowest_pm->ovector[1];
< 				break;
< #ifdef DEBUG
< 				default:
< 					/* unknown mode, cannot pass the pattern-compile-stage??? */
< 					g_print("applylevel, unknown mode, cannot pass the pattern-compile-stage???\n");
< 					exit(2);
< 				break;
< #endif
< 				}
< 				if (offset == to) {
< 					DEBUG_MSG("offset==to, there is no further pattern that will match inb this level\n");
< 					DEBUG_MSG("applylevel, finished, to=%d, returning to previous level\n", to);
< 					return;
< 				}
< 			
< 				/* init for the next round, rematch the patterns that have a startpoint < offset */
< 				lowest_pm = NULL;
< 
< 				tmplist = g_list_first(childs_list);
< 				while (tmplist) {
< 					if (((PATTERN(tmplist->data)->ovector[1] <=to) && (PATTERN(tmplist->data)->ovector[0] <= offset)) 
< 						|| PATTERN(tmplist->data)->ovector[1] > to) {
< 						if (PATTERN(tmplist->data)->mode == 3) {
< 							PATTERN(tmplist->data)->is_match = FALSE; /* mode 3 types can only match as first match */
< 						} else {
< 							patmatch_rematch(FALSE, PATTERN(tmplist->data), offset, buf, to, parentpat);
< 							DEBUG_MSG("2 rematch: pat=%p, pat.is_match=%d, start=%d\n",PATTERN(tmplist->data),PATTERN(tmplist->data)->is_match,PATTERN(tmplist->data)->ovector[0]);
< 						}
< 					} else if (PATTERN(tmplist->data)->ovector[1] > to) {
< 						PATTERN(tmplist->data)->is_match = 0;
< 					}
< 					if ((PATTERN(tmplist->data)->is_match>0) && (lowest_pm == NULL || (lowest_pm->ovector[0] > PATTERN(tmplist->data)->ovector[0]))) {
< 						lowest_pm = PATTERN(tmplist->data);
< 						DEBUG_MSG("2 new lowest_pm=%p, start=%d\n",lowest_pm,lowest_pm->ovector[0]);
< 					}
< #ifdef DEBUG
< 					else {
< 						DEBUG_MSG("2 pat %p is NOT the lowest pm with is_match=%d and ovector[0]=%d\n", PATTERN(tmplist->data), PATTERN(tmplist->data)->is_match, PATTERN(tmplist->data)->ovector[0]);
< 					}
< #endif
< 					tmplist = g_list_next(tmplist);
< 				}
< 
< 				if (parentpat && parentpat->mode == 1) {
< 					/* the end of the parent pattern needs matching too */
< 					if (parentpat->ovector[0] < offset) {
< 						patmatch_rematch(TRUE, parentpat, offset, buf, to, parentpat);
< 					}
< 					if (parentpat->is_match<=0) {
< 						DEBUG_MSG("4 mode 1 parent has no match, matching to 'to'=%d\n", to);
< 						parentpat->ovector[1] = to;
< 						parentpat->ovector[0] = to;
< 						parentpat->is_match = 1;
< 					}
< 					if (lowest_pm == NULL || (lowest_pm->ovector[0] > parentpat->ovector[0])) {
< 						lowest_pm = parentpat;
< 						DEBUG_MSG("4 new lowest_pm=%p (parentmatch!!), start=%d\n",lowest_pm,lowest_pm->ovector[0]);
< 					}
< #ifdef DEBUG
< 					else {
< 						DEBUG_MSG("4 (parent!!) is NOT the lowest pm with is_match=%d and ovector[0]=%d\n", parentpat->is_match, parentpat->ovector[0]);
< 					}
< #endif
< 				}
< #ifdef DEVELOPMENT
< 				if (lowest_pm && lowest_pm->ovector[1] > to) {
< 					g_print("BUG: lowest_pm->ovector[1] > to !!\n");
< 					g_print("is_parentpat=%d, lowest_pm->mode=%d\n",(lowest_pm == parentpat), lowest_pm->mode);
< 					exit(345);
< 				}
< #endif
< #ifdef DEBUG
< 				if (lowest_pm) {
< 					if (lowest_pm == parentpat) {
< 						DEBUG_MSG("lowest_match %p (parentpat) has start %d\n", lowest_pm, parentpat->ovector[0]);
< 					} else {
< 						DEBUG_MSG("lowest_match %p (some child) has start %d\n", lowest_pm, lowest_pm->ovector[0]);
< 					}
< 				}
< #endif
< 			}
< 		}
< 	}
< 	DEBUG_MSG("applylevel, finished, to=%d, returning to previous level\n", to);
< }
< 
< void doc_remove_highlighting(Tdocument * doc)
< {
< 	GtkTextIter itstart, itend;
< 	gtk_text_buffer_get_bounds(doc->buffer, &itstart, &itend);
< 	gtk_text_buffer_remove_all_tags(doc->buffer, &itstart, &itend);
< }
< 
< void doc_highlight_full(Tdocument * doc) {
< 	if (!doc->hl || !doc->hl->highlightlist) {
< 		return;
< 	} else {
< 		gchar *buf;
< 		guint charcount;
< /*		GdkCursor *cursor = gdk_cursor_new(GDK_WATCH);
< 		gdk_window_set_cursor(main_v->main_window->window, cursor);
< 		gdk_window_set_cursor(main_v->current_document->view->window, cursor);
< 		flush_queue();*/
< 		charcount = gtk_text_buffer_get_char_count(doc->buffer);
< 		doc_remove_highlighting(doc);
< #ifdef HL_TIMING
< 		timing_init();
< #endif
< #ifdef HL_PROFILING
< 		hl_profiling_reset(doc);
< #endif
< #ifdef HL_TIMING
< 		timing_start(TIMING_TOTAL);
< #endif
< 		utf8_offset_cache_reset();
< 		buf = doc_get_chars(doc, 0, charcount);
< #ifdef DEVELOPMENT
< 		g_assert(doc);
< 		g_assert(doc->hl);
< 		g_assert(buf);
< 		g_assert(doc->hl->highlightlist);
< #endif
< 		patmatch_init_run(doc->hl->highlightlist);
< 		applylevel(doc,buf,0,0,strlen(buf),NULL,doc->hl->highlightlist);
< 		g_free(buf);
< #ifdef HL_TIMING
< 		timing_stop(TIMING_TOTAL);
< 		g_print("doc_highlight_full done, %ld ms total, %ld ms tagging (%dX), %ld ms matching (%dX)\n",timing[TIMING_TOTAL].total_ms, timing[TIMING_TEXTBUF].total_ms, timing[TIMING_TEXTBUF].numtimes, timing[TIMING_PCRE_EXEC].total_ms, timing[TIMING_PCRE_EXEC].numtimes);
< 		g_print("%ld ms utf8-shit (%dX), %ld ms utf8-invalidate (%dX)\n", timing[TIMING_UTF8].total_ms, timing[TIMING_UTF8].numtimes, timing[TIMING_UTF8_INV].total_ms, timing[TIMING_UTF8_INV].numtimes);
< 		g_print("%ld ms setting iters, %ld ms setting tags\n", timing[TIMING_TEXTBUF_ITER].total_ms, timing[TIMING_TEXTBUF_TAG].total_ms);
< #endif
< #ifdef HL_PROFILING
< 		hl_profiling_print(doc);
< #endif
< 		doc->need_highlighting = FALSE;
< /*		gdk_window_set_cursor(main_v->main_window->window, NULL);
< 		gdk_cursor_unref(cursor);*/
< 	}
< }
< 
< static void remove_tag_by_list_in_region(Tdocument * doc, GList * patlist, GtkTextIter * itstart, GtkTextIter * itend)
< {
< 	GList *tmplist = g_list_first(patlist);
< 	DEBUG_MSG("remove_tag_by_list_in_region, started on list %p\n", patlist);
< 	/* remove all tags that are children of patlist */
< 	while (tmplist) {
< 		DEBUG_MSG("remove_tag_by_list_in_region, removing tags for pattern %p\n", tmplist->data);
< 		gtk_text_buffer_remove_tag(doc->buffer, ((Tpattern *) tmplist->data)->tag, itstart, itend);
< 		if (((Tpattern *) tmplist->data)->childs) {
< 			remove_tag_by_list_in_region(doc, ((Tpattern *) tmplist->data)->childs, itstart, itend);
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< static Tpattern *find_pattern_by_tag(GList * parentlist, GtkTextTag * tag)
< {
< 	GList *tmplist;
< 
< 	tmplist = g_list_first(parentlist);
< 	while (tmplist) {
< 		if (((Tpattern *) tmplist->data)->tag == tag) {
< 			return (Tpattern *) tmplist->data;
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return NULL;
< }
< 
< static gboolean pattern_has_mode3_child(Tpattern *pat) {
< 	GList *tmplist;
< 
< 	tmplist = g_list_first(pat->childs);
< 	while (tmplist) {
< 		if (((Tpattern *)tmplist->data)->mode == 3) return TRUE;
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return FALSE;
< }
< 
< void doc_highlight_region(Tdocument * doc, guint startof, guint endof) {
< 	Tpattern *pat = NULL;
< 	guint so=-1, eo=-1;
< 	GList *patternlist = doc->hl->highlightlist;
< #ifdef HL_TIMING
< 	timing_init();
< 	timing_start(TIMING_LINE_HIGHLIGHTING);
< #endif
< 	if (startof < endof) {
< 		GtkTextIter itstart, itend, itsearch;
< 		GSList *taglist = NULL, *slist;
< 		gtk_text_buffer_get_iter_at_offset(doc->buffer,&itstart,startof);
< 		gtk_text_buffer_get_iter_at_offset(doc->buffer,&itend,endof);
< 
< 		/* get all the tags that itstart is in */
< 		taglist = gtk_text_iter_get_tags(&itstart);
< 		DEBUG_MSG("doc_highlight_line, (1) getting all tags at itstart %d\n",gtk_text_iter_get_offset(&itstart));
< 		/* find for every tag if it ends _after_ itend or not */
< 		itsearch = itstart;
< 		slist = taglist;
< 		while (slist && slist->data) {
< 			gboolean tag_found;
< #ifdef DEBUG
< 			{
< 				Tpattern *testpat;
< 				gchar *test;
< 				testpat = find_pattern_by_tag(patternlist, GTK_TEXT_TAG(slist->data));
< 				if (testpat) {
< 					DEBUG_MSG("doc_highlight_line, (1) tag %p goes with ", testpat->tag);
< 					print_meta_for_pattern(testpat);
< 				} else {
< 					DEBUG_MSG("doc_highlight_line, (1) tag %p doesn't have pattern??\n",slist->data);
< 					print_meta_for_tag(GTK_TEXT_TAG(slist->data));
< 					/*exit(9);*/
< 				}
< 				test = gtk_text_buffer_get_text(doc->buffer, &itstart, &itend,FALSE);
< 				DEBUG_MSG("doc_highlight_line, (1) current string='%s'\n", test);
< 				g_free(test);
< 			}
< #endif
< 			/* if the tags ends at itstart there is no need to search forward to the end */
< 			if (!gtk_text_iter_ends_tag(&itstart, GTK_TEXT_TAG(slist->data))) {
< 				DEBUG_MSG("doc_highlight_line, (1) forward looking for tag %p (%s) from so=%d to eo=%d\n", slist->data, get_metaname_from_tag(slist->data),
< 						  gtk_text_iter_get_offset(&itstart), gtk_text_iter_get_offset(&itend));
< 				tag_found = gtk_text_iter_forward_to_tag_toggle(&itsearch, GTK_TEXT_TAG(slist->data));
< 				if (!tag_found) {
< 					/* this happens with several gtk versions, 
< 						up to 2.2.4 is buggy
< 						inbetween is unknown,
< 						2.4.4 is fixed */
< 					DEBUG_MSG("doc_highlight_line (1), very weird situation, the tag %p is started but it doesn't end ??, itsearch now is at %d\n", slist->data, gtk_text_iter_get_offset(&itsearch));
< 					/* itsearch is now at the end of the buffer so we do a backward search to find the first start */
< 					tag_found = gtk_text_iter_backward_to_tag_toggle(&itsearch, GTK_TEXT_TAG(slist->data));
< 					DEBUG_MSG("(1) a backward search to the tag finds %d\n", gtk_text_iter_get_offset(&itsearch));
< 					if (!tag_found) {
< 						g_print("doc_highlight_line, (1) a tag that is started is nowhere to be found ??? BUG!\n");
< 						exit(123);
< 					}
< 					if (gtk_text_iter_compare(&itsearch, &itend) < 0) {
< 						/* there is no tag toggle found between itend and the end of the buffer, we
< 						 probably have hit the gtk bug here, so we just set itsearch here to itend+1 */
< 						 itsearch = itend;
< 						 gtk_text_iter_forward_char(&itsearch);
< 					}
< 				}
< 				DEBUG_MSG("doc_highlight_line, (1) tag %p (%s) ends at itsearch=%d\n", slist->data, get_metaname_from_tag(slist->data),gtk_text_iter_get_offset(&itsearch));
< 				if (gtk_text_iter_compare(&itsearch, &itend) > 0) {
< 					/* both the start and endpoint are within this 
< 					   tag --> pattern matching can start with this
< 					   subpattern */
< 					pat = find_pattern_by_tag(patternlist, GTK_TEXT_TAG(slist->data));
< #ifdef DEBUG
< 					DEBUG_MSG("found pattern %p with tag %p and childs %p", pat, pat->tag,pat->childs);
< 					print_meta_for_pattern(pat);
< #endif					
< 					if (pat && (pat->mode == 1)) {
< 						gchar *string;
< 						int ovector[MAX_OVECTOR];
< 						/* but first we do a quick test if the parent-pattern is indeed still valid */
< 						string = gtk_text_buffer_get_text(doc->buffer, &itstart, &itend, FALSE);
< 						if (0 < pcre_exec(pat->reg2.pcre, pat->reg2.pcre_e, string, strlen(string), 0, 0, ovector, MAX_OVECTOR)) {
< 							/* the current line does not have the start of the tag or the end of the tag, but now 
< 							   it does have a match on the end pattern --> so the pattern should be invalidated */
< 							pat = NULL;
< 							DEBUG_MSG("doc_highlight_line, (1) a match of the endpattern is found on this line '%s', the pattern is invalidated\n",string);
< 							itend = itsearch;
< 							gtk_text_iter_backward_to_tag_toggle(&itstart, slist->data);
< 						}
< 						g_free(string);
< 					}
< 					if (pat && !pattern_has_mode3_child(pat)) {
< 						/* what happens if patternlist = NULL ?
< 						   that means we are inside a match without any subpatterns, but 
< 						   perhaps the subpattern should be invalidated... hmm..
< 						 */
< 						patternlist = pat->childs;
< #ifdef DEBUG
< 						DEBUG_MSG("doc_highlight_line, (1) going to use patternlist %p from pattern ", patternlist);
< 						print_meta_for_pattern(pat);
< #endif
< 					} else {
< 						DEBUG_MSG("doc_highlight_line, (1) no pat or pat has a mode3 child, continue with next tag\n");
< 					}
< 				} else {
< 					/* this tag stops somewhere in the middle of the line, move 
< 					   itstart to the beginning of this tag, 
< 						there is also no need anymore to look further in slist, we have to start with this patternlist */
< 					if (gtk_text_iter_begins_tag(&itstart, GTK_TEXT_TAG(slist->data))) {
< 						DEBUG_MSG("doc_highlight_line, (1) itstart at %d is already at the beginning of tag %p (%s)\n",gtk_text_iter_get_offset(&itstart), slist->data, get_metaname_from_tag(slist->data));
< 					} else {
< 						DEBUG_MSG("doc_highlight_line, (1) move itstart from %d to beginning of tag %p (%s)\n",
< 								  gtk_text_iter_get_offset(&itstart), slist->data, get_metaname_from_tag(slist->data));
< 						gtk_text_iter_backward_to_tag_toggle(&itstart, GTK_TEXT_TAG(slist->data));
< 						DEBUG_MSG("doc_highlight_line, (1) itstart is set back to %d\n", gtk_text_iter_get_offset(&itstart));
< 					}
< 					if (pat) {
< 						DEBUG_MSG("doc_highlight_line, (1) skip all other tags, slist=g_list_last()\n");
< 						slist = g_slist_last(slist);
< 					}
< 				}
< 			}
< 			itsearch = itstart;
< 			slist = g_slist_next(slist);
< 		}
< 		g_slist_free(taglist);
< 
< 		/* get all the tags that itend is in */
< 		taglist = gtk_text_iter_get_tags(&itend);
< 		DEBUG_MSG("doc_highlight_line, (2) getting all tags for itend at %d\n", gtk_text_iter_get_offset(&itend));
< 		/* find for every tag if it starts _before_ itstart (that means all of this line-highlighting
< 		 * is within that tag) or _after_ itstart (which means that we should remove that tag, move
< 		 * our highlighting endpoint to the end of that tag, and rehighlight the whole bit) */
< 		itsearch = itend;
< 		slist = taglist;
< 		while (slist && slist->data) {
< 			gboolean tag_found;
< 					/* if the tags starts at itend there is no need to search backward to the start */
< 			if (!gtk_text_iter_begins_tag(&itend, GTK_TEXT_TAG(slist->data))) {
< 				DEBUG_MSG("doc_highlight_line, (2) backwards looking for tag %p (%s) from eo=%d to so=%d, itsearch=%d\n", slist->data,
< 						  get_metaname_from_tag(slist->data), gtk_text_iter_get_offset(&itend),gtk_text_iter_get_offset(&itstart) ,gtk_text_iter_get_offset(&itsearch));
< #ifdef DEBUG
< 				DEBUG_MSG("does the itsearch position (%d) toggle(%d), begin(%d) or end(%d) the tag %p (%s)?\n"
< 						,gtk_text_iter_get_offset(&itsearch)
< 						,gtk_text_iter_toggles_tag(&itsearch,GTK_TEXT_TAG(slist->data)),gtk_text_iter_begins_tag(&itsearch,GTK_TEXT_TAG(slist->data))
< 						,gtk_text_iter_ends_tag(&itsearch,GTK_TEXT_TAG(slist->data)),slist->data, get_metaname_from_tag(slist->data));
< #endif
< 				/* this next function does crash sometimes, and I wonder why..... */
< 				tag_found = gtk_text_iter_backward_to_tag_toggle(&itsearch, GTK_TEXT_TAG(slist->data));
< 				if (!tag_found) {
< 					/* this happens with several gtk versions, 
< 						up to 2.2.4 is buggy
< 						inbetween is unknown,
< 						2.4.4 is fixed */
< 					if (gtk_text_iter_begins_tag(&itsearch, GTK_TEXT_TAG(slist->data))) {
< 						/* we have hit the bug in gtk, this tag should have been found by gtk_text_iter_backward_to_tag_toggle */
< 					} else {
< 						DEBUG_MSG("doc_highlight_line (2), very weird situation, the tag is ended but it doesn't start ??, itsearch now is at %d\n", gtk_text_iter_get_offset(&itsearch));
< 						/* itsearch is now at offset 0, so we do a forward search to find the first start */
< 						tag_found = gtk_text_iter_forward_to_tag_toggle(&itsearch, GTK_TEXT_TAG(slist->data));
< 						DEBUG_MSG("(2) a forward search to the tag finds %d\n", gtk_text_iter_get_offset(&itsearch));
< 						if (!tag_found) {
< 							g_print("doc_highlight_line, (2) a tag that is started is nowhere to be found ??? BUG!\n");
< 							exit(123);
< 						}
< 						if (gtk_text_iter_compare(&itsearch, &itend) > 0) {
< 							itsearch = itstart;
< 							gtk_text_iter_backward_char(&itsearch);
< 						}
< 					}
< 				}
< 				DEBUG_MSG("doc_highlight_line, (2) tag %p (%s) starts at itsearch=%d\n", slist->data,get_metaname_from_tag(slist->data),gtk_text_iter_get_offset(&itsearch));
< 				if (gtk_text_iter_compare(&itsearch, &itstart) <= 0) {
< 					/* both the start and endpoint are within this 
< 					   tag --> pattern matching can start with this
< 					   subpattern,	since we did run the same algorithm for itstart we can skip a bit now */
< 				} else {
< 					/* this tag starts somewhere in the middle of the line, move 
< 					   itend to the end of this tag */
< 					if (gtk_text_iter_ends_tag(&itend, GTK_TEXT_TAG(slist->data))) {
< 						DEBUG_MSG("doc_highlight_line, (2) itend at %d is already at the end of tag %p (%s)\n",
< 								  gtk_text_iter_get_offset(&itend), slist->data,get_metaname_from_tag(slist->data));
< 					} else {
< 						DEBUG_MSG("doc_highlight_line, (2) move itend from %d to end of tag %p (%s)\n",gtk_text_iter_get_offset(&itend), slist->data, get_metaname_from_tag(slist->data));
< 						gtk_text_iter_forward_to_tag_toggle(&itend, GTK_TEXT_TAG(slist->data));
< 						DEBUG_MSG("doc_highlight_line, (2) itend is set forward to %d\n", gtk_text_iter_get_offset(&itend));
< 					}
< 				}
< 			}
< 			itsearch = itend;
< 			slist = g_slist_next(slist);
< 		}
< 		g_slist_free(taglist);
< 		
< 		/* this function removes some specific tags from the region */
< 		remove_tag_by_list_in_region(doc, patternlist, &itstart, &itend);
< 		so = gtk_text_iter_get_offset(&itstart);
< 		eo = gtk_text_iter_get_offset(&itend);
< 	} else {
< 		DEBUG_MSG("doc_highlight_line, so >= eo, not highlighting!\n");
< 	}
< #ifdef HL_TIMING
< 		timing_stop(TIMING_LINE_HIGHLIGHTING);
< #endif
< 	if (patternlist) {
< 		gchar *buf;
< 		DEBUG_MSG("doc_highlight_line from so=%d to eo=%d\n", so, eo);
< 		
< 		patmatch_init_run(doc->hl->highlightlist);
< 		
< #ifdef HL_TIMING
< 		timing_start(TIMING_TOTAL);
< #endif
< 		buf = doc_get_chars(doc, so, eo);
< 		applylevel(doc,buf,so,0,strlen(buf),NULL,patternlist);
< 		g_free(buf);
< #ifdef HL_TIMING
< 		timing_stop(TIMING_TOTAL);
< 		g_print("doc_highlight_line done, %ld ms total, %ld ms line_highlighting\n",timing[TIMING_TOTAL].total_ms, timing[TIMING_LINE_HIGHLIGHTING].total_ms);
< #endif
< 	} else {
< 		DEBUG_MSG("doc_highlight_line, no patternlist, not highlighting!\n");
< 	}
< 	doc->need_highlighting = FALSE;
< }
< 
< void doc_highlight_line(Tdocument * doc) {
< 	GtkTextIter itstart, itend;
< 	GtkTextMark *mark = gtk_text_buffer_get_insert(doc->buffer);
< 	gtk_text_buffer_get_iter_at_mark(doc->buffer, &itstart, mark);
< 	/* move to the beginning of the line */
< 	gtk_text_iter_set_line_offset(&itstart, 0);
< 	if (main_v->props.highlight_num_lines_count) {
< 		gtk_text_iter_backward_lines(&itstart, main_v->props.highlight_num_lines_count);
< 	}
< 	gtk_text_buffer_get_iter_at_mark(doc->buffer, &itend, mark);
< /*		gtk_text_iter_forward_to_line_end(&itend);
< 	gtk_text_iter_set_line_offset(&itend, 0);*/
< 	if (main_v->props.highlight_num_lines_count) {
< 		gtk_text_iter_forward_lines(&itend, main_v->props.highlight_num_lines_count);
< 	}
< 	if (gtk_text_iter_forward_to_line_end(&itend)) {
< 		gtk_text_iter_forward_char(&itend);
< 	}
< 	doc_highlight_region(doc, gtk_text_iter_get_offset(&itstart), gtk_text_iter_get_offset(&itend));
< }
< 
< 
< 
< #ifdef HIGHLIGHTING_DEFAULTS_NOW_EXTERNAL
< void hl_reset_to_default()
< {
< 	gchar **arr;
< 	/* the further down, the higher the priority of the tag */
< 	arr = array_from_arglist("c", "string", "0", "\"", "\"", "1", "", "#009900", "", "0", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("c", "string-escape", "0", "\\\\.", "", "2", "^string$", "#009900", "", "0", "0",NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("c", "preprocessor", "0", "#(include|define|if|ifdef|else|endif).*$", "", "2", "","#000099", "", "0", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("c", "comment", "0", "/\\*", "\\*/", "1", "^(top|preprocessor)$", "#AAAAAA", "", "1", "2", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("c", "keywords", "0", "\\b(return|goto|if|else|case|default|switch|break|continue|while|do|for|sizeof)\\b","", "2", "", "#000000", "", "2", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr =	array_from_arglist("c", "storage-keywords", "0", "\\b(const|extern|auto|register|static|unsigned|signed|volatile|char|double|float|int|long|short|void|typedef|struct|union|enum|FILE|gint|gchar|GList|GtkWidget|gpointer|guint|gboolean)\\b","", "2", "", "#990000", "", "2", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("c", "braces", "0", "[{()}]", "",  "2", "", "#000000", "", "2", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("c", "character", "0", "'", "'",  "1", "", "#009900", "", "0", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 
< 	arr = array_from_arglist("php", "html", "1", "<((/)?[a-z0-9]+)", ">",  "1", "", "#000077", "", "0", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "html-tag", "1", "1", "", "3", "^html$", "#550044", "", "2", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr =	array_from_arglist("php", "html-tag-table", "1", "^(/)?(table|td|tr|tbody)$", "",  "2", "^html-tag$", "#5005AA", "", "0", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr =	array_from_arglist("php", "html-tag-special", "1", "^(/)?(img|a)$", "",  "2", "^html-tag$", "#BB0540", "", "0","0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "html-attrib", "1", "([a-z]*=)(\"[^\"]*\")", "",  "2", "^html$", "", "", "0", "0",NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "html-attrib-sub2", "1", "2", "",  "3", "^html-attrib$", "#009900", "", "0", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "specialchar", "1", "&[^;]*;", "", "2", "", "#999999", "", "2", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "comment", "0", "<!--", "-->",  "1", "", "#AAAAAA", "", "1", "2", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "php", "1", "<\\?php", "\\?>",  "1", "^(top|html|html-attrib-sub2)$", "#0000FF", "", "0", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "php-keywords", "0","\\b(return|goto|if|else|case|default|switch|break|continue|while|do|for|global|var|class|function|new)\\b","",  "2", "^php$", "#000000", "", "2", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "php-braces", "0", "[{()}]", "", "2", "^php$", "#000000", "", "2", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "php-string-double", "0", "\"", "\"",  "1", "^php$", "#009900", "", "1", "1", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "php-string-double-escape", "0", "\\\\.", "", "2", "^php-string-double$", "#009900", "", "1", "1",NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "php-var", "1", "\\$[a-z_][][a-z0-9>_$-]*", "",  "2", "^php$", "#CC0000", "", "2", "0",NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "php-var-specialchars", "0", "(\\[|\\]|->)", "",  "2", "^php-var$", "#0000CC", "", "0","0",NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "php-string-single", "0", "'", "'",  "1", "^php$", "#009900", "", "1", "1", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("php", "php-comment-C", "0", "/\\*", "\\*/",  "1", "^php$", "#7777AA", "", "1", "2", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr =array_from_arglist("php", "php-comment-C++", "0", "//.*$", "",  "2", "^php$", "#7777AA", "", "1", "2", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 
< 	arr = array_from_arglist("html", "html", "1", "<((/)?[a-z0-9]+)", ">", "1", "", "#0000EE", "", "0", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("html", "html-tag", "1", "1", "",  "3", "^html$", "#000077", "", "2", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("html", "html-attrib", "1", "([a-z]*=)(\"[^\"]*\")", "", "2", "^html$", "", "", "0", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("html", "html-attrib-sub2", "1", "2", "", "3", "^html-attrib$", "#009900", "", "0", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("html", "specialchar", "1", "&[^;]*;", "", "2", "", "#999999", "", "2", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("html", "comment", "0", "<!--", "-->", "1", "", "#AAAAAA", "", "1", "2",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("html", "doctype", "1", "<![a-z0-9]+", "[^?-]>",  "1", "", "#bb8800", "", "0", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 
< 	arr = array_from_arglist("xml", "tag", "1", "<((/)?[a-z0-9]+)", "[^?-]>",  "1", "", "#0000EE", "", "0", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("xml", "tag-name", "1", "1", "", "3", "^tag$", "#000077", "", "2", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("xml", "tag-attrib", "1", "([a-z]*=)(\"[^\"]*\")", "",  "2", "^tag$", "", "", "0", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("xml", "tag-attrib-sub2", "1", "2", "",  "3", "^tag-attrib$", "#009900", "", "0", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("xml", "specialchar", "1", "&[^;]*;", "",  "2", "", "#999999", "", "2", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("xml", "comment", "0", "<!--", "-->",  "1", "", "#AAAAAA", "", "1", "2",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("xml", "doctype", "1", "<![a-z0-9]+", "[^?-]>",  "1", "", "#bb8800", "", "0", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 
< 	arr = array_from_arglist("java", "comment-C-style", "0", "/\\*", "\\*/", "1", "", "#AAAAAA", "", "1", "2",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("java", "comment-C++-style", "0", "//.*$", "", "2", "", "#AAAAAA", "", "1", "2",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("java", "string", "0", "\"", "\"", "1", "", "#009900", "", "0", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("java", "string-escape", "0", "\\\\.", "", "2", "^string$", "#009900", "", "0", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr =	array_from_arglist("java", "include", "0", "^(import|package).*$", "",  "2", "", "#000099", "", "0", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr =	array_from_arglist("java", "keywords", "0", "\\b(new|super|return|goto|if|else|case|default|switch|break|continue|while|do|for|catch|throw|finally|try|class)\\b","",  "2", "", "#000000", "", "2", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("java", "special_values", "0", "\\b(false|null|true)\\b", "", "2", "", "#5caeee", "", "0", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("java", "modifiers", "0", "\\b(abstract|final|native|private|protected|public|static|transient|synchronized|volatile|extends|implements)\\b","", "2", "", "#990000", "", "2", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("java", "this", "0", "\\bthis\\.", "",  "2", "", "#000099", "", "2", "0", NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("java", "primitive-types", "0", "\\b(void|double|boolean|int)\\b", "",  "2", "", "#880088", "", "2","0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("java", "braces", "0", "[{()}]", "", "", "2", "", "#000000", "", "2", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	arr = array_from_arglist("java", "character", "0", "'", "'", "1", "", "#009900", "", "0", "0",  NULL);
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
< 	
< 	/* python support */
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "keywords", "0", "\\b(and|assert|break|continue|def|del|elif|else|except|exec|finally|for|if|in|is|not|or|pass|print|raise|return|try|while)\\b","",  "2", "", "#000000", "", "2", "0",  NULL));
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "string-double", "0", "\"", "\"", "1", "", "#009900", "", "0", "0",  NULL));
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "string-double-escape", "0", "\\\\.", "", "2", "^string-double$", "#009900", "", "0", "0",  NULL));
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "string-single", "0", "'", "'", "1", "", "#009900", "", "0", "0",  NULL));
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "string-single-escape", "0", "\\\\.", "", "2", "^string-single$", "#009900", "", "0", "0",  NULL));
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "special_values", "0", "\\b(None)\\b", "", "2", "", "#5caeee", "", "0", "0", NULL));
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "include", "0", "^(import|from).*$", "",  "2", "", "#000099", "", "0", "0",  NULL));
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "comment", "0", "#.*$", "", "2", "", "#AAAAAA", "", "1", "2",  NULL));
< 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "braces", "0", "[{()}\\[\\]]", "", "2", "", "#000000", "", "2", "0",  NULL));
< }
< #endif /* HIGHLIGHTING_DEFAULTS_NOW_EXTERNAL */
< GtkTextTagTable *highlight_return_tagtable() {
< 	return highlight.tagtable;
< }
---
> /* Bluefish HTML Editor
>  * highlight.c - the syntax highlighting with perl compatible regular expressions
>  *
>  * Copyright (C) 2002-2005 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> /*
>  * indenting is done with
>  * indent --line-length 100 --k-and-r-style --tab-size 4 -bbo --ignore-newlines highlight.c
>  */
> 
> /* #define HL_TIMING
> #define HL_DEBUG 
> #define DEBUG */
> 
> #ifdef DEBUG
> #define DEVELOPMENT
> #endif
> 
> #ifdef HL_TIMING /* some overall profiling information, not per pattern, but per type of code , interesting to bluefish programmers*/
> #include <sys/times.h>
> #include <unistd.h>
> #endif
> 
> #include <gtk/gtk.h>
> #include <sys/types.h>    /* _before_ regex.h for freeBSD */
> #include <pcre.h>         /* pcre_*() */
> 
> #ifdef HAVE_PCRE_UTF8 
> #ifndef PCRE_UTF8         /* for compatibility with older libpcre's */
> #define PCRE_UTF8 0
> #endif /* PCRE_UTF8 */
> #endif /* HAVE_PCRE_UTF8 */
> 
> #include <string.h>       /* strerror() */
> #include <stdlib.h>       /* atoi() */
> 
> #include "config.h"       /* HL_PROFILING might be defined there */
> 
> #ifdef HL_PROFILING       /* per pattern profiling information, interesting for users making a new pattern */
> #include <sys/times.h>
> #include <unistd.h>
> #endif
> 
> #include "bluefish.h"
> #include "bf_lib.h"       /* filename_test_extensions() */
> #include "document.h"     /* doc_get_chars() */
> #include "gtk_easy.h"     /* error_dialog() */
> #include "highlight.h"
> #include "menu.h"         /* menu_current_document_set_toggle_wo_activate */
> #include "rcfile.h"       /* array_from_arglist() */
> #include "stringlist.h"   /* count_array() */
> 
> #define MIN_OVECTOR 9     /* the minimum size for the ovector */
> #define MAX_OVECTOR 30    /* should be a multiple of three for pcre_exec(), 
>                              and at maximum 2/3 of this size can really be used for substrings */
> 
> typedef struct {
> 	pcre *pcre;
> 	pcre_extra *pcre_e;
> } Treg;
> 
> typedef struct {
> 	gchar *name;
> 	GtkTextTag *tag;
> } Thlstyle;
> 
> typedef struct {
> 	Treg reg1;
> 	Treg reg2;
> 	gint numsub;
> 	gint mode;
> 	GList *childs;
> 	GtkTextTag *tag;
> #ifdef HL_PROFILING
> 	gint runcount;
> 	gint applycount;
> 	struct tms tms1;
> 	struct tms tms2;
> 	glong total_ms;
> #endif
> 	int *ovector;
> 	gint ovector_size;
> 	gboolean is_match;
> } Tpattern;
> 
> #define PATTERN(var) ((Tpattern *)(var))
> 
> /* 
> proposed improvement (for speedup, but also simplicity):
> 	-add the int ovector[MAX_OVECTOR]; and gboolean is_match; fields to Tpattern
> 	-use the pcre_fullinfo() function to find the minimum required ovector[] length (remind the 3X!!)
> 	and if there are no child-patterns that need a subpattern we use the minimum
> 	-the results from a subpattern search are now automatically stored, improving the success ratio
> 	for applying/matching*100% as in the profiling information
> 	-the Tpatmatch structure is not needed anymore, also the start of applylevel() where this 
> 	structure is initialized is now more simple
> */
> 
> 
> typedef struct {
> 	gchar *filetype;
> 	gchar *name;
> 	gchar *parentmatch;
> 	pcre *pcre;
> 	Tpattern *pat;
> } Tmetapattern; /* mostly used during compiling since it contains some more meta-info about the pattern */
> 
> typedef struct {
> 	GtkTextTagTable *tagtable; /* this one should ultimately move to Tfiletype, so every set would have it's own tagtable, but there is currently no way to switch a document to a new tagtable */
> 	GList *all_highlight_patterns; /* contains Tmetapattern, not Tpattern !! */
> #ifdef HL_PROFILING
> 	struct tms tms1; /* start time for profiling info */
> 	struct tms tms2; /* stop time for profiling info */
> #endif
> } Thighlight;
> 
> /*typedef struct {
> 	int ovector[MAX_OVECTOR];
> 	gboolean is_match;
> 	Tpattern *pat;
> } Tpatmatch;*/
> 
> /***************************************************************
> how it works:
> 
> -types:
> 	1 - a start pattern and an end pattern
> 	2 - a pattern that defines the complete match
> 	3 - a sub-pattern , this must be a child pattern for type 2
> 
> -matching
>    all top-level patterns are matched, a matching table is formed
> 	with all the start positions for every type, the lowest start 
> 	position is the pattern where we start.
> 	for this pattern we crate a new matching table with all the start 
> 	values AND the end value for the parent pattern. If the parent 
> 	pattern is type 2 or 3 this value is fixed, and no pattern or 
> 	child-pattern can go beyond that value, if the parent is type 1 
> 	the end value is re-evaluated once another pattern has gone beyond
> 	it's value.
> 	Once a match is found, the text is tagged with the right style, and
> ***************************************************************/
> 
> /*********************************/
> /* global vars for this module   */
> /*********************************/
> static Thighlight highlight;
> 
> /*********************************/
> /* debugging                     */
> /*********************************/
> #ifdef DEBUG
> 
> static void print_meta_for_pattern(Tpattern *pat) {
> 	GList *tmplist = g_list_first(highlight.all_highlight_patterns);
> 	while (tmplist) {
> 		if (((Tmetapattern *)tmplist->data)->pat == pat) {
> /*			g_print("pattern %p: filetype=%s, name=%s, num_childs=%d, numsub=%d, mode=%d\n", pat, ((Tmetapattern *)tmplist->data)->filetype, ((Tmetapattern *)tmplist->data)->name, g_list_length(pat->childs), pat->numsub, pat->mode);*/
> 			g_print("pattern %p: name=%s\n",pat,((Tmetapattern *)tmplist->data)->name);
> 			return;
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> static Tmetapattern *get_metapattern_from_tag(GtkTextTag *tag) {
> 	GList *tmplist = g_list_first(highlight.all_highlight_patterns);
> 	while (tmplist) {
> 		if (((Tmetapattern *)tmplist->data)->pat->tag == tag) {
> 			return ((Tmetapattern *)tmplist->data);
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return NULL;
> }
> 
> static void print_meta_for_tag(GtkTextTag *tag) {
> 	Tmetapattern *mpat = get_metapattern_from_tag(tag);
> 	if (mpat) {
> 		g_print("tag %p: filetype=%s, name=%s, num_childs=%d\n", tag, mpat->filetype, mpat->name, g_list_length(mpat->pat->childs));
> 	}
> }
> 
> static char *get_metaname_from_tag(GtkTextTag *tag) {
> 	Tmetapattern *mpat = get_metapattern_from_tag(tag);
> 	if (mpat) {
> 		return mpat->name;
> 	}
> 	return "";
> }
> 
> /*
> because the gtk functions crash in one case, I tries these, and that works!
> */
> static gboolean my_own_iter_backward_to_tag_toggle(GtkTextIter *iter,GtkTextTag *tag) {
> 	while (gtk_text_iter_backward_char(iter)) {
> 		if (gtk_text_iter_toggles_tag(iter, tag))	return TRUE;
> 	}
> 	return FALSE;
> }
> static gboolean my_own_iter_forward_to_tag_toggle(GtkTextIter *iter,GtkTextTag *tag) {
> 	while (gtk_text_iter_forward_char(iter)) {
> 		if (gtk_text_iter_toggles_tag(iter, tag))	return TRUE;
> 	}
> 	return FALSE;
> }
> #endif /* DEBUG */
> 
> #ifdef HL_PROFILING
> static void hl_profiling_reset(Tdocument *doc) {
> 	/* reset all patterns for the current filetype */
> 	GList *tmplist = g_list_first(highlight.all_highlight_patterns);
> 	while (tmplist){
> 		Tmetapattern *mpat = (Tmetapattern *)tmplist->data;
> 		if (strcmp(mpat->filetype, doc->hl->type)==0) {
> 			mpat->pat->runcount = 0;
> 			mpat->pat->applycount = 0;
> 			mpat->pat->total_ms = 0;
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	times(&highlight.tms1);
> }
> 
> static void hl_profiling_tagstart(Tpattern *pat) {
> 	times(&pat->tms1);
> 	pat->runcount++;
> }
> 
> static void hl_profiling_tagstop(Tpattern *pat) {
> 	times(&pat->tms2);
> 	pat->total_ms += (glong) (double) ((pat->tms2.tms_utime - pat->tms1.tms_utime) * 1000 / sysconf(_SC_CLK_TCK));
> }
> 
> static void hl_profiling_tagapply(Tpattern *pat) {
> 	pat->applycount++;
> }
> 
> static void hl_profiling_print(Tdocument *doc) {
> 	GList *tmplist;
> 	glong tot_ms;
> 	/* print results for all patterns for the current filetype */
> 	times(&highlight.tms2);
> 	tot_ms = (glong) (double) ((highlight.tms2.tms_utime - highlight.tms1.tms_utime) * 1000 / sysconf(_SC_CLK_TCK));
> 	g_print("PROFILING: total time %ld ms\n", tot_ms);
> 	tmplist = g_list_first(highlight.all_highlight_patterns);
> 	while (tmplist){
> 		Tmetapattern *mpat = (Tmetapattern *)tmplist->data;
> 		if (strcmp(mpat->filetype, doc->hl->type)==0) {
> 			g_print("PROFILING: patterns %s ran %d times, %d times successful (%d%%), and was matching %ld ms\n", mpat->name, mpat->pat->runcount, mpat->pat->applycount,(int)(100.0*mpat->pat->applycount/mpat->pat->runcount),mpat->pat->total_ms);
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	g_print("-- -- -- -- -- --\n");
> }
> 
> #endif /* HL_PROFILING */
> 
> #ifdef HL_TIMING
> typedef struct {
> 	struct tms tms1;
> 	struct tms tms2;
> 	glong total_ms;
> 	gint numtimes;
> }Ttiming;
> #define TIMING_TEXTBUF 0
> #define TIMING_PCRE_EXEC 1
> #define TIMING_TOTAL 2
> #define TIMING_UTF8 3
> #define TIMING_UTF8_INV 4
> #define TIMING_TEXTBUF_ITER 5
> #define TIMING_TEXTBUF_TAG 6
> #define TIMING_LINE_HIGHLIGHTING 7
> #define TIMING_NUM 8
> static Ttiming timing[TIMING_NUM];
> static void timing_init() {
> 	gint i;
> 	for (i=0;i<TIMING_NUM;i++){
> 		timing[i].total_ms = 0;
> 		timing[i].numtimes = 0;
> 	}
> }
> static void timing_start(gint id) {
> 	times(&timing[id].tms1);
> }
> static void timing_stop(gint id) {
> 	times(&timing[id].tms2);
> 	timing[id].numtimes++;
> 	timing[id].total_ms += (int) (double) ((timing[id].tms2.tms_utime - timing[id].tms1.tms_utime) * 1000.0 / sysconf(_SC_CLK_TCK));
> }
> #endif /* HL_TIMING */
> 
> 
> /*********************************/
> /* initializing the highlighting */
> /*********************************/
> 
> static void highlight_error(gboolean gui_errors, gchar *str1, gchar *str2) {
> 	if (gui_errors) {
> 		error_dialog(NULL,str1, str2);
> 	} else {
> 		gchar *message = g_strconcat(str1, ", ", str2, "\n", NULL);
> 		g_print(message);
> 		g_free(message);
> 	}
> }
> 
> static void compile_pattern(gboolean gui_errors, gchar *filetype, gchar *name, gint case_insens
> 			, gchar *pat1, gchar *pat2, gint mode, gchar *parentmatch
> 			, gchar *fgcolor, gchar *bgcolor, gint weight, gint style) {
> 	/*
> 	 * test if the pattern is correct 
> 	 */
> 	if (!name || strlen(name) == 0) {
> 		g_print("error compiling nameless pattern: name is not set\n");
> 		return;
> 	}
> 	switch (mode) {
> 	case 1:
> 		if (!(pat1 && pat2 && strlen(pat1) && strlen(pat2))) {
> 			g_print("error compiling pattern '%s' for mode 1: some pattern(s) missing\n", name);
> 			return;
> 		}
> 		break;
> 	case 2:
> 		if (!(pat1 && strlen(pat1))) {
> 			g_print("error compiling pattern '%s' for mode 2: pattern missing\n", name);
> 			return;
> 		}
> 		break;
> 	case 3:
> 		if (!(pat1 && strlen(pat1) && atoi(pat1) > 0 && atoi(pat1) < MAX_OVECTOR)) {
> 			g_print("error compiling pattern '%s' for mode 3: sub-pattern number missing, too large or incorrect\n", name);
> 			return;
> 		}
> 		break;
> 	default:
> 		g_print("error compiling pattern '%s', mode %d unknown\n", name, mode);
> 		return;
> 		break;
> 	}
> 
> 	{
> 		Tmetapattern *mpat;
> 		Tpattern *pat = g_new0(Tpattern, 1);
> 		pat->mode = mode;
> 		if (mode == 1 || mode ==2) {
> 			const char *err=NULL;
> 			int erroffset=0;
> 			DEBUG_MSG("compiling pat1 '%s'\n", pat1);
> #ifdef HAVE_PCRE_UTF8
> 			if (main_v->props.highlight_utf8)
> 				pat->reg1.pcre = pcre_compile(pat1,
> 					(case_insens) ? PCRE_UTF8|PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL : PCRE_UTF8|PCRE_MULTILINE|PCRE_DOTALL,
> 					&err,&erroffset,NULL);
> 			else
> 				pat->reg1.pcre = pcre_compile(pat1,
> 					(case_insens) ? PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL : PCRE_MULTILINE|PCRE_DOTALL,
> 					&err,&erroffset,NULL);
> #else
> 			pat->reg1.pcre = pcre_compile(pat1,
> 				(case_insens) ? PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL : PCRE_MULTILINE|PCRE_DOTALL,
> 				&err,&erroffset,NULL);
> #endif /* HAVE_PCRE_UTF8 */
> 			if (err) {
> 				gchar *str1, *str2;
> 				str1 = g_strconcat(_("Syntax highlighting error for "),filetype," - ",name,NULL);
> 				str2 = g_strdup_printf(_("compiling pattern '%s': %s at offset %d"), pat1, err, erroffset);
> 				highlight_error(gui_errors, str1, str2);
> 				g_free(str1);
> 				g_free(str2);
> 				g_free(pat);
> 				return;
> 			} else {
> 				DEBUG_MSG("result: pat->reg1.pcre=%p\n", pat->reg1.pcre);
> 				pat->reg1.pcre_e = pcre_study(pat->reg1.pcre,0,&err);
> 				if (err) {
> 					gchar *str1, *str2;
> 					str1 = g_strconcat(_("Syntax highlighting error for "),filetype," - ",name,NULL);
> 					str2 = g_strdup_printf(_("studying pattern '%s': %s"), pat1, err);
> 					highlight_error(gui_errors, str1, str2);
> 					g_free(str1);
> 					g_free(str2);
> 					pcre_free(pat->reg1.pcre);
> 					g_free(pat);
> 					return;
> 				} else {
> 					if (pcre_fullinfo(pat->reg1.pcre,pat->reg1.pcre_e,PCRE_INFO_CAPTURECOUNT,&pat->ovector_size)!=0) {
> 						g_print("Error for %s - %s, gettting info for pattern '%s'\n", filetype, name, pat1);
> 					}
> 					if (pat->ovector_size > MAX_OVECTOR) pat->ovector_size = MAX_OVECTOR;
> 					if (pat->ovector_size < MIN_OVECTOR) pat->ovector_size = MIN_OVECTOR;
> 					pat->ovector = g_malloc((pat->ovector_size+1)*3*sizeof(int));
> 				}
> 			}
> 		}
> 		if (mode == 1) {
> 			const char *err=NULL;
> 			int erroffset=0;
> 			DEBUG_MSG("compiling pat2 '%s'\n", pat2);
> #ifdef HAVE_PCRE_UTF8
> 			if (main_v->props.highlight_utf8)
> 				pat->reg2.pcre = pcre_compile(pat2,
> 					(case_insens) ? PCRE_UTF8|PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL : PCRE_UTF8|PCRE_MULTILINE|PCRE_DOTALL,
> 					&err,&erroffset,NULL);
> 			else
> 				pat->reg2.pcre = pcre_compile(pat2,
> 					(case_insens) ? PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL : PCRE_MULTILINE|PCRE_DOTALL,
> 					&err,&erroffset,NULL);			
> #else
> 			pat->reg2.pcre = pcre_compile(pat2,
> 				(case_insens) ? PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL : PCRE_MULTILINE|PCRE_DOTALL,
> 				&err,&erroffset,NULL);
> #endif /* HAVE_PCRE_UTF8 */
> 			if (err) {
> 				gchar *str1, *str2;
> 				str1 = g_strconcat(_("Syntax highlighting error for "),filetype," - ",name,NULL);
> 				str2 = g_strdup_printf(_("compiling 2nd pattern '%s': %s at offset %d"), pat2, err, erroffset);
> 				highlight_error(gui_errors, str1, str2);
> 				g_free(str1);
> 				g_free(str2);
> 				pcre_free(pat->reg1.pcre);
> 				g_free(pat->ovector);
> 				g_free(pat);
> 				return;
> 			}
> 			DEBUG_MSG("result: pat->reg2.pcre=%p\n", pat->reg2.pcre);
> 			pat->reg2.pcre_e = pcre_study(pat->reg2.pcre,0,&err);
> 			if (err) {
> 				gchar *str1, *str2;
> 				str1 = g_strconcat(_("Syntax highlighting error for "),filetype," - ",name,NULL);
> 				str2 = g_strdup_printf(_("studying 2nd pattern '%s': %s"), pat2, err);
> 				highlight_error(gui_errors, str1, str2);
> 				g_free(str1);
> 				g_free(str2);
> 				pcre_free(pat->reg1.pcre);
> 				pcre_free(pat->reg2.pcre);
> 				g_free(pat->ovector);
> 				g_free(pat);
> 				return;
> 			}
> 		}
> 		if (mode == 3) {
> 			pat->numsub = atoi(pat1);
> 			pat->ovector_size = 3;
> 			pat->ovector = g_malloc((pat->ovector_size+1)*3*sizeof(int));
> 		}
> 
> 		pat->tag = gtk_text_tag_new(NULL);
> 		if (strlen(fgcolor)) {
> 			g_object_set(pat->tag, "foreground", fgcolor, NULL);
> 		}
> 		if (strlen(bgcolor)) {
> 			g_object_set(pat->tag, "background", bgcolor, NULL);
> 		}
> 		if (weight > 0) {
> 			if (1 == weight) {
> 				g_object_set(pat->tag, "weight", PANGO_WEIGHT_NORMAL, NULL);
> 			} else {
> 				g_object_set(pat->tag, "weight", PANGO_WEIGHT_BOLD, NULL);
> 			}
> 		}
> 		if (style > 0) {
> 			if (1 == style) {
> 				g_object_set(pat->tag, "style", PANGO_STYLE_NORMAL, NULL);
> 			} else {
> 				g_object_set(pat->tag, "style", PANGO_STYLE_ITALIC, NULL);
> 			}
> 		}
> 		DEBUG_MSG("adding tag %p to table %p\n", pat->tag, highlight.tagtable);
> 		gtk_text_tag_table_add(highlight.tagtable, pat->tag);
> 		/* this might fix a memory leak reported by Jim Hayward <jimhayward@linuxexperience.com> Fri, 13 Aug 2004 14:45:23 -0700 */
> 		g_object_unref(pat->tag);
> 		/* from the documentation:
> 			When adding a tag to a tag table, it will be assigned the highest priority in the table by 
> 			default; so normally the precedence of a set of tags is the order in which they were added 
> 			to the table.
> 			so the order of the styles in the list will be the order in the tagtable */
> 		
> 		mpat = g_new(Tmetapattern, 1);
> 		mpat->pat = pat;			
> 		mpat->name = g_strdup(name);
> 		if (strlen(parentmatch)) {
> 			mpat->parentmatch = g_strdup(parentmatch);
> 		} else {
> 			mpat->parentmatch = g_strdup("^top$");
> 		}
> 		mpat->filetype = g_strdup(filetype);
> 		DEBUG_MSG("adding mpat %s (%p) to list %p\n", mpat->name, mpat, highlight.all_highlight_patterns);
> 		highlight.all_highlight_patterns = g_list_append(highlight.all_highlight_patterns, mpat);
> 		DEBUG_MSG("finished compiling pattern %s and added it to the list\n", mpat->name);
> 	}
> }
> 
> static void add_patterns_to_parent(GList **list, gchar *filetype, gchar *name) {
> 	GList *tmplist = g_list_first(highlight.all_highlight_patterns);
> 	while (tmplist) {
> 		Tmetapattern *mpat = (Tmetapattern *)tmplist->data;
> 		if (strcmp(filetype, mpat->filetype)==0) {
> 			int ovector[9];
> 			if (pcre_exec(mpat->pcre,NULL, name,strlen(name),0,0,ovector,9) > 0) {
> 				*list = g_list_append(*list, mpat->pat);
> 			}
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> /*
>  * if gui_errors is set, we can send a popup with an error message,
>  * else (during startup) we use g_print()
>  */
> void filetype_highlighting_rebuild(gboolean gui_errors) {
> 	GList *tmplist;
> 	GList *alldoclist;
> 	
> 	alldoclist = return_allwindows_documentlist();
> 	/* remove filetypes from documents, but to reconnect them 
> 	again after the rebuild, we temporary put a string with 
> 	the filetype on that pointer */
> 	if (alldoclist) {
> 		tmplist = g_list_first(alldoclist);
> 		while (tmplist) {
> 			Tdocument *thisdoc = (Tdocument *)tmplist->data;
> 			if (thisdoc->hl) {
> 				DEBUG_MSG("doc %p has type %p named %s\n", thisdoc, thisdoc->hl, thisdoc->hl->type);
> 				DEBUG_MSG("disconnected document %p from filetype %s\n", thisdoc, thisdoc->hl->type);
> 				thisdoc->hl = (gpointer)g_strdup(thisdoc->hl->type);
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 
> 	/* first remove the menu widgets, and delete the filetype structs */
> 	DEBUG_MSG("filetype_highlighting_rebuild, testing for filetypelist existance\n");
> 	filetype_menus_empty();
> 	tmplist = g_list_first(main_v->filetypelist);
> 	while (tmplist) {
> 		Tfiletype *filetype = (Tfiletype *)tmplist->data;
> 		g_free(filetype->type);
> 		g_strfreev(filetype->extensions);
> 		g_free(filetype->update_chars);
> 		if (filetype->icon) {
> 			g_object_unref(filetype->icon);
> 		}
> 		g_free(filetype->content_regex);
> 		/* the highlightpatterns are freed separately, see below */
> 		g_free(filetype);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	g_list_free(main_v->filetypelist);
> 	main_v->filetypelist = NULL;
> 
> 	DEBUG_MSG("filetype_highlighting_rebuild, testing for metapattern existence\n");
> 	if (highlight.all_highlight_patterns) {
> 		tmplist = g_list_first(highlight.all_highlight_patterns);
> 		while (tmplist) {
> 			Tmetapattern *mpat = tmplist->data;
> 			pcre_free(mpat->pat->reg1.pcre);
> 			pcre_free(mpat->pat->reg1.pcre_e);
> 			pcre_free(mpat->pat->reg2.pcre);
> 			pcre_free(mpat->pat->reg2.pcre_e);
> 			g_free(mpat->pat->ovector);
> 			gtk_text_tag_table_remove(highlight.tagtable,mpat->pat->tag);
> 			g_free(mpat->pat);
> 			g_free(mpat->name);
> 			g_free(mpat->parentmatch);
> 			g_free(mpat->filetype);
> 			g_free(mpat);
> 			tmplist = g_list_next(tmplist);
> 		}
> 		g_list_free(highlight.all_highlight_patterns);
> 		highlight.all_highlight_patterns = NULL;
> 	}
> 
> 
> 	DEBUG_MSG("filetype_highlighting_rebuild, rebuilding the filetype list\n");
> 	/* now rebuild the filetype list */
> 	tmplist = g_list_first(main_v->props.filetypes);
> 	while (tmplist) {
> 		gint arrcount;
> 		gchar **strarr;
> 		Tfiletype *filetype;
> 		strarr = (gchar **) tmplist->data;
> 		arrcount = count_array(strarr);
> 		if (arrcount >= 7) {
> 			filetype = g_new(Tfiletype, 1);
> 			filetype->editable = (strarr[4][0] != '0');
> 			filetype->content_regex = g_strdup(strarr[5]);
> 			filetype->type = g_strdup(strarr[0]);
> 			filetype->autoclosingtag = atoi(strarr[6]);
> 			DEBUG_MSG("extensions for %s loaded from %s\n", strarr[0], strarr[1]);
> 			filetype->extensions = g_strsplit(strarr[1], ":", 127);
> 			filetype->update_chars = g_strdup(strarr[2]);
> 			if (strlen(strarr[3])){
> 				GError *error=NULL;
> 				filetype->icon = gdk_pixbuf_new_from_file(strarr[3], &error);
> 				if (error != NULL) {
> 					/* Report error to user, and free error */
> 					g_print("ERROR while loading icon: %s\n", error->message);
> 					g_error_free(error);
> 					filetype->icon = NULL;
> 				}
> 			} else {
> 				filetype->icon = NULL;
> 			}
> 			filetype->highlightlist = NULL;
> 			main_v->filetypelist = g_list_append(main_v->filetypelist, filetype);
> 		}
> #ifdef DEBUG
> 		else {
> 			DEBUG_MSG("filetype_list_rebuild, filetype needs 4 params in array\n");
> 		}
> #endif
> 		tmplist = g_list_next(tmplist);
> 	}
> 
> 	DEBUG_MSG("filetype_highlighting_rebuild, compile configpatterns into metapatterns\n");
> 	/* now compile the patterns in metapatterns, they should come from the configfile */
> 	tmplist = g_list_first(main_v->props.highlight_patterns);
> 	while (tmplist) {
> 		gchar **strarr;
> 		strarr = (gchar **) tmplist->data;
> 		if (count_array(strarr) == 11) {
> 			compile_pattern(gui_errors, strarr[0], strarr[1], atoi(strarr[2]), strarr[3], strarr[4], atoi(strarr[5]), strarr[6]
> 				, strarr[7], strarr[8], atoi(strarr[9]), atoi(strarr[10]));
> 		}
> #ifdef DEBUG		
> 		else {
> 			g_print("filetype_list_rebuild, pattern %s does NOT have 11 parameters in array\n", strarr[0]);
> 		}
> #endif
> 		tmplist = g_list_next(tmplist);
> 	}
> 
> 	/* now start adding the patterns to the right filetype and the right pattern using the meta-info */
> 	
> 	/* first compile the parentmatch pattern */
> 	tmplist = g_list_first(highlight.all_highlight_patterns);
> 	DEBUG_MSG("filetype_highlighting_rebuild, compile parentmatch pattern\n");
> 	while (tmplist) {
> 		const char *err=NULL;
> 		int erroffset=0;
> 		Tmetapattern *mpat = (Tmetapattern *)tmplist->data;
> #ifdef HAVE_PCRE_UTF8		
> 		mpat->pcre = pcre_compile(mpat->parentmatch, PCRE_UTF8, &err, &erroffset,NULL);
> #else
> 		mpat->pcre = pcre_compile(mpat->parentmatch, 0, &err, &erroffset,NULL);
> #endif
> 		if (err) {
> 			g_print("error compiling parentmatch %s at %d\n", err, erroffset);
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	/* now match the top-level patterns */
> 	tmplist = g_list_first(main_v->filetypelist);
> 	DEBUG_MSG("filetype_highlighting_rebuild, match toplevel patterns\n");
> 	while (tmplist) {
> 		Tfiletype *filetype = (Tfiletype *)tmplist->data;
> 		add_patterns_to_parent(&filetype->highlightlist, filetype->type, "top");
> 		tmplist = g_list_next(tmplist);
> 	}
> 	/* now match the rest of the patterns */
> 	DEBUG_MSG("filetype_highlighting_rebuild, match rest of the patterns\n");
> 	tmplist = g_list_first(highlight.all_highlight_patterns);
> 	while (tmplist) {
> 		Tmetapattern *mpat = (Tmetapattern *)tmplist->data;
> 		add_patterns_to_parent(&mpat->pat->childs, mpat->filetype, mpat->name);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	/* free the parentmatch pattern now */
> 	DEBUG_MSG("filetype_highlighting_rebuild, free-ing mpat->pcre\n");
> 	tmplist = g_list_first(highlight.all_highlight_patterns);
> 	while (tmplist) {
> 		Tmetapattern *mpat = (Tmetapattern *)tmplist->data;
> 		pcre_free(mpat->pcre);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	
> 
> 	/* now we have finished the rebuilding of the filetypes, we 
> 	have to connect all the documents with their filetypes again, we 
> 	stored the name of the filetype temporary in the place of the Tfiletype,
> 	undo that now */
> 	if (alldoclist) {
> 		tmplist = g_list_first(alldoclist);
> 		while (tmplist) {
> 			if (((Tdocument *)tmplist->data)->hl) {
> 				gchar *tmpstr = (gchar *)((Tdocument *)tmplist->data)->hl;
> 				((Tdocument *)tmplist->data)->hl = get_filetype_by_name(tmpstr);
> 				DEBUG_MSG("reconnecting document %p to filetype %s\n", tmplist->data, tmpstr);
> 				g_free(tmpstr);
> 				((Tdocument *)tmplist->data)->need_highlighting = TRUE;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	g_list_free(alldoclist);
> }
> 
> void hl_init() {
> 	/* init main_v->filetypelist, the first set is the defaultset */
> 	highlight.all_highlight_patterns = NULL; 
> 	highlight.tagtable = gtk_text_tag_table_new();
> 
> 	filetype_highlighting_rebuild(FALSE);
> }
> 
> /**************************************/
> /* end of initialisation code         */
> /**************************************/
> 
> /*****************************/
> /* applying the highlighting */
> /*****************************/
> 
> static void patmatch_init_run(GList *level) {
> 	GList *tmplist = g_list_first(level);
> 	while (tmplist) {
> 		Tpattern * pat = (Tpattern *)tmplist->data;
> 		memset(pat->ovector,0,sizeof(pat->ovector));
> 		pat->is_match = FALSE;
> 		patmatch_init_run(pat->childs);
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> /**
>  * patmatch_rematch:
>  * @is_parentmatch: #gboolean if we search for the end pattern from (a mode 1) parent
>  * @pat: #Tpattern* the pattern
>  * @offset: #gint where to start the search, in bytes
>  * @buf: #gchar* the buffer we work on
>  * @to: #gint with the end location where to stop searching in the buffer
>  * @parentpat: #Tpattern with the parent pattern, needed for a mode 3 subpattern
>  */
> static void patmatch_rematch(gboolean is_parentmatch, Tpattern *pat, gint offset, gchar *buf, gint to, Tpattern *parentpat) {
> #ifdef DEVELOPMENT
> 	if (to < offset) {
> 		DEBUG_MSG("patmatch_rematch: impossible, to < offset, to=%d, offset=%d\n", to, offset);
> 		DEBUG_MSG("is_parentmatch=%d, pat=%p, offset=%d, to=%d, parentpat=%p\n", is_parentmatch, pat, offset, to, parentpat);
> 		exit(23);
> 	}
> 	if (!pat) {
> 		g_print("no pattern, BUG, exiting!\n");
> 		exit(32);
> 	}
> #endif
> #ifdef DEBUG
> 	if ((to-offset) < 20) {
> 		gchar *tmp = g_strndup(&buf[offset],to-offset);
> 		DEBUG_MSG("patmatch_rematch, searching offset=%d,to=%d, len=%d '%s' with pat ",offset,to,to-offset,tmp);
> 		g_free(tmp);
> 	} else {
> 		DEBUG_MSG("patmatch_rematch, searching offset=%d,to=%d, len=%d with pat ",offset,to, to-offset);
> 	}
> 	print_meta_for_pattern(pat);
> #endif
> 	if (is_parentmatch) {
> #ifdef HL_PROFILING
> 		hl_profiling_tagstart(pat);
> #endif
> 	
> #ifdef HL_TIMING
> 		timing_start(TIMING_PCRE_EXEC);
> #endif
> 		/* probably 'length' refers to the total buffer length, so if we want to stop at 'to', we need to pass 'to' as length*/
> 		pat->is_match = pcre_exec(pat->reg2.pcre, pat->reg2.pcre_e, buf, to, offset, 0, pat->ovector, pat->ovector_size);
> #ifdef HL_TIMING
> 		timing_stop(TIMING_PCRE_EXEC);
> #endif
> #ifdef HL_PROFILING
> 		hl_profiling_tagstop(pat);
> #endif
> 	} else {
> 		if (pat->mode == 3) {
> #ifdef DEBUG
> 			DEBUG_MSG("patmatch_rematch, getting value from  parentpat->ovector[%d]\n", pat->numsub*2+1);
> 			if ((pat->numsub*2+1) >= MAX_OVECTOR || (pat->numsub*2+1) >=parentpat->ovector_size) {
> 				DEBUG_MSG("wanted subpattern is out of bounds!!, parentpat->ovector_size=%d\n", parentpat->ovector_size);
> 			} else {
> 				DEBUG_MSG("parentpat=%p with ovector_size=%d,requested ovector segment=%d\n",parentpat,parentpat->ovector_size,pat->numsub*2+1);
> 			}
> #endif
> #ifdef HL_PROFILING
> 			hl_profiling_tagstart(pat);
> #endif
> 			pat->ovector[0] = parentpat->ovector[pat->numsub*2];
> 			pat->ovector[1] = parentpat->ovector[pat->numsub*2+1];
> 			pat->is_match = TRUE;
> #ifdef HL_PROFILING
> 			hl_profiling_tagstop(pat);
> #endif
> 		} else {
> #ifdef HL_PROFILING
> 			hl_profiling_tagstart(pat);
> #endif
> #ifdef HL_TIMING
> 			timing_start(TIMING_PCRE_EXEC);
> #endif
> 			/* probably 'length' refers to the total buffer length, so if we want to stop at 'to', we need to pass 'to' as length*/
> 			pat->is_match = pcre_exec(pat->reg1.pcre, pat->reg1.pcre_e, buf, to, offset, 0, pat->ovector, pat->ovector_size);
> 			if (pat->is_match == -1) {
> 				pat->ovector[0] = to;
> 				pat->ovector[1] = to;
> 			}
> #ifdef HL_TIMING
> 			timing_stop(TIMING_PCRE_EXEC);
> #endif
> #ifdef HL_PROFILING
> 			hl_profiling_tagstop(pat);
> #endif
> 		}
> 	}
> #ifdef DEVELOPMENT
> 	if (pat->ovector[1] > to) {
> 		g_print("BUG: patmatch_rematch,end > to, setting ovector[1] to to (=%d)\n", to);
> 		/*pat->ovector[1] = to;*/
> 		exit(567);
> 	}
> #endif
> }
> 
> static void applystyle(Tdocument *doc, gchar *buf, guint buf_char_offset, gint so, gint eo, Tpattern *pat) {
> 	GtkTextIter itstart, itend;
> 	gint istart, iend;
> 	guint char_start, char_end, byte_char_diff_start;
> 
> #ifdef DEBUG
> 	{
> 		gchar *tmp;
> 		DEBUG_MSG("applystyle, coloring from so=%d to eo=%d", so, eo);
> 		tmp = g_strndup(&buf[so],eo-so);
> 		DEBUG_MSG("'%s'\n", tmp);
> 		g_free(tmp);
> 	}
> #endif
> #ifdef HL_PROFILING
> 	hl_profiling_tagapply(pat);
> #endif
> 
> #ifdef HL_TIMING
> 	timing_start(TIMING_UTF8);
> #endif
> 	char_start = utf8_byteoffset_to_charsoffset_cached(buf, so);
> 	char_end = utf8_byteoffset_to_charsoffset_cached(buf, eo);
> 	byte_char_diff_start = so-char_start;
> #ifdef HL_TIMING
> 	timing_stop(TIMING_UTF8);
> #endif
> 	istart = char_start+buf_char_offset;
> 	iend = char_end+buf_char_offset;
> #ifdef HL_DEBUG1
> 	DEBUG_MSG("applystyle, byte_char_diff=%d\n", byte_char_diff_start);
> 	DEBUG_MSG("applystyle, coloring from %d to %d\n", istart, iend);
> #endif
> #ifdef HL_TIMING
> 	timing_start(TIMING_TEXTBUF);
> #endif
> 
> #ifdef HL_TIMING
> 	timing_start(TIMING_TEXTBUF_ITER);
> #endif
> 	gtk_text_buffer_get_iter_at_offset(doc->buffer, &itstart, istart);
> 	gtk_text_buffer_get_iter_at_offset(doc->buffer, &itend, iend);
> #ifdef HL_TIMING
> 	timing_stop(TIMING_TEXTBUF_ITER);
> #endif
> #ifdef HL_TIMING
> 	timing_start(TIMING_TEXTBUF_TAG);
> #endif
> 	gtk_text_buffer_apply_tag(doc->buffer, pat->tag, &itstart, &itend);
> #ifdef HL_TIMING
> 	timing_stop(TIMING_TEXTBUF_TAG);
> #endif
> #ifdef HL_TIMING
> 	timing_stop(TIMING_TEXTBUF);
> #endif
> }
> 
> /* applylevel(Tdocument * doc, gchar * buf, guint buf_char_offset, gint offset, gint length, Tpatmatch *parentmatch, GList *childs_list)
>  * doc: the document
>  * buf: the buffer with all characters to apply the highlighting to
>  * buf_char_offset: the character offset of the first char of the buffer 
>  * offset: the byte offset where we start in the buffer
>  * to: the byte offset where we stop the search for this level
>  * parentmatch: if there is a parent with mode 1 we have to search for the end together with it's children
>  * childs_list: a list of Tpattern that needs to be applied in this region
>  *
>  * if childs_list is NULL, it MUST BE a parent with mode 1 match!
>  * this not checked in the code for performance reasons!
>  */
> 
> static void applylevel(Tdocument * doc, gchar * buf, guint buf_char_offset, gint offset, const gint to, Tpattern *parentpat, GList *childs_list) {
> 	gint parent_mode1_start=offset;
> 	gint parent_mode1_offset=offset;
> #ifdef DEVELOPMENT
> 	if (offset >= to ) {
> 		DEBUG_MSG("applylevel, impossible start, offset >= to, offset=%d, to=%d\n", offset, to);
> 		exit(24);
> 	}
> 	
> 	if (!childs_list && (!parentpat || parentpat->mode != 1)) {
> 		g_print("applylevel: BUG, no child list, but also no mode 1 parent pattern!");
> 		exit(31);
> 	}
> #endif
> 	if (parentpat && parentpat->mode == 1) {
> 		/* before any patmatch_rematch, this has the end of the start pattern */
> 		parent_mode1_offset = parentpat->ovector[1];
> 	}
> 	DEBUG_MSG("applylevel, started with offset=%d, to=%d, len=%d\n", offset, to, to - offset);
> 	if (!childs_list) {
> 		/* we assume the parent is mode 1, IF NOT we are called with INVALID ARGUMENTS */
> 		patmatch_rematch(TRUE, parentpat, offset > parent_mode1_offset ? offset : parent_mode1_offset, buf, to, parentpat);
> 		if (parentpat->is_match<1) {
> 			DEBUG_MSG("no childs list, mode 1 parent has no match, set matching to 'to'=%d\n", to);
> 			parentpat->ovector[1] = to;
> 			parentpat->is_match = 1;
> 		}
> 		applystyle(doc, buf,buf_char_offset, offset, parentpat->ovector[1], parentpat);
> 		DEBUG_MSG("no childs list, mode 1 parent is applied, returning\n");
> 		return;
> 	} else {
> 		GList *tmplist;
> 		Tpattern *lowest_pm = NULL;
> 		tmplist = g_list_first(childs_list);
> 		while (tmplist) {
> 			/* check if we need to match the pattern */
> 			if (PATTERN(tmplist->data)->ovector[0] <= offset) {
> 				DEBUG_MSG("1, rematching pattern %p, ovector[0]=%d, offset=%d\n",PATTERN(tmplist->data),PATTERN(tmplist->data)->ovector[0], offset);
> 				patmatch_rematch(FALSE, PATTERN(tmplist->data), offset, buf, to, parentpat);
> #ifdef DEVELOPMENT
> 				if (PATTERN(tmplist->data)->ovector[1] > to) {
> 					g_print("BUG: PATTERN(tmplist->data)->ovector[1] > to\n");
> 					exit(321);
> 				}
> #endif
> 			}
> #ifdef DEBUG
> 			else {
> 				DEBUG_MSG("1 not rematching pattern %p, ovector[0]=%d, offset=%d, pattern ",PATTERN(tmplist->data), PATTERN(tmplist->data)->ovector[0], offset);
> 				print_meta_for_pattern(PATTERN(tmplist->data));
> 			}
> #endif
> 			if ((PATTERN(tmplist->data)->is_match > 0) && (PATTERN(tmplist->data)->ovector[1]<=to) &&(lowest_pm == NULL || (lowest_pm->ovector[0] > PATTERN(tmplist->data)->ovector[0]))) {
> 				lowest_pm = PATTERN(tmplist->data);
> #ifdef DEBUG
> 				DEBUG_MSG("1 new lowest_pm=%p, pat->is_match=%d, start=%d, pattern=",lowest_pm,PATTERN(tmplist->data)->is_match, PATTERN(tmplist->data)->ovector[0]);
> 				print_meta_for_pattern(lowest_pm);
> #endif
> 			}
> #ifdef DEBUG
> 			else {
> 				DEBUG_MSG("1 pat %p is NOT the lowest pm with is_match=%d and ovector[0]=%d\n", PATTERN(tmplist->data), PATTERN(tmplist->data)->is_match, PATTERN(tmplist->data)->ovector[0]);
> 			}
> #endif
> 			tmplist = g_list_next(tmplist);
> 		}
> 		if (parentpat && parentpat->mode == 1) {
> 			/* the end of the parent pattern needs matching too */
> 			DEBUG_MSG("matching the parent-end with offset %d\n", offset > parent_mode1_start ? offset : parent_mode1_start);
> 			patmatch_rematch(TRUE, parentpat, offset > parent_mode1_offset ? offset : parent_mode1_offset, buf, to, parentpat);
> 			if (parentpat->is_match <=0) {
> 				DEBUG_MSG("mode 1 parent has no match, matching to=%d\n", to);
> 				parentpat->ovector[1] = to;
> 				parentpat->ovector[0] = to;
> 				parentpat->is_match = 1;
> 			}
> #ifdef DEVELOPMENT
> 			if (parentpat->ovector[1] > to) {
> 				g_print("BUG: parentpat->ovector[1] > to\n");
> 				exit(765);
> 			}
> #endif
> 			if ((lowest_pm == NULL || (lowest_pm->ovector[0] > parentpat->ovector[0]))) {
> 				lowest_pm = parentpat;
> 				DEBUG_MSG("3 lowest_pm=%p (parentpat!!), parentpat->is_match=%d, start=%d\n",lowest_pm,parentpat->is_match, parentpat->ovector[0]);
> 			}
> #ifdef DEBUG
> 			else {
> 				DEBUG_MSG("3 (parent!!) is NOT the lowest pm with is_match=%d and ovector[0]=%d\n", parentpat->is_match, parentpat->ovector[0]);
> 			}
> #endif
> 		}
> #ifdef DEVELOPMENT
> 		if (offset > to ) {
> 			g_print("BUG: applylevel, impossible before applying, offset > to, offset=%d, to=%d\n", offset, to);
> 			g_print("lowest_pm->mode=%d, lowest_pm->childs=%p\n",lowest_pm->mode,lowest_pm->childs);
> 			exit(24);
> 		}
> #endif
> 
> 		/* apply the lowest match */
> 		while (lowest_pm != NULL) {
> 			if (lowest_pm == parentpat) {
> #ifdef DEBUG
> 				DEBUG_MSG("*apply: offset=%d, lowest_pm=%p with ovector=%d, ovector[1]=%d\n", offset, lowest_pm, parentpat->ovector[0],parentpat->ovector[1]);
> #endif
> 				/* apply the parent, and return from this level */
> 				applystyle(doc, buf,buf_char_offset, parent_mode1_start, parentpat->ovector[1], parentpat);
> 				lowest_pm = NULL; /* makes us return */
> 			} else {
> #ifdef DEBUG
> 				DEBUG_MSG("*apply:a child is the lowest match, offset=%d, lowest_pm=%p with start=%d and ovector[1]=%d ", offset, lowest_pm, lowest_pm->ovector[0],lowest_pm->ovector[1]);
> 				print_meta_for_pattern(lowest_pm);
> #endif
> 				switch (lowest_pm->mode) {
> 				case 1:
> 					/* if mode==1 the style is applied within the applylevel for the children because the end is not yet 
> 					known, the end is set in ovector[1] after applylevel for the children is finished */
> 					applylevel(doc, buf,buf_char_offset, lowest_pm->ovector[0], to, lowest_pm, lowest_pm->childs);
> 					offset = lowest_pm->ovector[1];
> 				break;
> 				case 2:
> 					/* ovector[0] and ovector[1] are both offsets in the buffer matched by the entire pattern */
> 					applystyle(doc, buf,buf_char_offset, lowest_pm->ovector[0], lowest_pm->ovector[1], lowest_pm);
> 					if (lowest_pm->childs) applylevel(doc, buf,buf_char_offset, lowest_pm->ovector[0], lowest_pm->ovector[1], lowest_pm, lowest_pm->childs);
> 					offset = lowest_pm->ovector[1];
> 				break;
> 				case 3:
> 					applystyle(doc, buf,buf_char_offset, lowest_pm->ovector[0], lowest_pm->ovector[1], lowest_pm);
> 					if (lowest_pm->childs) applylevel(doc, buf,buf_char_offset, lowest_pm->ovector[0], lowest_pm->ovector[1], lowest_pm, lowest_pm->childs);
> 					offset = lowest_pm->ovector[1];
> 				break;
> #ifdef DEBUG
> 				default:
> 					/* unknown mode, cannot pass the pattern-compile-stage??? */
> 					g_print("applylevel, unknown mode, cannot pass the pattern-compile-stage???\n");
> 					exit(2);
> 				break;
> #endif
> 				}
> 				if (offset == to) {
> 					DEBUG_MSG("offset==to, there is no further pattern that will match inb this level\n");
> 					DEBUG_MSG("applylevel, finished, to=%d, returning to previous level\n", to);
> 					return;
> 				}
> 			
> 				/* init for the next round, rematch the patterns that have a startpoint < offset */
> 				lowest_pm = NULL;
> 
> 				tmplist = g_list_first(childs_list);
> 				while (tmplist) {
> 					if (((PATTERN(tmplist->data)->ovector[1] <=to) && (PATTERN(tmplist->data)->ovector[0] <= offset)) 
> 						|| PATTERN(tmplist->data)->ovector[1] > to) {
> 						if (PATTERN(tmplist->data)->mode == 3) {
> 							PATTERN(tmplist->data)->is_match = FALSE; /* mode 3 types can only match as first match */
> 						} else {
> 							patmatch_rematch(FALSE, PATTERN(tmplist->data), offset, buf, to, parentpat);
> 							DEBUG_MSG("2 rematch: pat=%p, pat.is_match=%d, start=%d\n",PATTERN(tmplist->data),PATTERN(tmplist->data)->is_match,PATTERN(tmplist->data)->ovector[0]);
> 						}
> 					} else if (PATTERN(tmplist->data)->ovector[1] > to) {
> 						PATTERN(tmplist->data)->is_match = 0;
> 					}
> 					if ((PATTERN(tmplist->data)->is_match>0) && (lowest_pm == NULL || (lowest_pm->ovector[0] > PATTERN(tmplist->data)->ovector[0]))) {
> 						lowest_pm = PATTERN(tmplist->data);
> 						DEBUG_MSG("2 new lowest_pm=%p, start=%d\n",lowest_pm,lowest_pm->ovector[0]);
> 					}
> #ifdef DEBUG
> 					else {
> 						DEBUG_MSG("2 pat %p is NOT the lowest pm with is_match=%d and ovector[0]=%d\n", PATTERN(tmplist->data), PATTERN(tmplist->data)->is_match, PATTERN(tmplist->data)->ovector[0]);
> 					}
> #endif
> 					tmplist = g_list_next(tmplist);
> 				}
> 
> 				if (parentpat && parentpat->mode == 1) {
> 					/* the end of the parent pattern needs matching too */
> 					if (parentpat->ovector[0] < offset) {
> 						patmatch_rematch(TRUE, parentpat, offset, buf, to, parentpat);
> 					}
> 					if (parentpat->is_match<=0) {
> 						DEBUG_MSG("4 mode 1 parent has no match, matching to 'to'=%d\n", to);
> 						parentpat->ovector[1] = to;
> 						parentpat->ovector[0] = to;
> 						parentpat->is_match = 1;
> 					}
> 					if (lowest_pm == NULL || (lowest_pm->ovector[0] > parentpat->ovector[0])) {
> 						lowest_pm = parentpat;
> 						DEBUG_MSG("4 new lowest_pm=%p (parentmatch!!), start=%d\n",lowest_pm,lowest_pm->ovector[0]);
> 					}
> #ifdef DEBUG
> 					else {
> 						DEBUG_MSG("4 (parent!!) is NOT the lowest pm with is_match=%d and ovector[0]=%d\n", parentpat->is_match, parentpat->ovector[0]);
> 					}
> #endif
> 				}
> #ifdef DEVELOPMENT
> 				if (lowest_pm && lowest_pm->ovector[1] > to) {
> 					g_print("BUG: lowest_pm->ovector[1] > to !!\n");
> 					g_print("is_parentpat=%d, lowest_pm->mode=%d\n",(lowest_pm == parentpat), lowest_pm->mode);
> 					exit(345);
> 				}
> #endif
> #ifdef DEBUG
> 				if (lowest_pm) {
> 					if (lowest_pm == parentpat) {
> 						DEBUG_MSG("lowest_match %p (parentpat) has start %d\n", lowest_pm, parentpat->ovector[0]);
> 					} else {
> 						DEBUG_MSG("lowest_match %p (some child) has start %d\n", lowest_pm, lowest_pm->ovector[0]);
> 					}
> 				}
> #endif
> 			}
> 		}
> 	}
> 	DEBUG_MSG("applylevel, finished, to=%d, returning to previous level\n", to);
> }
> 
> void doc_remove_highlighting(Tdocument * doc)
> {
> 	GtkTextIter itstart, itend;
> 	gtk_text_buffer_get_bounds(doc->buffer, &itstart, &itend);
> 	gtk_text_buffer_remove_all_tags(doc->buffer, &itstart, &itend);
> }
> 
> void doc_highlight_full(Tdocument * doc) {
> 	if (!doc->hl || !doc->hl->highlightlist) {
> 		return;
> 	} else {
> 		gchar *buf;
> 		guint charcount;
> /*		GdkCursor *cursor = gdk_cursor_new(GDK_WATCH);
> 		gdk_window_set_cursor(main_v->main_window->window, cursor);
> 		gdk_window_set_cursor(main_v->current_document->view->window, cursor);
> 		flush_queue();*/
> 		charcount = gtk_text_buffer_get_char_count(doc->buffer);
> 		doc_remove_highlighting(doc);
> #ifdef HL_TIMING
> 		timing_init();
> #endif
> #ifdef HL_PROFILING
> 		hl_profiling_reset(doc);
> #endif
> #ifdef HL_TIMING
> 		timing_start(TIMING_TOTAL);
> #endif
> 		utf8_offset_cache_reset();
> 		buf = doc_get_chars(doc, 0, charcount);
> #ifdef DEVELOPMENT
> 		g_assert(doc);
> 		g_assert(doc->hl);
> 		g_assert(buf);
> 		g_assert(doc->hl->highlightlist);
> #endif
> 		patmatch_init_run(doc->hl->highlightlist);
> 		applylevel(doc,buf,0,0,strlen(buf),NULL,doc->hl->highlightlist);
> 		g_free(buf);
> #ifdef HL_TIMING
> 		timing_stop(TIMING_TOTAL);
> 		g_print("doc_highlight_full done, %ld ms total, %ld ms tagging (%dX), %ld ms matching (%dX)\n",timing[TIMING_TOTAL].total_ms, timing[TIMING_TEXTBUF].total_ms, timing[TIMING_TEXTBUF].numtimes, timing[TIMING_PCRE_EXEC].total_ms, timing[TIMING_PCRE_EXEC].numtimes);
> 		g_print("%ld ms utf8-shit (%dX), %ld ms utf8-invalidate (%dX)\n", timing[TIMING_UTF8].total_ms, timing[TIMING_UTF8].numtimes, timing[TIMING_UTF8_INV].total_ms, timing[TIMING_UTF8_INV].numtimes);
> 		g_print("%ld ms setting iters, %ld ms setting tags\n", timing[TIMING_TEXTBUF_ITER].total_ms, timing[TIMING_TEXTBUF_TAG].total_ms);
> #endif
> #ifdef HL_PROFILING
> 		hl_profiling_print(doc);
> #endif
> 		doc->need_highlighting = FALSE;
> /*		gdk_window_set_cursor(main_v->main_window->window, NULL);
> 		gdk_cursor_unref(cursor);*/
> 	}
> }
> 
> static void remove_tag_by_list_in_region(Tdocument * doc, GList * patlist, GtkTextIter * itstart, GtkTextIter * itend)
> {
> 	GList *tmplist = g_list_first(patlist);
> 	DEBUG_MSG("remove_tag_by_list_in_region, started on list %p\n", patlist);
> 	/* remove all tags that are children of patlist */
> 	while (tmplist) {
> 		DEBUG_MSG("remove_tag_by_list_in_region, removing tags for pattern %p\n", tmplist->data);
> 		gtk_text_buffer_remove_tag(doc->buffer, ((Tpattern *) tmplist->data)->tag, itstart, itend);
> 		if (((Tpattern *) tmplist->data)->childs) {
> 			remove_tag_by_list_in_region(doc, ((Tpattern *) tmplist->data)->childs, itstart, itend);
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> static Tpattern *find_pattern_by_tag(GList * parentlist, GtkTextTag * tag)
> {
> 	GList *tmplist;
> 
> 	tmplist = g_list_first(parentlist);
> 	while (tmplist) {
> 		if (((Tpattern *) tmplist->data)->tag == tag) {
> 			return (Tpattern *) tmplist->data;
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return NULL;
> }
> 
> static gboolean pattern_has_mode3_child(Tpattern *pat) {
> 	GList *tmplist;
> 
> 	tmplist = g_list_first(pat->childs);
> 	while (tmplist) {
> 		if (((Tpattern *)tmplist->data)->mode == 3) return TRUE;
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return FALSE;
> }
> 
> void doc_highlight_region(Tdocument * doc, guint startof, guint endof) {
> 	Tpattern *pat = NULL;
> 	guint so=-1, eo=-1;
> 	GList *patternlist = doc->hl->highlightlist;
> #ifdef HL_TIMING
> 	timing_init();
> 	timing_start(TIMING_LINE_HIGHLIGHTING);
> #endif
> 	if (startof < endof) {
> 		GtkTextIter itstart, itend, itsearch;
> 		GSList *taglist = NULL, *slist;
> 		gtk_text_buffer_get_iter_at_offset(doc->buffer,&itstart,startof);
> 		gtk_text_buffer_get_iter_at_offset(doc->buffer,&itend,endof);
> 
> 		/* get all the tags that itstart is in */
> 		taglist = gtk_text_iter_get_tags(&itstart);
> 		DEBUG_MSG("doc_highlight_line, (1) getting all tags at itstart %d\n",gtk_text_iter_get_offset(&itstart));
> 		/* find for every tag if it ends _after_ itend or not */
> 		itsearch = itstart;
> 		slist = taglist;
> 		while (slist && slist->data) {
> 			gboolean tag_found;
> #ifdef DEBUG
> 			{
> 				Tpattern *testpat;
> 				gchar *test;
> 				testpat = find_pattern_by_tag(patternlist, GTK_TEXT_TAG(slist->data));
> 				if (testpat) {
> 					DEBUG_MSG("doc_highlight_line, (1) tag %p goes with ", testpat->tag);
> 					print_meta_for_pattern(testpat);
> 				} else {
> 					DEBUG_MSG("doc_highlight_line, (1) tag %p doesn't have pattern??\n",slist->data);
> 					print_meta_for_tag(GTK_TEXT_TAG(slist->data));
> 					/*exit(9);*/
> 				}
> 				test = gtk_text_buffer_get_text(doc->buffer, &itstart, &itend,FALSE);
> 				DEBUG_MSG("doc_highlight_line, (1) current string='%s'\n", test);
> 				g_free(test);
> 			}
> #endif
> 			/* if the tags ends at itstart there is no need to search forward to the end */
> 			if (!gtk_text_iter_ends_tag(&itstart, GTK_TEXT_TAG(slist->data))) {
> 				DEBUG_MSG("doc_highlight_line, (1) forward looking for tag %p (%s) from so=%d to eo=%d\n", slist->data, get_metaname_from_tag(slist->data),
> 						  gtk_text_iter_get_offset(&itstart), gtk_text_iter_get_offset(&itend));
> 				tag_found = gtk_text_iter_forward_to_tag_toggle(&itsearch, GTK_TEXT_TAG(slist->data));
> 				if (!tag_found) {
> 					/* this happens with several gtk versions, 
> 						up to 2.2.4 is buggy
> 						inbetween is unknown,
> 						2.4.4 is fixed */
> 					DEBUG_MSG("doc_highlight_line (1), very weird situation, the tag %p is started but it doesn't end ??, itsearch now is at %d\n", slist->data, gtk_text_iter_get_offset(&itsearch));
> 					/* itsearch is now at the end of the buffer so we do a backward search to find the first start */
> 					tag_found = gtk_text_iter_backward_to_tag_toggle(&itsearch, GTK_TEXT_TAG(slist->data));
> 					DEBUG_MSG("(1) a backward search to the tag finds %d\n", gtk_text_iter_get_offset(&itsearch));
> 					if (!tag_found) {
> 						g_print("doc_highlight_line, (1) a tag that is started is nowhere to be found ??? BUG!\n");
> 						exit(123);
> 					}
> 					if (gtk_text_iter_compare(&itsearch, &itend) < 0) {
> 						/* there is no tag toggle found between itend and the end of the buffer, we
> 						 probably have hit the gtk bug here, so we just set itsearch here to itend+1 */
> 						 itsearch = itend;
> 						 gtk_text_iter_forward_char(&itsearch);
> 					}
> 				}
> 				DEBUG_MSG("doc_highlight_line, (1) tag %p (%s) ends at itsearch=%d\n", slist->data, get_metaname_from_tag(slist->data),gtk_text_iter_get_offset(&itsearch));
> 				if (gtk_text_iter_compare(&itsearch, &itend) > 0) {
> 					/* both the start and endpoint are within this 
> 					   tag --> pattern matching can start with this
> 					   subpattern */
> 					pat = find_pattern_by_tag(patternlist, GTK_TEXT_TAG(slist->data));
> #ifdef DEBUG
> 					DEBUG_MSG("found pattern %p with tag %p and childs %p", pat, pat->tag,pat->childs);
> 					print_meta_for_pattern(pat);
> #endif					
> 					if (pat && (pat->mode == 1)) {
> 						gchar *string;
> 						int ovector[MAX_OVECTOR];
> 						/* but first we do a quick test if the parent-pattern is indeed still valid */
> 						string = gtk_text_buffer_get_text(doc->buffer, &itstart, &itend, FALSE);
> 						if (0 < pcre_exec(pat->reg2.pcre, pat->reg2.pcre_e, string, strlen(string), 0, 0, ovector, MAX_OVECTOR)) {
> 							/* the current line does not have the start of the tag or the end of the tag, but now 
> 							   it does have a match on the end pattern --> so the pattern should be invalidated */
> 							pat = NULL;
> 							DEBUG_MSG("doc_highlight_line, (1) a match of the endpattern is found on this line '%s', the pattern is invalidated\n",string);
> 							itend = itsearch;
> 							gtk_text_iter_backward_to_tag_toggle(&itstart, slist->data);
> 						}
> 						g_free(string);
> 					}
> 					if (pat && !pattern_has_mode3_child(pat)) {
> 						/* what happens if patternlist = NULL ?
> 						   that means we are inside a match without any subpatterns, but 
> 						   perhaps the subpattern should be invalidated... hmm..
> 						 */
> 						patternlist = pat->childs;
> #ifdef DEBUG
> 						DEBUG_MSG("doc_highlight_line, (1) going to use patternlist %p from pattern ", patternlist);
> 						print_meta_for_pattern(pat);
> #endif
> 					} else {
> 						DEBUG_MSG("doc_highlight_line, (1) no pat or pat has a mode3 child, continue with next tag\n");
> 					}
> 				} else {
> 					/* this tag stops somewhere in the middle of the line, move 
> 					   itstart to the beginning of this tag, 
> 						there is also no need anymore to look further in slist, we have to start with this patternlist */
> 					if (gtk_text_iter_begins_tag(&itstart, GTK_TEXT_TAG(slist->data))) {
> 						DEBUG_MSG("doc_highlight_line, (1) itstart at %d is already at the beginning of tag %p (%s)\n",gtk_text_iter_get_offset(&itstart), slist->data, get_metaname_from_tag(slist->data));
> 					} else {
> 						DEBUG_MSG("doc_highlight_line, (1) move itstart from %d to beginning of tag %p (%s)\n",
> 								  gtk_text_iter_get_offset(&itstart), slist->data, get_metaname_from_tag(slist->data));
> 						gtk_text_iter_backward_to_tag_toggle(&itstart, GTK_TEXT_TAG(slist->data));
> 						DEBUG_MSG("doc_highlight_line, (1) itstart is set back to %d\n", gtk_text_iter_get_offset(&itstart));
> 					}
> 					if (pat) {
> 						DEBUG_MSG("doc_highlight_line, (1) skip all other tags, slist=g_list_last()\n");
> 						slist = g_slist_last(slist);
> 					}
> 				}
> 			}
> 			itsearch = itstart;
> 			slist = g_slist_next(slist);
> 		}
> 		g_slist_free(taglist);
> 
> 		/* get all the tags that itend is in */
> 		taglist = gtk_text_iter_get_tags(&itend);
> 		DEBUG_MSG("doc_highlight_line, (2) getting all tags for itend at %d\n", gtk_text_iter_get_offset(&itend));
> 		/* find for every tag if it starts _before_ itstart (that means all of this line-highlighting
> 		 * is within that tag) or _after_ itstart (which means that we should remove that tag, move
> 		 * our highlighting endpoint to the end of that tag, and rehighlight the whole bit) */
> 		itsearch = itend;
> 		slist = taglist;
> 		while (slist && slist->data) {
> 			gboolean tag_found;
> 					/* if the tags starts at itend there is no need to search backward to the start */
> 			if (!gtk_text_iter_begins_tag(&itend, GTK_TEXT_TAG(slist->data))) {
> 				DEBUG_MSG("doc_highlight_line, (2) backwards looking for tag %p (%s) from eo=%d to so=%d, itsearch=%d\n", slist->data,
> 						  get_metaname_from_tag(slist->data), gtk_text_iter_get_offset(&itend),gtk_text_iter_get_offset(&itstart) ,gtk_text_iter_get_offset(&itsearch));
> #ifdef DEBUG
> 				DEBUG_MSG("does the itsearch position (%d) toggle(%d), begin(%d) or end(%d) the tag %p (%s)?\n"
> 						,gtk_text_iter_get_offset(&itsearch)
> 						,gtk_text_iter_toggles_tag(&itsearch,GTK_TEXT_TAG(slist->data)),gtk_text_iter_begins_tag(&itsearch,GTK_TEXT_TAG(slist->data))
> 						,gtk_text_iter_ends_tag(&itsearch,GTK_TEXT_TAG(slist->data)),slist->data, get_metaname_from_tag(slist->data));
> #endif
> 				/* this next function does crash sometimes, and I wonder why..... */
> 				tag_found = gtk_text_iter_backward_to_tag_toggle(&itsearch, GTK_TEXT_TAG(slist->data));
> 				if (!tag_found) {
> 					/* this happens with several gtk versions, 
> 						up to 2.2.4 is buggy
> 						inbetween is unknown,
> 						2.4.4 is fixed */
> 					if (gtk_text_iter_begins_tag(&itsearch, GTK_TEXT_TAG(slist->data))) {
> 						/* we have hit the bug in gtk, this tag should have been found by gtk_text_iter_backward_to_tag_toggle */
> 					} else {
> 						DEBUG_MSG("doc_highlight_line (2), very weird situation, the tag is ended but it doesn't start ??, itsearch now is at %d\n", gtk_text_iter_get_offset(&itsearch));
> 						/* itsearch is now at offset 0, so we do a forward search to find the first start */
> 						tag_found = gtk_text_iter_forward_to_tag_toggle(&itsearch, GTK_TEXT_TAG(slist->data));
> 						DEBUG_MSG("(2) a forward search to the tag finds %d\n", gtk_text_iter_get_offset(&itsearch));
> 						if (!tag_found) {
> 							g_print("doc_highlight_line, (2) a tag that is started is nowhere to be found ??? BUG!\n");
> 							exit(123);
> 						}
> 						if (gtk_text_iter_compare(&itsearch, &itend) > 0) {
> 							itsearch = itstart;
> 							gtk_text_iter_backward_char(&itsearch);
> 						}
> 					}
> 				}
> 				DEBUG_MSG("doc_highlight_line, (2) tag %p (%s) starts at itsearch=%d\n", slist->data,get_metaname_from_tag(slist->data),gtk_text_iter_get_offset(&itsearch));
> 				if (gtk_text_iter_compare(&itsearch, &itstart) <= 0) {
> 					/* both the start and endpoint are within this 
> 					   tag --> pattern matching can start with this
> 					   subpattern,	since we did run the same algorithm for itstart we can skip a bit now */
> 				} else {
> 					/* this tag starts somewhere in the middle of the line, move 
> 					   itend to the end of this tag */
> 					if (gtk_text_iter_ends_tag(&itend, GTK_TEXT_TAG(slist->data))) {
> 						DEBUG_MSG("doc_highlight_line, (2) itend at %d is already at the end of tag %p (%s)\n",
> 								  gtk_text_iter_get_offset(&itend), slist->data,get_metaname_from_tag(slist->data));
> 					} else {
> 						DEBUG_MSG("doc_highlight_line, (2) move itend from %d to end of tag %p (%s)\n",gtk_text_iter_get_offset(&itend), slist->data, get_metaname_from_tag(slist->data));
> 						gtk_text_iter_forward_to_tag_toggle(&itend, GTK_TEXT_TAG(slist->data));
> 						DEBUG_MSG("doc_highlight_line, (2) itend is set forward to %d\n", gtk_text_iter_get_offset(&itend));
> 					}
> 				}
> 			}
> 			itsearch = itend;
> 			slist = g_slist_next(slist);
> 		}
> 		g_slist_free(taglist);
> 		
> 		/* this function removes some specific tags from the region */
> 		remove_tag_by_list_in_region(doc, patternlist, &itstart, &itend);
> 		so = gtk_text_iter_get_offset(&itstart);
> 		eo = gtk_text_iter_get_offset(&itend);
> 	} else {
> 		DEBUG_MSG("doc_highlight_line, so >= eo, not highlighting!\n");
> 	}
> #ifdef HL_TIMING
> 		timing_stop(TIMING_LINE_HIGHLIGHTING);
> #endif
> 	if (patternlist) {
> 		gchar *buf;
> 		DEBUG_MSG("doc_highlight_line from so=%d to eo=%d\n", so, eo);
> 		
> 		patmatch_init_run(doc->hl->highlightlist);
> 		
> #ifdef HL_TIMING
> 		timing_start(TIMING_TOTAL);
> #endif
> 		buf = doc_get_chars(doc, so, eo);
> 		applylevel(doc,buf,so,0,strlen(buf),NULL,patternlist);
> 		g_free(buf);
> #ifdef HL_TIMING
> 		timing_stop(TIMING_TOTAL);
> 		g_print("doc_highlight_line done, %ld ms total, %ld ms line_highlighting\n",timing[TIMING_TOTAL].total_ms, timing[TIMING_LINE_HIGHLIGHTING].total_ms);
> #endif
> 	} else {
> 		DEBUG_MSG("doc_highlight_line, no patternlist, not highlighting!\n");
> 	}
> 	doc->need_highlighting = FALSE;
> }
> 
> void doc_highlight_line(Tdocument * doc) {
> 	GtkTextIter itstart, itend;
> 	GtkTextMark *mark = gtk_text_buffer_get_insert(doc->buffer);
> 	gtk_text_buffer_get_iter_at_mark(doc->buffer, &itstart, mark);
> 	/* move to the beginning of the line */
> 	gtk_text_iter_set_line_offset(&itstart, 0);
> 	if (main_v->props.highlight_num_lines_count) {
> 		gtk_text_iter_backward_lines(&itstart, main_v->props.highlight_num_lines_count);
> 	}
> 	gtk_text_buffer_get_iter_at_mark(doc->buffer, &itend, mark);
> /*		gtk_text_iter_forward_to_line_end(&itend);
> 	gtk_text_iter_set_line_offset(&itend, 0);*/
> 	if (main_v->props.highlight_num_lines_count) {
> 		gtk_text_iter_forward_lines(&itend, main_v->props.highlight_num_lines_count);
> 	}
> 	if (gtk_text_iter_forward_to_line_end(&itend)) {
> 		gtk_text_iter_forward_char(&itend);
> 	}
> 	doc_highlight_region(doc, gtk_text_iter_get_offset(&itstart), gtk_text_iter_get_offset(&itend));
> }
> 
> 
> 
> #ifdef HIGHLIGHTING_DEFAULTS_NOW_EXTERNAL
> void hl_reset_to_default()
> {
> 	gchar **arr;
> 	/* the further down, the higher the priority of the tag */
> 	arr = array_from_arglist("c", "string", "0", "\"", "\"", "1", "", "#009900", "", "0", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("c", "string-escape", "0", "\\\\.", "", "2", "^string$", "#009900", "", "0", "0",NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("c", "preprocessor", "0", "#(include|define|if|ifdef|else|endif).*$", "", "2", "","#000099", "", "0", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("c", "comment", "0", "/\\*", "\\*/", "1", "^(top|preprocessor)$", "#AAAAAA", "", "1", "2", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("c", "keywords", "0", "\\b(return|goto|if|else|case|default|switch|break|continue|while|do|for|sizeof)\\b","", "2", "", "#000000", "", "2", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr =	array_from_arglist("c", "storage-keywords", "0", "\\b(const|extern|auto|register|static|unsigned|signed|volatile|char|double|float|int|long|short|void|typedef|struct|union|enum|FILE|gint|gchar|GList|GtkWidget|gpointer|guint|gboolean)\\b","", "2", "", "#990000", "", "2", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("c", "braces", "0", "[{()}]", "",  "2", "", "#000000", "", "2", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("c", "character", "0", "'", "'",  "1", "", "#009900", "", "0", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 
> 	arr = array_from_arglist("php", "html", "1", "<((/)?[a-z0-9]+)", ">",  "1", "", "#000077", "", "0", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "html-tag", "1", "1", "", "3", "^html$", "#550044", "", "2", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr =	array_from_arglist("php", "html-tag-table", "1", "^(/)?(table|td|tr|tbody)$", "",  "2", "^html-tag$", "#5005AA", "", "0", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr =	array_from_arglist("php", "html-tag-special", "1", "^(/)?(img|a)$", "",  "2", "^html-tag$", "#BB0540", "", "0","0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "html-attrib", "1", "([a-z]*=)(\"[^\"]*\")", "",  "2", "^html$", "", "", "0", "0",NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "html-attrib-sub2", "1", "2", "",  "3", "^html-attrib$", "#009900", "", "0", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "specialchar", "1", "&[^;]*;", "", "2", "", "#999999", "", "2", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "comment", "0", "<!--", "-->",  "1", "", "#AAAAAA", "", "1", "2", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "php", "1", "<\\?php", "\\?>",  "1", "^(top|html|html-attrib-sub2)$", "#0000FF", "", "0", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "php-keywords", "0","\\b(return|goto|if|else|case|default|switch|break|continue|while|do|for|global|var|class|function|new)\\b","",  "2", "^php$", "#000000", "", "2", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "php-braces", "0", "[{()}]", "", "2", "^php$", "#000000", "", "2", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "php-string-double", "0", "\"", "\"",  "1", "^php$", "#009900", "", "1", "1", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "php-string-double-escape", "0", "\\\\.", "", "2", "^php-string-double$", "#009900", "", "1", "1",NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "php-var", "1", "\\$[a-z_][][a-z0-9>_$-]*", "",  "2", "^php$", "#CC0000", "", "2", "0",NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "php-var-specialchars", "0", "(\\[|\\]|->)", "",  "2", "^php-var$", "#0000CC", "", "0","0",NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "php-string-single", "0", "'", "'",  "1", "^php$", "#009900", "", "1", "1", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("php", "php-comment-C", "0", "/\\*", "\\*/",  "1", "^php$", "#7777AA", "", "1", "2", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr =array_from_arglist("php", "php-comment-C++", "0", "//.*$", "",  "2", "^php$", "#7777AA", "", "1", "2", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 
> 	arr = array_from_arglist("html", "html", "1", "<((/)?[a-z0-9]+)", ">", "1", "", "#0000EE", "", "0", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("html", "html-tag", "1", "1", "",  "3", "^html$", "#000077", "", "2", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("html", "html-attrib", "1", "([a-z]*=)(\"[^\"]*\")", "", "2", "^html$", "", "", "0", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("html", "html-attrib-sub2", "1", "2", "", "3", "^html-attrib$", "#009900", "", "0", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("html", "specialchar", "1", "&[^;]*;", "", "2", "", "#999999", "", "2", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("html", "comment", "0", "<!--", "-->", "1", "", "#AAAAAA", "", "1", "2",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("html", "doctype", "1", "<![a-z0-9]+", "[^?-]>",  "1", "", "#bb8800", "", "0", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 
> 	arr = array_from_arglist("xml", "tag", "1", "<((/)?[a-z0-9]+)", "[^?-]>",  "1", "", "#0000EE", "", "0", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("xml", "tag-name", "1", "1", "", "3", "^tag$", "#000077", "", "2", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("xml", "tag-attrib", "1", "([a-z]*=)(\"[^\"]*\")", "",  "2", "^tag$", "", "", "0", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("xml", "tag-attrib-sub2", "1", "2", "",  "3", "^tag-attrib$", "#009900", "", "0", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("xml", "specialchar", "1", "&[^;]*;", "",  "2", "", "#999999", "", "2", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("xml", "comment", "0", "<!--", "-->",  "1", "", "#AAAAAA", "", "1", "2",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("xml", "doctype", "1", "<![a-z0-9]+", "[^?-]>",  "1", "", "#bb8800", "", "0", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 
> 	arr = array_from_arglist("java", "comment-C-style", "0", "/\\*", "\\*/", "1", "", "#AAAAAA", "", "1", "2",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("java", "comment-C++-style", "0", "//.*$", "", "2", "", "#AAAAAA", "", "1", "2",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("java", "string", "0", "\"", "\"", "1", "", "#009900", "", "0", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("java", "string-escape", "0", "\\\\.", "", "2", "^string$", "#009900", "", "0", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr =	array_from_arglist("java", "include", "0", "^(import|package).*$", "",  "2", "", "#000099", "", "0", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr =	array_from_arglist("java", "keywords", "0", "\\b(new|super|return|goto|if|else|case|default|switch|break|continue|while|do|for|catch|throw|finally|try|class)\\b","",  "2", "", "#000000", "", "2", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("java", "special_values", "0", "\\b(false|null|true)\\b", "", "2", "", "#5caeee", "", "0", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("java", "modifiers", "0", "\\b(abstract|final|native|private|protected|public|static|transient|synchronized|volatile|extends|implements)\\b","", "2", "", "#990000", "", "2", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("java", "this", "0", "\\bthis\\.", "",  "2", "", "#000099", "", "2", "0", NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("java", "primitive-types", "0", "\\b(void|double|boolean|int)\\b", "",  "2", "", "#880088", "", "2","0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("java", "braces", "0", "[{()}]", "", "", "2", "", "#000000", "", "2", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	arr = array_from_arglist("java", "character", "0", "'", "'", "1", "", "#009900", "", "0", "0",  NULL);
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns, arr);
> 	
> 	/* python support */
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "keywords", "0", "\\b(and|assert|break|continue|def|del|elif|else|except|exec|finally|for|if|in|is|not|or|pass|print|raise|return|try|while)\\b","",  "2", "", "#000000", "", "2", "0",  NULL));
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "string-double", "0", "\"", "\"", "1", "", "#009900", "", "0", "0",  NULL));
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "string-double-escape", "0", "\\\\.", "", "2", "^string-double$", "#009900", "", "0", "0",  NULL));
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "string-single", "0", "'", "'", "1", "", "#009900", "", "0", "0",  NULL));
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "string-single-escape", "0", "\\\\.", "", "2", "^string-single$", "#009900", "", "0", "0",  NULL));
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "special_values", "0", "\\b(None)\\b", "", "2", "", "#5caeee", "", "0", "0", NULL));
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "include", "0", "^(import|from).*$", "",  "2", "", "#000099", "", "0", "0",  NULL));
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "comment", "0", "#.*$", "", "2", "", "#AAAAAA", "", "1", "2",  NULL));
> 	main_v->props.highlight_patterns = g_list_append(main_v->props.highlight_patterns,array_from_arglist("python", "braces", "0", "[{()}\\[\\]]", "", "2", "", "#000000", "", "2", "0",  NULL));
> }
> #endif /* HIGHLIGHTING_DEFAULTS_NOW_EXTERNAL */
> GtkTextTagTable *highlight_return_tagtable() {
> 	return highlight.tagtable;
> }
1,2576c1,2562
< /* Bluefish HTML Editor
<  * menu.c - the menu(s)
<  *
<  * this file has content-type: UTF-8
<  * and it is important you keep it UTF-8 !!!
<  *
<  * Copyright (C) 1998-2000 Olivier Sessink, Chris Mazuc and Roland Steinbach
<  * Copyright (C) 2000-2002 Olivier Sessink and Roland Steinbach
<  * Copyright (C) 2002-2005 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< #include <gtk/gtk.h>
< #include <stdlib.h>    /* atoi */
< #include <string.h>    /* strchr() */
< #include <gdk/gdkkeysyms.h>
< 
< /* #define DEBUG */
< 
< #include "bluefish.h"
< #include "menu.h"
< #include "about.h"
< #include "bf_lib.h"        /* append_string_to_file() */
< #include "bfspell.h"
< #include "bookmark.h"
< #include "document.h"      /* file_open etc. */
< #include "gtk_easy.h"      /* window_full, bf_stock_ok_button */
< #include "gui.h"           /* go_to_line_win_cb */
< #include "highlight.h"     /* doc_highlight_full */
< #include "html.h"
< #include "html2.h"
< #include "html_table.h"
< #include "html_form.h"
< #include "image.h"
< #include "outputbox.h"     /* temporary */
< #include "pixmap.h"
< #include "preferences.h"   /* open_preferences_menu_cb */
< #include "project.h"
< #include "rcfile.h"        /* rcfile_save_configfile_menu_cb */
< #include "rpopup.h"
< #include "snr2.h"          /* search_cb, replace_cb */
< #include "stringlist.h"    /* free_stringlist() */
< #include "undo_redo.h"     /* undo_cb() redo_cb() etc. */
< #include "wizards.h"
< 
< #ifdef HAVE_ATLEAST_GTK_2_4
< #include "quickstart.h"
< #endif /* HAVE_ATLEAST_GTK_2_4 */
< 
< /*
< The callback for an ItemFactory entry can take two forms. If callback_action is zero, it is of the following form:
< void callback(void)
< otherwise it is of the form:
< void callback( gpointer callback_data,guint callback_action, GtkWidget *widget)
< callback_data is a pointer to an arbitrary piece of data and is set during the call to gtk_item_factory_create_items().
< 
< we want to pass the Tbfwin* so we should never use a callback_action of zero
< */
< static void menu_file_operations_cb(Tbfwin *bfwin, guint callback_action, GtkWidget *widget) {
< 	switch(callback_action) {
< 	case 1:
< 		file_new_cb(NULL,bfwin);
< 	break;
< 	case 2:
< 		file_open_cb(NULL,bfwin);
< 	break;
< #ifdef EXTERNAL_GREP
< #ifdef EXTERNAL_FIND
< 	case 3:
< 		file_open_advanced_cb(NULL,bfwin);
< 	break;
< #endif
< #endif
< 	case 4:
< 		doc_reload(bfwin->current_document);
< 	break;
< 	case 5:
< 		file_save_cb(NULL, bfwin);
< 	break;
< 	case 6:
< 		file_save_as_cb(NULL, bfwin);
< 	break;
< 	case 7:
< 		file_move_to_cb(NULL, bfwin);
< 	break;
< 	case 8:
< 		file_save_all_cb(NULL, bfwin);
< 	break;
< 	case 9:
< 		file_close_cb(NULL, bfwin);
< 	break;
< 	case 10:
< 		edit_cut_cb(NULL, bfwin);
< 	break;
< 	case 11:
< 		edit_copy_cb(NULL, bfwin);
< 	break;
< 	case 12:
< 		edit_paste_cb(NULL, bfwin);
< 	break;
< 	case 13:
< 		edit_select_all_cb(NULL, bfwin);
< 	break;
< 	case 14:
< 		search_cb(NULL, bfwin);
< 	break;
< 	case 16:
< 		search_again_cb(NULL, bfwin);
< 	break;
< 	case 17:
< 		replace_cb(NULL, bfwin);
< 	break;
< 	case 19:
< 		replace_again_cb(NULL, bfwin);
< 	break;
< 	case 20:
< 		undo_cb(NULL, bfwin);
< 	break;
< 	case 21:
< 		redo_cb(NULL, bfwin);
< 	break;
< 	case 22:
< 		undo_all_cb(NULL, bfwin);
< 	break;
< 	case 23:
< 		redo_all_cb(NULL, bfwin);
< 	break;
< 	case 24:
< 		file_close_all_cb(NULL,bfwin);
< 	break;
< #ifdef HAVE_GNOME_VFS
< 	case 25:
< 		file_open_url_cb(NULL, bfwin);
< 	break;
< #endif
< 	case 26:
< 		file_open_from_selection(bfwin);
< 	break;
< 	case 27:
< 		search_from_selection(bfwin);
< 	break;
< 	default:
< 		g_print("menu_file_operations_cb, unknown action, abort!\n");
< 		exit(123);
< 	}
< }
< static void menu_html_dialogs_lcb(Tbfwin *bfwin, guint callback_action, GtkWidget *widget) {
< 	switch (callback_action) {
< 	case 1:
< 		body_dialog(bfwin,NULL);
< 	break;
< 	case 2:
< 		DEBUG_MSG("menu_html_dialogs_lcb,calling quickanchor_dialog with bfwin=%p and data=NULL\n",bfwin);
< 		quickanchor_dialog(bfwin,NULL);
< 	break;
< 	case 3:
< 		email_dialog(bfwin,NULL);
< 	break;
< 	case 4:
< 		quickrule_dialog(bfwin,NULL);
< 	break;
< 	case 5:
< 		font_dialog(bfwin,NULL);
< 	break;
< 	case 6:
< 		basefont_dialog(bfwin,NULL);
< 	break;
< 	case 7:
< 		quicklist_dialog(bfwin,NULL);
< 	break;
< 	case 8:
< 		meta_dialog(bfwin,NULL);
< 	break;
< 	case 9:
< 		embed_dialog(bfwin,NULL);
< 	break;
< 	case 10:
< 		image_insert_dialog(bfwin,NULL);
< 	break;
< 	case 11:
< 		thumbnail_insert_dialog(bfwin);
< 	break;
< 	case 12:
< 		tablewizard_dialog(bfwin);
< 	break;
< 	case 13:
< 		tabledialog_dialog(bfwin,NULL);
< 	break;
< 	case 14:
< 		tablerowdialog_dialog(bfwin,NULL);
< 	break;
< 	case 15:
< 		tableheaddialog_dialog(bfwin,NULL);
< 	break;
< 	case 16:
< 		tabledatadialog_dialog(bfwin,NULL);
< 	break;
< 	case 17:
< 		span_dialog(bfwin,NULL);
< 	break;
< 	case 18:
< 		div_dialog(bfwin,NULL);
< 	break;
< 	case 19:
< 		framewizard_dialog(bfwin);
< 	break;
< 	case 20:
< 		frameset_dialog(bfwin,NULL);
< 	break;
< 	case 21:
< 		frame_dialog(bfwin,NULL);
< 	break;
< 	case 22:
< 		formdialog_dialog(bfwin,NULL);
< 	break;
< 	case 23:
< 		inputdialog_dialog(bfwin, NULL, "submit");
< 	break;
< 	case 24:
< 		inputdialog_dialog(bfwin, NULL, "text");
< 	break;
< 	case 25:
< 		buttondialog_dialog(bfwin, NULL);
< 	break;
< 	case 26:
< 		textareadialog_dialog(bfwin,NULL);
< 	break;
< 	case 29:
< 		selectdialog_dialog(bfwin,NULL);
< 	break;
< 	case 30:
< 		optiondialog_dialog(bfwin,NULL);
< 	break;
< 	case 31:
< 		optgroupdialog_dialog(bfwin,NULL);
< 	break;
< 	case 32:
< #ifdef HAVE_ATLEAST_GTK_2_4
< 		quickstart_dialog_new(bfwin);
< #else
< 		quickstart_dialog(bfwin,NULL);
< #endif
< 	break;
< 	case 33:
< 		inputdialog_dialog(bfwin, NULL, NULL);
< 	break;
< 	case 34:
< 		insert_time_dialog(bfwin);
< 	break;
< 	case 35:
< 		linkdialog_dialog(bfwin,NULL,linkdialog_mode_default);
< 	break;
< 	case 36:
< 		linkdialog_dialog(bfwin,NULL,linkdialog_mode_css);
< 	break;
< 	case 37:
< 		new_css_dialog(NULL,bfwin);
< 	break;
< 	case 38:
< 		sel_colour_cb(NULL,bfwin);	
< 	break;
< 	case 39:
< 		edit_tag_under_cursor_cb(bfwin);
< 	break;
< 	default:
< 		g_print("menu_file_operations_cb, unknown action, abort!\n");
< 		exit(123);
< 	}
< }
< #ifdef HAVE_LIBASPELL
< static void spell_check_menu_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
< 	spell_check_cb(NULL, bfwin);
< }
< #endif /* HAVE_LIBASPELL */
< 
< static void menu_bmark_operations_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
< 	switch(callback_action) {
< 	case 1:
< 	   bmark_add(bfwin);
< 	break;
< /*	case 2:
< 	   bmark_add_perm(bfwin);
< 	break;*/
< 	default:
< 			g_print("Bmark action no. %d\n",callback_action);
< 	}
< }
< 
< static void toggle_doc_property(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
< 	switch(callback_action) {
< 	case 1:
< 		bfwin->current_document->wrapstate = GTK_CHECK_MENU_ITEM(widget)->active;
< 		doc_set_wrap(bfwin->current_document);
< 		break;
< 	case 2:
< 		bfwin->current_document->linenumberstate = GTK_CHECK_MENU_ITEM(widget)->active;
< 		document_set_line_numbers(bfwin->current_document, bfwin->current_document->linenumberstate);
< 		break;
< 	case 3:
< 		bfwin->current_document->autoclosingtag = GTK_CHECK_MENU_ITEM(widget)->active;
< 		break;
< 	case 4:
< 		main_v->props.autoindent = GTK_CHECK_MENU_ITEM(widget)->active;
< 		break;
< 	}
< }
< 
< static GtkItemFactoryEntry menu_items[] = {
< 	{N_("/_File"), NULL, NULL, 0, "<Branch>"},
< 	{"/File/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/File/_New"), "<control>n", menu_file_operations_cb, 1, "<StockItem>", GTK_STOCK_NEW},
< 	{N_("/File/New _Window"), "<shift><control>n", gui_window_menu_cb, 1, "<Item>"},	
< 	{N_("/File/_Open..."), "<control>O", menu_file_operations_cb, 2, "<StockItem>", GTK_STOCK_OPEN},
< 	{N_("/File/Open _recent"), NULL, NULL, 0, "<Branch>"},
< 	{"/File/Open recent/tearoff1", NULL, NULL, 0, "<Tearoff>"},	
< #ifdef EXTERNAL_GREP
< #ifdef EXTERNAL_FIND
< 	{N_("/File/Open Ad_vanced..."), "<shift><control>O", menu_file_operations_cb, 3, "<Item>"},
< #endif /* EXTERNAL_FIND */
< #endif /* EXTERNAL_GREP */
< #ifdef HAVE_GNOME_VFS
< 	{N_("/File/Open _URL..."), NULL, menu_file_operations_cb, 25, "<Item>"},
< #endif /* HAVE_GNOME_VFS */
< 	{N_("/File/Open _from selection"), NULL, menu_file_operations_cb, 26, "<Item>"},
< 	{"/File/sep1", NULL, NULL, 0, "<Separator>"},
< 	{N_("/File/_Save"), "<control>S", menu_file_operations_cb, 5, "<StockItem>", GTK_STOCK_SAVE},
< 	{N_("/File/Save _As..."), "<shift><control>S", menu_file_operations_cb, 6, "<StockItem>", GTK_STOCK_SAVE_AS},
< 	{N_("/File/Sav_e All"), NULL, menu_file_operations_cb, 8, "<Item>"},
< 	{N_("/File/Rever_t to Saved"), NULL, menu_file_operations_cb, 4, "<StockItem>", GTK_STOCK_REVERT_TO_SAVED},
< 	{"/File/sep2", NULL, NULL, 0, "<Separator>"},	
< 	{N_("/File/_Insert..."), NULL, file_insert_menucb, 1, "<Item>"},	
< 	{N_("/File/Rena_me..."), "F2", menu_file_operations_cb, 7, "<Item>"},
< 	{"/File/sep3", NULL, NULL, 0, "<Separator>"},
< 	{N_("/File/_Close"), "<control>w", menu_file_operations_cb, 9, "<StockItem>", GTK_STOCK_CLOSE},
< 	{N_("/File/Close A_ll"), "<shift><control>w", menu_file_operations_cb, 24, "<Item>"},
< 	{N_("/File/Close Win_dow"), NULL, gui_window_menu_cb, 2, "<Item>"},
< 	{"/File/sep4", NULL, NULL, 0, "<Separator>"},
< 	{N_("/File/_Quit"), "<control>Q", bluefish_exit_request, 0, "<StockItem>", GTK_STOCK_QUIT},
< 	{N_("/_Edit"), NULL, NULL, 0, "<Branch>"},
< 	{"/Edit/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Edit/_Undo"), "<control>z", menu_file_operations_cb, 20, "<StockItem>", GTK_STOCK_UNDO},
< 	{N_("/Edit/_Redo"), "<shift><control>z", menu_file_operations_cb, 21, "<StockItem>", GTK_STOCK_REDO},
< 	{N_("/Edit/Undo All"), NULL, menu_file_operations_cb, 22, "<Item>"},
< 	{N_("/Edit/Redo All"), NULL, menu_file_operations_cb, 23, "<Item>"},
< 	{"/Edit/sep1", NULL, NULL, 0, "<Separator>"},	
< 	{N_("/Edit/Cu_t"), "<control>x", menu_file_operations_cb, 10, "<StockItem>", GTK_STOCK_CUT},
< 	{N_("/Edit/_Copy"), "<control>c", menu_file_operations_cb, 11, "<StockItem>", GTK_STOCK_COPY},
< 	{N_("/Edit/_Paste"), "<control>v", menu_file_operations_cb, 12, "<StockItem>", GTK_STOCK_PASTE},
< 	{"/Edit/sep2", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Edit/Select _All"), NULL, menu_file_operations_cb, 13, "<Item>"},
< 	{"/Edit/sep3", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Edit/_Find..."), "<control>f", menu_file_operations_cb, 14, "<StockItem>", GTK_STOCK_FIND},
< 	{N_("/Edit/Find A_gain"), "<control>g", menu_file_operations_cb, 16, "<Item>"},
< 	{N_("/Edit/Find from selection"), NULL, menu_file_operations_cb, 27, "<Item>"},
< 	{N_("/Edit/R_eplace..."), "<control>h", menu_file_operations_cb, 17, "<StockItem>", GTK_STOCK_FIND_AND_REPLACE},
< 	{N_("/Edit/Replace Agai_n"), "<shift><control>h", menu_file_operations_cb, 19, "<Item>"},
< 	{N_("/Edit/Replace special"), NULL, NULL, 0, "<Branch>"},
< 	{"/Edit/Replace special/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Edit/Replace special/_ASCII to HTML Entities"), NULL, doc_convert_asciichars_in_selection, 1, "<Item>"},
< 	{N_("/Edit/Replace special/_ISO8859 to HTML Entities"), NULL, doc_convert_asciichars_in_selection, 2, "<Item>"},
< 	{N_("/Edit/Replace special/_Both Types to HTML Entities"), NULL, doc_convert_asciichars_in_selection, 3, "<Item>"},
< 	{N_("/Edit/Replace special/To _Uppercase"), NULL, doc_convert_asciichars_in_selection, 4, "<Item>"},
< 	{N_("/Edit/Replace special/To _Lowercase"), NULL, doc_convert_asciichars_in_selection, 5, "<Item>"},
< 	{"/Edit/sep4", NULL, NULL, 0, "<Separator>"},
< #ifdef HAVE_ATLEAST_GTK_2_4
<    {N_("/Edit/S_hift Right"), NULL, menu_indent_cb, 2, "<StockItem>", GTK_STOCK_INDENT},
<    {N_("/Edit/Shift _Left"), NULL, menu_indent_cb, 1, "<StockItem>", GTK_STOCK_UNINDENT},
< #else
< 	{N_("/Edit/S_hift Right"), NULL, menu_indent_cb, 2, "<ImageItem>", pixmap_indent},
< 	{N_("/Edit/Shift _Left"), NULL, menu_indent_cb, 1, "<ImageItem>", pixmap_unindent},
< #endif
< 	{"/Edit/sep5", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Edit/Add _Bookmark"), "<control>d", menu_bmark_operations_cb, 1, "<Item>"},	
< 	{"/Edit/sep6", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Edit/Save Sett_ings"), NULL, rcfile_save_configfile_menu_cb, 0, "<Item>"},
< 	{N_("/Edit/Save Shortcut _Keys"), NULL, rcfile_save_configfile_menu_cb, 3, "<Item>"},	
< 	{N_("/Edit/Preference_s"), NULL, open_preferences_menu_cb, 0, "<StockItem>", GTK_STOCK_PREFERENCES},
< 	{N_("/_View"), NULL, NULL, 0, "<Branch>"},
< 	{"/View/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/View/View _Main Toolbar"), NULL, gui_toggle_hidewidget_cb, 1, "<ToggleItem>"},
< 	{N_("/View/View _HTML Toolbar"), NULL, gui_toggle_hidewidget_cb, 2, "<ToggleItem>"},
< 	{N_("/View/View _Custom Menu"), NULL, gui_toggle_hidewidget_cb, 3, "<ToggleItem>"},
< 	{N_("/View/View _Sidebar"), "F9", gui_toggle_hidewidget_cb, 4, "<ToggleItem>"},
< 	{N_("/_Tags"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< /*	{N_("/Tags/Repeat last"), "F4", repeat_last_insert_cb, 0, NULL},*/
< 	{N_("/Tags/_Headings"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Headings/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Headings/H_1"), "<control><alt>1", general_html_menu_cb, 18, "<ImageItem>",pixmap_fonth1},
< 	{N_("/Tags/Headings/H_2"), "<control><alt>2", general_html_menu_cb, 19, "<ImageItem>",pixmap_fonth2},
< 	{N_("/Tags/Headings/H_3"), "<control><alt>3", general_html_menu_cb, 20, "<ImageItem>",pixmap_fonth3},
< 	{N_("/Tags/Headings/H_4"), "<control><alt>4", general_html_menu_cb, 21, "<ImageItem>",pixmap_fonth4},
< 	{N_("/Tags/Headings/H_5"), "<control><alt>5", general_html_menu_cb, 22, "<ImageItem>",pixmap_fonth5},
< 	{N_("/Tags/Headings/H_6"), "<control><alt>6", general_html_menu_cb, 23, "<ImageItem>",pixmap_fonth6},
< 	{N_("/Tags/_Special"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Special/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Special/_Accent"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Special/Accent/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Special/Accent/_Uppercase"), NULL, NULL, 0, "<Branch>"},
< 	{N_("/Tags/Special/Accent/Uppercase/_A-I"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Special/Accent/Uppercase/A-I/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/A grave À"), NULL, insert_char_cb, 100, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/A acute Á"), NULL, insert_char_cb, 1, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/A circumflex Â"), NULL, insert_char_cb, 2, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/A tilde Ã"), NULL, insert_char_cb, 3, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/AE ligature Æ"), NULL, insert_char_cb, 4, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/A diaeresis Ä"), NULL, insert_char_cb, 5, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/A ring Å"), NULL, insert_char_cb, 6, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/C cedilla Ç"), NULL, insert_char_cb, 7, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/E grave È"), NULL, insert_char_cb, 8, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/E acute É"), NULL, insert_char_cb, 9, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/E circumflex Ê"), NULL, insert_char_cb, 10, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/E diaeresis Ë"), NULL, insert_char_cb, 11, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/I grave Ì"), NULL, insert_char_cb, 12, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/I acute Í"), NULL, insert_char_cb, 13, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/I circumflex Î"), NULL, insert_char_cb, 14, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/A-I/I diaeresis Ï"), NULL, insert_char_cb, 15, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/_J-Z"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Special/Accent/Uppercase/J-Z/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/N tilde Ñ"), NULL, insert_char_cb, 16, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/O grave Ò"), NULL, insert_char_cb, 17, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/O acute Ó"), NULL, insert_char_cb, 18, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/O circumflex Ô"), NULL, insert_char_cb, 19, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/OE ligature Œ"), NULL, insert_char_cb, 100, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/O tilde Õ"), NULL, insert_char_cb, 20, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/O diaeresis Ö"), NULL, insert_char_cb, 21, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/O slash Ø"), NULL, insert_char_cb, 22, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/U grave Ù"), NULL, insert_char_cb, 23, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/U acute Ú"), NULL, insert_char_cb, 24, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/U circumflex Û"), NULL, insert_char_cb, 25, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/U diaeresis Ü"), NULL, insert_char_cb, 26, "<Item>"},
< 	{N_("/Tags/Special/Accent/Uppercase/J-Z/Y acute Ý"), NULL, insert_char_cb, 27, "<Item>"},
< 	{N_("/Tags/Special/Accent/_Lowercase"), NULL, NULL, 0, "<Branch>"},
< 	{N_("/Tags/Special/Accent/Lowercase/_A-I"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Special/Accent/Lowercase/A-I/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/a grave à"), NULL, insert_char_cb, 28, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/a acute á"), NULL, insert_char_cb, 29, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/a circumflex â"), NULL, insert_char_cb, 30, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/a tilde ã"), NULL, insert_char_cb, 31, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/a ring å"), NULL, insert_char_cb, 32, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/ae ligature æ"), NULL, insert_char_cb, 33, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/a diaeresis ä"), NULL, insert_char_cb, 34, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/c cedilla ç"), NULL, insert_char_cb, 35, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/e grave è"), NULL, insert_char_cb, 36, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/e acute é"), NULL, insert_char_cb, 37, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/e circumflex ê"), NULL, insert_char_cb, 38, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/e diaeresis ë"), NULL, insert_char_cb, 39, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/i grave ì"), NULL, insert_char_cb, 40, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/i acute í"), NULL, insert_char_cb, 41, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/i circumflex î"), NULL, insert_char_cb, 42, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/A-I/i diaeresis ï"), NULL, insert_char_cb, 43, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/_J-Z"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Special/Accent/Lowercase/J-Z/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/n tilde ñ"), NULL, insert_char_cb, 44, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/o grave ò"), NULL, insert_char_cb, 45, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/o acute ó"), NULL, insert_char_cb,46, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/oe ligature œ"), NULL, insert_char_cb,99, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/o circumflex ô"), NULL, insert_char_cb, 47, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/o tilde õ"), NULL, insert_char_cb, 48, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/o diaeresis ö"), NULL, insert_char_cb, 49, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/o slash ø"), NULL, insert_char_cb, 50, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/u grave ù"), NULL, insert_char_cb, 51, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/u acute ú"), NULL, insert_char_cb, 52, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/u circumflex û"), NULL, insert_char_cb, 53, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/u diaeresis ü"), NULL, insert_char_cb, 54, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/y acute ý"), NULL, insert_char_cb, 55, "<Item>"},
< 	{N_("/Tags/Special/Accent/Lowercase/J-Z/y diaeresis ÿ"), NULL, insert_char_cb, 56, "<Item>"},
< 	{"/Tags/Special/Accent/sep1", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Tags/Special/Accent/U_mlaut ¨"), NULL, insert_char_cb, 57, "<Item>"},
< 	{N_("/Tags/Special/Accent/_Acute ´"), NULL, insert_char_cb, 58, "<Item>"},
< 	{N_("/Tags/Special/Accent/_Cedilla ¸"), NULL, insert_char_cb, 59, "<Item>"},
< 	{N_("/Tags/Special/_Currency"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Special/Currency/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Special/Currency/_Cent sign ¢"), NULL, insert_char_cb, 60, "<Item>"},
< 	{N_("/Tags/Special/Currency/_Pound sterling £"), NULL, insert_char_cb, 61, "<Item>"},
< 	{N_("/Tags/Special/Currency/C_urrency sign ¤"), NULL, insert_char_cb, 62, "<Item>"},
< 	{N_("/Tags/Special/Currency/_Yen sign ¥"), NULL, insert_char_cb, 63, "<Item>"},
< 	{N_("/Tags/Special/Currency/_Euro "), NULL, insert_char_cb, 98, "<Item>"},
< 	{N_("/Tags/Special/_Math-Science"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Special/Math-Science/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Special/Math-Science/Logical _not sign ¬"), NULL, insert_char_cb, 64, "<Item>"},
< 	{N_("/Tags/Special/Math-Science/_Multiplication sign ×"), NULL, insert_char_cb, 65, "<Item>"},
< 	{N_("/Tags/Special/Math-Science/_Division sign ÷"), "<control><alt>slash", insert_char_cb, 66, "<Item>"},
< 	{N_("/Tags/Special/Math-Science/_Plus-minus sign ±"), NULL, insert_char_cb, 67, "<Item>"},
< 	{N_("/Tags/Special/Math-Science/_Less-than sign <"), "<control><alt>comma", insert_char_cb, 68, "<Item>"},
< 	{N_("/Tags/Special/Math-Science/_Greater-than sign >"), "<control><alt>period", insert_char_cb, 69, "<Item>"},
< 	{N_("/Tags/Special/Math-Science/Superscript _1 ¹"), NULL, insert_char_cb, 70, "<Item>"},
< 	{N_("/Tags/Special/Math-Science/Superscript _2 ²"), NULL, insert_char_cb, 71, "<Item>"},
< 	{N_("/Tags/Special/Math-Science/Superscript _3 ³"), NULL, insert_char_cb, 72, "<Item>"},
< 	{N_("/Tags/Special/Math-Science/One _quarter ¼"), NULL, insert_char_cb, 73, "<Item>"},
< 	{N_("/Tags/Special/Math-Science/One _half ½"), NULL, insert_char_cb, 74, "<Item>"},
< 	{N_("/Tags/Special/Math-Science/_Three quarters ¾"), NULL, insert_char_cb, 75, "<Item>"},
< 	{N_("/Tags/Special/Math-Science/Deg_ree sign °"), NULL, insert_char_cb, 76, "<Item>"},
< 	{N_("/Tags/Special/_Non Latin"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Special/Non Latin/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Special/Non Latin/_ETH (Icelandic) Ð"), NULL, insert_char_cb, 77, "<Item>"},
< 	{N_("/Tags/Special/Non Latin/_THORN (Icelandic) Þ"), NULL, insert_char_cb, 78, "<Item>"},
< 	{N_("/Tags/Special/Non Latin/et_h (Icelandic) ð"), NULL, insert_char_cb, 79, "<Item>"},
< 	{N_("/Tags/Special/Non Latin/th_orn ÿ"), NULL, insert_char_cb, 80, "<Item>"},
< 	{N_("/Tags/Special/Non Latin/Sharp _s ß"), NULL, insert_char_cb, 81, "<Item>"},
< 	{N_("/Tags/Special/Non Latin/_Micro sign µ"), NULL, insert_char_cb, 82, "<Item>"},
< 	{N_("/Tags/Special/_Other"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Special/Other/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Special/Other/_Non-breaking space"), NULL, insert_char_cb, 83, "<Item>"},
< 	{N_("/Tags/Special/Other/_Section sign §"), NULL, insert_char_cb, 84, "<Item>"},
< 	{N_("/Tags/Special/Other/_Copyright sign ©"), NULL, insert_char_cb, 85, "<Item>"},
< 	{N_("/Tags/Special/Other/_Left angle quotes «"), NULL, insert_char_cb, 86, "<Item>"},
< 	{N_("/Tags/Special/Other/_Right angle quotes »"), NULL, insert_char_cb, 87, "<Item>"},
< 	{N_("/Tags/Special/Other/Registered _trademark ®"), NULL, insert_char_cb, 88, "<Item>"},
< 	{N_("/Tags/Special/Other/Inverted _exclamation ¡"), NULL, insert_char_cb, 89, "<Item>"},
< 	{N_("/Tags/Special/Other/Inverted _question mark ¿"), NULL, insert_char_cb, 90, "<Item>"},
< 	{N_("/Tags/Special/Other/_Feminine ordinal ª"), NULL, insert_char_cb, 91, "<Item>"},
< 	{N_("/Tags/Special/Other/_Masculine ordinal º"), NULL, insert_char_cb, 92, "<Item>"},
< 	{N_("/Tags/Special/Other/_Pilcrow (paragraph sign) ¶"), NULL, insert_char_cb, 93, "<Item>"},
< 	{N_("/Tags/Special/Other/_Broken bar ¦"), NULL, insert_char_cb, 94, "<Item>"},
< 	{N_("/Tags/Special/Other/Soft _hypen -"), NULL, insert_char_cb, 95, "<Item>"},
< 	{N_("/Tags/Special/Other/Spa_cing macron ¯"), NULL, insert_char_cb, 96, "<Item>"},
< 	{N_("/Tags/Special/Other/Middle _dot ·"), NULL, insert_char_cb, 97, "<Item>"},
< 	{N_("/Tags/_Format by layout"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Format by layout/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Format by layout/_Bold"), "<control><alt>b", general_html_menu_cb, 1, "<StockItem>", GTK_STOCK_BOLD},
< 	{N_("/Tags/Format by layout/_Italic"), "<control><alt>i", general_html_menu_cb, 2, "<StockItem>", GTK_STOCK_ITALIC},
< 	{N_("/Tags/Format by layout/_Underline"), "<control><alt>u", general_html_menu_cb, 3, "<StockItem>", GTK_STOCK_UNDERLINE},
< 	{N_("/Tags/Format by layout/_Strikeout"), "<control><alt>s", general_html_menu_cb, 4, "<StockItem>", GTK_STOCK_STRIKETHROUGH},
< 	{N_("/Tags/Format by layout/Sm_all"), NULL, general_html_menu_cb, 56, "<Item>"},
< 	{N_("/Tags/Format by layout/Bi_g"), NULL, general_html_menu_cb, 57, "<Item>"},
< 	{N_("/Tags/F_ormat by context"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Format by context/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Format by context/_Strong"), "<control><alt>g", general_html_menu_cb, 16, "<ImageItem>",pixmap_bold},
< 	{N_("/Tags/Format by context/_Emphasis"), "<control><alt>e", general_html_menu_cb, 17, "<ImageItem>",pixmap_italic},
< 	{N_("/Tags/Format by context/_Define"), NULL, general_html_menu_cb, 48, "<ImageItem>",pixmap_dfn},
< 	{N_("/Tags/Format by context/_Code"), NULL, general_html_menu_cb, 49, "<ImageItem>",pixmap_code},
< 	{N_("/Tags/Format by context/Sa_mple"), NULL, general_html_menu_cb, 50, "<ImageItem>",pixmap_samp},
< 	{N_("/Tags/Format by context/_Keyboard"), NULL, general_html_menu_cb, 51, "<ImageItem>",pixmap_kbd},
< 	{N_("/Tags/Format by context/_Variable"), NULL, general_html_menu_cb, 52, "<ImageItem>",pixmap_var},
< 	{N_("/Tags/Format by context/Ci_tation"), NULL, general_html_menu_cb, 53, "<ImageItem>",pixmap_cite},
< 	{N_("/Tags/Format by context/_Abbreviation"), NULL, general_html_menu_cb, 54, "<ImageItem>",pixmap_abbr},
< 	{N_("/Tags/Format by context/Ac_ronym"), NULL, general_html_menu_cb, 55, "<ImageItem>",pixmap_acronym},
< 	{N_("/Tags/Format _general"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Format general/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Format general/_Paragraph"), "<control><alt>p", general_html_menu_cb, 5, "<ImageItem>",pixmap_paragraph},
< 	{N_("/Tags/Format general/_Break"),  "<control><alt>k", general_html_menu_cb, 6, "<ImageItem>",pixmap_brbreak},
< 	{N_("/Tags/Format general/Break clear _all"), NULL, general_html_menu_cb, 41, "<ImageItem>",pixmap_breakall},
< 	{N_("/Tags/Format general/_Non-Breaking Space"), "<control><alt>n", general_html_menu_cb, 7, "<ImageItem>",pixmap_nbsp},
< 	{"/Tags/Format general/sep1", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Tags/Format general/Font Si_ze +1"), "<control><alt>equal", general_html_menu_cb, 11, "<ImageItem>",pixmap_fontp1},
< 	{N_("/Tags/Format general/Font _Size -1"), "<control><alt>minus", general_html_menu_cb, 12, "<ImageItem>",pixmap_fontm1},
< 	{"/Tags/Format general/sep2", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Tags/Format general/Preformatted _Text"), "<Control><Alt>f", general_html_menu_cb, 13, "<ImageItem>",pixmap_fontpre},
< 	{N_("/Tags/Format general/Su_bscript"), NULL, general_html_menu_cb, 14, "<ImageItem>",pixmap_fontsub},
< 	{N_("/Tags/Format general/Su_perscript"), NULL, general_html_menu_cb, 15, "<ImageItem>",pixmap_fontsuper},
< 	{"/Tags/Format general/sep3", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Tags/Format general/_Center"), NULL, general_html_menu_cb, 8, "<ImageItem>",pixmap_center},
< 	{N_("/Tags/Format general/Align _right"), "<control><Alt>r", general_html_menu_cb, 9, "<ImageItem>",pixmap_right},
< 	{N_("/Tags/_Table"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Table/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Table/_Table"), "<control><alt>t", general_html_menu_cb, 24, "<ImageItem>", pixmap_table2},
< 	{N_("/Tags/Table/Table _Row"), NULL, general_html_menu_cb, 25, "<ImageItem>", pixmap_table_tr2},
< 	{N_("/Tags/Table/Table _Header"), NULL, general_html_menu_cb, 26, "<ImageItem>", pixmap_table_th2},
< 	{N_("/Tags/Table/Table _Data"), NULL, general_html_menu_cb, 27, "<ImageItem>", pixmap_table_td2},
< 	{N_("/Tags/Table/Table _Caption"), NULL, general_html_menu_cb, 28, "<ImageItem>", pixmap_table_capt},
< 	{N_("/Tags/_List"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/List/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/List/Unordered _List"), "<control><alt>L", general_html_menu_cb, 33, "<ImageItem>", pixmap_list_ul},
< 	{N_("/Tags/List/_Ordered List"), "<control><alt>O", general_html_menu_cb, 34, "<ImageItem>", pixmap_list_ol},
< 	{N_("/Tags/List/List Ite_m"), "<control><alt>M", general_html_menu_cb, 35, "<ImageItem>", pixmap_list_li},
< 	{N_("/Tags/List/De_finition List"), NULL, general_html_menu_cb, 36, "<ImageItem>", pixmap_list_dl},
< 	{N_("/Tags/List/Definition _Term"), NULL, general_html_menu_cb, 37, "<ImageItem>", pixmap_list_dt},
< 	{N_("/Tags/List/_Definition"), NULL, general_html_menu_cb, 38, "<ImageItem>", pixmap_list_dd},
< 	{N_("/Tags/List/Men_u"), NULL, general_html_menu_cb, 39, "<Item>"},
< 	{N_("/Tags/Fo_rm"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Form/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Form/_Form"), NULL, general_html_menu_cb, 67, "<ImageItem>", pixmap_form},
< 	{N_("/Tags/Form/_Button"), NULL, general_html_menu_cb, 58, "<Item>"},
< 	{N_("/Tags/Form/_Input"), NULL, general_html_menu_cb, 65, "<Item>"},
< 	{N_("/Tags/Form/_Textarea"), NULL, general_html_menu_cb, 66, "<Item>"},
< /*	{N_("/Tags/Form/"), NULL, general_html_menu_cb, , "<Item>"},*/
< 	{N_("/Tags/_Misc"), NULL, NULL, 0, "<Branch>"},
< 	{"/Tags/Misc/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Tags/Misc/Insert Generator _META-Tag"), NULL, general_html_menu_cb, 47, "<Item>"},
< 	{N_("/Tags/Misc/_Span"), NULL, general_html_menu_cb, 60, "<Item>"},
< 	{N_("/Tags/Misc/_Div"), NULL, general_html_menu_cb, 62, "<Item>"},
< 	{N_("/Tags/Misc/_Link"), NULL, general_html_menu_cb, 61, "<Item>"},
< 	{N_("/Tags/Misc/S_cript"), NULL, general_html_menu_cb, 59, "<Item>"},
< 	{N_("/Tags/Misc/_Anchor"), NULL, general_html_menu_cb, 63, "<ImageItem>", pixmap_anchor},
< 	{N_("/Tags/Misc/_Image"), NULL, general_html_menu_cb, 64, "<ImageItem>", pixmap_image},
< /*	{N_("/Tags/Misc/"), NULL, general_html_menu_cb, , "<Item>"},*/
< 	{N_("/Tags/_Comment"), "<control><alt>C", general_html_menu_cb, 10, "<ImageItem>", pixmap_comment},
< 	{N_("/Dial_ogs"), NULL, NULL, 0, "<Branch>"},
< 	{"/Dialogs/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Dialogs/_General"), NULL, NULL, 0, "<Branch>"},
< 	{"/Dialogs/General/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Dialogs/General/_Quickstart..."), "<shift><alt>q", menu_html_dialogs_lcb, 32, "<ImageItem>", pixmap_quick_start},
< /*	{N_("/Dialogs/General/DTD"), NULL, dtd_cb, 0, NULL},
< 	{N_("/Dialogs/General/Head"), NULL, head_cb, 0, NULL}, */
< 	{N_("/Dialogs/General/_Link Header..."), NULL, menu_html_dialogs_lcb, 35, "<Item>"},
< 	{N_("/Dialogs/General/_Body..."), "<shift><alt>B", menu_html_dialogs_lcb, 1, "<ImageItem>", pixmap_body},
< 	{N_("/Dialogs/General/_Anchor..."), "<shift><alt>a", menu_html_dialogs_lcb, 2, "<ImageItem>", pixmap_anchor},
< 	{N_("/Dialogs/General/_Email..."), "<shift><alt>e", menu_html_dialogs_lcb, 3, "<Item>"},
< 	{N_("/Dialogs/General/_Rule..."), "<shift><alt>r", menu_html_dialogs_lcb, 4, "<ImageItem>", pixmap_hrule},
< 	{N_("/Dialogs/General/_Font..."), "<shift><alt>f", menu_html_dialogs_lcb, 5, "<Item>"},
< 	{N_("/Dialogs/General/Basef_ont..."), NULL, menu_html_dialogs_lcb, 6, "<Item>"},
< 	{N_("/Dialogs/General/Quick_list..."), "<shift><alt>L", menu_html_dialogs_lcb, 7, "<ImageItem>", pixmap_list},
< 	{N_("/Dialogs/General/_Meta..."), "<shift><alt>m", menu_html_dialogs_lcb, 8, "<Item>"},
< 	{N_("/Dialogs/General/Embe_d..."), NULL, menu_html_dialogs_lcb, 9, "<Item>"},
< 	{N_("/Dialogs/General/Select _Color..."), NULL, menu_html_dialogs_lcb, 38, "<Item>"},
< 	{N_("/Dialogs/General/Insert _Time..."), NULL, menu_html_dialogs_lcb, 34, "<Item>"},
< 	{N_("/Dialogs/General/Insert _Image..."), "<shift><alt>I", menu_html_dialogs_lcb, 10, "<ImageItem>", pixmap_image},
< 	{N_("/Dialogs/General/Insert T_humbnail..."), "<shift><alt>N", menu_html_dialogs_lcb, 11, "<ImageItem>", pixmap_thumbnail},
< 	{N_("/Dialogs/_Table"), NULL, NULL, 0, "<Branch>"},
< 	{"/Dialogs/Table/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Dialogs/Table/Table _Wizard..."), NULL, menu_html_dialogs_lcb, 12, "<ImageItem>", pixmap_tablewhiz},
< 	{N_("/Dialogs/Table/_Table..."), "<shift><alt>T", menu_html_dialogs_lcb, 13, "<ImageItem>", pixmap_table},
< 	{N_("/Dialogs/Table/Table _Row..."), NULL, menu_html_dialogs_lcb, 14, "<ImageItem>", pixmap_table_tr},
< 	{N_("/Dialogs/Table/Table _Head..."), NULL, menu_html_dialogs_lcb, 15, "<ImageItem>", pixmap_table_th},
< 	{N_("/Dialogs/Table/Table _Data..."), NULL, menu_html_dialogs_lcb, 16, "<ImageItem>", pixmap_table_td},
< 	{N_("/Dialogs/_CSS"), NULL, NULL, 0, "<Branch>"},
< 	{"/Dialogs/CSS/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Dialogs/CSS/_Create Style..."), "<shift><alt>S", menu_html_dialogs_lcb, 37, "<ImageItem>",pixmap_cssnewstyle},
< 	{N_("/Dialogs/CSS/S_pan..."), NULL, menu_html_dialogs_lcb, 17, "<ImageItem>",pixmap_cssspan},
< 	{N_("/Dialogs/CSS/_Div..."), "<shift><alt>D", menu_html_dialogs_lcb, 18, "<ImageItem>",pixmap_cssdiv},
< 	{N_("/Dialogs/CSS/_Style..."), NULL, general_html_menu_cb, 42, "<ImageItem>",pixmap_cssstyle},
< 	{N_("/Dialogs/CSS/_Link to Stylesheet..."), NULL, menu_html_dialogs_lcb, 36, "<Item>"},
< 	{N_("/Dialogs/_Frame"), NULL, NULL, 0, "<Branch>"},
< 	{"/Dialogs/Frame/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Dialogs/Frame/Frame _Wizard..."), NULL, menu_html_dialogs_lcb, 19, "<ImageItem>", pixmap_framewhiz},
< 	{N_("/Dialogs/Frame/Frame_set..."), NULL, menu_html_dialogs_lcb, 20, "<ImageItem>", pixmap_frameset},
< 	{N_("/Dialogs/Frame/_Frame..."), NULL, menu_html_dialogs_lcb, 21, "<ImageItem>", pixmap_frame},
< 	{N_("/Dialogs/F_orm"), NULL, NULL, 0, "<Branch>"},
< 	{"/Dialogs/Form/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Dialogs/Form/F_orm..."), NULL, menu_html_dialogs_lcb, 22, "<ImageItem>", pixmap_form},
< 	{N_("/Dialogs/Form/_Input..."), NULL, menu_html_dialogs_lcb, 33, "<Item>"},
< 	{N_("/Dialogs/Form/Input Buttons..."), NULL, menu_html_dialogs_lcb, 23, "<ImageItem>", pixmap_form_submit},
< 	{N_("/Dialogs/Form/Input Text..."), NULL, menu_html_dialogs_lcb, 24, "<ImageItem>", pixmap_form_text},
< 	{N_("/Dialogs/Form/Text_area..."), NULL, menu_html_dialogs_lcb, 26, "<ImageItem>", pixmap_form_textarea},
< 	{N_("/Dialogs/Form/_Select..."), NULL, menu_html_dialogs_lcb, 29, "<ImageItem>", pixmap_form_select},
< 	{N_("/Dialogs/Form/O_ption..."), NULL, menu_html_dialogs_lcb, 30, "<ImageItem>", pixmap_form_option},
< 	{N_("/Dialogs/Form/Option _Group..."), NULL, menu_html_dialogs_lcb, 31, "<ImageItem>",pixmap_form_optiongroup },
< 	{N_("/Dialogs/Form/_Button..."), NULL, menu_html_dialogs_lcb, 25, "<Item>"},
< /*	{N_("/Dialogs/Javascript"), NULL, NULL, 0, "<Branch>"},
< 	{"/Dialogs/Javascript/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Dialogs/Javascript/Mouseover Script"), NULL, mouseover_script_cb, 0, NULL},
< 	{N_("/Dialogs/Javascript/Netscape 4 Resize Bugfix Script"), NULL, ns47_bugfix_script_cb, 0, NULL},
< 	{N_("/Dialogs/Javascript/Image Preload Script"), NULL, imagepreload_script_cb, 0, NULL},
< 	{N_("/Dialogs/_WML"), NULL, NULL, 0, "<Branch>"},
< 	{"/Dialogs/WML/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Dialogs/WML/Standard Document"), NULL, general_wml_cb, 6, NULL},
< 	{N_("/Dialogs/WML/Card..."), NULL, carddialog_cb, 0, NULL},
< 	{N_("/Dialogs/WML/Postfield..."), NULL, postfielddialog_cb, 0, NULL},
< 	{N_("/Dialogs/WML/Go..."), NULL, godialog_cb, 0, NULL},
< 	{N_("/Dialogs/WML/Do..."), NULL, dodialog_cb, 0, NULL},
< 	{N_("/Dialogs/WML/Anchor..."), NULL, anchordialog_cb, 0, NULL},
< 	{N_("/Dialogs/WML/Access..."), NULL, accessdialog_cb, 0, NULL},
< 	{"/Dialogs/WML/sep11", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Dialogs/WML/Paragraph"), NULL, general_wml_cb, 1, NULL},
< 	{N_("/Dialogs/WML/Line Break"), NULL, general_wml_cb, 2, NULL},
< 	{N_("/Dialogs/WML/Italic"), NULL, general_wml_cb, 3, NULL},
< 	{N_("/Dialogs/WML/Non-Breaking Space"), NULL, general_wml_cb, 4, NULL},
< 	{N_("/Dialogs/WML/Bold"), NULL, general_wml_cb, 5, NULL},
< 	{"/Dialogs/WML/sep12", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Dialogs/WML/Prev"), NULL, general_wml_cb, 7, NULL},
< 	{N_("/Dialogs/WML/Refresh"), NULL, general_wml_cb, 8, NULL},
< 	{N_("/Dialogs/WML/Noop"), NULL, general_wml_cb, 9, NULL},
< 	{"/Dialogs/WML/sep13", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Dialogs/WML/Set Variable..."), NULL, vardialog_cb, 0, NULL},*/
< 	{"/Dialogs/sep1", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Dialogs/_Edit tag under cursor..."), "F3", menu_html_dialogs_lcb, 39, "<ImageItem>", pixmap_edit_tag},
< 	{N_("/_Document"), NULL, NULL, 0, "<Branch>"},
< 	{"/Document/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Document/_Increase Tabsize"), NULL, gui_change_tabsize, 1, "<Item>"},
< 	{N_("/Document/_Decrease Tabsize"), NULL, gui_change_tabsize, 0, "<Item>"},
< 	{N_("/Document/_Auto Indent"), NULL, toggle_doc_property, 4, "<ToggleItem>"},
< 	{"/Document/sep1", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Document/Auto Close H_TML tags"), "<control>T", toggle_doc_property, 3, "<ToggleItem>"},
< 	{N_("/Document/_Wrap"), NULL, toggle_doc_property, 1, "<ToggleItem>"},
< 	{N_("/Document/_Line Numbers"), NULL, toggle_doc_property, 2, "<ToggleItem>"},
< 	{"/Document/sep2", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Document/_Highlight Syntax"), NULL, doc_toggle_highlighting_cb, 1, "<ToggleItem>"},
< 	{N_("/Document/_Update Highlighting"), "F5", doc_update_highlighting, 0, "<Item>"},
< 	{"/Document/sep3", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Document/Document Ty_pe"), NULL, NULL, 0, "<Branch>"},
< 	{"/Document/Document Type/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Document/Character _Encoding"), NULL, NULL, 0, "<Branch>"},
< 	{"/Document/Character Encoding/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{"/Document/sep4", NULL, NULL, 0, "<Separator>"},
< #ifdef HAVE_LIBASPELL
< 	{N_("/Document/Check _Spelling..."), NULL, spell_check_menu_cb, 0, "<StockItem>", GTK_STOCK_SPELL_CHECK},
< #endif /* HAVE_LIBASPELL */
< 	{N_("/Document/_Floating window"), NULL, file_floatingview_menu_cb, 1, "<Item>"},			
< 	{N_("/Document/Word _Count"), NULL, word_count_cb, 1, "<Item>"},
< 	{N_("/_Go"), NULL, NULL, 0, "<Branch>"},
< 	{"/Go/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Go/_Previous document"), NULL, gui_notebook_switch, 1, "<StockItem>", GTK_STOCK_GO_BACK},
< 	{N_("/Go/_Next document"), NULL, gui_notebook_switch, 2, "<StockItem>", GTK_STOCK_GO_FORWARD},
< 	{"/Go/sep1", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Go/_First document"), NULL, gui_notebook_switch, 3, "<StockItem>", GTK_STOCK_GOTO_FIRST},
< 	{N_("/Go/L_ast document"), NULL, gui_notebook_switch, 4, "<StockItem>", GTK_STOCK_GOTO_LAST},
< 	{"/Go/sep2", NULL, NULL, 0, "<Separator>"},	
< 	{N_("/Go/Goto _Line"), "<control>l", go_to_line_win_cb, 1, "<StockItem>", GTK_STOCK_JUMP_TO},
< 	{N_("/Go/Goto _Selection"), NULL, go_to_line_from_selection_cb, 1, "<Item>"},
< 	{N_("/_Project"), NULL, NULL, 0, "<Branch>"},
< 	{"/Project/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/Project/_New Project"), NULL, project_menu_cb, 6, "<Item>"},
< 	{N_("/Project/_Open Project..."), NULL, project_menu_cb, 1, "<Item>"},
< 	{N_("/Project/Open _recent"), NULL, NULL, 0, "<Branch>"},		
< 	{"/Project/Open recent/tearoff1", NULL, NULL, 0, "<Tearoff>"},	
< 	{"/Project/sep1", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Project/_Save"), NULL, project_menu_cb, 2, "<Item>"},
< 	{N_("/Project/Save _as..."), NULL, project_menu_cb, 3, "<Item>"},
< 	{N_("/Project/Save & _close"), NULL, project_menu_cb, 4, "<Item>"},
< 	{"/Project/sep2", NULL, NULL, 0, "<Separator>"},
< 	{N_("/Project/E_dit Project Options..."), NULL, project_menu_cb, 5, "<StockItem>", GTK_STOCK_PREFERENCES},
< 	{N_("/E_xternal"), NULL, NULL, 0, "<Branch>"},
< 	{"/External/tearoff1", NULL, NULL, 0, "<Tearoff>"}, 
< /*	{N_("/External/_Commands"), NULL, NULL, 0, "<Branch>"},
< 	{"/External/Commands/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{N_("/External/_Outputbox"), NULL, NULL, 0, "<Branch>"},
< 	{"/External/Outputbox/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 	{"/External/sep1", NULL, NULL, 0, "<Separator>"},*/
< 	{N_("/_Help"), NULL, NULL, 0, "<Branch>"},
< 	{N_("/Help/_About..."), NULL, about_dialog_create, 0, "<Item>"},	
< };
< 
< #ifdef ENABLE_NLS
< gchar *menu_translate(const gchar * path, gpointer data) {
< 	gchar *retval;
< /*	static gchar *menupath = NULL;
< 	if (menupath) g_free(menupath);
< 	menupath = g_strdup(path);
< 	if ((strstr(path, "/tearoff1") != NULL) 
< 			|| (strstr(path, "/---") != NULL) 
< 			|| (strstr(path, "/sep1") != NULL)) {
< 		DEBUG_MSG("menu_translate, nogettext returning %s for %s\n", menupath, path);
< 		return menupath;
< 	}*/
< 	retval = gettext(path);
< 	return retval;
< }
< #endif       
< 
< /************************************************/
< /* generic functions for dynamic created menu's */
< /************************************************/
< 
< typedef struct {
< 	Tbfwin *bfwin;
< 	GtkWidget *menuitem;
< 	gpointer data;
< 	gulong signal_id;
< } Tbfw_dynmenu;
< #define BFW_DYNMENU(var) ((Tbfw_dynmenu *)(var))
< 
< static Tbfw_dynmenu *find_bfw_dynmenu_by_data_in_list(GList *thelist, gpointer data) {
< 	GList *tmplist = g_list_first(thelist);
< 	while (tmplist) {
< 		if (BFW_DYNMENU(tmplist->data)->data == data) return BFW_DYNMENU(tmplist->data);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return NULL;
< }
< 
< /*
< NOT IN USE
< static Tbfw_dynmenu *find_bfw_dynmenu_by_label_in_list(GList *itemlist, gchar *label) {
< 	GList *tmplist;
< 
< 	tmplist = g_list_first(itemlist);
< 	while (tmplist) {
< 		if(!strcmp(GTK_LABEL(GTK_BIN(BFW_DYNMENU(tmplist->data)->menuitem)->child)->label, label)) {
< 			return BFW_DYNMENU(tmplist->data);
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return NULL;
< }
< */
< 
< static GtkWidget *remove_menuitem_in_list_by_label(const gchar *labelstring, GList **menuitemlist) {
< 	GList *tmplist;
< 	gpointer tmp;
< 
< 	tmplist = g_list_first(*menuitemlist);
< 	while (tmplist) {
< 		DEBUG_MSG("remove_recent_entry, tmplist=%p, data=%p\n", tmplist, tmplist->data);
< 		DEBUG_MSG("remove_recent_entry, tmplist->data=%s\n",GTK_LABEL(GTK_BIN(tmplist->data)->child)->label);
< 		if(!strcmp(GTK_LABEL(GTK_BIN(tmplist->data)->child)->label, labelstring)) {
< 			tmp = tmplist->data;
< 			*menuitemlist = g_list_remove(*menuitemlist, tmplist->data);
< 			DEBUG_MSG("remove_recent_entry, returning %p\n", tmp);
< 			return tmp;
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return NULL;
< }
< 
< /* the result of this function can be added to the menuitem-list */
< static GtkWidget *create_dynamic_menuitem(Tbfwin *bfwin, gchar *menubasepath, const gchar *label, GCallback callback, gpointer data, gint menu_insert_offset) {
< 	GtkWidget *tmp, *menu;
< 	GtkItemFactory *factory;
< 
< 	/* add it to bfwin->menubar */
< 	factory = gtk_item_factory_from_widget(bfwin->menubar);
< 	menu = gtk_item_factory_get_widget(factory, menubasepath);
< 	DEBUG_MSG("create_dynamic_menuitem, menubar=%p, menu=%p basepath=%s, label=%s\n", bfwin->menubar, menu, menubasepath,label);
< 	if (menu != NULL) {
< 		tmp = gtk_menu_item_new_with_label(label);
< 		g_signal_connect(G_OBJECT(tmp), "activate",callback, data);
< 
< 		gtk_widget_show(tmp);
< 		if (menu_insert_offset == -1) {
< 			gtk_menu_shell_append(GTK_MENU_SHELL(menu),tmp);
< 		} else {
< 			gtk_menu_shell_insert(GTK_MENU_SHELL(menu),tmp,menu_insert_offset);
< 		}
< 		return tmp;
< 	} else {
< 		DEBUG_MSG("create_dynamic_menuitem, NO MENU FOR BASEPATH %s\n", menubasepath);
< 		return NULL;
< 	}
< }
< 
< static void create_parent_and_tearoff(gchar *menupath, GtkItemFactory *ifactory) {
< 	char *basepath;
< 	GtkWidget *widg=NULL;
< 	GtkItemFactoryEntry entry;
< 
< 	basepath = g_strndup(menupath, (strlen(menupath) - strlen(strrchr(menupath, '/'))));
< 	DEBUG_MSG("create_parent_and_tearoff, basepath=%s for menupath=%s\n", basepath, menupath);
< 	widg = gtk_item_factory_get_widget(ifactory, basepath);
< 	if (!widg) {
< 		DEBUG_MSG("create_parent_and_tearoff, no widget found for %s, will create it\n", basepath);
< 		create_parent_and_tearoff(basepath, ifactory);
< 		entry.path = g_strconcat(basepath, "/tearoff1", NULL);
< 		entry.accelerator = NULL;
< 		entry.callback = NULL;
< 		entry.callback_action = 0;
< 		entry.item_type = "<Tearoff>";
< 		gtk_item_factory_create_item(ifactory, &entry, NULL, 2);
< 		g_free(entry.path);
< 	}
< 	g_free(basepath);
< }	
< 
< static void menu_current_document_type_change(GtkMenuItem *menuitem,Tbfw_dynmenu *bdm) {
< 	DEBUG_MSG("menu_current_document_type_change, started for hlset %p\n", bdm->data);
< 	if (GTK_CHECK_MENU_ITEM(menuitem)->active) {
< 		if (doc_set_filetype(bdm->bfwin->current_document, bdm->data)) {
< 			doc_highlight_full(bdm->bfwin->current_document);
< 		} else {
< 			menu_current_document_set_toggle_wo_activate(bdm->bfwin,bdm->bfwin->current_document->hl, NULL);
< 		}
< 	}
< 	doc_set_statusbar_editmode_encoding(bdm->bfwin->current_document);
< 	DEBUG_MSG("menu_current_document_type_change, finished\n");
< }
< 
< void filetype_menus_empty() {
< 	GList *tmplist = g_list_first(main_v->bfwinlist);
< 	while (tmplist) {
< 		Tbfwin *bfwin = BFWIN(tmplist->data);
< 		GList *tmplist2 = g_list_first(bfwin->menu_filetypes);
< 		while (tmplist2) {
< 			Tbfw_dynmenu *bdm = BFW_DYNMENU(tmplist2->data);
< 			g_signal_handler_disconnect(bdm->menuitem,bdm->signal_id);
< 			gtk_widget_destroy(bdm->menuitem);
< 			g_free(bdm);
< 			tmplist2 = g_list_next(tmplist2);
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< void filetype_menu_rebuild(Tbfwin *bfwin,GtkItemFactory *item_factory) {
< 	GSList *group=NULL;
< 	GtkWidget *parent_menu;
< 	GList *tmplist = g_list_last(main_v->filetypelist);
< 	if (!item_factory) {
< 		item_factory = gtk_item_factory_from_widget(bfwin->menubar);
< 	}
< 	DEBUG_MSG("filetype_menu_rebuild, adding filetypes in menu\n");
< 	bfwin->menu_filetypes = NULL;
< 	parent_menu = gtk_item_factory_get_widget(item_factory, N_("/Document/Document Type"));
< 	while (tmplist) {
< 		Tfiletype *filetype = (Tfiletype *)tmplist->data;
< 		if (filetype->editable) {
< 			Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
< 			bdm->data = filetype;
< 			bdm->bfwin = bfwin;
< 			bdm->menuitem = gtk_radio_menu_item_new_with_label(group, filetype->type);
< 			bdm->signal_id = g_signal_connect(G_OBJECT(bdm->menuitem), "activate",G_CALLBACK(menu_current_document_type_change), (gpointer) bdm);
< 			gtk_widget_show(bdm->menuitem);
< 			gtk_menu_insert(GTK_MENU(parent_menu), bdm->menuitem, 1);
< 			group = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(bdm->menuitem));
< 			bfwin->menu_filetypes = g_list_append(bfwin->menu_filetypes, bdm);
< 		}
< 		tmplist = g_list_previous(tmplist);
< 	}
< }
< 
< /* 
<  * menu factory crap, thanks to the gtk tutorial for this
<  * both the 1.0 and the 1.2 code is directly from the tutorial
<  */
< void menu_create_main(Tbfwin *bfwin, GtkWidget *vbox) {
< 	GtkItemFactory *item_factory;
< 	GtkAccelGroup *accel_group;
< 	gint nmenu_items = sizeof(menu_items) / sizeof(menu_items[0]);
< 	accel_group = gtk_accel_group_new();
< 	item_factory = gtk_item_factory_new(GTK_TYPE_MENU_BAR, "<bluefishmain>", accel_group);
< #ifdef ENABLE_NLS
< 	gtk_item_factory_set_translate_func(item_factory, menu_translate, "<bluefishmain>", NULL);
< #endif
< 	gtk_item_factory_create_items(item_factory, nmenu_items, menu_items, bfwin);
< 	gtk_window_add_accel_group(GTK_WINDOW(bfwin->main_window), accel_group);
< 	bfwin->menubar = gtk_item_factory_get_widget(item_factory, "<bluefishmain>");
< 	gtk_box_pack_start(GTK_BOX(vbox), bfwin->menubar, FALSE, TRUE, 0);
< 	gtk_accel_map_add_entry("<bluefishmain>/Edit/Shift Right", GDK_period, GDK_CONTROL_MASK);
< 	gtk_accel_map_add_entry("<bluefishmain>/Edit/Shift Left", GDK_comma, GDK_CONTROL_MASK);
< 	gtk_accel_map_add_entry("<bluefishmain>/Go/Previous document", GDK_Page_Up, GDK_CONTROL_MASK);
< 	gtk_accel_map_add_entry("<bluefishmain>/Go/Next document", GDK_Page_Down, GDK_CONTROL_MASK);
< 	gtk_accel_map_add_entry("<bluefishmain>/Go/First document", GDK_Page_Up, GDK_SHIFT_MASK | GDK_CONTROL_MASK);
< 	gtk_accel_map_add_entry("<bluefishmain>/Go/Last document", GDK_Page_Down, GDK_SHIFT_MASK | GDK_CONTROL_MASK);	
< 	gtk_widget_show(bfwin->menubar);
< 
<     setup_toggle_item(item_factory, "/View/View Main Toolbar", bfwin->session->view_main_toolbar);
<     setup_toggle_item(item_factory, "/View/View HTML Toolbar", bfwin->session->view_html_toolbar);
<     setup_toggle_item(item_factory, "/View/View Custom Menu", bfwin->session->view_custom_menu);
<     setup_toggle_item(item_factory, "/View/View Sidebar", bfwin->session->view_left_panel);	
< 	setup_toggle_item(item_factory, "/Document/Auto Indent", main_v->props.autoindent);
< 	set_project_menu_widgets(bfwin, FALSE);
< 	filetype_menu_rebuild(bfwin, item_factory);
< }
< 
< 
< /*************************************************************/
< /*               Output Box handling                         */
< /*************************************************************/
< static GtkWidget *dynamic_menu_append_spacing(Tbfwin *bfwin, gchar *basepath) {
< 	GtkItemFactory *factory;
< 	GtkWidget *menu, *menuitem;
< 	factory = gtk_item_factory_from_widget(bfwin->menubar);
< 	menu = gtk_item_factory_get_widget(factory, basepath);
< 	menuitem = gtk_menu_item_new();
< 	gtk_widget_show(menuitem);
< 	gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);
< 	return menuitem;
< }
< 
< static void menu_outputbox_lcb(GtkMenuItem *menuitem,Tbfw_dynmenu *bdm) {
< 	gchar **arr = (gchar **)bdm->data;
< 	outputbox(bdm->bfwin,arr[1], atoi(arr[2]), atoi(arr[3]), atoi(arr[4]), arr[5], (arr[6][0]=='1'));
< }
< 
< /*******************************************************************/
< /*               Open Recent menu handling                         */
< /*******************************************************************/
< /* the only required header */
< static GtkWidget *create_recent_entry(Tbfwin *bfwin, const gchar *filename, gboolean is_project, gboolean check_for_duplicates);
< /*******************************************************************/
< 
< static GtkWidget *remove_recent_entry(Tbfwin *bfwin, const gchar *filename, gboolean is_project) {
< 	GList *tmplist;
< 	GList **worklist;
< 	gpointer tmp;
< #ifdef WIN32
< 	if (filename[0] == '/') { filename ++;}
< #endif /* WIN32 */
< 	worklist = (is_project) ? &bfwin->menu_recent_projects : &bfwin->menu_recent_files;
< 
< 	if(strcmp(filename, "last") ==0) {
< 		tmplist = g_list_first(*worklist);
< 		if (tmplist) {
< 			tmp = tmplist->data;
< 			DEBUG_MSG("remove_recent_entry, remove last entry\n");
< 			*worklist = g_list_remove(*worklist, tmplist->data);
< 			return tmp;
< 		} else {
< 			DEBUG_MSG("remove_recent_entry, worklist contained no items, returning NULL\n");
< 			return NULL;
< 		}
< 	}	else {
< 		return remove_menuitem_in_list_by_label(filename, worklist);
< 	}
< }
< 
< static void open_recent_project_cb(GtkWidget *widget, Tbfwin *bfwin) {
< 	gchar *filename = GTK_LABEL(GTK_BIN(widget)->child)->label;
< 	DEBUG_MSG("open_recent_project_cb, started, filename is %s\n", filename);
< 	project_open_from_file(bfwin, filename);
< 	add_to_recent_list(bfwin,filename, 0, TRUE);
< }
< 
< /* open_recent_file
<  * This function should be called when a menu from the Open Recent list
<  * has been selected. */
< static void open_recent_file_cb(GtkWidget *widget, Tbfwin *bfwin) {
< 	gboolean success;
< 	gchar *filename = GTK_LABEL(GTK_BIN(widget)->child)->label;
< 	DEBUG_MSG("open_recent_file_cb, started, filename is %s\n", filename);
< 
< 	statusbar_message(bfwin,_("Loading file(s)..."),2000);
< 	flush_queue();
< 	success = (doc_new_with_file(bfwin,filename, FALSE, FALSE) != NULL);
< 	if (!success) {
< 		gchar *message = g_strconcat(_("The filename was:\n"), filename, NULL);
< 		warning_dialog(bfwin->main_window,_("Could not open file\n"), message);
< 		g_free(message);
< 		return;
< 	}
< 	DEBUG_MSG("open_recent_file_cb, document %s opened\n", filename);
< 	add_to_recent_list(bfwin,filename, 0, FALSE);
< }
< 
< /* create_recent_entry
<  * This function builds the gtkitemfactoryentry and inserts it at the
<  * bfwin->menubar. Furthermore, it returns a pointer to it, so that
<  * this pointer can be added in the main_v->recent_files list */
< static GtkWidget *create_recent_entry(Tbfwin *bfwin, const gchar *filename, gboolean is_project, gboolean check_for_duplicates) {
< 	GtkWidget *tmp;
< 
< #ifdef WIN32
< 	if (filename[0] == '/') { filename ++;}
< #endif /* WIN32 */
< 
< 	if (check_for_duplicates) {
< 		tmp = remove_recent_entry(bfwin,filename,is_project);
< 		if (tmp) {
< 			gtk_widget_hide(tmp);
< 			gtk_widget_destroy(tmp);
< 		}
< 	}
< 	if (is_project) {
< 		return  create_dynamic_menuitem(bfwin,N_("/Project/Open recent")
< 			, filename, G_CALLBACK(open_recent_project_cb), bfwin
< 			, 1);
< 	} else {
< 		return  create_dynamic_menuitem(bfwin,N_("/File/Open recent")
< 			, filename, G_CALLBACK(open_recent_file_cb), bfwin
< 			, 1);
< 	}
< }
< 
< GList *recent_menu_from_list(Tbfwin *bfwin, GList *startat, gboolean is_project) {
< 	GList *retlist=NULL, *tmplist=startat;
< 	while (tmplist) {
< 		DEBUG_MSG("recent_menu_init, adding recent project %s\n",(gchar *)tmplist->data);		
< 		retlist = g_list_append(retlist, create_recent_entry(bfwin,tmplist->data,is_project,FALSE));
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return retlist;
< }
< 
< /* void recent_menu_from_file(Tbfwin *bfwin, gchar *file_name, gboolean is_project) {
< 	gchar *filename;
< 	GList *inputlist, *recentfiles=NULL, *tmplist, **worklist;
< 	gint num;
< 	worklist = (is_project) ? &bfwin->menu_recent_projects : &bfwin->menu_recent_files;
< 	/ * empty any existing menu * /
< 	tmplist = g_list_first(*worklist);
< 	while (tmplist) {
< 		gtk_widget_destroy(tmplist->data);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	
< 	filename = g_strconcat(g_get_home_dir(), file_name, NULL);
< 	inputlist = get_stringlist(filename, NULL);
< 	/ * the last entry in inputlist is the most recent file * /
< 	tmplist = g_list_first(inputlist);
< 	while (tmplist) {
< 		recentfiles = add_to_history_stringlist(recentfiles, (gchar *)tmplist->data, TRUE);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	free_stringlist(inputlist);
< 	num = g_list_length(recentfiles) - main_v->props.max_recent_files;
< 	*worklist = recent_menu_from_list(bfwin, g_list_nth(recentfiles, (num > 0)?num:0), is_project);
< 	put_stringlist_limited(filename, recentfiles, main_v->props.max_recent_files);
< 	free_stringlist(recentfiles);
< 	g_free(filename);
< }*/
< 
< /* recent_menu_init()
<  * Gets the list of documents from .bluefish/recentlist and inserts
<  * it at the File-->Open Recent menu. If the file doesn't exist (probably
<  * because this is the first time Bluefish is running) then a menu
<  * item telling that no recent files exist will appear */
< void recent_menu_init(Tbfwin *bfwin) {
< /*	recent_menu_from_file(bfwin, "/.bluefish/recentlist", FALSE);
< 	recent_menu_from_file(bfwin, "/.bluefish/recentprojects", TRUE);*/
< 	recent_menu_from_list(bfwin, bfwin->session->recent_files, FALSE);
< 	recent_menu_from_list(bfwin, main_v->globses.recent_projects, TRUE);
< }
< 
< /* when a project is opened, the recent menu should show the recent files
< from that project */
< void recent_menu_init_project(Tbfwin *bfwin) {
< 	gint num;
< 	GList *tmplist = g_list_first(bfwin->menu_recent_files);
< 	while (tmplist) {
< 		gtk_widget_destroy(tmplist->data);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	num = g_list_length(bfwin->session->recent_files) - main_v->props.max_recent_files;
< 	bfwin->menu_recent_files = recent_menu_from_list(bfwin, g_list_nth(bfwin->session->recent_files, (num > 0)?num:0), FALSE);
< }
< 
< /* Add_to_recent_list
<  * This should be called when a new file is opened, i.e. from
<  * file_open_cb, it adds a new entry which also appears in the
<  * menu bar, and (if nessecary) deletes the last entry */
< void add_to_recent_list(Tbfwin *bfwin,gchar *filename, gint closed_file, gboolean is_project) {
< 	DEBUG_MSG("add_to_recent_list, started for %s\n", filename);
< #ifdef WIN32
< 	if (filename[0] == '/') {filename ++;}
< #endif /* WIN32 */
< 	if (closed_file) {
< 		GList *tmplist = g_list_first(main_v->bfwinlist);
< 		while (tmplist) {
< 			Tbfwin *curbfwin = BFWIN(tmplist->data);
< 			if (!curbfwin->project || curbfwin == bfwin || is_project) {
< 				GtkWidget *tmp;
< 				GList **worklist;
< 				worklist = (is_project) ? &curbfwin->menu_recent_projects : &curbfwin->menu_recent_files;
< 				
< 				/* First of all, create the entry and insert it at the list*/
< 				*worklist = g_list_append(*worklist,create_recent_entry(curbfwin,filename,is_project,TRUE));
< 	
< 				DEBUG_MSG("add_to_recent_list, inserted item in menu\n");
< 				if(g_list_length(*worklist) > main_v->props.max_recent_files) {
< 					tmp = remove_recent_entry(bfwin,"last",is_project);
< 					if (tmp) {
< 						DEBUG_MSG("add_to_recent_list, list too long, entry %s to be deleted\n", GTK_LABEL(GTK_BIN(tmp)->child)->label);
< 						gtk_widget_hide(tmp);
< 						gtk_widget_destroy(tmp);
< 					}
< 				}
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	if (is_project) {
< 		main_v->globses.recent_projects = add_to_history_stringlist(main_v->globses.recent_projects, filename, FALSE,TRUE);
< 	} else {
< 		bfwin->session->recent_files = add_to_history_stringlist(bfwin->session->recent_files, filename, FALSE,TRUE);
< 	}
< 
< 
< /*	} else {
< 		/ * once we get rid of the other ways to store recent files this will be the only line we still need * /
< 		if (is_project) {
< 			main_v->globses.recent_projects = add_to_history_stringlist(main_v->globses.recent_projects, filename, TRUE);
< 		} else {
< 			bfwin->session->recent_files = add_to_history_stringlist(bfwin->session->recent_files, filename, TRUE);
< 		}
< 		DEBUG_MSG("add_to_recent_list, added to session recent_files, length=%d\n",g_list_length(bfwin->session->recent_files));
< 		if (bfwin->project) {
< 			/ * we do nothing when the file is opened, since opened files are anyway opened again in a project * /
< 		} else {
< 			gchar *tmpfilename, *recentfile;
< 			recentfile = g_strconcat(g_get_home_dir(), (is_project) ? "/.bluefish/recentprojects" : "/.bluefish/recentlist", NULL);
< 			/ * save the new list * /
< 			tmpfilename = g_strconcat(filename, "\n", NULL);
< 			DEBUG_MSG("add_to_recent_list, trying to append to %s\n", recentfile);
< 			append_string_to_file(recentfile, tmpfilename);
< 			g_free(recentfile);
< 			g_free(tmpfilename);
< 		}
< 		* /
< 	} */
< }
< /*****************/
< /* Windows !!    */
< /*****************/
< 
< static void remove_all_window_entries_in_window(Tbfwin *menubfwin) {
< 	GList *tmplist = g_list_first(menubfwin->menu_windows);
< 	DEBUG_MSG("removing all window entries in menubfwin %p\n",menubfwin);
< 	while (tmplist) {
< 		Tbfw_dynmenu *bdm = BFW_DYNMENU(tmplist->data);
< 		/*g_signal_handler_disconnect(bdm->menuitem,bdm->signal_id);*/
< 		DEBUG_MSG("remove_all_window_entries_in_window, destroy menuitem=%p\n",bdm->menuitem);
< 		gtk_widget_destroy(bdm->menuitem);
< 		g_free(bdm);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	g_list_free(menubfwin->menu_windows);
< 	menubfwin->menu_windows = NULL;
< }
< static void remove_window_entry_from_window(Tbfwin *menubfwin, Tbfwin *tobfwin) {
< 	Tbfw_dynmenu *bdm = find_bfw_dynmenu_by_data_in_list(menubfwin->menu_windows, tobfwin);
< 	DEBUG_MSG("remove_window_entry_from_window, menuwin=%p, found bdm=%p\n",menubfwin,bdm);
< 	if (bdm) {
< 		/*g_signal_handler_disconnect(bdm->menuitem,bdm->signal_id);*/
< 		DEBUG_MSG("remove_window_entry_from_window, destroy menuitem=%p\n",bdm->menuitem);
< 		gtk_widget_destroy(bdm->menuitem);
< 		menubfwin->menu_windows = g_list_remove(menubfwin->menu_windows,bdm);
< 		g_free(bdm);
< 		
< 	}
< }
< static void rename_window_entry_from_window(Tbfwin *menubfwin, Tbfwin *tobfwin, gchar *newtitle) {
< 	Tbfw_dynmenu *bdm = find_bfw_dynmenu_by_data_in_list(menubfwin->menu_windows, tobfwin);
< 	DEBUG_MSG("rename_window_entry_from_window, menubfwin=%p, found bdm=%p\n",menubfwin,bdm);
< 	if (bdm) {
< 		GtkWidget *label = gtk_bin_get_child(GTK_BIN(bdm->menuitem));
< 		DEBUG_MSG("rename_window_entry_from_window, setting label to have title %s\n",newtitle);
< 		gtk_label_set_text(GTK_LABEL(label), newtitle);
< 	}
< }	
< static void menu_window_lcb(GtkWidget *widget, Tbfw_dynmenu *bdm) {
< 	gtk_window_present(GTK_WINDOW(BFWIN(bdm->data)->main_window));
< }
< static void add_window_entry(Tbfwin *menubfwin, Tbfwin *tobfwin) {
< 	const gchar *winname;
< 	Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
< 	bdm->bfwin = menubfwin;
< 	bdm->data = tobfwin;
< 	winname = gtk_window_get_title(GTK_WINDOW(tobfwin->main_window));
< 	DEBUG_MSG("add_window_entry, menubfwin=%p, bdm=%p with title %s\n",menubfwin,bdm,winname);
< 	bdm->menuitem = create_dynamic_menuitem(menubfwin,_("/Windows"),winname,G_CALLBACK(menu_window_lcb),(gpointer)bdm,-1);
< 	DEBUG_MSG("add_window_entry, menuitem=%p\n",bdm->menuitem);
< 	menubfwin->menu_windows = g_list_append(menubfwin->menu_windows, bdm);
< }
< void add_window_entry_to_all_windows(Tbfwin *tobfwin) {
< 	GList *tmplist = g_list_first(main_v->bfwinlist);
< 	while (tmplist) {
< 		if (tmplist->data != tobfwin) {
< 			add_window_entry(BFWIN(tmplist->data), tobfwin);
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< void add_allwindows_entries_to_window(Tbfwin *menubfwin) {
< 	GList *tmplist = g_list_first(main_v->bfwinlist);
< 	while (tmplist) {
< 		if (tmplist->data != menubfwin) {
< 			add_window_entry(menubfwin, BFWIN(tmplist->data));
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< }	
< void remove_window_entry_from_all_windows(Tbfwin *tobfwin) {
< 	GList *tmplist = g_list_first(main_v->bfwinlist);
< 	while (tmplist) {
< 		remove_window_entry_from_window(BFWIN(tmplist->data), tobfwin);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	remove_all_window_entries_in_window(tobfwin);
< }
< void rename_window_entry_in_all_windows(Tbfwin *tobfwin, gchar *newtitle) {
< 	GList *tmplist = g_list_first(main_v->bfwinlist);
< 	while (tmplist) {
< 		rename_window_entry_from_window(BFWIN(tmplist->data), tobfwin, newtitle);
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< /*****************/
< /* Browsers!!    */
< /*****************/
< 
< static void view_in_browser(Tbfwin *bfwin, gchar *browser) {
< 	if (bfwin->current_document->filename) {
< 		Tconvert_table *table, *tmpt;
< 		gchar *command;
< 		table = tmpt = g_new(Tconvert_table, 2);
< 		tmpt->my_int = 's';
< 		if (bfwin->project && bfwin->project->webdir 
< 				&& bfwin->project->basedir && strlen(bfwin->project->webdir)>2
< 				&& strlen(bfwin->project->basedir)>2 
< 				&& strncmp(bfwin->current_document->filename, bfwin->project->basedir, strlen(bfwin->project->basedir))==0
< 				) {
< 			tmpt->my_char = g_strconcat(bfwin->project->webdir, &bfwin->current_document->filename[strlen(bfwin->project->basedir)], NULL);
< 		} else {
< 			tmpt->my_char = g_strdup(bfwin->current_document->filename);
< 		}
< 		tmpt++;
< 		tmpt->my_char = NULL;
< 		command = replace_string_printflike(browser, table);
< 		g_free(table->my_char);
< 		g_free(table);
< 		DEBUG_MSG("view_in_browser, should start %s now\n", command);
< 		system(command);
< 		g_free(command);
< 	} else {
< 		warning_dialog(bfwin->main_window,_("Could not view file in browser, the file does not yet have a name\n"), NULL);
< 	}
< }
< 
< void browser_toolbar_cb(GtkWidget *widget, Tbfwin *bfwin) {
< 	GList *tmplist = g_list_first(main_v->props.browsers);
< 	if (tmplist && tmplist->data) {
< 		gchar **arr = tmplist->data;
< 		DEBUG_MSG("first browser in main_v->props.browsers(%p) is %s with command %s\n", main_v->props.browsers, arr[0], arr[1]);
< 		view_in_browser(bfwin,arr[1]);
< 	}
< }
< 
< static void browser_lcb(GtkWidget *widget, Tbfw_dynmenu *bdm) {
< 	gchar **arr = (gchar **)bdm->data;
< 	if (!bdm->bfwin->current_document->filename || bdm->bfwin->current_document->modified) {
< 		file_save_cb(NULL, bdm->bfwin);
< 	}
< 	view_in_browser(bdm->bfwin,arr[1]);
< }
< static void external_command_lcb(GtkWidget *widget, Tbfw_dynmenu *bdm) {
< 	gchar *secure_tempname = NULL, *secure_tempname2 = NULL;
< 	gboolean need_s=FALSE, need_f=FALSE, need_i=FALSE;
< 	gchar **arr = (gchar **)bdm->data;
< 	/* now check if
< 	 * %s - current document filename
< 	 * %f - output filename that we need to read after the command has finished (filter)
< 	 * %i - input filename for the filter
< 	 */
< 	need_f = (strstr(arr[1], "%f") != NULL);
< 	need_i = (strstr(arr[1], "%i") != NULL);
< 	need_s = (strstr(arr[1], "%s") != NULL);
< 
< 	if (need_s) {
< 		file_save_cb(NULL, bdm->bfwin);
< 		if (!bdm->bfwin->current_document->filename) {
< 			return;
< 		}
< 		if (bdm->bfwin->current_document->filename[0] == '/'){
< 			/* for local files we chdir() to their directory */
< 			gchar *tmpstring = g_path_get_dirname(bdm->bfwin->current_document->filename);
< #ifdef WIN32
< 			if (tmpstring[0] == '/')
< 				chdir(tmpstring + 1);
< #else
< 			chdir(tmpstring);
< #endif /* WIN32 */
< 			g_free(tmpstring);
< 		}
< 	}
< 	if (need_f || need_s || need_i) {
< 		gchar *command;
< 		Tconvert_table *table, *tmpt;
< 		table = tmpt = g_new(Tconvert_table, 4);
< 		if (need_s) {
< 			DEBUG_MSG("adding 's' to table\n");
< 			tmpt->my_int = 's';
< 			tmpt->my_char = bdm->bfwin->current_document->filename;
< 			tmpt++;
< 		}
< 		if (need_f) {
< 			secure_tempname = create_secure_dir_return_filename();
< 			DEBUG_MSG("adding 'f' to table\n");
< 			tmpt->my_int = 'f';
< 			tmpt->my_char = secure_tempname;
< 			tmpt++;
< 		}
< 		if (need_i) {
< 			gchar *buffer;
< 			GtkTextIter itstart, itend;
< 			gtk_text_buffer_get_bounds(bdm->bfwin->current_document->buffer,&itstart,&itend);
< 			secure_tempname2 = create_secure_dir_return_filename();
< 			DEBUG_MSG("adding 'i' to table\n");
< 			tmpt->my_int = 'i';
< 			tmpt->my_char = secure_tempname2;
< 			tmpt++;
< 			/* now we also save the current filename (or in the future the selection) to this file */
< 			buffer = gtk_text_buffer_get_text(bdm->bfwin->current_document->buffer,&itstart,&itend,FALSE);
< 			buffer_to_file(BFWIN(bdm->bfwin), buffer, secure_tempname2);
< 			g_free(buffer);
< 		}
< 		tmpt->my_char = NULL;
< 		command = replace_string_printflike(arr[1], table);
< 		g_free(table);
< 		system(command);
< 		g_free(command);
< 		if (need_f) {
< 			gint end;
< 			gchar *buf = NULL;
< 			gboolean suc6;
< 			/* empty textbox and fill from file secure_tempname */
< 			end = doc_get_max_offset(bdm->bfwin->current_document);
< 			suc6 = g_file_get_contents(secure_tempname, &buf, NULL, NULL);
< 			if (suc6 && buf) {
< 				if (strlen(buf)) {
< 					doc_replace_text(bdm->bfwin->current_document, buf, 0, end);
< 				}
< 				g_free(buf);
< 			}
< 		}
< 		if (secure_tempname) remove_secure_dir_and_filename(secure_tempname);
< 		if (secure_tempname2) remove_secure_dir_and_filename(secure_tempname2);
< 	} else {
< 		DEBUG_MSG("external_command_lcb, about to start %s\n", arr[1]);
< 		system(arr[1]);
< 	}
< 	
< 	if (bdm->bfwin->current_document->need_highlighting) {
< 	    DEBUG_MSG("external_command_lcb, need_highlighting = %d\n", bdm->bfwin->current_document->need_highlighting);
< 	    doc_highlight_full(bdm->bfwin->current_document);
< 	}
< }
< /**
<  * external_menu_rebuild:
<  * @bfwin: #Tbfwin*
<  *
<  * rebuild the browsers, external commands and outputbox menu's
<  *
<  * Return value: void
<  */
< void external_menu_rebuild(Tbfwin *bfwin) {
< 	GList *tmplist;
< 	
< 	/* first cleanup all menu's */
< 	tmplist = g_list_first(bfwin->menu_external);
< 	while (tmplist) {
< 		Tbfw_dynmenu *bdm = (Tbfw_dynmenu *)tmplist->data;
< 		DEBUG_MSG("external_menu_rebuild,destroying,bfwin=%p,bdm=%p,menuitem=%p\n",bfwin,bdm,bdm->menuitem);
< 		gtk_widget_destroy(bdm->menuitem);
< 		g_free(bdm);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	g_list_free(bfwin->menu_external);
< 	bfwin->menu_external = NULL;
< 
< 	tmplist = g_list_first(bfwin->menu_outputbox);
< 	while (tmplist) {
< 		gtk_widget_destroy(BFW_DYNMENU(tmplist->data)->menuitem);
< 		g_free(BFW_DYNMENU(tmplist->data));
< 		tmplist = g_list_next(tmplist);
< 	}
< 	g_list_free(bfwin->menu_outputbox);
< 	bfwin->menu_outputbox = NULL;
< 	
< 	if (main_v->props.ext_outputbox_in_submenu) {
< 		create_parent_and_tearoff(N_("/External/Outputbox/"), gtk_item_factory_from_widget(bfwin->menubar));
< 	}
< 	if (main_v->props.ext_commands_in_submenu) {
< 		create_parent_and_tearoff(N_("/External/Commands/"), gtk_item_factory_from_widget(bfwin->menubar));
< 	}
< 	if (main_v->props.ext_browsers_in_submenu) {
< 		create_parent_and_tearoff(N_("/External/Browsers/"), gtk_item_factory_from_widget(bfwin->menubar));
< 	}
< 
< 	if (!main_v->props.ext_browsers_in_submenu) {
< 		Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
< 		bdm->menuitem = dynamic_menu_append_spacing(bfwin,N_("/External"));
< 		bfwin->menu_external = g_list_append(bfwin->menu_external,bdm);
< 	} 
< 	tmplist = g_list_first(main_v->props.browsers);
< 	while (tmplist) {
< 		gchar **arr = tmplist->data;
< 		/*  arr[0] = name
< 		 *  arr[1] = command
< 		 */
< 		if (count_array(arr)==2) {
< 			Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
< 			gchar *tmp1;
< 			if (main_v->props.ext_browsers_in_submenu) {
< 				tmp1 = N_("/External/Browsers");
< 			} else {
< 				tmp1 = N_("/External");
< 			}
< 			bdm->bfwin = bfwin;
< 			bdm->data = arr;
< 			DEBUG_MSG("external_menu_rebuild,Adding browser %s with command %s to the menu at %s\n", arr[0], arr[1], tmp1);
< 			bdm->menuitem = create_dynamic_menuitem(bfwin,tmp1,arr[0],G_CALLBACK(browser_lcb),bdm,-1);
< 			DEBUG_MSG("external_menu_rebuild,creating,bfwin=%p,bdm=%p,menuitem=%p\n",bfwin,bdm,bdm->menuitem);
< 			bfwin->menu_external = g_list_append(bfwin->menu_external, bdm);
< 		}
< #ifdef DEBUG
< 		else {
< 			DEBUG_MSG("need count=2 for browser menu! %p has count %d\n", arr, count_array(arr));
< 		}
< #endif
< 		tmplist = g_list_next(tmplist);
< 	}
< 	
< 	if (!main_v->props.ext_commands_in_submenu) {
< 		Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
< 		bdm->menuitem = dynamic_menu_append_spacing(bfwin,N_("/External"));
< 		bfwin->menu_external = g_list_append(bfwin->menu_external,bdm);
< 	}
< 	
< 	tmplist = g_list_first(main_v->props.external_commands);
< 	while (tmplist) {
< 		gchar **arr = tmplist->data;
< 		/*  arr[0] = name
< 		 *  arr[1] = command
< 		 */
< 		if (count_array(arr)==2) {
< 			gchar *tmp1;
< 			Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
< 			if (main_v->props.ext_commands_in_submenu) {
< 				tmp1 = N_("/External/Commands");
< 			} else {
< 				tmp1 = N_("/External");
< 			}
< 			bdm->bfwin = bfwin;
< 			bdm->data = arr;
< 			bdm->menuitem = create_dynamic_menuitem(bfwin,tmp1,arr[0],G_CALLBACK(external_command_lcb),bdm,-1);
< 			bfwin->menu_external = g_list_append(bfwin->menu_external, bdm);
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 
< 	/* the outputbox */	
< 	if (!main_v->props.ext_outputbox_in_submenu) {
< 		Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
< 		bdm->menuitem = dynamic_menu_append_spacing(bfwin,N_("/External"));
< 		bfwin->menu_outputbox = g_list_append(bfwin->menu_outputbox, bdm);
< 	}
< 	
< 	tmplist = g_list_first(main_v->props.outputbox);
< 	while (tmplist) {
< 		gchar **arr = tmplist->data;
< 		/* outputbox(gchar *pattern, gint file_subpat, gint line_subpat, gint output_subpat, gchar *command, gboolean show_all_output)
< 		 * arr[0] = name
< 		 * arr[1] = pattern
< 		 * arr[2] = file subpattern
< 		 * arr[3] = line subpattern
< 		 * arr[4] = output subpattern
< 		 * arr[5] = command
< 		 * arr[6] = show_all_output
< 		 */
< 		if (count_array(arr)==7) {
< 			Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
< 			gchar *tmp1;
< 			if (main_v->props.ext_outputbox_in_submenu) {
< 				tmp1 = N_("/External/Outputbox");
< 			} else {
< 				tmp1 = N_("/External");
< 			}
< 			bdm->data = arr;
< 			bdm->bfwin = bfwin;
< 			bdm->menuitem = create_dynamic_menuitem(bfwin,tmp1,arr[0],G_CALLBACK(menu_outputbox_lcb),(gpointer)bdm,-1);
< 			bfwin->menu_outputbox = g_list_append(bfwin->menu_outputbox,bdm);
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< static void menu_current_document_encoding_change(GtkMenuItem *menuitem,Tbfw_dynmenu *bdm) {
< 	if (GTK_CHECK_MENU_ITEM(menuitem)->active) {
< 		gchar *encoding = (gchar *)bdm->data;
< 		Tbfwin *bfwin = bdm->bfwin;
< 		if (encoding && (!bfwin->current_document->encoding || strcmp(encoding,bfwin->current_document->encoding)!=0)) {
< 			if (bfwin->current_document->encoding) {
< 				g_free(bfwin->current_document->encoding);
< 			}
< 			bfwin->current_document->encoding = g_strdup(encoding);
< 			if (main_v->props.auto_set_encoding_meta) {
< 				update_encoding_meta_in_file(bfwin->current_document, bfwin->current_document->encoding);
< 			}
< 			doc_set_statusbar_editmode_encoding(bfwin->current_document);
< 			DEBUG_MSG("menu_current_document_encoding_change, set to %s\n", encoding);
< 		}
< 	}
< }
< 
< void encoding_menu_rebuild(Tbfwin *bfwin) {
< 	GSList *group=NULL;
< 	GtkWidget *parent_menu;
< 	GList *tmplist;
< 	tmplist = g_list_first(bfwin->menu_encodings);
< 	while (tmplist) {
< 		Tbfw_dynmenu *bdm = tmplist->data;
< 		gtk_widget_destroy(GTK_WIDGET(bdm->menuitem));
< 		g_free(bdm);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	g_list_free(bfwin->menu_encodings);
< 	bfwin->menu_encodings = NULL;
< 
< 	tmplist = g_list_last(main_v->props.encodings);
< 	parent_menu = gtk_item_factory_get_widget(gtk_item_factory_from_widget(bfwin->menubar), N_("/Document/Character Encoding"));
< 	while (tmplist) {
< 		gchar **strarr = (gchar **)tmplist->data;
< 		if (count_array(strarr)==2) {
< 			Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
< 			bdm->menuitem = gtk_radio_menu_item_new_with_label(group, strarr[0]);
< 			bdm->data = strarr[1];
< 			bdm->bfwin = bfwin;
< 			g_signal_connect(G_OBJECT(bdm->menuitem), "activate",G_CALLBACK(menu_current_document_encoding_change), (gpointer) bdm);
< 			gtk_widget_show(bdm->menuitem);
< 			gtk_menu_insert(GTK_MENU(parent_menu), bdm->menuitem, 1);
< 			group = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(bdm->menuitem));
< 			bfwin->menu_encodings = g_list_append(bfwin->menu_encodings, bdm);
< 		}
< 		tmplist = g_list_previous(tmplist);
< 	}
< }
< 
< void menu_current_document_set_toggle_wo_activate(Tbfwin *bfwin, Tfiletype *filetype, gchar *encoding) {
< 	Tbfw_dynmenu *bdm = find_bfw_dynmenu_by_data_in_list(bfwin->menu_filetypes, filetype);
< 	if (bdm && filetype && bdm->menuitem && !GTK_CHECK_MENU_ITEM(bdm->menuitem)->active) {
< 		DEBUG_MSG("setting widget from hlset %p active\n", bfwin->current_document->hl);
< 		g_signal_handler_disconnect(G_OBJECT(bdm->menuitem),bdm->signal_id);
< 		gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM(bdm->menuitem), TRUE);
< 		bdm->signal_id = g_signal_connect(G_OBJECT(bdm->menuitem), "activate",G_CALLBACK(menu_current_document_type_change), (gpointer) bdm);
< 	}
< #ifdef DEBUG
< 	 else {
< 	 	DEBUG_MSG("widget from filetype %p is already active, or filetype does not have a widget!!\n", bfwin->current_document->hl);
< 	 }
< #endif
< 	if (encoding) {
< 		GList *tmplist;
< 		tmplist = g_list_first(main_v->props.encodings);
< 		while (tmplist) {
< 			gchar **tmparr = (gchar **)tmplist->data;
< 			if (strcmp(tmparr[1], encoding)==0) {
< 				Tbfw_dynmenu *bdm = find_bfw_dynmenu_by_data_in_list(bfwin->menu_encodings, tmparr[1]);
< 				if (bdm) {
< 					g_signal_handlers_block_matched(G_OBJECT(bdm->menuitem), G_SIGNAL_MATCH_FUNC,
< 							0, 0, NULL, menu_current_document_encoding_change, NULL);
< 					gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(bdm->menuitem),TRUE);
< 					g_signal_handlers_unblock_matched(G_OBJECT(bdm->menuitem), G_SIGNAL_MATCH_FUNC,
< 							0, 0, NULL, menu_current_document_encoding_change, NULL);
< 				}
< 				break;
< 			}
< 			tmplist = g_list_next(tmplist);	
< 		}
< 	}
< }
< 
< 
< /***************/
< /* custom menu */
< /***************/
< #define MAX_TEXT_ENTRY 10
< typedef struct {
< 	GtkWidget *dialog;
< 	GtkWidget *textentry[MAX_TEXT_ENTRY];
< 	gint type;
< 	gchar **array;
< 	Tbfwin *bfwin;
< } Tcust_con_struc;
< 
< typedef struct {
< 	GtkItemFactoryEntry entry;
< 	gint type;
< 	gchar **array;
< 	Tbfwin *bfwin;
< } Tcmenu_entry;
< 
< /*
< instead of having one list where both insert and replace types have their
< place, I changed that to 2 arraylists:
< main_v->props.cmenu_insert
< main_v->props.cmenu_replace
< 
< ** for insert **
< array[0] = title / menupath
< array[1] = formatstring before, containing %0, %1... that should be replaced by the 
< 				values from the dialog
< array[2] = formatstring after
< array[3] = number of variables from the dialog
< array[4..] = the description of those variables
< 
< ** for replace **
< array[0] = title / menupath
< array[1] = search pattern, containing %0 etc.
< array[2] = replace pattern, containing %0 etc.
< array[3] = replace where:
< 							0 = from beginning
< 							1 = from cursor
< 							2 = selection (selection required)
< 							3 = all open documents
< 							4 = ask
< array[4] = replace type:
< 							0 = normal
< 							1 = regular expression
< array[5] = case sensitivity:
< 							0 = no
< 							1 = yes
< array[6] = number of variables from the dialog
< array[7..] = the description of those variables
< */
< 
< static void cust_con_struc_dialog_destroy_lcb(GtkWidget *widget, Tcust_con_struc *ccs) {
< 	window_destroy(ccs->dialog);
< 	g_free(ccs);
< }
< 
< static void cust_con_struc_dialog_cancel_lcb(GtkWidget *widget, gpointer data) {
< 	cust_con_struc_dialog_destroy_lcb(NULL, data);
< }
< 
< static void cust_con_struc_dialog_ok_lcb(GtkWidget *widget, Tcust_con_struc *ccs) {
< 	Tconvert_table *table, *tmpt;
< 	gint num_vars, i;
< 
< 	DEBUG_MSG("cust_con_struc_dialog_ok_lcb, ccs at %p\n", ccs);
< 	DEBUG_MSG("cust_con_struc_dialog_ok_lcb, array at %p, &array[0]=%p\n", ccs->array, &ccs->array[0]);
< 	DEBUG_MSG("cust_con_struc_dialog_ok_lcb, array[0] at %p, *array=%p\n", ccs->array[0], *ccs->array);
< 	if (ccs->type == 0) {
< 		gchar *before=NULL, *after=NULL;
< 		num_vars = atoi(ccs->array[3]);
< 		DEBUG_MSG("cust_con_struc_dialog_ok_lcb, num_vars=%d, ccs->array[3]=%s\n", num_vars, ccs->array[3]);
< 		table = tmpt = g_new(Tconvert_table, num_vars+2);
< 		tmpt->my_int = '%';
< 		tmpt->my_char = g_strdup("%");
< 		tmpt++;
< 		for (i=0; i<num_vars; i++) {
< 			DEBUG_MSG("cust_con_struc_dialog_ok_lcb, tmpt=%p, i=%d\n", tmpt, i);
< 			tmpt->my_int = 48 + i;
< 			tmpt->my_char = gtk_editable_get_chars(GTK_EDITABLE(ccs->textentry[i]), 0, -1);
< 			tmpt++;
< 		}
< 		DEBUG_MSG("cust_con_struc_dialog_ok_lcb, setting tmpt(%p) to NULL\n", tmpt);
< 		tmpt->my_char = NULL;
< 
< 		if (strlen(ccs->array[1])) {
< 			DEBUG_MSG("cust_con_struc_dialog_ok_lcb, ccs->array[1]=%s\n",ccs->array[1] );
< 			before = replace_string_printflike(ccs->array[1], table);
< 		}
< 		if (strlen(ccs->array[2])) {
< 			after = replace_string_printflike(ccs->array[2], table);
< 		}
< 		doc_insert_two_strings(ccs->bfwin->current_document, before, after);
< 		doc_scroll_to_cursor(ccs->bfwin->current_document);
< 		
< 		tmpt = table;
< 		while (tmpt->my_char) {
< 			DEBUG_MSG("cust_con_struc_dialog_ok_lcb, tmpt=%p, about to free(%p) %s\n", tmpt, tmpt->my_char, tmpt->my_char);
< 			g_free(tmpt->my_char);
< 			tmpt++;
< 		}
< 		g_free(table);
< 
< 		if (before) {
< 			g_free(before);
< 		}
< 		if (after) {
< 			g_free(after);
< 		}
< 	} else {
< 		gchar *search=NULL, *replace=NULL;
< 		num_vars = atoi(ccs->array[6]);
< 		table = tmpt = g_new(Tconvert_table, num_vars+1);
< 		for (i=0; i<num_vars; i++) {
< 			tmpt->my_int = 48 + i;
< 			tmpt->my_char = gtk_editable_get_chars(GTK_EDITABLE(ccs->textentry[i]), 0, -1);
< 			tmpt++;
< 		}
< 		tmpt->my_char = NULL;
< 		if (strlen(ccs->array[1])) {
< 			DEBUG_MSG("cust_con_struc_dialog_ok_lcb, ccs->array[1]=%s\n",ccs->array[1] );
< 			search = replace_string_printflike(ccs->array[1], table);
< 		}
< 		if (strlen(ccs->array[2])) {
< 			replace = replace_string_printflike(ccs->array[2], table);
< 		} else {
< 			replace = g_strdup("");
< 		}
< 		snr2_run_extern_replace(ccs->bfwin->current_document, search, atoi(ccs->array[3]),
< 				atoi(ccs->array[4]), atoi(ccs->array[5]), replace, TRUE);
< 		
< 		tmpt = table;
< 		while (tmpt->my_char) {
< 			g_free(tmpt->my_char);
< 			tmpt++;
< 		}
< 		g_free(table);
< 		
< 		if (search) {
< 			g_free(search);
< 		}
< 		if (replace) {
< 			g_free(replace);
< 		} 
< 	}
< 	cust_con_struc_dialog_cancel_lcb(NULL, ccs);
< }
< 
< static void cust_con_struc_dialog(Tbfwin *bfwin, gchar **array, gint type) {
< 	Tcust_con_struc *ccs;
< 	GtkWidget *vbox, *table, *hbox, *okb, *cancb;
< 	gint i, num_vars;
< 
< 	ccs = g_malloc(sizeof(Tcust_con_struc));
< 	ccs->type = type;
< 	ccs->bfwin = bfwin;
< 	DEBUG_MSG("cust_con_struc_dialog_cb, ccs at %p\n", ccs);
< 	ccs->array = array;
< 	DEBUG_MSG("cust_con_struc_dialog_cb, array at %p, &array[0]=%p\n", ccs->array, &ccs->array[0]);
< 	DEBUG_MSG("cust_con_struc_dialog_cb, array[0] at %p, *array=%p\n", ccs->array[0], *ccs->array);
< 	ccs->dialog = window_full2(ccs->array[0], GTK_WIN_POS_MOUSE,  
< 			5, G_CALLBACK(cust_con_struc_dialog_destroy_lcb), ccs, TRUE, NULL);
< 	vbox = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(ccs->dialog), vbox);
< 	DEBUG_MSG("cust_con_struc_dialog_cb, ccs->array[0]=%s\n", ccs->array[0]);
< 	
< 	if (type == 0) {
< 		num_vars = atoi(ccs->array[3]);
< 	} else {
< 		num_vars = atoi(ccs->array[6]);
< 	}
< 	DEBUG_MSG("cust_con_struc_dialog_cb, num_vars=%d\n", num_vars);
< 
<    table = gtk_table_new (num_vars, 2, FALSE);
<    gtk_table_set_row_spacings (GTK_TABLE (table), 12);
<    gtk_table_set_col_spacings (GTK_TABLE (table), 12);
<    gtk_box_pack_start (GTK_BOX (vbox), table, TRUE, TRUE, 0);
< 
<    for (i = 0; i < num_vars; i++) {
<       gchar *labelTxt = NULL;
<       
<       if (type == 0) {
<          labelTxt = g_strconcat (ccs->array[i+4], ": ", NULL);
<       } else {
<          labelTxt = g_strconcat (ccs->array[i+7], ": ", NULL); 
<       }
<       
<       ccs->textentry[i] = gtk_entry_new ();
< 		DEBUG_MSG("cust_con_struc_dialog_cb, textentry[%d]=%p\n", i, ccs->textentry[i]);
< 		bf_mnemonic_label_tad_with_alignment(labelTxt, ccs->textentry[i], 0, 0.5, table, 0, 1, i, i+1);
< 		gtk_table_attach (GTK_TABLE (table), ccs->textentry[i], 1, 2, i, i+1, GTK_EXPAND|GTK_FILL, GTK_SHRINK, 0, 0);
< 		
< 		g_free (labelTxt);
<    }
<    
< 	gtk_box_pack_start(GTK_BOX(vbox), gtk_hseparator_new(), FALSE, FALSE, 12);
< 	hbox = gtk_hbutton_box_new();
< 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
< 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 12);
< 	okb = bf_stock_ok_button(G_CALLBACK(cust_con_struc_dialog_ok_lcb), ccs);
< 	cancb = bf_stock_cancel_button(G_CALLBACK(cust_con_struc_dialog_cancel_lcb), ccs);
< 	gtk_box_pack_start(GTK_BOX(hbox),cancb , FALSE, FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(hbox),okb , FALSE, FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
< 
< 	gtk_widget_grab_focus(ccs->textentry[0]);
< 	gtk_widget_grab_default(okb);
< 	gtk_widget_show_all(ccs->dialog);
< }
< 
< 
< static void cust_menu_lcb(Tcmenu_entry *cmentry,guint callback_action,GtkWidget *widget) {
< 	if (cmentry->type == 0) {
< 		DEBUG_MSG("cust_menu_lcb, a custom insert, array[3]=%s\n", cmentry->array[3]);
< 		if (atoi(cmentry->array[3]) > 0) {
< 		     cust_con_struc_dialog(cmentry->bfwin,cmentry->array, 0);
< 		} else {
< 		     doc_insert_two_strings(cmentry->bfwin->current_document, cmentry->array[1],cmentry->array[2]);
< 		}
< 	} else {
< 		DEBUG_MSG("cust_menu_lcb, a custom replace!, cmentry->array[6]=%s\n", cmentry->array[6]);
< 		if (strcmp(cmentry->array[3], "2")==0 && !doc_has_selection(cmentry->bfwin->current_document)) {
< 			warning_dialog(cmentry->bfwin->main_window,_("This custom search and replace requires a selection"), NULL);
< 			return;
< 		}
< 		if (atoi(cmentry->array[6]) > 0) {
< 			cust_con_struc_dialog(cmentry->bfwin,cmentry->array, 1);
< 		} else {
< 		     snr2_run_extern_replace(cmentry->bfwin->current_document,cmentry->array[1], atoi(cmentry->array[3]),
< 							atoi(cmentry->array[4]), atoi(cmentry->array[5]), cmentry->array[2],TRUE);
< 		}
< 	}
< }
< 
< static Tcmenu_entry *create_cmentry(Tbfwin *bfwin,const gchar *menupath, gint count, gchar **array, GtkItemFactory *ifactory, gint type) {
< 	Tcmenu_entry *cmentry = g_malloc0(sizeof(Tcmenu_entry));
< 	cmentry->bfwin = bfwin;
< 	cmentry->entry.path = g_strdup(menupath);
< 	DEBUG_MSG("create_cmentry, entry.path=%s, count=%d\n", cmentry->entry.path, count);
< 	cmentry->entry.callback = cust_menu_lcb;
< 	cmentry->entry.callback_action = count;
< 	cmentry->array = array;
< 	cmentry->type = type;
< 	create_parent_and_tearoff(cmentry->entry.path, ifactory);
< 	gtk_item_factory_create_item(ifactory, &cmentry->entry, cmentry, 1);
< 	return cmentry;
< }
< 
< static void fill_cust_menubar(Tbfwin *bfwin) {
< 	GtkItemFactory *ifactory;
< 	gint count;
< 	gchar **splittedstring;
< 	GList *tmplist;
< 	Tcmenu_entry *cmentry;
< 
< 	ifactory = gtk_item_factory_from_widget(bfwin->menu_cmenu);
< 
< 	tmplist = g_list_first(bfwin->menu_cmenu_entries);
< 	while (tmplist) {
< 		cmentry = (Tcmenu_entry *) tmplist->data;
< 		gtk_item_factory_delete_entry(ifactory, &cmentry->entry);
< 		DEBUG_MSG("fill_cust_menubar, removed entry.path=%s\n", cmentry->entry.path);
< 		g_free(cmentry->entry.path);
< 		g_free(cmentry);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	g_list_free(bfwin->menu_cmenu_entries);
< 	bfwin->menu_cmenu_entries = NULL;
< 
< 	count = 0;
< 	tmplist = g_list_first(main_v->props.cmenu_insert);
< 	while (tmplist) {
< 		gint count2;
< 		splittedstring = (gchar **) tmplist->data;
< 		count2 = count_array(splittedstring);
< 		if (count2 >= 4) {
< 			cmentry = create_cmentry(bfwin,splittedstring[0], count, splittedstring, ifactory, 0);
< 			bfwin->menu_cmenu_entries = g_list_append(bfwin->menu_cmenu_entries, cmentry);
< 		}
< 		count++;
< 		tmplist = g_list_next(tmplist);
< 	}
< 	tmplist = g_list_first(main_v->props.cmenu_replace);
< 	while (tmplist) {
< 		gint count2;
< 		splittedstring = (gchar **) tmplist->data;
< 		count2 = count_array(splittedstring);
< 		if (count2 >= 4) {
< 			cmentry = create_cmentry(bfwin,splittedstring[0], count, splittedstring, ifactory, 1);
< 			bfwin->menu_cmenu_entries = g_list_append(bfwin->menu_cmenu_entries, cmentry);
< 		}
< 		count++;
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< static void cmenu_reset_lcb(Tbfwin *bfwin,guint callback_action,GtkWidget *widget) {
< 	GList *tmplist;
< 	rcfile_parse_custom_menu(TRUE, FALSE);
< 	tmplist = g_list_first(main_v->bfwinlist);
< 	while (tmplist) {
< 		fill_cust_menubar(BFWIN(tmplist->data));
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< static void cmenu_load_new_lcb(Tbfwin *bfwin,guint callback_action,GtkWidget *widget) {
< 	GList *tmplist;
< 	rcfile_parse_custom_menu(FALSE, TRUE);
< 	tmplist = g_list_first(main_v->bfwinlist);
< 	while (tmplist) {
< 		fill_cust_menubar(BFWIN(tmplist->data));
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< /* function declaration needed here */
< void cmenu_editor(Tbfwin *bfwin,guint callback_action,GtkWidget *widget);
< 
< void make_cust_menubar(Tbfwin *bfwin, GtkWidget *cust_handle_box) {
< 	static GtkItemFactoryEntry cust_menu[] = {
< 		{N_("/_Custom menu"), NULL, NULL, 0, "<Branch>"},
< 		{"/Custom menu/tearoff1", NULL, NULL, 0, "<Tearoff>"},
< 		{N_("/Custom menu/Edit custom menu..."), NULL, cmenu_editor, 0, NULL},
< 		{N_("/Custom menu/Reset"), NULL, cmenu_reset_lcb, 0, NULL},
< 		{N_("/Custom menu/Load new"), NULL, cmenu_load_new_lcb, 0, NULL}
< 	};
< 	GtkItemFactory *item_factory;
< 	GtkAccelGroup *accel_group;
< 	gint nmenu_items = sizeof(cust_menu) / sizeof(cust_menu[0]);
< 
< 	DEBUG_MSG("make_cust_menubar, started\n");
< 
< 	/* this should only happen once !!!!!!!!!! */
< 	accel_group = gtk_accel_group_new();
< 	item_factory = gtk_item_factory_new(GTK_TYPE_MENU_BAR, "<bluefishcustom>", accel_group);
< #ifdef ENABLE_NLS
< 	gtk_item_factory_set_translate_func(item_factory, menu_translate, "<bluefishcustom>", NULL);
< #endif
< 	gtk_item_factory_create_items(item_factory, nmenu_items, cust_menu, bfwin);
< 	gtk_window_add_accel_group(GTK_WINDOW(bfwin->main_window), accel_group);
< 
< 	bfwin->menu_cmenu = gtk_item_factory_get_widget(item_factory, "<bluefishcustom>");
< 	gtk_container_add(GTK_CONTAINER(bfwin->custom_menu_hb), bfwin->menu_cmenu);
< 	gtk_widget_show(bfwin->menu_cmenu);
< 
< 	fill_cust_menubar(bfwin);
< 
< 	DEBUG_MSG("make_cust_menubar, finished\n");
< }
< 
< /*******************************************************************/
< /*               Custom menu editor                                */
< /*******************************************************************/
< typedef struct {
< 	GtkWidget *win;
< 	GtkWidget *type[2];
< 	GtkListStore *lstore;
< 	GtkWidget *lview;
< 	GtkWidget *label1;
< 	GtkWidget *label2;
< 	GtkWidget *menupath;
< /*	GtkWidget *befv;*/
< 	GtkTextBuffer *befb;
< /*	GtkWidget *aftv;*/
< 	GtkTextBuffer *aftb;
< 	GtkWidget *num;
< 	gchar **lastarray;
< 	GtkWidget *dynvbox;
< 	GtkWidget *hboxes[MAX_TEXT_ENTRY];
< 	GtkWidget *descriptions[MAX_TEXT_ENTRY];
< 	GtkWidget *csnr_box;
< 	GtkWidget *region;
< 	GtkWidget *matching;
< 	GtkWidget *is_case_sens;
< /*	GList *worklist;*/
< 	GList *worklist_insert;
< 	GList *worklist_replace;
< 	Tbfwin *bfwin;
< } Tcmenu_editor;
< 
< static void cme_destroy_lcb(GtkWidget *widget, Tcmenu_editor* cme) {
< 	window_destroy(cme->win);
< 	free_arraylist(cme->worklist_insert);
< 	free_arraylist(cme->worklist_replace);
< 	g_free(cme);
< }
< 
< static void cme_close_lcb(GtkWidget *widget, gpointer data) {
< 	cme_destroy_lcb(NULL, data);
< }
< 
< static void cme_ok_lcb(GtkWidget *widget, Tcmenu_editor *cme) {
< 	GList *tmplist;
< 	DEBUG_MSG("cme_ok_lcb, start cmenu_insert=%p, worklist_insert=%p\n",main_v->props.cmenu_insert, cme->worklist_insert);
< 	pointer_switch_addresses((gpointer)&main_v->props.cmenu_insert, (gpointer)&cme->worklist_insert);
< 	DEBUG_MSG("cme_ok_lcb, after cmenu_insert=%p, worklist_insert=%p\n",main_v->props.cmenu_insert, cme->worklist_insert);
< 	pointer_switch_addresses((gpointer)&main_v->props.cmenu_replace, (gpointer)&cme->worklist_replace);
< 	cme_destroy_lcb(NULL, cme);
< 	tmplist = g_list_first(main_v->bfwinlist);
< 	while (tmplist) {
< 		fill_cust_menubar(BFWIN(tmplist->data));
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< static void cme_create_entries(Tcmenu_editor *cme, gint num) {
< 	gint i;
< 
< 	for (i = 0; i < MAX_TEXT_ENTRY ; i++) {
< 		if (i < num) {
< 			gtk_widget_show(cme->hboxes[i]);
< 		} else {
< 			gtk_widget_hide(cme->hboxes[i]); 
< 		}
< 	}
< }
< 
< static gboolean cme_iter_at_pointer(GtkTreeIter *iter, gpointer pointer, Tcmenu_editor *cme) {
< 	gpointer tmp;
< 	gboolean cont;
< 	cont = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(cme->lstore),iter);
< 	while (cont) {
< 		gtk_tree_model_get(GTK_TREE_MODEL(cme->lstore),iter,2,&tmp,-1);
< 		if (pointer == tmp) {
< 			return TRUE;
< 		}
< 		cont = gtk_tree_model_iter_next(GTK_TREE_MODEL(cme->lstore),iter);
< 	}
< 	return FALSE;
< }
< 
< static void cme_lview_selection_changed(GtkTreeSelection *selection, Tcmenu_editor *cme) {
< 	GtkTreeIter iter;
< 	GtkTreeModel *model;
< 	if (gtk_tree_selection_get_selected (selection,&model,&iter)) {
< 		gint num=0, i;
< 		gint type=0;
< 
< 		gtk_tree_model_get(model, &iter, 1, &type, 2, &cme->lastarray, -1);
< 		
< 		DEBUG_MSG("cme_clist_select_lcb, lastarray=%p, lastarray[0]=%s, type=%d\n", cme->lastarray, cme->lastarray[0], type);
< 
< 		DEBUG_MSG("cme_clist_select_lcb, cme->lastarray[0]=%s, [i]='%s'\n", cme->lastarray[0], cme->lastarray[1]);
< 		gtk_entry_set_text(GTK_ENTRY(cme->menupath), cme->lastarray[0]);
< 
< 		DEBUG_MSG("cme_clist_select_lcb, cme->lastarray[1]='%s'\n", cme->lastarray[1]);
< 		gtk_text_buffer_set_text(cme->befb, cme->lastarray[1], -1);
< 
< 		DEBUG_MSG("cme_clist_select_lcb, cme->lastarray[2]='%s'\n", cme->lastarray[2]);
< 		gtk_text_buffer_set_text(cme->aftb, cme->lastarray[2], -1);
< 
< 		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(cme->type[type]), TRUE);
< 		if (type == 0) {
< 			DEBUG_MSG("cme_clist_select_lcb, type=0, custom dialog\n");
< 			gtk_widget_hide(cme->csnr_box);
< 		
< 			num = atoi(cme->lastarray[3]);
< 			DEBUG_MSG("cme_clist_select_lcb, num=%d\n", num);
< 			gtk_spin_button_set_value(GTK_SPIN_BUTTON(cme->num), num);
< 	
< 			cme_create_entries(cme, num);
< 			DEBUG_MSG("cme_clist_select_lcb, %d entries created\n", num);
< 			for (i = 0 ; i < num; i++) {
< 				gtk_entry_set_text(GTK_ENTRY(cme->descriptions[i]), cme->lastarray[i+4]);
< 			}
< 			for (i = num ; i < MAX_TEXT_ENTRY; i++) {
< 				gtk_entry_set_text(GTK_ENTRY(cme->descriptions[i]), "");
< 			}
< 		} else if (type == 1) {
< 			static Tconvert_table table1[] = {{0, "0"}, {1, "1"}, {0, NULL}};
< /*			static Tconvert_table table2[] = {{0, N_("in current document")}, {1, N_("from cursor")}, {2, N_("in selection")}, {3, N_("in all open documents")}, {0,NULL}};
< 			static Tconvert_table table3[] = {{0, N_("normal")}, {1, N_("posix regular expressions")}, {2, N_("perl regular expressions")}, {0, NULL}};*/
< 			gint converti;
< 			/*gchar *convertc;*/
< 			DEBUG_MSG("cme_clist_select_lcb, type=1, custom search and replace\n");
< 			gtk_widget_show(cme->csnr_box);
< 			DEBUG_MSG("cme_clist_select_lcb, cme->lastarray[4]=%s\n", cme->lastarray[4]);
< 			
< 			/*gtk_editable_delete_text(GTK_EDITABLE(GTK_COMBO(cme->matching)->entry), 0, -1);
< 			converti = atoi(cme->lastarray[4]);
< 			convertc = table_convert_int2char(table3, converti);
< 			if (convertc) {
< 				gint pos=0;
< 				gtk_editable_insert_text(GTK_EDITABLE(GTK_COMBO(cme->matching)->entry), convertc, strlen(convertc), &pos);
< 			}*/
< 			converti = atoi(cme->lastarray[4]);
< 			gtk_option_menu_set_history(GTK_OPTION_MENU(cme->matching),converti);
< 
< 			DEBUG_MSG("cme_clist_select_lcb, cme->lastarray[5]=%s\n", cme->lastarray[5]);
< 			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(cme->is_case_sens), table_convert_char2int(table1, cme->lastarray[5], tcc2i_full_match));
< 			
< 			/*gtk_editable_delete_text(GTK_EDITABLE(GTK_COMBO(cme->region)->entry), 0, -1);
< 			converti = atoi(cme->lastarray[3]);
< 			convertc = table_convert_int2char(table2, converti);
< 			if (convertc) {
< 				gint pos=0;
< 				gtk_editable_insert_text(GTK_EDITABLE(GTK_COMBO(cme->region)->entry), convertc, strlen(convertc), &pos);
< 			}*/
< 			converti = atoi(cme->lastarray[3]);
< 			gtk_option_menu_set_history(GTK_OPTION_MENU(cme->region),converti);
< 
< 			num = atoi(cme->lastarray[6]);
< 			gtk_spin_button_set_value(GTK_SPIN_BUTTON(cme->num), num);
< 	
< 			cme_create_entries(cme, num);
< 			for (i = 0 ; i < num; i++) {
< 				gtk_entry_set_text(GTK_ENTRY(cme->descriptions[i]), cme->lastarray[i+7]);
< 			}
< 			for (i = num ; i < MAX_TEXT_ENTRY; i++) {
< 				gtk_entry_set_text(GTK_ENTRY(cme->descriptions[i]), "");
< 			}
< 		}
< 		DEBUG_MSG("cme_clist_select_lcb, finished\n");
< 	} else {
< 		gint i;
< 		gtk_entry_set_text(GTK_ENTRY(cme->menupath), "");
< 		{
< 			GtkTextIter itstart, itend;
< 			gtk_text_buffer_get_bounds(cme->befb,&itstart,&itend);
< 			gtk_text_buffer_delete(cme->befb,&itstart,&itend);
< 			gtk_text_buffer_get_bounds(cme->aftb,&itstart,&itend);
< 			gtk_text_buffer_delete(cme->aftb,&itstart,&itend);
< 		}
< 		gtk_spin_button_set_value(GTK_SPIN_BUTTON(cme->num), 0);
< 		for (i = 0 ; i < MAX_TEXT_ENTRY; i++) {
< 			gtk_entry_set_text(GTK_ENTRY(cme->descriptions[i]), "");
< 		}
< 		cme->lastarray = NULL;
< 		DEBUG_MSG("cme_clist_unselect_lcb, lastarray=%p\n", cme->lastarray);
< 	}
< }
< 
< static void cme_spin_changed_lcb(GtkWidget *widget, Tcmenu_editor *cme) {
< 	cme_create_entries(cme, gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(cme->num)));
< }
< 
< static void cme_type_changed_lcb(GtkWidget *widget, Tcmenu_editor *cme) {
< 	if (GTK_TOGGLE_BUTTON(cme->type[1])->active) {
< 		DEBUG_MSG("cme_clist_select_lcb, type[1] is active\n");
< 		gtk_widget_show(cme->csnr_box);
< 		gtk_label_set_text(GTK_LABEL(cme->label1), _("Search Pattern"));
< 		gtk_label_set_text(GTK_LABEL(cme->label2), _("Replace String"));
< 	} else {
< 		gtk_widget_hide(cme->csnr_box);
< 		gtk_label_set_text(GTK_LABEL(cme->label1), _("Formatstring Before"));
< 		gtk_label_set_text(GTK_LABEL(cme->label2), _("Formatstring After"));
< 	}
< }
< 
< static gchar **cme_create_array(Tcmenu_editor *cme, gboolean is_update) {
< 	gchar **newarray;
< 	gint num, i, type;
< 	
< 	gtk_spin_button_update(GTK_SPIN_BUTTON(cme->num));
< 	num  = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(cme->num));
< 	DEBUG_MSG("cme_create_array, num=%d\n", num);
< 	if (GTK_TOGGLE_BUTTON(cme->type[1])->active) {
< 		type = 1;
< 	} else {
< 		type = 0;
< 	}
< 	if (type == 0) {
< 		newarray = g_malloc0((num+5) * sizeof(char *));
< 	} else {
< 		newarray = g_malloc0((num+8) * sizeof(char *));
< 	}
< 	DEBUG_MSG("cme_create_array, newarray at %p\n",newarray);
< 	newarray[0] = gtk_editable_get_chars(GTK_EDITABLE(cme->menupath), 0, -1);
< 	{
< 		gboolean invalid=is_update;
< 		GList *tmplist = g_list_first(cme->worklist_insert);
< 		while (tmplist) {
< 			gchar **tmparr = (gchar **)tmplist->data;
< 			if (strcmp(tmparr[0],newarray[0])==0) {
< 				/* if it is an update they path should exist already, else is should not */
< 				invalid = (!is_update);
< 				break;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		tmplist = g_list_first(cme->worklist_replace);
< 		while (tmplist) {
< 			gchar **tmparr = (gchar **)tmplist->data;
< 			if (strcmp(tmparr[0],newarray[0])==0) {
< 				/* if it is an update they path should exist already, else is should not */
< 				invalid = (!is_update);
< 				break;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		if (invalid) {
< 			if (is_update) {
< 				warning_dialog(cme->bfwin->main_window,_("The menupath you want to update does not exist yet"), _("Try 'add' instead."));
< 			} else {
< 				warning_dialog(cme->bfwin->main_window,_("The menupath you want to add already exists."), NULL);
< 			}
< 		}
< 		if (newarray[0][0] != '/') {
< 			DEBUG_MSG("cme_create_array, menupath does not start with slash, returning NULL\n");
< 			warning_dialog(cme->bfwin->main_window,_("The menupath should start with a / character"), NULL);
< 			invalid = TRUE;
< 		}
< 		if (invalid) {
< 			g_free(newarray[0]);
< 			g_free(newarray);
< 			return (NULL);
< 		}
< 	}
< 	if (type == 0) {
< 		newarray[3] = gtk_editable_get_chars(GTK_EDITABLE(cme->num), 0, -1);
< 		for (i = 0 ; i < num; i++) {
< 			DEBUG_MSG("cme_create_array, adding descriptions[%d] to newarray[%d]\n", i, i+4);
< 			newarray[4+i] = gtk_editable_get_chars(GTK_EDITABLE(cme->descriptions[i]), 0, -1);
< 		}
< 		DEBUG_MSG("cme_create_array, setting newarray[%d] to NULL\n",i+4);
< 		newarray[4+i] = NULL;
< 	} else {
< /*		static Tconvert_table table2[] = {{0, N_("in current document")}, {1, N_("from cursor")}, {2, N_("in selection")}, {3, N_("in all open documents")}, {0,NULL}};
< 		static Tconvert_table table3[] = {{0, N_("normal")}, {1, N_("posix regular expressions")}, {2, N_("perl regular expressions")}, {0, NULL}};*/
< 		gint converti;
< /*		gchar *convertc;
< 		convertc = gtk_editable_get_chars(GTK_EDITABLE(GTK_COMBO(cme->region)->entry), 0, -1);
< 		converti = table_convert_char2int(table2, convertc, tcc2i_full_match_gettext);
< 		g_free(convertc);*/
< 		converti = gtk_option_menu_get_history(GTK_OPTION_MENU(cme->region));
< 		newarray[3] = g_strdup_printf("%d", converti);
< 
< 		/*convertc = gtk_editable_get_chars(GTK_EDITABLE(GTK_COMBO(cme->matching)->entry), 0, -1);
< 		g_free(convertc);*/
< 		converti = gtk_option_menu_get_history(GTK_OPTION_MENU(cme->matching));
< 		newarray[4] = g_strdup_printf("%d", converti);
< 		
< 		newarray[5] = g_strdup_printf("%d", GTK_TOGGLE_BUTTON(cme->is_case_sens)->active);
< 	
< 		newarray[6] = gtk_editable_get_chars(GTK_EDITABLE(cme->num), 0, -1);
< 		DEBUG_MSG("cme_create_array, newarray[6]=%s\n", newarray[6]);
< 		for (i = 0 ; i < num; i++) {
< 			DEBUG_MSG("cme_create_array, adding descriptions[%d] to newarray[%d]\n", i, i+7);
< 			newarray[7+i] = gtk_editable_get_chars(GTK_EDITABLE(cme->descriptions[i]), 0, -1);
< 		}
< 		DEBUG_MSG("cme_create_array, setting newarray[%d] to NULL\n",i+7);
< 		newarray[7+i] = NULL;
< 	}
< 	{
< 		GtkTextIter itstart, itend;
< 		gtk_text_buffer_get_bounds(cme->befb,&itstart,&itend);
< 		newarray[1] = gtk_text_buffer_get_text(cme->befb,&itstart,&itend, FALSE);
< 		gtk_text_buffer_get_bounds(cme->aftb,&itstart,&itend);
< 		newarray[2] = gtk_text_buffer_get_text(cme->aftb,&itstart,&itend, FALSE);
< 	}
< 
< 	return newarray;
< }
< 
< static void cme_add_lcb(GtkWidget *widget, Tcmenu_editor *cme) {
< 	gchar **newarray;
< 	newarray = cme_create_array(cme, FALSE);
< 	if (newarray != NULL){
< 		GtkTreeIter iter;
< 		GtkTreeSelection *gtsel;
< 		gint type = GTK_TOGGLE_BUTTON(cme->type[1])->active;
< 		DEBUG_MSG("cme_add_lcb, adding %p with type %d\n",newarray,type);
< 		if (type == 0) {
< 			cme->worklist_insert = g_list_append(cme->worklist_insert, newarray);
< 		} else {
< 			cme->worklist_replace = g_list_append(cme->worklist_replace, newarray);
< 		}
< 		gtk_list_store_append(GTK_LIST_STORE(cme->lstore),&iter);
< 		gtk_list_store_set(GTK_LIST_STORE(cme->lstore),&iter,0,newarray[0],1,type,2,newarray,-1);
< 		cme->lastarray = newarray;
< 		gtsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(cme->lview));
< 		gtk_tree_selection_select_iter(gtsel,&iter);
< 	}
< }
< 
< static void cme_update_lcb(GtkWidget *widget, Tcmenu_editor *cme) {
< 	gchar **newarray;
< 	if (cme->lastarray == NULL) {
< 		cme_add_lcb(NULL, cme);
< 		return;
< 	}
< 	newarray = cme_create_array(cme, TRUE);
< 	if (newarray) {
< 		GtkTreeIter iter;
< 		if (cme_iter_at_pointer(&iter, cme->lastarray, cme)) {
< 			gint newtype, oldtype;
< 			gtk_tree_model_get(GTK_TREE_MODEL(cme->lstore),&iter,1,&oldtype,-1);
< 			newtype = GTK_TOGGLE_BUTTON(cme->type[1])->active;
< 			gtk_list_store_set(GTK_LIST_STORE(cme->lstore),&iter,0,newarray[0],1,newtype,2,newarray,-1);
< 			if (oldtype == 0) {
< 				if (newtype == 1) {
< 					cme->worklist_insert = g_list_remove(cme->worklist_insert, cme->lastarray);
< 					cme->worklist_replace = g_list_append(cme->worklist_replace, newarray);
< 				} else {
< 					GList *tmplist = g_list_find(cme->worklist_insert,cme->lastarray);
< 					tmplist->data = newarray;
< 				}
< 			} else if (oldtype == 1) {
< 				if (newtype == 0) {
< 					cme->worklist_replace = g_list_remove(cme->worklist_replace, cme->lastarray);
< 					cme->worklist_insert = g_list_append(cme->worklist_insert, newarray);
< 				} else {
< 					GList *tmplist = g_list_find(cme->worklist_replace,cme->lastarray);
< 					tmplist->data = newarray;
< 				}
< 			}
< 		} else {
< 			DEBUG_MSG("cme_update_lcb, cannot find iter for pointer %p\n",cme->lastarray);
< 		}
< 		g_strfreev(cme->lastarray);
< 		cme->lastarray = newarray;
< 	} else {
< 		DEBUG_MSG ("cme_update_lcb, no new array, cancelled\n");
< 	}
< 	DEBUG_MSG ("cme_update_lcb finished\n");
< }
< 
< static void cme_delete_lcb(GtkWidget *widget, Tcmenu_editor *cme) {
< 	if (cme->lastarray) {
< 		GtkTreeIter iter;
< 		if (cme_iter_at_pointer(&iter, cme->lastarray, cme)) {
< 			gint type;
< 			DEBUG_MSG("cme_delete_lcb, removing from listmodel\n");
< 			gtk_tree_model_get(GTK_TREE_MODEL(cme->lstore),&iter,1,&type,-1);
< 			if (type == 0) {
< 				cme->worklist_insert = g_list_remove(cme->worklist_insert, cme->lastarray);
< 			} else if (type == 1) {
< 				cme->worklist_replace = g_list_remove(cme->worklist_replace, cme->lastarray);
< 			} else {
< 				DEBUG_MSG("NOT removed from lists, type=%d ???\n",type);
< 			}
< 			if (type == 1 || type == 0) {
< 				g_strfreev(cme->lastarray);
< 			}
< 			/* removing the iter will call cme_clist_unselect_lcb which will set the lastarray to NULL
< 			therefore we will do this as last action */
< 			gtk_list_store_remove(GTK_LIST_STORE(cme->lstore),&iter);
< 		} else {
< 			DEBUG_MSG("NOT REMOVED, no iter can be found for pointer %p?!?\n",cme->lastarray);
< 		}
< 		DEBUG_MSG("cme_delete_lcb, setting lastarray NULL\n");
< 		cme->lastarray = NULL;
< 	} else {
< 		DEBUG_MSG("cme_delete_lcb, lastarray=NULL, nothing to delete\n");
< 	}
< }
< 
< gint menu_entry_sort(gchar ** a,gchar ** b) {
< 	return strcmp(a[0],b[0]);
< }
< 
< void cmenu_editor(Tbfwin *bfwin,guint callback_action,GtkWidget *widget) {
< 	Tcmenu_editor *cme;
< 	GtkWidget *hbox, *vbox, *frame, *vbox2, *vbox3, *hbox2, *label, *toolbar;
< 	GList *tmplist;
< 	gint i;
< 	gchar *tmpstr;
< 	
< 	cme = g_malloc0(sizeof(Tcmenu_editor));
< 	cme->bfwin = bfwin;
< 	DEBUG_MSG("cmenu_editor, cme is at %p\n", cme);
< 	cme->win = window_full2(_("Custom Menu Editor"), GTK_WIN_POS_CENTER, 
< 							0, G_CALLBACK(cme_destroy_lcb), cme, TRUE, bfwin->main_window);
< 
< 	vbox = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(cme->win), vbox);
< 	
< 	toolbar = gtk_toolbar_new();
< 	gtk_toolbar_set_orientation(GTK_TOOLBAR(toolbar), GTK_ORIENTATION_HORIZONTAL);
< 	gtk_toolbar_set_icon_size(GTK_TOOLBAR(toolbar), GTK_ICON_SIZE_SMALL_TOOLBAR);
< 	gtk_box_pack_start(GTK_BOX(vbox), toolbar, FALSE, FALSE, 0);
< 	
< 	gtk_toolbar_insert_stock(GTK_TOOLBAR(toolbar), GTK_STOCK_ADD, _("Add New Menu Entry"),
< 								NULL, G_CALLBACK(cme_add_lcb), cme, -1);
< 	gtk_toolbar_insert_stock(GTK_TOOLBAR(toolbar), GTK_STOCK_APPLY, _("Apply Changes"),
< 								NULL, G_CALLBACK(cme_update_lcb), cme, -1);
< 	gtk_toolbar_insert_stock(GTK_TOOLBAR(toolbar), GTK_STOCK_DELETE, _("Delete Menu Entry"),
< 								NULL, G_CALLBACK(cme_delete_lcb), cme, -1);
< 	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
< 	gtk_toolbar_insert_stock(GTK_TOOLBAR(toolbar), GTK_STOCK_CLOSE, _("Close Discards Changes"),
< 								NULL, G_CALLBACK(cme_close_lcb), cme, -1);
< 	gtk_toolbar_insert_stock(GTK_TOOLBAR(toolbar), GTK_STOCK_SAVE, _("Save Changes and Exit"),
< 								NULL, G_CALLBACK(cme_ok_lcb), cme, -1);
< 	
< 	vbox2 = gtk_vbox_new(FALSE, 12);
< 	gtk_container_set_border_width(GTK_CONTAINER(vbox2), 6);
< 	gtk_box_pack_start(GTK_BOX(vbox), vbox2, TRUE, TRUE, 0);							
< 	/* upper area */
< 	hbox = gtk_hbox_new(FALSE, 12);
< 	gtk_box_pack_start(GTK_BOX(vbox2), hbox, FALSE, TRUE, 6);
< 
< 	label = gtk_label_new_with_mnemonic(_("_Menu Path:"));
< 	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, TRUE, 0);
< 	cme->menupath = gtk_entry_new();
< 	gtk_label_set_mnemonic_widget(GTK_LABEL(label), cme->menupath);
< 	gtk_box_pack_start(GTK_BOX(hbox),cme->menupath , TRUE, TRUE, 0);
< 	
< 	hbox = gtk_hbox_new(FALSE, 12);
< 	gtk_box_pack_start(GTK_BOX(vbox2), hbox, TRUE, TRUE, 6);
< 
< 	/* clist & type area */
< 	vbox3 = gtk_vbox_new(FALSE, 12);	
< 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, TRUE, TRUE, 0);
< 	{
< 		GtkWidget *scrolwin;
< 		GtkTreeViewColumn *column;
< 		GtkTreeSelection *select;
< 		GtkCellRenderer *renderer = gtk_cell_renderer_text_new ();
< 
< 		cme->lstore = gtk_list_store_new (3, G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_POINTER);
< 		cme->lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(cme->lstore));
< 
< 		column = gtk_tree_view_column_new_with_attributes (_("Menu path"), renderer,"text", 0,NULL);
< 		gtk_tree_view_append_column (GTK_TREE_VIEW(cme->lview), column);
< 
< 		scrolwin = gtk_scrolled_window_new(NULL, NULL);
< 		gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
< 
< 		DEBUG_MSG("cmenu_editor, created lstore and lview\n");
< 		gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolwin), cme->lview);
< 		gtk_widget_set_size_request(scrolwin, 180, 250);
< 		gtk_box_pack_start(GTK_BOX(vbox3), scrolwin, TRUE, TRUE, 0);
< 		
< 		select = gtk_tree_view_get_selection(GTK_TREE_VIEW(cme->lview));
< 		g_signal_connect(G_OBJECT(select), "changed",G_CALLBACK(cme_lview_selection_changed),cme);
< 	}
< 
< 	/* dynamic entries area */
< 	vbox3 = gtk_vbox_new(FALSE, 0);	
< 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, TRUE, TRUE, 0);
< 
< 	hbox2 = gtk_hbox_new(FALSE, 12); 
< 	label = gtk_label_new_with_mnemonic(_("Number of _Variables:"));
< 	gtk_box_pack_start(GTK_BOX(hbox2), label, FALSE, FALSE, 0);		
< 	cme->num = spinbut_with_value(NULL, 0, MAX_TEXT_ENTRY, 1,1);
< 	g_signal_connect(GTK_OBJECT(cme->num), "changed", G_CALLBACK(cme_spin_changed_lcb), cme);
< 	gtk_label_set_mnemonic_widget(GTK_LABEL(label), cme->num);
< 	gtk_box_pack_start(GTK_BOX(hbox2),cme->num , FALSE, FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox3), hbox2, FALSE, FALSE, 0);
< 	
< 	frame = gtk_frame_new(_("Variables"));
< 	gtk_box_pack_end(GTK_BOX(vbox3), frame, TRUE, TRUE, 0);
< 	cme->dynvbox = gtk_vbox_new(FALSE, 2);	
< 	gtk_container_add(GTK_CONTAINER(frame), cme->dynvbox);
< 	for (i = 0; i <  MAX_TEXT_ENTRY; i++) {
< 		cme->hboxes[i] = gtk_hbox_new(FALSE, 0);
< 		gtk_box_pack_start(GTK_BOX(cme->dynvbox), cme->hboxes[i], FALSE, FALSE, 0);
< 		tmpstr = g_strdup_printf("%%%d: ", i);
< 		gtk_box_pack_start(GTK_BOX(cme->hboxes[i]), gtk_label_new(tmpstr), FALSE, FALSE, 0);
< 		g_free(tmpstr);
< 		cme->descriptions[i] = gtk_entry_new();
< 		gtk_box_pack_start(GTK_BOX(cme->hboxes[i]), cme->descriptions[i], TRUE, TRUE, 0);
< 	}
< 
< 	/* lower area */
< 	/* before and after text area */
< 	vbox3 = gtk_vbox_new(FALSE, 6);
< 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, TRUE, TRUE, 0);
< 	
< 	cme->type[0] = gtk_radio_button_new_with_mnemonic(NULL, _("Custom Dialo_g"));
< 	gtk_box_pack_start(GTK_BOX(vbox3), cme->type[0], FALSE, TRUE, 0);
< 	cme->type[1] = gtk_radio_button_new_with_mnemonic_from_widget(GTK_RADIO_BUTTON(cme->type[0]), _("Custom Replace"));
< 	gtk_box_pack_start(GTK_BOX(vbox3), cme->type[1], FALSE, TRUE, 0);
< 
< 	g_signal_connect(GTK_OBJECT(cme->type[0]), "toggled", G_CALLBACK(cme_type_changed_lcb), cme);
< 	
< 	/* csnr area */
< 	cme->csnr_box = gtk_vbox_new(FALSE, 6);
< 	gtk_box_pack_start(GTK_BOX(vbox3), cme->csnr_box, FALSE, TRUE, 12);
< 
< 	hbox2 = gtk_hbox_new(FALSE, 12);
< 	gtk_box_pack_start(GTK_BOX(cme->csnr_box), hbox2, FALSE, TRUE, 0);
< 	
< 	label = gtk_label_new_with_mnemonic(_("_Replace:"));
< 	gtk_box_pack_start(GTK_BOX(hbox2), label, FALSE, FALSE, 0);
< 	{
< 		gchar *whereoptions[] = {N_("in current document"),N_("from cursor"),N_("in selection"),N_("in all open documents"), NULL};
< 		cme->region = optionmenu_with_value(whereoptions, 0);
< 	}
< 	gtk_box_pack_start(GTK_BOX(hbox2),cme->region , TRUE, TRUE, 3);
< 	gtk_label_set_mnemonic_widget(GTK_LABEL(label), cme->region);
< 
< 	hbox2 = gtk_hbox_new(FALSE, 12);
< 	gtk_box_pack_start(GTK_BOX(cme->csnr_box), hbox2, TRUE, TRUE, 0);
< 	label = gtk_label_new_with_mnemonic(_("Matc_hing:"));
< 	gtk_box_pack_start(GTK_BOX(hbox2), label, FALSE, FALSE, 0);
< 	{
< 		gchar *matchactions[] = {N_("normal"), N_("posix regular expressions"),	N_("perl regular expressions"), NULL};
< 		cme->matching = optionmenu_with_value(matchactions, 0);
< 	}
< 	gtk_box_pack_start(GTK_BOX(hbox2),cme->matching , TRUE, TRUE, 3);
< 	gtk_label_set_mnemonic_widget(GTK_LABEL(label), cme->matching);
< 	
< 	cme->is_case_sens = boxed_checkbut_with_value(_("Case Se_nsitive"), 0, cme->csnr_box);
< 
< 	{
< 		GtkWidget *scrolwin, *textview;
< 		cme->label1 = gtk_label_new_with_mnemonic("");
< 		gtk_box_pack_start(GTK_BOX(vbox3), cme->label1, FALSE, FALSE, 0);
< 
< 		scrolwin = textview_buffer_in_scrolwin(&textview, -1, -1, NULL, GTK_WRAP_NONE);
< 		cme->befb = gtk_text_view_get_buffer(GTK_TEXT_VIEW(textview));
< 		gtk_box_pack_start(GTK_BOX(vbox3), scrolwin, TRUE, TRUE, 0);
< 
< 		cme->label2 = gtk_label_new_with_mnemonic("");
< 		gtk_box_pack_start(GTK_BOX(vbox3), cme->label2, FALSE, FALSE, 0);
< 		
< 		scrolwin = textview_buffer_in_scrolwin(&textview, -1, -1, NULL, GTK_WRAP_NONE);
< 		cme->aftb = gtk_text_view_get_buffer(GTK_TEXT_VIEW(textview));
< 		gtk_box_pack_start(GTK_BOX(vbox3), scrolwin, TRUE, TRUE, 0);
< 	}
< 	
< 	/* ready !! */
< 	cme->worklist_insert = duplicate_arraylist(main_v->props.cmenu_insert);
< 	cme->worklist_replace = duplicate_arraylist(main_v->props.cmenu_replace);
< 	cme->worklist_insert = g_list_sort(cme->worklist_insert, (GCompareFunc)menu_entry_sort);
< 	cme->worklist_replace = g_list_sort(cme->worklist_replace, (GCompareFunc)menu_entry_sort);
< 	{
< 		GtkTreeIter iter;
< 		tmplist = g_list_first(cme->worklist_insert);
< 		while (tmplist) {
< 			DEBUG_MSG("cmenu_editor, adding type 0 '%s'\n", *(gchar **)tmplist->data);
< 			gtk_list_store_append(GTK_LIST_STORE(cme->lstore), &iter);
< 			gtk_list_store_set(GTK_LIST_STORE(cme->lstore), &iter, 0, *(gchar **)tmplist->data, 1, 0, 2, tmplist->data, -1); /* the name , the type, the pointer */
< 			tmplist = g_list_next(tmplist);
< 		}
< 		tmplist = g_list_first(cme->worklist_replace);
< 		while (tmplist) {
< 			DEBUG_MSG("cmenu_editor, adding type 1 '%s'\n", *(gchar **)tmplist->data);
< 			gtk_list_store_append(GTK_LIST_STORE(cme->lstore), &iter);
< 			gtk_list_store_set(GTK_LIST_STORE(cme->lstore), &iter, 0, *(gchar **)tmplist->data, 1, 1, 2, tmplist->data, -1); /* the name , the type, the pointer */
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	gtk_widget_show_all(cme->win);
< 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(cme->type[0]), TRUE);
< 	cme_type_changed_lcb(NULL, cme);
< }
< 
< /*************************************************************************/
---
> /* Bluefish HTML Editor
>  * menu.c - the menu(s)
>  *
>  * this file has content-type: UTF-8
>  * and it is important you keep it UTF-8 !!!
>  *
>  * Copyright (C) 1998-2000 Olivier Sessink, Chris Mazuc and Roland Steinbach
>  * Copyright (C) 2000-2002 Olivier Sessink and Roland Steinbach
>  * Copyright (C) 2002-2005 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> #include <gtk/gtk.h>
> #include <stdlib.h>    /* atoi */
> #include <string.h>    /* strchr() */
> #include <gdk/gdkkeysyms.h>
> 
> /* #define DEBUG */
> 
> #include "bluefish.h"
> #include "menu.h"
> #include "about.h"
> #include "bf_lib.h"        /* append_string_to_file() */
> #include "bfspell.h"
> #include "bookmark.h"
> #include "document.h"      /* file_open etc. */
> #include "gtk_easy.h"      /* window_full, bf_stock_ok_button */
> #include "gui.h"           /* go_to_line_win_cb */
> #include "highlight.h"     /* doc_highlight_full */
> #include "html.h"
> #include "html2.h"
> #include "html_table.h"
> #include "html_form.h"
> #include "image.h"
> #include "outputbox.h"     /* temporary */
> #include "pixmap.h"
> #include "preferences.h"   /* open_preferences_menu_cb */
> #include "project.h"
> #include "rcfile.h"        /* rcfile_save_configfile_menu_cb */
> #include "rpopup.h"
> #include "snr2.h"          /* search_cb, replace_cb */
> #include "stringlist.h"    /* free_stringlist() */
> #include "undo_redo.h"     /* undo_cb() redo_cb() etc. */
> #include "wizards.h"
> 
> #ifdef HAVE_ATLEAST_GTK_2_4
> #include "quickstart.h"
> #endif /* HAVE_ATLEAST_GTK_2_4 */
> 
> /*
> The callback for an ItemFactory entry can take two forms. If callback_action is zero, it is of the following form:
> void callback(void)
> otherwise it is of the form:
> void callback( gpointer callback_data,guint callback_action, GtkWidget *widget)
> callback_data is a pointer to an arbitrary piece of data and is set during the call to gtk_item_factory_create_items().
> 
> we want to pass the Tbfwin* so we should never use a callback_action of zero
> */
> static void menu_file_operations_cb(Tbfwin *bfwin, guint callback_action, GtkWidget *widget) {
> 	switch(callback_action) {
> 	case 1:
> 		file_new_cb(NULL,bfwin);
> 	break;
> 	case 2:
> 		file_open_cb(NULL,bfwin);
> 	break;
> #ifdef EXTERNAL_GREP
> #ifdef EXTERNAL_FIND
> 	case 3:
> 		file_open_advanced_cb(NULL,bfwin);
> 	break;
> #endif
> #endif
> 	case 4:
> 		doc_reload(bfwin->current_document);
> 	break;
> 	case 5:
> 		file_save_cb(NULL, bfwin);
> 	break;
> 	case 6:
> 		file_save_as_cb(NULL, bfwin);
> 	break;
> 	case 7:
> 		file_move_to_cb(NULL, bfwin);
> 	break;
> 	case 8:
> 		file_save_all_cb(NULL, bfwin);
> 	break;
> 	case 9:
> 		file_close_cb(NULL, bfwin);
> 	break;
> 	case 10:
> 		edit_cut_cb(NULL, bfwin);
> 	break;
> 	case 11:
> 		edit_copy_cb(NULL, bfwin);
> 	break;
> 	case 12:
> 		edit_paste_cb(NULL, bfwin);
> 	break;
> 	case 13:
> 		edit_select_all_cb(NULL, bfwin);
> 	break;
> 	case 14:
> 		search_cb(NULL, bfwin);
> 	break;
> 	case 16:
> 		search_again_cb(NULL, bfwin);
> 	break;
> 	case 17:
> 		replace_cb(NULL, bfwin);
> 	break;
> 	case 19:
> 		replace_again_cb(NULL, bfwin);
> 	break;
> 	case 20:
> 		undo_cb(NULL, bfwin);
> 	break;
> 	case 21:
> 		redo_cb(NULL, bfwin);
> 	break;
> 	case 22:
> 		undo_all_cb(NULL, bfwin);
> 	break;
> 	case 23:
> 		redo_all_cb(NULL, bfwin);
> 	break;
> 	case 24:
> 		file_close_all_cb(NULL,bfwin);
> 	break;
> #ifdef HAVE_GNOME_VFS
> 	case 25:
> 		file_open_url_cb(NULL, bfwin);
> 	break;
> #endif
> 	case 26:
> 		file_open_from_selection(bfwin);
> 	break;
> 	case 27:
> 		search_from_selection(bfwin);
> 	break;
> 	default:
> 		g_print("menu_file_operations_cb, unknown action, abort!\n");
> 		exit(123);
> 	}
> }
> static void menu_html_dialogs_lcb(Tbfwin *bfwin, guint callback_action, GtkWidget *widget) {
> 	switch (callback_action) {
> 	case 1:
> 		body_dialog(bfwin,NULL);
> 	break;
> 	case 2:
> 		DEBUG_MSG("menu_html_dialogs_lcb,calling quickanchor_dialog with bfwin=%p and data=NULL\n",bfwin);
> 		quickanchor_dialog(bfwin,NULL);
> 	break;
> 	case 3:
> 		email_dialog(bfwin,NULL);
> 	break;
> 	case 4:
> 		quickrule_dialog(bfwin,NULL);
> 	break;
> 	case 5:
> 		font_dialog(bfwin,NULL);
> 	break;
> 	case 6:
> 		basefont_dialog(bfwin,NULL);
> 	break;
> 	case 7:
> 		quicklist_dialog(bfwin,NULL);
> 	break;
> 	case 8:
> 		meta_dialog(bfwin,NULL);
> 	break;
> 	case 9:
> 		embed_dialog(bfwin,NULL);
> 	break;
> 	case 10:
> 		image_insert_dialog(bfwin,NULL);
> 	break;
> 	case 11:
> 		thumbnail_insert_dialog(bfwin);
> 	break;
> 	case 12:
> 		tablewizard_dialog(bfwin);
> 	break;
> 	case 13:
> 		tabledialog_dialog(bfwin,NULL);
> 	break;
> 	case 14:
> 		tablerowdialog_dialog(bfwin,NULL);
> 	break;
> 	case 15:
> 		tableheaddialog_dialog(bfwin,NULL);
> 	break;
> 	case 16:
> 		tabledatadialog_dialog(bfwin,NULL);
> 	break;
> 	case 17:
> 		span_dialog(bfwin,NULL);
> 	break;
> 	case 18:
> 		div_dialog(bfwin,NULL);
> 	break;
> 	case 19:
> 		framewizard_dialog(bfwin);
> 	break;
> 	case 20:
> 		frameset_dialog(bfwin,NULL);
> 	break;
> 	case 21:
> 		frame_dialog(bfwin,NULL);
> 	break;
> 	case 22:
> 		formdialog_dialog(bfwin,NULL);
> 	break;
> 	case 23:
> 		inputdialog_dialog(bfwin, NULL, "submit");
> 	break;
> 	case 24:
> 		inputdialog_dialog(bfwin, NULL, "text");
> 	break;
> 	case 25:
> 		buttondialog_dialog(bfwin, NULL);
> 	break;
> 	case 26:
> 		textareadialog_dialog(bfwin,NULL);
> 	break;
> 	case 29:
> 		selectdialog_dialog(bfwin,NULL);
> 	break;
> 	case 30:
> 		optiondialog_dialog(bfwin,NULL);
> 	break;
> 	case 31:
> 		optgroupdialog_dialog(bfwin,NULL);
> 	break;
> 	case 32:
> #ifdef HAVE_ATLEAST_GTK_2_4
> 		quickstart_dialog_new(bfwin);
> #else
> 		quickstart_dialog(bfwin,NULL);
> #endif
> 	break;
> 	case 33:
> 		inputdialog_dialog(bfwin, NULL, NULL);
> 	break;
> 	case 34:
> 		insert_time_dialog(bfwin);
> 	break;
> 	case 35:
> 		linkdialog_dialog(bfwin,NULL,linkdialog_mode_default);
> 	break;
> 	case 36:
> 		linkdialog_dialog(bfwin,NULL,linkdialog_mode_css);
> 	break;
> 	case 37:
> 		new_css_dialog(NULL,bfwin);
> 	break;
> 	case 38:
> 		sel_colour_cb(NULL,bfwin);	
> 	break;
> 	case 39:
> 		edit_tag_under_cursor_cb(bfwin);
> 	break;
> 	default:
> 		g_print("menu_file_operations_cb, unknown action, abort!\n");
> 		exit(123);
> 	}
> }
> #ifdef HAVE_LIBASPELL
> static void spell_check_menu_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
> 	spell_check_cb(NULL, bfwin);
> }
> #endif /* HAVE_LIBASPELL */
> 
> static void menu_bmark_operations_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
> 	switch(callback_action) {
> 	case 1:
> 	   bmark_add(bfwin);
> 	break;
> /*	case 2:
> 	   bmark_add_perm(bfwin);
> 	break;*/
> 	default:
> 			g_print("Bmark action no. %d\n",callback_action);
> 	}
> }
> 
> static void toggle_doc_property(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
> 	switch(callback_action) {
> 	case 1:
> 		bfwin->current_document->wrapstate = GTK_CHECK_MENU_ITEM(widget)->active;
> 		doc_set_wrap(bfwin->current_document);
> 		break;
> 	case 2:
> 		bfwin->current_document->linenumberstate = GTK_CHECK_MENU_ITEM(widget)->active;
> 		document_set_line_numbers(bfwin->current_document, bfwin->current_document->linenumberstate);
> 		break;
> 	case 3:
> 		bfwin->current_document->autoclosingtag = GTK_CHECK_MENU_ITEM(widget)->active;
> 		break;
> 	case 4:
> 		main_v->props.autoindent = GTK_CHECK_MENU_ITEM(widget)->active;
> 		break;
> 	}
> }
> 
> static GtkItemFactoryEntry menu_items[] = {
> 	{N_("/_File"), NULL, NULL, 0, "<Branch>"},
> 	{"/File/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/File/_New"), "<control>n", menu_file_operations_cb, 1, "<StockItem>", GTK_STOCK_NEW},
> 	{N_("/File/New _Window"), "<shift><control>n", gui_window_menu_cb, 1, "<Item>"},	
> 	{N_("/File/_Open..."), "<control>O", menu_file_operations_cb, 2, "<StockItem>", GTK_STOCK_OPEN},
> 	{N_("/File/Open _recent"), NULL, NULL, 0, "<Branch>"},
> 	{"/File/Open recent/tearoff1", NULL, NULL, 0, "<Tearoff>"},	
> #ifdef EXTERNAL_GREP
> #ifdef EXTERNAL_FIND
> 	{N_("/File/Open Ad_vanced..."), "<shift><control>O", menu_file_operations_cb, 3, "<Item>"},
> #endif /* EXTERNAL_FIND */
> #endif /* EXTERNAL_GREP */
> #ifdef HAVE_GNOME_VFS
> 	{N_("/File/Open _URL..."), NULL, menu_file_operations_cb, 25, "<Item>"},
> #endif /* HAVE_GNOME_VFS */
> 	{N_("/File/Open _from selection"), NULL, menu_file_operations_cb, 26, "<Item>"},
> 	{"/File/sep1", NULL, NULL, 0, "<Separator>"},
> 	{N_("/File/_Save"), "<control>S", menu_file_operations_cb, 5, "<StockItem>", GTK_STOCK_SAVE},
> 	{N_("/File/Save _As..."), "<shift><control>S", menu_file_operations_cb, 6, "<StockItem>", GTK_STOCK_SAVE_AS},
> 	{N_("/File/Sav_e All"), NULL, menu_file_operations_cb, 8, "<Item>"},
> 	{N_("/File/Rever_t to Saved"), NULL, menu_file_operations_cb, 4, "<StockItem>", GTK_STOCK_REVERT_TO_SAVED},
> 	{"/File/sep2", NULL, NULL, 0, "<Separator>"},	
> 	{N_("/File/_Insert..."), NULL, file_insert_menucb, 1, "<Item>"},	
> 	{N_("/File/Rena_me..."), "F2", menu_file_operations_cb, 7, "<Item>"},
> 	{"/File/sep3", NULL, NULL, 0, "<Separator>"},
> 	{N_("/File/_Close"), "<control>w", menu_file_operations_cb, 9, "<StockItem>", GTK_STOCK_CLOSE},
> 	{N_("/File/Close A_ll"), "<shift><control>w", menu_file_operations_cb, 24, "<Item>"},
> 	{N_("/File/Close Win_dow"), NULL, gui_window_menu_cb, 2, "<Item>"},
> 	{"/File/sep4", NULL, NULL, 0, "<Separator>"},
> 	{N_("/File/_Quit"), "<control>Q", bluefish_exit_request, 0, "<StockItem>", GTK_STOCK_QUIT},
> 	{N_("/_Edit"), NULL, NULL, 0, "<Branch>"},
> 	{"/Edit/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Edit/_Undo"), "<control>z", menu_file_operations_cb, 20, "<StockItem>", GTK_STOCK_UNDO},
> 	{N_("/Edit/_Redo"), "<shift><control>z", menu_file_operations_cb, 21, "<StockItem>", GTK_STOCK_REDO},
> 	{N_("/Edit/Undo All"), NULL, menu_file_operations_cb, 22, "<Item>"},
> 	{N_("/Edit/Redo All"), NULL, menu_file_operations_cb, 23, "<Item>"},
> 	{"/Edit/sep1", NULL, NULL, 0, "<Separator>"},	
> 	{N_("/Edit/Cu_t"), "<control>x", menu_file_operations_cb, 10, "<StockItem>", GTK_STOCK_CUT},
> 	{N_("/Edit/_Copy"), "<control>c", menu_file_operations_cb, 11, "<StockItem>", GTK_STOCK_COPY},
> 	{N_("/Edit/_Paste"), "<control>v", menu_file_operations_cb, 12, "<StockItem>", GTK_STOCK_PASTE},
> 	{"/Edit/sep2", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Edit/Select _All"), NULL, menu_file_operations_cb, 13, "<Item>"},
> 	{"/Edit/sep3", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Edit/_Find..."), "<control>f", menu_file_operations_cb, 14, "<StockItem>", GTK_STOCK_FIND},
> 	{N_("/Edit/Find A_gain"), "<control>g", menu_file_operations_cb, 16, "<Item>"},
> 	{N_("/Edit/Find from selection"), NULL, menu_file_operations_cb, 27, "<Item>"},
> 	{N_("/Edit/R_eplace..."), "<control>h", menu_file_operations_cb, 17, "<StockItem>", GTK_STOCK_FIND_AND_REPLACE},
> 	{N_("/Edit/Replace Agai_n"), "<shift><control>h", menu_file_operations_cb, 19, "<Item>"},
> 	{N_("/Edit/Replace special"), NULL, NULL, 0, "<Branch>"},
> 	{"/Edit/Replace special/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Edit/Replace special/_ASCII to HTML Entities"), NULL, doc_convert_asciichars_in_selection, 1, "<Item>"},
> 	{N_("/Edit/Replace special/_ISO8859 to HTML Entities"), NULL, doc_convert_asciichars_in_selection, 2, "<Item>"},
> 	{N_("/Edit/Replace special/_Both Types to HTML Entities"), NULL, doc_convert_asciichars_in_selection, 3, "<Item>"},
> 	{N_("/Edit/Replace special/To _Uppercase"), NULL, doc_convert_asciichars_in_selection, 4, "<Item>"},
> 	{N_("/Edit/Replace special/To _Lowercase"), NULL, doc_convert_asciichars_in_selection, 5, "<Item>"},
> 	{"/Edit/sep4", NULL, NULL, 0, "<Separator>"},
> #ifdef HAVE_ATLEAST_GTK_2_4
>    {N_("/Edit/S_hift Right"), NULL, menu_indent_cb, 2, "<StockItem>", GTK_STOCK_INDENT},
>    {N_("/Edit/Shift _Left"), NULL, menu_indent_cb, 1, "<StockItem>", GTK_STOCK_UNINDENT},
> #else
> 	{N_("/Edit/S_hift Right"), NULL, menu_indent_cb, 2, "<ImageItem>", pixmap_indent},
> 	{N_("/Edit/Shift _Left"), NULL, menu_indent_cb, 1, "<ImageItem>", pixmap_unindent},
> #endif
> 	{"/Edit/sep5", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Edit/Add _Bookmark"), "<control>d", menu_bmark_operations_cb, 1, "<Item>"},	
> 	{"/Edit/sep6", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Edit/Save Sett_ings"), NULL, rcfile_save_configfile_menu_cb, 0, "<Item>"},
> 	{N_("/Edit/Save Shortcut _Keys"), NULL, rcfile_save_configfile_menu_cb, 3, "<Item>"},	
> 	{N_("/Edit/Preference_s"), NULL, open_preferences_menu_cb, 0, "<StockItem>", GTK_STOCK_PREFERENCES},
> 	{N_("/_View"), NULL, NULL, 0, "<Branch>"},
> 	{"/View/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/View/View _Main Toolbar"), NULL, gui_toggle_hidewidget_cb, 1, "<ToggleItem>"},
> 	{N_("/View/View _HTML Toolbar"), NULL, gui_toggle_hidewidget_cb, 2, "<ToggleItem>"},
> 	{N_("/View/View _Custom Menu"), NULL, gui_toggle_hidewidget_cb, 3, "<ToggleItem>"},
> 	{N_("/View/View _Sidebar"), "F9", gui_toggle_hidewidget_cb, 4, "<ToggleItem>"},
> 	{N_("/_Tags"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> /*	{N_("/Tags/Repeat last"), "F4", repeat_last_insert_cb, 0, NULL},*/
> 	{N_("/Tags/_Headings"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Headings/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Headings/H_1"), "<control><alt>1", general_html_menu_cb, 18, "<ImageItem>",pixmap_fonth1},
> 	{N_("/Tags/Headings/H_2"), "<control><alt>2", general_html_menu_cb, 19, "<ImageItem>",pixmap_fonth2},
> 	{N_("/Tags/Headings/H_3"), "<control><alt>3", general_html_menu_cb, 20, "<ImageItem>",pixmap_fonth3},
> 	{N_("/Tags/Headings/H_4"), "<control><alt>4", general_html_menu_cb, 21, "<ImageItem>",pixmap_fonth4},
> 	{N_("/Tags/Headings/H_5"), "<control><alt>5", general_html_menu_cb, 22, "<ImageItem>",pixmap_fonth5},
> 	{N_("/Tags/Headings/H_6"), "<control><alt>6", general_html_menu_cb, 23, "<ImageItem>",pixmap_fonth6},
> 	{N_("/Tags/_Special"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Special/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Special/_Accent"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Special/Accent/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Special/Accent/_Uppercase"), NULL, NULL, 0, "<Branch>"},
> 	{N_("/Tags/Special/Accent/Uppercase/_A-I"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Special/Accent/Uppercase/A-I/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/A grave À"), NULL, insert_char_cb, 100, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/A acute Á"), NULL, insert_char_cb, 1, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/A circumflex Â"), NULL, insert_char_cb, 2, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/A tilde Ã"), NULL, insert_char_cb, 3, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/AE ligature Æ"), NULL, insert_char_cb, 4, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/A diaeresis Ä"), NULL, insert_char_cb, 5, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/A ring Å"), NULL, insert_char_cb, 6, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/C cedilla Ç"), NULL, insert_char_cb, 7, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/E grave È"), NULL, insert_char_cb, 8, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/E acute É"), NULL, insert_char_cb, 9, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/E circumflex Ê"), NULL, insert_char_cb, 10, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/E diaeresis Ë"), NULL, insert_char_cb, 11, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/I grave Ì"), NULL, insert_char_cb, 12, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/I acute Í"), NULL, insert_char_cb, 13, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/I circumflex Î"), NULL, insert_char_cb, 14, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/A-I/I diaeresis Ï"), NULL, insert_char_cb, 15, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/_J-Z"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Special/Accent/Uppercase/J-Z/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/N tilde Ñ"), NULL, insert_char_cb, 16, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/O grave Ò"), NULL, insert_char_cb, 17, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/O acute Ó"), NULL, insert_char_cb, 18, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/O circumflex Ô"), NULL, insert_char_cb, 19, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/OE ligature Œ"), NULL, insert_char_cb, 100, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/O tilde Õ"), NULL, insert_char_cb, 20, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/O diaeresis Ö"), NULL, insert_char_cb, 21, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/O slash Ø"), NULL, insert_char_cb, 22, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/U grave Ù"), NULL, insert_char_cb, 23, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/U acute Ú"), NULL, insert_char_cb, 24, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/U circumflex Û"), NULL, insert_char_cb, 25, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/U diaeresis Ü"), NULL, insert_char_cb, 26, "<Item>"},
> 	{N_("/Tags/Special/Accent/Uppercase/J-Z/Y acute Ý"), NULL, insert_char_cb, 27, "<Item>"},
> 	{N_("/Tags/Special/Accent/_Lowercase"), NULL, NULL, 0, "<Branch>"},
> 	{N_("/Tags/Special/Accent/Lowercase/_A-I"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Special/Accent/Lowercase/A-I/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/a grave à"), NULL, insert_char_cb, 28, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/a acute á"), NULL, insert_char_cb, 29, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/a circumflex â"), NULL, insert_char_cb, 30, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/a tilde ã"), NULL, insert_char_cb, 31, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/a ring å"), NULL, insert_char_cb, 32, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/ae ligature æ"), NULL, insert_char_cb, 33, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/a diaeresis ä"), NULL, insert_char_cb, 34, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/c cedilla ç"), NULL, insert_char_cb, 35, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/e grave è"), NULL, insert_char_cb, 36, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/e acute é"), NULL, insert_char_cb, 37, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/e circumflex ê"), NULL, insert_char_cb, 38, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/e diaeresis ë"), NULL, insert_char_cb, 39, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/i grave ì"), NULL, insert_char_cb, 40, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/i acute í"), NULL, insert_char_cb, 41, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/i circumflex î"), NULL, insert_char_cb, 42, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/A-I/i diaeresis ï"), NULL, insert_char_cb, 43, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/_J-Z"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Special/Accent/Lowercase/J-Z/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/n tilde ñ"), NULL, insert_char_cb, 44, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/o grave ò"), NULL, insert_char_cb, 45, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/o acute ó"), NULL, insert_char_cb,46, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/oe ligature œ"), NULL, insert_char_cb,99, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/o circumflex ô"), NULL, insert_char_cb, 47, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/o tilde õ"), NULL, insert_char_cb, 48, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/o diaeresis ö"), NULL, insert_char_cb, 49, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/o slash ø"), NULL, insert_char_cb, 50, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/u grave ù"), NULL, insert_char_cb, 51, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/u acute ú"), NULL, insert_char_cb, 52, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/u circumflex û"), NULL, insert_char_cb, 53, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/u diaeresis ü"), NULL, insert_char_cb, 54, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/y acute ý"), NULL, insert_char_cb, 55, "<Item>"},
> 	{N_("/Tags/Special/Accent/Lowercase/J-Z/y diaeresis ÿ"), NULL, insert_char_cb, 56, "<Item>"},
> 	{"/Tags/Special/Accent/sep1", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Tags/Special/Accent/U_mlaut ¨"), NULL, insert_char_cb, 57, "<Item>"},
> 	{N_("/Tags/Special/Accent/_Acute ´"), NULL, insert_char_cb, 58, "<Item>"},
> 	{N_("/Tags/Special/Accent/_Cedilla ¸"), NULL, insert_char_cb, 59, "<Item>"},
> 	{N_("/Tags/Special/_Currency"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Special/Currency/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Special/Currency/_Cent sign ¢"), NULL, insert_char_cb, 60, "<Item>"},
> 	{N_("/Tags/Special/Currency/_Pound sterling £"), NULL, insert_char_cb, 61, "<Item>"},
> 	{N_("/Tags/Special/Currency/C_urrency sign ¤"), NULL, insert_char_cb, 62, "<Item>"},
> 	{N_("/Tags/Special/Currency/_Yen sign ¥"), NULL, insert_char_cb, 63, "<Item>"},
> 	{N_("/Tags/Special/Currency/_Euro "), NULL, insert_char_cb, 98, "<Item>"},
> 	{N_("/Tags/Special/_Math-Science"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Special/Math-Science/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Special/Math-Science/Logical _not sign ¬"), NULL, insert_char_cb, 64, "<Item>"},
> 	{N_("/Tags/Special/Math-Science/_Multiplication sign ×"), NULL, insert_char_cb, 65, "<Item>"},
> 	{N_("/Tags/Special/Math-Science/_Division sign ÷"), "<control><alt>slash", insert_char_cb, 66, "<Item>"},
> 	{N_("/Tags/Special/Math-Science/_Plus-minus sign ±"), NULL, insert_char_cb, 67, "<Item>"},
> 	{N_("/Tags/Special/Math-Science/_Less-than sign <"), "<control><alt>comma", insert_char_cb, 68, "<Item>"},
> 	{N_("/Tags/Special/Math-Science/_Greater-than sign >"), "<control><alt>period", insert_char_cb, 69, "<Item>"},
> 	{N_("/Tags/Special/Math-Science/Superscript _1 ¹"), NULL, insert_char_cb, 70, "<Item>"},
> 	{N_("/Tags/Special/Math-Science/Superscript _2 ²"), NULL, insert_char_cb, 71, "<Item>"},
> 	{N_("/Tags/Special/Math-Science/Superscript _3 ³"), NULL, insert_char_cb, 72, "<Item>"},
> 	{N_("/Tags/Special/Math-Science/One _quarter ¼"), NULL, insert_char_cb, 73, "<Item>"},
> 	{N_("/Tags/Special/Math-Science/One _half ½"), NULL, insert_char_cb, 74, "<Item>"},
> 	{N_("/Tags/Special/Math-Science/_Three quarters ¾"), NULL, insert_char_cb, 75, "<Item>"},
> 	{N_("/Tags/Special/Math-Science/Deg_ree sign °"), NULL, insert_char_cb, 76, "<Item>"},
> 	{N_("/Tags/Special/_Non Latin"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Special/Non Latin/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Special/Non Latin/_ETH (Icelandic) Ð"), NULL, insert_char_cb, 77, "<Item>"},
> 	{N_("/Tags/Special/Non Latin/_THORN (Icelandic) Þ"), NULL, insert_char_cb, 78, "<Item>"},
> 	{N_("/Tags/Special/Non Latin/et_h (Icelandic) ð"), NULL, insert_char_cb, 79, "<Item>"},
> 	{N_("/Tags/Special/Non Latin/th_orn ÿ"), NULL, insert_char_cb, 80, "<Item>"},
> 	{N_("/Tags/Special/Non Latin/Sharp _s ß"), NULL, insert_char_cb, 81, "<Item>"},
> 	{N_("/Tags/Special/Non Latin/_Micro sign µ"), NULL, insert_char_cb, 82, "<Item>"},
> 	{N_("/Tags/Special/_Other"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Special/Other/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Special/Other/_Non-breaking space"), NULL, insert_char_cb, 83, "<Item>"},
> 	{N_("/Tags/Special/Other/_Section sign §"), NULL, insert_char_cb, 84, "<Item>"},
> 	{N_("/Tags/Special/Other/_Copyright sign ©"), NULL, insert_char_cb, 85, "<Item>"},
> 	{N_("/Tags/Special/Other/_Left angle quotes «"), NULL, insert_char_cb, 86, "<Item>"},
> 	{N_("/Tags/Special/Other/_Right angle quotes »"), NULL, insert_char_cb, 87, "<Item>"},
> 	{N_("/Tags/Special/Other/Registered _trademark ®"), NULL, insert_char_cb, 88, "<Item>"},
> 	{N_("/Tags/Special/Other/Inverted _exclamation ¡"), NULL, insert_char_cb, 89, "<Item>"},
> 	{N_("/Tags/Special/Other/Inverted _question mark ¿"), NULL, insert_char_cb, 90, "<Item>"},
> 	{N_("/Tags/Special/Other/_Feminine ordinal ª"), NULL, insert_char_cb, 91, "<Item>"},
> 	{N_("/Tags/Special/Other/_Masculine ordinal º"), NULL, insert_char_cb, 92, "<Item>"},
> 	{N_("/Tags/Special/Other/_Pilcrow (paragraph sign) ¶"), NULL, insert_char_cb, 93, "<Item>"},
> 	{N_("/Tags/Special/Other/_Broken bar ¦"), NULL, insert_char_cb, 94, "<Item>"},
> 	{N_("/Tags/Special/Other/Soft _hypen -"), NULL, insert_char_cb, 95, "<Item>"},
> 	{N_("/Tags/Special/Other/Spa_cing macron ¯"), NULL, insert_char_cb, 96, "<Item>"},
> 	{N_("/Tags/Special/Other/Middle _dot ·"), NULL, insert_char_cb, 97, "<Item>"},
> 	{N_("/Tags/_Format by layout"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Format by layout/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Format by layout/_Bold"), "<control><alt>b", general_html_menu_cb, 1, "<StockItem>", GTK_STOCK_BOLD},
> 	{N_("/Tags/Format by layout/_Italic"), "<control><alt>i", general_html_menu_cb, 2, "<StockItem>", GTK_STOCK_ITALIC},
> 	{N_("/Tags/Format by layout/_Underline"), "<control><alt>u", general_html_menu_cb, 3, "<StockItem>", GTK_STOCK_UNDERLINE},
> 	{N_("/Tags/Format by layout/_Strikeout"), "<control><alt>s", general_html_menu_cb, 4, "<StockItem>", GTK_STOCK_STRIKETHROUGH},
> 	{N_("/Tags/Format by layout/Sm_all"), NULL, general_html_menu_cb, 56, "<Item>"},
> 	{N_("/Tags/Format by layout/Bi_g"), NULL, general_html_menu_cb, 57, "<Item>"},
> 	{N_("/Tags/F_ormat by context"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Format by context/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Format by context/_Strong"), "<control><alt>g", general_html_menu_cb, 16, "<ImageItem>",pixmap_bold},
> 	{N_("/Tags/Format by context/_Emphasis"), "<control><alt>e", general_html_menu_cb, 17, "<ImageItem>",pixmap_italic},
> 	{N_("/Tags/Format by context/_Define"), NULL, general_html_menu_cb, 48, "<ImageItem>",pixmap_dfn},
> 	{N_("/Tags/Format by context/_Code"), NULL, general_html_menu_cb, 49, "<ImageItem>",pixmap_code},
> 	{N_("/Tags/Format by context/Sa_mple"), NULL, general_html_menu_cb, 50, "<ImageItem>",pixmap_samp},
> 	{N_("/Tags/Format by context/_Keyboard"), NULL, general_html_menu_cb, 51, "<ImageItem>",pixmap_kbd},
> 	{N_("/Tags/Format by context/_Variable"), NULL, general_html_menu_cb, 52, "<ImageItem>",pixmap_var},
> 	{N_("/Tags/Format by context/Ci_tation"), NULL, general_html_menu_cb, 53, "<ImageItem>",pixmap_cite},
> 	{N_("/Tags/Format by context/_Abbreviation"), NULL, general_html_menu_cb, 54, "<ImageItem>",pixmap_abbr},
> 	{N_("/Tags/Format by context/Ac_ronym"), NULL, general_html_menu_cb, 55, "<ImageItem>",pixmap_acronym},
> 	{N_("/Tags/Format _general"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Format general/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Format general/_Paragraph"), "<control><alt>p", general_html_menu_cb, 5, "<ImageItem>",pixmap_paragraph},
> 	{N_("/Tags/Format general/_Break"),  "<control><alt>k", general_html_menu_cb, 6, "<ImageItem>",pixmap_brbreak},
> 	{N_("/Tags/Format general/Break clear _all"), NULL, general_html_menu_cb, 41, "<ImageItem>",pixmap_breakall},
> 	{N_("/Tags/Format general/_Non-Breaking Space"), "<control><alt>n", general_html_menu_cb, 7, "<ImageItem>",pixmap_nbsp},
> 	{"/Tags/Format general/sep1", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Tags/Format general/Font Si_ze +1"), "<control><alt>equal", general_html_menu_cb, 11, "<ImageItem>",pixmap_fontp1},
> 	{N_("/Tags/Format general/Font _Size -1"), "<control><alt>minus", general_html_menu_cb, 12, "<ImageItem>",pixmap_fontm1},
> 	{"/Tags/Format general/sep2", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Tags/Format general/Preformatted _Text"), "<Control><Alt>f", general_html_menu_cb, 13, "<ImageItem>",pixmap_fontpre},
> 	{N_("/Tags/Format general/Su_bscript"), NULL, general_html_menu_cb, 14, "<ImageItem>",pixmap_fontsub},
> 	{N_("/Tags/Format general/Su_perscript"), NULL, general_html_menu_cb, 15, "<ImageItem>",pixmap_fontsuper},
> 	{"/Tags/Format general/sep3", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Tags/Format general/_Center"), NULL, general_html_menu_cb, 8, "<ImageItem>",pixmap_center},
> 	{N_("/Tags/Format general/Align _right"), "<control><Alt>r", general_html_menu_cb, 9, "<ImageItem>",pixmap_right},
> 	{N_("/Tags/_Table"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Table/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Table/_Table"), "<control><alt>t", general_html_menu_cb, 24, "<ImageItem>", pixmap_table2},
> 	{N_("/Tags/Table/Table _Row"), NULL, general_html_menu_cb, 25, "<ImageItem>", pixmap_table_tr2},
> 	{N_("/Tags/Table/Table _Header"), NULL, general_html_menu_cb, 26, "<ImageItem>", pixmap_table_th2},
> 	{N_("/Tags/Table/Table _Data"), NULL, general_html_menu_cb, 27, "<ImageItem>", pixmap_table_td2},
> 	{N_("/Tags/Table/Table _Caption"), NULL, general_html_menu_cb, 28, "<ImageItem>", pixmap_table_capt},
> 	{N_("/Tags/_List"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/List/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/List/Unordered _List"), "<control><alt>L", general_html_menu_cb, 33, "<ImageItem>", pixmap_list_ul},
> 	{N_("/Tags/List/_Ordered List"), "<control><alt>O", general_html_menu_cb, 34, "<ImageItem>", pixmap_list_ol},
> 	{N_("/Tags/List/List Ite_m"), "<control><alt>M", general_html_menu_cb, 35, "<ImageItem>", pixmap_list_li},
> 	{N_("/Tags/List/De_finition List"), NULL, general_html_menu_cb, 36, "<ImageItem>", pixmap_list_dl},
> 	{N_("/Tags/List/Definition _Term"), NULL, general_html_menu_cb, 37, "<ImageItem>", pixmap_list_dt},
> 	{N_("/Tags/List/_Definition"), NULL, general_html_menu_cb, 38, "<ImageItem>", pixmap_list_dd},
> 	{N_("/Tags/List/Men_u"), NULL, general_html_menu_cb, 39, "<Item>"},
> 	{N_("/Tags/Fo_rm"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Form/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Form/_Form"), NULL, general_html_menu_cb, 67, "<ImageItem>", pixmap_form},
> 	{N_("/Tags/Form/_Button"), NULL, general_html_menu_cb, 58, "<Item>"},
> 	{N_("/Tags/Form/_Input"), NULL, general_html_menu_cb, 65, "<Item>"},
> 	{N_("/Tags/Form/_Textarea"), NULL, general_html_menu_cb, 66, "<Item>"},
> /*	{N_("/Tags/Form/"), NULL, general_html_menu_cb, , "<Item>"},*/
> 	{N_("/Tags/_Misc"), NULL, NULL, 0, "<Branch>"},
> 	{"/Tags/Misc/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Tags/Misc/Insert Generator _META-Tag"), NULL, general_html_menu_cb, 47, "<Item>"},
> 	{N_("/Tags/Misc/_Span"), NULL, general_html_menu_cb, 60, "<Item>"},
> 	{N_("/Tags/Misc/_Div"), NULL, general_html_menu_cb, 62, "<Item>"},
> 	{N_("/Tags/Misc/_Link"), NULL, general_html_menu_cb, 61, "<Item>"},
> 	{N_("/Tags/Misc/S_cript"), NULL, general_html_menu_cb, 59, "<Item>"},
> 	{N_("/Tags/Misc/_Anchor"), NULL, general_html_menu_cb, 63, "<ImageItem>", pixmap_anchor},
> 	{N_("/Tags/Misc/_Image"), NULL, general_html_menu_cb, 64, "<ImageItem>", pixmap_image},
> /*	{N_("/Tags/Misc/"), NULL, general_html_menu_cb, , "<Item>"},*/
> 	{N_("/Tags/_Comment"), "<control><alt>C", general_html_menu_cb, 10, "<ImageItem>", pixmap_comment},
> 	{N_("/Dial_ogs"), NULL, NULL, 0, "<Branch>"},
> 	{"/Dialogs/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Dialogs/_General"), NULL, NULL, 0, "<Branch>"},
> 	{"/Dialogs/General/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Dialogs/General/_Quickstart..."), "<shift><alt>q", menu_html_dialogs_lcb, 32, "<ImageItem>", pixmap_quick_start},
> /*	{N_("/Dialogs/General/DTD"), NULL, dtd_cb, 0, NULL},
> 	{N_("/Dialogs/General/Head"), NULL, head_cb, 0, NULL}, */
> 	{N_("/Dialogs/General/_Link Header..."), NULL, menu_html_dialogs_lcb, 35, "<Item>"},
> 	{N_("/Dialogs/General/_Body..."), "<shift><alt>B", menu_html_dialogs_lcb, 1, "<ImageItem>", pixmap_body},
> 	{N_("/Dialogs/General/_Anchor..."), "<shift><alt>a", menu_html_dialogs_lcb, 2, "<ImageItem>", pixmap_anchor},
> 	{N_("/Dialogs/General/_Email..."), "<shift><alt>e", menu_html_dialogs_lcb, 3, "<Item>"},
> 	{N_("/Dialogs/General/_Rule..."), "<shift><alt>r", menu_html_dialogs_lcb, 4, "<ImageItem>", pixmap_hrule},
> 	{N_("/Dialogs/General/_Font..."), "<shift><alt>f", menu_html_dialogs_lcb, 5, "<Item>"},
> 	{N_("/Dialogs/General/Basef_ont..."), NULL, menu_html_dialogs_lcb, 6, "<Item>"},
> 	{N_("/Dialogs/General/Quick_list..."), "<shift><alt>L", menu_html_dialogs_lcb, 7, "<ImageItem>", pixmap_list},
> 	{N_("/Dialogs/General/_Meta..."), "<shift><alt>m", menu_html_dialogs_lcb, 8, "<Item>"},
> 	{N_("/Dialogs/General/Embe_d..."), NULL, menu_html_dialogs_lcb, 9, "<Item>"},
> 	{N_("/Dialogs/General/Select _Color..."), NULL, menu_html_dialogs_lcb, 38, "<Item>"},
> 	{N_("/Dialogs/General/Insert _Time..."), NULL, menu_html_dialogs_lcb, 34, "<Item>"},
> 	{N_("/Dialogs/General/Insert _Image..."), "<shift><alt>I", menu_html_dialogs_lcb, 10, "<ImageItem>", pixmap_image},
> 	{N_("/Dialogs/General/Insert T_humbnail..."), "<shift><alt>N", menu_html_dialogs_lcb, 11, "<ImageItem>", pixmap_thumbnail},
> 	{N_("/Dialogs/_Table"), NULL, NULL, 0, "<Branch>"},
> 	{"/Dialogs/Table/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Dialogs/Table/Table _Wizard..."), NULL, menu_html_dialogs_lcb, 12, "<ImageItem>", pixmap_tablewhiz},
> 	{N_("/Dialogs/Table/_Table..."), "<shift><alt>T", menu_html_dialogs_lcb, 13, "<ImageItem>", pixmap_table},
> 	{N_("/Dialogs/Table/Table _Row..."), NULL, menu_html_dialogs_lcb, 14, "<ImageItem>", pixmap_table_tr},
> 	{N_("/Dialogs/Table/Table _Head..."), NULL, menu_html_dialogs_lcb, 15, "<ImageItem>", pixmap_table_th},
> 	{N_("/Dialogs/Table/Table _Data..."), NULL, menu_html_dialogs_lcb, 16, "<ImageItem>", pixmap_table_td},
> 	{N_("/Dialogs/_CSS"), NULL, NULL, 0, "<Branch>"},
> 	{"/Dialogs/CSS/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Dialogs/CSS/_Create Style..."), "<shift><alt>S", menu_html_dialogs_lcb, 37, "<ImageItem>",pixmap_cssnewstyle},
> 	{N_("/Dialogs/CSS/S_pan..."), NULL, menu_html_dialogs_lcb, 17, "<ImageItem>",pixmap_cssspan},
> 	{N_("/Dialogs/CSS/_Div..."), "<shift><alt>D", menu_html_dialogs_lcb, 18, "<ImageItem>",pixmap_cssdiv},
> 	{N_("/Dialogs/CSS/_Style..."), NULL, general_html_menu_cb, 42, "<ImageItem>",pixmap_cssstyle},
> 	{N_("/Dialogs/CSS/_Link to Stylesheet..."), NULL, menu_html_dialogs_lcb, 36, "<Item>"},
> 	{N_("/Dialogs/_Frame"), NULL, NULL, 0, "<Branch>"},
> 	{"/Dialogs/Frame/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Dialogs/Frame/Frame _Wizard..."), NULL, menu_html_dialogs_lcb, 19, "<ImageItem>", pixmap_framewhiz},
> 	{N_("/Dialogs/Frame/Frame_set..."), NULL, menu_html_dialogs_lcb, 20, "<ImageItem>", pixmap_frameset},
> 	{N_("/Dialogs/Frame/_Frame..."), NULL, menu_html_dialogs_lcb, 21, "<ImageItem>", pixmap_frame},
> 	{N_("/Dialogs/F_orm"), NULL, NULL, 0, "<Branch>"},
> 	{"/Dialogs/Form/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Dialogs/Form/F_orm..."), NULL, menu_html_dialogs_lcb, 22, "<ImageItem>", pixmap_form},
> 	{N_("/Dialogs/Form/_Input..."), NULL, menu_html_dialogs_lcb, 33, "<Item>"},
> 	{N_("/Dialogs/Form/Input Buttons..."), NULL, menu_html_dialogs_lcb, 23, "<ImageItem>", pixmap_form_submit},
> 	{N_("/Dialogs/Form/Input Text..."), NULL, menu_html_dialogs_lcb, 24, "<ImageItem>", pixmap_form_text},
> 	{N_("/Dialogs/Form/Text_area..."), NULL, menu_html_dialogs_lcb, 26, "<ImageItem>", pixmap_form_textarea},
> 	{N_("/Dialogs/Form/_Select..."), NULL, menu_html_dialogs_lcb, 29, "<ImageItem>", pixmap_form_select},
> 	{N_("/Dialogs/Form/O_ption..."), NULL, menu_html_dialogs_lcb, 30, "<ImageItem>", pixmap_form_option},
> 	{N_("/Dialogs/Form/Option _Group..."), NULL, menu_html_dialogs_lcb, 31, "<ImageItem>",pixmap_form_optiongroup },
> 	{N_("/Dialogs/Form/_Button..."), NULL, menu_html_dialogs_lcb, 25, "<Item>"},
> /*	{N_("/Dialogs/Javascript"), NULL, NULL, 0, "<Branch>"},
> 	{"/Dialogs/Javascript/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Dialogs/Javascript/Mouseover Script"), NULL, mouseover_script_cb, 0, NULL},
> 	{N_("/Dialogs/Javascript/Netscape 4 Resize Bugfix Script"), NULL, ns47_bugfix_script_cb, 0, NULL},
> 	{N_("/Dialogs/Javascript/Image Preload Script"), NULL, imagepreload_script_cb, 0, NULL},
> 	{N_("/Dialogs/_WML"), NULL, NULL, 0, "<Branch>"},
> 	{"/Dialogs/WML/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Dialogs/WML/Standard Document"), NULL, general_wml_cb, 6, NULL},
> 	{N_("/Dialogs/WML/Card..."), NULL, carddialog_cb, 0, NULL},
> 	{N_("/Dialogs/WML/Postfield..."), NULL, postfielddialog_cb, 0, NULL},
> 	{N_("/Dialogs/WML/Go..."), NULL, godialog_cb, 0, NULL},
> 	{N_("/Dialogs/WML/Do..."), NULL, dodialog_cb, 0, NULL},
> 	{N_("/Dialogs/WML/Anchor..."), NULL, anchordialog_cb, 0, NULL},
> 	{N_("/Dialogs/WML/Access..."), NULL, accessdialog_cb, 0, NULL},
> 	{"/Dialogs/WML/sep11", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Dialogs/WML/Paragraph"), NULL, general_wml_cb, 1, NULL},
> 	{N_("/Dialogs/WML/Line Break"), NULL, general_wml_cb, 2, NULL},
> 	{N_("/Dialogs/WML/Italic"), NULL, general_wml_cb, 3, NULL},
> 	{N_("/Dialogs/WML/Non-Breaking Space"), NULL, general_wml_cb, 4, NULL},
> 	{N_("/Dialogs/WML/Bold"), NULL, general_wml_cb, 5, NULL},
> 	{"/Dialogs/WML/sep12", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Dialogs/WML/Prev"), NULL, general_wml_cb, 7, NULL},
> 	{N_("/Dialogs/WML/Refresh"), NULL, general_wml_cb, 8, NULL},
> 	{N_("/Dialogs/WML/Noop"), NULL, general_wml_cb, 9, NULL},
> 	{"/Dialogs/WML/sep13", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Dialogs/WML/Set Variable..."), NULL, vardialog_cb, 0, NULL},*/
> 	{"/Dialogs/sep1", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Dialogs/_Edit tag under cursor..."), "F3", menu_html_dialogs_lcb, 39, "<ImageItem>", pixmap_edit_tag},
> 	{N_("/_Document"), NULL, NULL, 0, "<Branch>"},
> 	{"/Document/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Document/_Increase Tabsize"), NULL, gui_change_tabsize, 1, "<Item>"},
> 	{N_("/Document/_Decrease Tabsize"), NULL, gui_change_tabsize, 0, "<Item>"},
> 	{N_("/Document/_Auto Indent"), NULL, toggle_doc_property, 4, "<ToggleItem>"},
> 	{"/Document/sep1", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Document/Auto Close H_TML tags"), "<control>T", toggle_doc_property, 3, "<ToggleItem>"},
> 	{N_("/Document/_Wrap"), NULL, toggle_doc_property, 1, "<ToggleItem>"},
> 	{N_("/Document/_Line Numbers"), NULL, toggle_doc_property, 2, "<ToggleItem>"},
> 	{"/Document/sep2", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Document/_Highlight Syntax"), NULL, doc_toggle_highlighting_cb, 1, "<ToggleItem>"},
> 	{N_("/Document/_Update Highlighting"), "F5", doc_update_highlighting, 0, "<Item>"},
> 	{"/Document/sep3", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Document/Document Ty_pe"), NULL, NULL, 0, "<Branch>"},
> 	{"/Document/Document Type/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Document/Character _Encoding"), NULL, NULL, 0, "<Branch>"},
> 	{"/Document/Character Encoding/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{"/Document/sep4", NULL, NULL, 0, "<Separator>"},
> #ifdef HAVE_LIBASPELL
> 	{N_("/Document/Check _Spelling..."), NULL, spell_check_menu_cb, 0, "<StockItem>", GTK_STOCK_SPELL_CHECK},
> #endif /* HAVE_LIBASPELL */
> 	{N_("/Document/_Floating window"), NULL, file_floatingview_menu_cb, 1, "<Item>"},			
> 	{N_("/Document/Word _Count"), NULL, word_count_cb, 1, "<Item>"},
> 	{N_("/_Go"), NULL, NULL, 0, "<Branch>"},
> 	{"/Go/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Go/_Previous document"), NULL, gui_notebook_switch, 1, "<StockItem>", GTK_STOCK_GO_BACK},
> 	{N_("/Go/_Next document"), NULL, gui_notebook_switch, 2, "<StockItem>", GTK_STOCK_GO_FORWARD},
> 	{"/Go/sep1", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Go/_First document"), NULL, gui_notebook_switch, 3, "<StockItem>", GTK_STOCK_GOTO_FIRST},
> 	{N_("/Go/L_ast document"), NULL, gui_notebook_switch, 4, "<StockItem>", GTK_STOCK_GOTO_LAST},
> 	{"/Go/sep2", NULL, NULL, 0, "<Separator>"},	
> 	{N_("/Go/Goto _Line"), "<control>l", go_to_line_win_cb, 1, "<StockItem>", GTK_STOCK_JUMP_TO},
> 	{N_("/Go/Goto _Selection"), NULL, go_to_line_from_selection_cb, 1, "<Item>"},
> 	{N_("/_Project"), NULL, NULL, 0, "<Branch>"},
> 	{"/Project/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/Project/_New Project"), NULL, project_menu_cb, 6, "<Item>"},
> 	{N_("/Project/_Open Project..."), NULL, project_menu_cb, 1, "<Item>"},
> 	{N_("/Project/Open _recent"), NULL, NULL, 0, "<Branch>"},		
> 	{"/Project/Open recent/tearoff1", NULL, NULL, 0, "<Tearoff>"},	
> 	{"/Project/sep1", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Project/_Save"), NULL, project_menu_cb, 2, "<Item>"},
> 	{N_("/Project/Save _as..."), NULL, project_menu_cb, 3, "<Item>"},
> 	{N_("/Project/Save & _close"), NULL, project_menu_cb, 4, "<Item>"},
> 	{"/Project/sep2", NULL, NULL, 0, "<Separator>"},
> 	{N_("/Project/E_dit Project Options..."), NULL, project_menu_cb, 5, "<StockItem>", GTK_STOCK_PREFERENCES},
> 	{N_("/E_xternal"), NULL, NULL, 0, "<Branch>"},
> 	{"/External/tearoff1", NULL, NULL, 0, "<Tearoff>"}, 
> /*	{N_("/External/_Commands"), NULL, NULL, 0, "<Branch>"},
> 	{"/External/Commands/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{N_("/External/_Outputbox"), NULL, NULL, 0, "<Branch>"},
> 	{"/External/Outputbox/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 	{"/External/sep1", NULL, NULL, 0, "<Separator>"},*/
> 	{N_("/_Help"), NULL, NULL, 0, "<Branch>"},
> 	{N_("/Help/_About..."), NULL, about_dialog_create, 0, "<Item>"},	
> };
> 
> #ifdef ENABLE_NLS
> gchar *menu_translate(const gchar * path, gpointer data) {
> 	gchar *retval;
> /*	static gchar *menupath = NULL;
> 	if (menupath) g_free(menupath);
> 	menupath = g_strdup(path);
> 	if ((strstr(path, "/tearoff1") != NULL) 
> 			|| (strstr(path, "/---") != NULL) 
> 			|| (strstr(path, "/sep1") != NULL)) {
> 		DEBUG_MSG("menu_translate, nogettext returning %s for %s\n", menupath, path);
> 		return menupath;
> 	}*/
> 	retval = gettext(path);
> 	return retval;
> }
> #endif       
> 
> /************************************************/
> /* generic functions for dynamic created menu's */
> /************************************************/
> 
> typedef struct {
> 	Tbfwin *bfwin;
> 	GtkWidget *menuitem;
> 	gpointer data;
> 	gulong signal_id;
> } Tbfw_dynmenu;
> #define BFW_DYNMENU(var) ((Tbfw_dynmenu *)(var))
> 
> static Tbfw_dynmenu *find_bfw_dynmenu_by_data_in_list(GList *thelist, gpointer data) {
> 	GList *tmplist = g_list_first(thelist);
> 	while (tmplist) {
> 		if (BFW_DYNMENU(tmplist->data)->data == data) return BFW_DYNMENU(tmplist->data);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return NULL;
> }
> 
> /*
> NOT IN USE
> static Tbfw_dynmenu *find_bfw_dynmenu_by_label_in_list(GList *itemlist, gchar *label) {
> 	GList *tmplist;
> 
> 	tmplist = g_list_first(itemlist);
> 	while (tmplist) {
> 		if(!strcmp(GTK_LABEL(GTK_BIN(BFW_DYNMENU(tmplist->data)->menuitem)->child)->label, label)) {
> 			return BFW_DYNMENU(tmplist->data);
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return NULL;
> }
> */
> 
> static GtkWidget *remove_menuitem_in_list_by_label(const gchar *labelstring, GList **menuitemlist) {
> 	GList *tmplist;
> 	gpointer tmp;
> 
> 	tmplist = g_list_first(*menuitemlist);
> 	while (tmplist) {
> 		DEBUG_MSG("remove_recent_entry, tmplist=%p, data=%p\n", tmplist, tmplist->data);
> 		DEBUG_MSG("remove_recent_entry, tmplist->data=%s\n",GTK_LABEL(GTK_BIN(tmplist->data)->child)->label);
> 		if(!strcmp(GTK_LABEL(GTK_BIN(tmplist->data)->child)->label, labelstring)) {
> 			tmp = tmplist->data;
> 			*menuitemlist = g_list_remove(*menuitemlist, tmplist->data);
> 			DEBUG_MSG("remove_recent_entry, returning %p\n", tmp);
> 			return tmp;
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return NULL;
> }
> 
> /* the result of this function can be added to the menuitem-list */
> static GtkWidget *create_dynamic_menuitem(Tbfwin *bfwin, gchar *menubasepath, const gchar *label, GCallback callback, gpointer data, gint menu_insert_offset) {
> 	GtkWidget *tmp, *menu;
> 	GtkItemFactory *factory;
> 
> 	/* add it to bfwin->menubar */
> 	factory = gtk_item_factory_from_widget(bfwin->menubar);
> 	menu = gtk_item_factory_get_widget(factory, menubasepath);
> 	DEBUG_MSG("create_dynamic_menuitem, menubar=%p, menu=%p basepath=%s, label=%s\n", bfwin->menubar, menu, menubasepath,label);
> 	if (menu != NULL) {
> 		tmp = gtk_menu_item_new_with_label(label);
> 		g_signal_connect(G_OBJECT(tmp), "activate",callback, data);
> 
> 		gtk_widget_show(tmp);
> 		if (menu_insert_offset == -1) {
> 			gtk_menu_shell_append(GTK_MENU_SHELL(menu),tmp);
> 		} else {
> 			gtk_menu_shell_insert(GTK_MENU_SHELL(menu),tmp,menu_insert_offset);
> 		}
> 		return tmp;
> 	} else {
> 		DEBUG_MSG("create_dynamic_menuitem, NO MENU FOR BASEPATH %s\n", menubasepath);
> 		return NULL;
> 	}
> }
> 
> static void create_parent_and_tearoff(gchar *menupath, GtkItemFactory *ifactory) {
> 	char *basepath;
> 	GtkWidget *widg=NULL;
> 	GtkItemFactoryEntry entry;
> 
> 	basepath = g_strndup(menupath, (strlen(menupath) - strlen(strrchr(menupath, '/'))));
> 	DEBUG_MSG("create_parent_and_tearoff, basepath=%s for menupath=%s\n", basepath, menupath);
> 	widg = gtk_item_factory_get_widget(ifactory, basepath);
> 	if (!widg) {
> 		DEBUG_MSG("create_parent_and_tearoff, no widget found for %s, will create it\n", basepath);
> 		create_parent_and_tearoff(basepath, ifactory);
> 		entry.path = g_strconcat(basepath, "/tearoff1", NULL);
> 		entry.accelerator = NULL;
> 		entry.callback = NULL;
> 		entry.callback_action = 0;
> 		entry.item_type = "<Tearoff>";
> 		gtk_item_factory_create_item(ifactory, &entry, NULL, 2);
> 		g_free(entry.path);
> 	}
> 	g_free(basepath);
> }	
> 
> static void menu_current_document_type_change(GtkMenuItem *menuitem,Tbfw_dynmenu *bdm) {
> 	DEBUG_MSG("menu_current_document_type_change, started for hlset %p\n", bdm->data);
> 	if (GTK_CHECK_MENU_ITEM(menuitem)->active) {
> 		if (doc_set_filetype(bdm->bfwin->current_document, bdm->data)) {
> 			doc_highlight_full(bdm->bfwin->current_document);
> 		} else {
> 			menu_current_document_set_toggle_wo_activate(bdm->bfwin,bdm->bfwin->current_document->hl, NULL);
> 		}
> 	}
> 	doc_set_statusbar_editmode_encoding(bdm->bfwin->current_document);
> 	DEBUG_MSG("menu_current_document_type_change, finished\n");
> }
> 
> void filetype_menus_empty() {
> 	GList *tmplist = g_list_first(main_v->bfwinlist);
> 	while (tmplist) {
> 		Tbfwin *bfwin = BFWIN(tmplist->data);
> 		GList *tmplist2 = g_list_first(bfwin->menu_filetypes);
> 		while (tmplist2) {
> 			Tbfw_dynmenu *bdm = BFW_DYNMENU(tmplist2->data);
> 			g_signal_handler_disconnect(bdm->menuitem,bdm->signal_id);
> 			gtk_widget_destroy(bdm->menuitem);
> 			g_free(bdm);
> 			tmplist2 = g_list_next(tmplist2);
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> void filetype_menu_rebuild(Tbfwin *bfwin,GtkItemFactory *item_factory) {
> 	GSList *group=NULL;
> 	GtkWidget *parent_menu;
> 	GList *tmplist = g_list_last(main_v->filetypelist);
> 	if (!item_factory) {
> 		item_factory = gtk_item_factory_from_widget(bfwin->menubar);
> 	}
> 	DEBUG_MSG("filetype_menu_rebuild, adding filetypes in menu\n");
> 	bfwin->menu_filetypes = NULL;
> 	parent_menu = gtk_item_factory_get_widget(item_factory, N_("/Document/Document Type"));
> 	while (tmplist) {
> 		Tfiletype *filetype = (Tfiletype *)tmplist->data;
> 		if (filetype->editable) {
> 			Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
> 			bdm->data = filetype;
> 			bdm->bfwin = bfwin;
> 			bdm->menuitem = gtk_radio_menu_item_new_with_label(group, filetype->type);
> 			bdm->signal_id = g_signal_connect(G_OBJECT(bdm->menuitem), "activate",G_CALLBACK(menu_current_document_type_change), (gpointer) bdm);
> 			gtk_widget_show(bdm->menuitem);
> 			gtk_menu_insert(GTK_MENU(parent_menu), bdm->menuitem, 1);
> 			group = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(bdm->menuitem));
> 			bfwin->menu_filetypes = g_list_append(bfwin->menu_filetypes, bdm);
> 		}
> 		tmplist = g_list_previous(tmplist);
> 	}
> }
> 
> /* 
>  * menu factory crap, thanks to the gtk tutorial for this
>  * both the 1.0 and the 1.2 code is directly from the tutorial
>  */
> void menu_create_main(Tbfwin *bfwin, GtkWidget *vbox) {
> 	GtkItemFactory *item_factory;
> 	GtkAccelGroup *accel_group;
> 	gint nmenu_items = sizeof(menu_items) / sizeof(menu_items[0]);
> 	accel_group = gtk_accel_group_new();
> 	item_factory = gtk_item_factory_new(GTK_TYPE_MENU_BAR, "<bluefishmain>", accel_group);
> #ifdef ENABLE_NLS
> 	gtk_item_factory_set_translate_func(item_factory, menu_translate, "<bluefishmain>", NULL);
> #endif
> 	gtk_item_factory_create_items(item_factory, nmenu_items, menu_items, bfwin);
> 	gtk_window_add_accel_group(GTK_WINDOW(bfwin->main_window), accel_group);
> 	bfwin->menubar = gtk_item_factory_get_widget(item_factory, "<bluefishmain>");
> 	gtk_box_pack_start(GTK_BOX(vbox), bfwin->menubar, FALSE, TRUE, 0);
> 	gtk_accel_map_add_entry("<bluefishmain>/Edit/Shift Right", GDK_period, GDK_CONTROL_MASK);
> 	gtk_accel_map_add_entry("<bluefishmain>/Edit/Shift Left", GDK_comma, GDK_CONTROL_MASK);
> 	gtk_accel_map_add_entry("<bluefishmain>/Go/Previous document", GDK_Page_Up, GDK_CONTROL_MASK);
> 	gtk_accel_map_add_entry("<bluefishmain>/Go/Next document", GDK_Page_Down, GDK_CONTROL_MASK);
> 	gtk_accel_map_add_entry("<bluefishmain>/Go/First document", GDK_Page_Up, GDK_SHIFT_MASK | GDK_CONTROL_MASK);
> 	gtk_accel_map_add_entry("<bluefishmain>/Go/Last document", GDK_Page_Down, GDK_SHIFT_MASK | GDK_CONTROL_MASK);	
> 	gtk_widget_show(bfwin->menubar);
> 
>     setup_toggle_item(item_factory, "/View/View Main Toolbar", bfwin->session->view_main_toolbar);
>     setup_toggle_item(item_factory, "/View/View HTML Toolbar", bfwin->session->view_html_toolbar);
>     setup_toggle_item(item_factory, "/View/View Custom Menu", bfwin->session->view_custom_menu);
>     setup_toggle_item(item_factory, "/View/View Sidebar", bfwin->session->view_left_panel);	
> 	setup_toggle_item(item_factory, "/Document/Auto Indent", main_v->props.autoindent);
> 	set_project_menu_widgets(bfwin, FALSE);
> 	filetype_menu_rebuild(bfwin, item_factory);
> }
> 
> 
> /*************************************************************/
> /*               Output Box handling                         */
> /*************************************************************/
> static GtkWidget *dynamic_menu_append_spacing(Tbfwin *bfwin, gchar *basepath) {
> 	GtkItemFactory *factory;
> 	GtkWidget *menu, *menuitem;
> 	factory = gtk_item_factory_from_widget(bfwin->menubar);
> 	menu = gtk_item_factory_get_widget(factory, basepath);
> 	menuitem = gtk_menu_item_new();
> 	gtk_widget_show(menuitem);
> 	gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);
> 	return menuitem;
> }
> 
> static void menu_outputbox_lcb(GtkMenuItem *menuitem,Tbfw_dynmenu *bdm) {
> 	gchar **arr = (gchar **)bdm->data;
> 	outputbox(bdm->bfwin,arr[1], atoi(arr[2]), atoi(arr[3]), atoi(arr[4]), arr[5], (arr[6][0]=='1'));
> }
> 
> /*******************************************************************/
> /*               Open Recent menu handling                         */
> /*******************************************************************/
> /* the only required header */
> static GtkWidget *create_recent_entry(Tbfwin *bfwin, const gchar *filename, gboolean is_project, gboolean check_for_duplicates);
> /*******************************************************************/
> 
> static GtkWidget *remove_recent_entry(Tbfwin *bfwin, const gchar *filename, gboolean is_project) {
> 	GList *tmplist;
> 	GList **worklist;
> 	gpointer tmp;
> 
> 	worklist = (is_project) ? &bfwin->menu_recent_projects : &bfwin->menu_recent_files;
> 
> 	if(strcmp(filename, "last") ==0) {
> 		tmplist = g_list_first(*worklist);
> 		if (tmplist) {
> 			tmp = tmplist->data;
> 			DEBUG_MSG("remove_recent_entry, remove last entry\n");
> 			*worklist = g_list_remove(*worklist, tmplist->data);
> 			return tmp;
> 		} else {
> 			DEBUG_MSG("remove_recent_entry, worklist contained no items, returning NULL\n");
> 			return NULL;
> 		}
> 	}	else {
> 		return remove_menuitem_in_list_by_label(filename, worklist);
> 	}
> }
> 
> static void open_recent_project_cb(GtkWidget *widget, Tbfwin *bfwin) {
> 	gchar *filename = GTK_LABEL(GTK_BIN(widget)->child)->label;
> 	DEBUG_MSG("open_recent_project_cb, started, filename is %s\n", filename);
> 	project_open_from_file(bfwin, filename);
> 	add_to_recent_list(bfwin,filename, 0, TRUE);
> }
> 
> /* open_recent_file
>  * This function should be called when a menu from the Open Recent list
>  * has been selected. */
> static void open_recent_file_cb(GtkWidget *widget, Tbfwin *bfwin) {
> 	gboolean success;
> 	gchar *filename = GTK_LABEL(GTK_BIN(widget)->child)->label;
> 	DEBUG_MSG("open_recent_file_cb, started, filename is %s\n", filename);
> 
> 	statusbar_message(bfwin,_("Loading file(s)..."),2000);
> 	flush_queue();
> 	success = (doc_new_with_file(bfwin,filename, FALSE, FALSE) != NULL);
> 	if (!success) {
> 		gchar *message = g_strconcat(_("The filename was:\n"), filename, NULL);
> 		warning_dialog(bfwin->main_window,_("Could not open file\n"), message);
> 		g_free(message);
> 		return;
> 	}
> 	DEBUG_MSG("open_recent_file_cb, document %s opened\n", filename);
> 	add_to_recent_list(bfwin,filename, 0, FALSE);
> }
> 
> /* create_recent_entry
>  * This function builds the gtkitemfactoryentry and inserts it at the
>  * bfwin->menubar. Furthermore, it returns a pointer to it, so that
>  * this pointer can be added in the main_v->recent_files list */
> static GtkWidget *create_recent_entry(Tbfwin *bfwin, const gchar *filename, gboolean is_project, gboolean check_for_duplicates) {
> 	GtkWidget *tmp;
> 
> 	if (check_for_duplicates) {
> 		tmp = remove_recent_entry(bfwin,filename,is_project);
> 		if (tmp) {
> 			gtk_widget_hide(tmp);
> 			gtk_widget_destroy(tmp);
> 		}
> 	}
> 	if (is_project) {
> 		return  create_dynamic_menuitem(bfwin,N_("/Project/Open recent")
> 			, filename, G_CALLBACK(open_recent_project_cb), bfwin
> 			, 1);
> 	} else {
> 		return  create_dynamic_menuitem(bfwin,N_("/File/Open recent")
> 			, filename, G_CALLBACK(open_recent_file_cb), bfwin
> 			, 1);
> 	}
> }
> 
> GList *recent_menu_from_list(Tbfwin *bfwin, GList *startat, gboolean is_project) {
> 	GList *retlist=NULL, *tmplist=startat;
> 	while (tmplist) {
> 		DEBUG_MSG("recent_menu_init, adding recent project %s\n",(gchar *)tmplist->data);
> 		retlist = g_list_append(retlist, create_recent_entry(bfwin,tmplist->data,is_project,FALSE));
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return retlist;
> }
> 
> /* void recent_menu_from_file(Tbfwin *bfwin, gchar *file_name, gboolean is_project) {
> 	gchar *filename;
> 	GList *inputlist, *recentfiles=NULL, *tmplist, **worklist;
> 	gint num;
> 	worklist = (is_project) ? &bfwin->menu_recent_projects : &bfwin->menu_recent_files;
> 	/ * empty any existing menu * /
> 	tmplist = g_list_first(*worklist);
> 	while (tmplist) {
> 		gtk_widget_destroy(tmplist->data);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	
> 	filename = g_strconcat(g_get_home_dir(), file_name, NULL);
> 	inputlist = get_stringlist(filename, NULL);
> 	/ * the last entry in inputlist is the most recent file * /
> 	tmplist = g_list_first(inputlist);
> 	while (tmplist) {
> 		recentfiles = add_to_history_stringlist(recentfiles, (gchar *)tmplist->data, TRUE);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	free_stringlist(inputlist);
> 	num = g_list_length(recentfiles) - main_v->props.max_recent_files;
> 	*worklist = recent_menu_from_list(bfwin, g_list_nth(recentfiles, (num > 0)?num:0), is_project);
> 	put_stringlist_limited(filename, recentfiles, main_v->props.max_recent_files);
> 	free_stringlist(recentfiles);
> 	g_free(filename);
> }*/
> 
> /* recent_menu_init()
>  * Gets the list of documents from .bluefish/recentlist and inserts
>  * it at the File-->Open Recent menu. If the file doesn't exist (probably
>  * because this is the first time Bluefish is running) then a menu
>  * item telling that no recent files exist will appear */
> void recent_menu_init(Tbfwin *bfwin) {
> /*	recent_menu_from_file(bfwin, "/.bluefish/recentlist", FALSE);
> 	recent_menu_from_file(bfwin, "/.bluefish/recentprojects", TRUE);*/
> 	recent_menu_from_list(bfwin, bfwin->session->recent_files, FALSE);
> 	recent_menu_from_list(bfwin, main_v->globses.recent_projects, TRUE);
> }
> 
> /* when a project is opened, the recent menu should show the recent files
> from that project */
> void recent_menu_init_project(Tbfwin *bfwin) {
> 	gint num;
> 	GList *tmplist = g_list_first(bfwin->menu_recent_files);
> 	while (tmplist) {
> 		gtk_widget_destroy(tmplist->data);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	num = g_list_length(bfwin->session->recent_files) - main_v->props.max_recent_files;
> 	bfwin->menu_recent_files = recent_menu_from_list(bfwin, g_list_nth(bfwin->session->recent_files, (num > 0)?num:0), FALSE);
> }
> 
> /* Add_to_recent_list
>  * This should be called when a new file is opened, i.e. from
>  * file_open_cb, it adds a new entry which also appears in the
>  * menu bar, and (if nessecary) deletes the last entry */
> void add_to_recent_list(Tbfwin *bfwin,gchar *filename, gint closed_file, gboolean is_project) {
> 	DEBUG_MSG("add_to_recent_list, started for %s\n", filename);
> 	if (closed_file) {
> 		GList *tmplist = g_list_first(main_v->bfwinlist);
> 		while (tmplist) {
> 			Tbfwin *curbfwin = BFWIN(tmplist->data);
> 			if (!curbfwin->project || curbfwin == bfwin || is_project) {
> 				GtkWidget *tmp;
> 				GList **worklist;
> 				worklist = (is_project) ? &curbfwin->menu_recent_projects : &curbfwin->menu_recent_files;
> 				
> 				/* First of all, create the entry and insert it at the list*/
> 				*worklist = g_list_append(*worklist,create_recent_entry(curbfwin,filename,is_project,TRUE));
> 	
> 				DEBUG_MSG("add_to_recent_list, inserted item in menu\n");
> 				if(g_list_length(*worklist) > main_v->props.max_recent_files) {
> 					tmp = remove_recent_entry(bfwin,"last",is_project);
> 					if (tmp) {
> 						DEBUG_MSG("add_to_recent_list, list too long, entry %s to be deleted\n", GTK_LABEL(GTK_BIN(tmp)->child)->label);
> 						gtk_widget_hide(tmp);
> 						gtk_widget_destroy(tmp);
> 					}
> 				}
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	if (is_project) {
> 		main_v->globses.recent_projects = add_to_history_stringlist(main_v->globses.recent_projects, filename, FALSE,TRUE);
> 	} else {
> 		bfwin->session->recent_files = add_to_history_stringlist(bfwin->session->recent_files, filename, FALSE,TRUE);
> 	}
> 
> 
> /*	} else {
> 		/ * once we get rid of the other ways to store recent files this will be the only line we still need * /
> 		if (is_project) {
> 			main_v->globses.recent_projects = add_to_history_stringlist(main_v->globses.recent_projects, filename, TRUE);
> 		} else {
> 			bfwin->session->recent_files = add_to_history_stringlist(bfwin->session->recent_files, filename, TRUE);
> 		}
> 		DEBUG_MSG("add_to_recent_list, added to session recent_files, length=%d\n",g_list_length(bfwin->session->recent_files));
> 		if (bfwin->project) {
> 			/ * we do nothing when the file is opened, since opened files are anyway opened again in a project * /
> 		} else {
> 			gchar *tmpfilename, *recentfile;
> 			recentfile = g_strconcat(g_get_home_dir(), (is_project) ? "/.bluefish/recentprojects" : "/.bluefish/recentlist", NULL);
> 			/ * save the new list * /
> 			tmpfilename = g_strconcat(filename, "\n", NULL);
> 			DEBUG_MSG("add_to_recent_list, trying to append to %s\n", recentfile);
> 			append_string_to_file(recentfile, tmpfilename);
> 			g_free(recentfile);
> 			g_free(tmpfilename);
> 		}
> 		* /
> 	} */
> }
> /*****************/
> /* Windows !!    */
> /*****************/
> 
> static void remove_all_window_entries_in_window(Tbfwin *menubfwin) {
> 	GList *tmplist = g_list_first(menubfwin->menu_windows);
> 	DEBUG_MSG("removing all window entries in menubfwin %p\n",menubfwin);
> 	while (tmplist) {
> 		Tbfw_dynmenu *bdm = BFW_DYNMENU(tmplist->data);
> 		/*g_signal_handler_disconnect(bdm->menuitem,bdm->signal_id);*/
> 		DEBUG_MSG("remove_all_window_entries_in_window, destroy menuitem=%p\n",bdm->menuitem);
> 		gtk_widget_destroy(bdm->menuitem);
> 		g_free(bdm);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	g_list_free(menubfwin->menu_windows);
> 	menubfwin->menu_windows = NULL;
> }
> static void remove_window_entry_from_window(Tbfwin *menubfwin, Tbfwin *tobfwin) {
> 	Tbfw_dynmenu *bdm = find_bfw_dynmenu_by_data_in_list(menubfwin->menu_windows, tobfwin);
> 	DEBUG_MSG("remove_window_entry_from_window, menuwin=%p, found bdm=%p\n",menubfwin,bdm);
> 	if (bdm) {
> 		/*g_signal_handler_disconnect(bdm->menuitem,bdm->signal_id);*/
> 		DEBUG_MSG("remove_window_entry_from_window, destroy menuitem=%p\n",bdm->menuitem);
> 		gtk_widget_destroy(bdm->menuitem);
> 		menubfwin->menu_windows = g_list_remove(menubfwin->menu_windows,bdm);
> 		g_free(bdm);
> 		
> 	}
> }
> static void rename_window_entry_from_window(Tbfwin *menubfwin, Tbfwin *tobfwin, gchar *newtitle) {
> 	Tbfw_dynmenu *bdm = find_bfw_dynmenu_by_data_in_list(menubfwin->menu_windows, tobfwin);
> 	DEBUG_MSG("rename_window_entry_from_window, menubfwin=%p, found bdm=%p\n",menubfwin,bdm);
> 	if (bdm) {
> 		GtkWidget *label = gtk_bin_get_child(GTK_BIN(bdm->menuitem));
> 		DEBUG_MSG("rename_window_entry_from_window, setting label to have title %s\n",newtitle);
> 		gtk_label_set_text(GTK_LABEL(label), newtitle);
> 	}
> }	
> static void menu_window_lcb(GtkWidget *widget, Tbfw_dynmenu *bdm) {
> 	gtk_window_present(GTK_WINDOW(BFWIN(bdm->data)->main_window));
> }
> static void add_window_entry(Tbfwin *menubfwin, Tbfwin *tobfwin) {
> 	const gchar *winname;
> 	Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
> 	bdm->bfwin = menubfwin;
> 	bdm->data = tobfwin;
> 	winname = gtk_window_get_title(GTK_WINDOW(tobfwin->main_window));
> 	DEBUG_MSG("add_window_entry, menubfwin=%p, bdm=%p with title %s\n",menubfwin,bdm,winname);
> 	bdm->menuitem = create_dynamic_menuitem(menubfwin,_("/Windows"),winname,G_CALLBACK(menu_window_lcb),(gpointer)bdm,-1);
> 	DEBUG_MSG("add_window_entry, menuitem=%p\n",bdm->menuitem);
> 	menubfwin->menu_windows = g_list_append(menubfwin->menu_windows, bdm);
> }
> void add_window_entry_to_all_windows(Tbfwin *tobfwin) {
> 	GList *tmplist = g_list_first(main_v->bfwinlist);
> 	while (tmplist) {
> 		if (tmplist->data != tobfwin) {
> 			add_window_entry(BFWIN(tmplist->data), tobfwin);
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> void add_allwindows_entries_to_window(Tbfwin *menubfwin) {
> 	GList *tmplist = g_list_first(main_v->bfwinlist);
> 	while (tmplist) {
> 		if (tmplist->data != menubfwin) {
> 			add_window_entry(menubfwin, BFWIN(tmplist->data));
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> }	
> void remove_window_entry_from_all_windows(Tbfwin *tobfwin) {
> 	GList *tmplist = g_list_first(main_v->bfwinlist);
> 	while (tmplist) {
> 		remove_window_entry_from_window(BFWIN(tmplist->data), tobfwin);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	remove_all_window_entries_in_window(tobfwin);
> }
> void rename_window_entry_in_all_windows(Tbfwin *tobfwin, gchar *newtitle) {
> 	GList *tmplist = g_list_first(main_v->bfwinlist);
> 	while (tmplist) {
> 		rename_window_entry_from_window(BFWIN(tmplist->data), tobfwin, newtitle);
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> /*****************/
> /* Browsers!!    */
> /*****************/
> 
> static void view_in_browser(Tbfwin *bfwin, gchar *browser) {
> 	if (bfwin->current_document->filename) {
> 		Tconvert_table *table, *tmpt;
> 		gchar *command;
> 		table = tmpt = g_new(Tconvert_table, 2);
> 		tmpt->my_int = 's';
> 		if (bfwin->project && bfwin->project->webdir 
> 				&& bfwin->project->basedir && strlen(bfwin->project->webdir)>2
> 				&& strlen(bfwin->project->basedir)>2 
> 				&& strncmp(bfwin->current_document->filename, bfwin->project->basedir, strlen(bfwin->project->basedir))==0
> 				) {
> 			tmpt->my_char = g_strconcat(bfwin->project->webdir, &bfwin->current_document->filename[strlen(bfwin->project->basedir)], NULL);
> 		} else {
> 			tmpt->my_char = g_strdup(bfwin->current_document->filename);
> 		}
> 		tmpt++;
> 		tmpt->my_char = NULL;
> 		command = replace_string_printflike(browser, table);
> 		g_free(table->my_char);
> 		g_free(table);
> 		DEBUG_MSG("view_in_browser, should start %s now\n", command);
> 		system(command);
> 		g_free(command);
> 	} else {
> 		warning_dialog(bfwin->main_window,_("Could not view file in browser, the file does not yet have a name\n"), NULL);
> 	}
> }
> 
> void browser_toolbar_cb(GtkWidget *widget, Tbfwin *bfwin) {
> 	GList *tmplist = g_list_first(main_v->props.browsers);
> 	if (tmplist && tmplist->data) {
> 		gchar **arr = tmplist->data;
> 		DEBUG_MSG("first browser in main_v->props.browsers(%p) is %s with command %s\n", main_v->props.browsers, arr[0], arr[1]);
> 		view_in_browser(bfwin,arr[1]);
> 	}
> }
> 
> static void browser_lcb(GtkWidget *widget, Tbfw_dynmenu *bdm) {
> 	gchar **arr = (gchar **)bdm->data;
> 	if (!bdm->bfwin->current_document->filename || bdm->bfwin->current_document->modified) {
> 		file_save_cb(NULL, bdm->bfwin);
> 	}
> 	view_in_browser(bdm->bfwin,arr[1]);
> }
> static void external_command_lcb(GtkWidget *widget, Tbfw_dynmenu *bdm) {
> 	gchar *secure_tempname = NULL, *secure_tempname2 = NULL;
> 	gboolean need_s=FALSE, need_f=FALSE, need_i=FALSE;
> 	gchar **arr = (gchar **)bdm->data;
> 	/* now check if
> 	 * %s - current document filename
> 	 * %f - output filename that we need to read after the command has finished (filter)
> 	 * %i - input filename for the filter
> 	 */
> 	need_f = (strstr(arr[1], "%f") != NULL);
> 	need_i = (strstr(arr[1], "%i") != NULL);
> 	need_s = (strstr(arr[1], "%s") != NULL);
> 
> 	if (need_s) {
> 		file_save_cb(NULL, bdm->bfwin);
> 		if (!bdm->bfwin->current_document->filename) {
> 			return;
> 		}
> 		if (bdm->bfwin->current_document->filename[0] == '/'){
> 			/* for local files we chdir() to their directory */
> 			gchar *tmpstring = g_path_get_dirname(bdm->bfwin->current_document->filename);
> 			chdir(tmpstring);
> 			g_free(tmpstring);
> 		}
> 	}
> 	if (need_f || need_s || need_i) {
> 		gchar *command;
> 		Tconvert_table *table, *tmpt;
> 		table = tmpt = g_new(Tconvert_table, 4);
> 		if (need_s) {
> 			DEBUG_MSG("adding 's' to table\n");
> 			tmpt->my_int = 's';
> 			tmpt->my_char = bdm->bfwin->current_document->filename;
> 			tmpt++;
> 		}
> 		if (need_f) {
> 			secure_tempname = create_secure_dir_return_filename();
> 			DEBUG_MSG("adding 'f' to table\n");
> 			tmpt->my_int = 'f';
> 			tmpt->my_char = secure_tempname;
> 			tmpt++;
> 		}
> 		if (need_i) {
> 			gchar *buffer;
> 			GtkTextIter itstart, itend;
> 			gtk_text_buffer_get_bounds(bdm->bfwin->current_document->buffer,&itstart,&itend);
> 			secure_tempname2 = create_secure_dir_return_filename();
> 			DEBUG_MSG("adding 'i' to table\n");
> 			tmpt->my_int = 'i';
> 			tmpt->my_char = secure_tempname2;
> 			tmpt++;
> 			/* now we also save the current filename (or in the future the selection) to this file */
> 			buffer = gtk_text_buffer_get_text(bdm->bfwin->current_document->buffer,&itstart,&itend,FALSE);
> 			buffer_to_file(BFWIN(bdm->bfwin), buffer, secure_tempname2);
> 			g_free(buffer);
> 		}
> 		tmpt->my_char = NULL;
> 		command = replace_string_printflike(arr[1], table);
> 		g_free(table);
> 		system(command);
> 		g_free(command);
> 		if (need_f) {
> 			gint end;
> 			gchar *buf = NULL;
> 			gboolean suc6;
> 			/* empty textbox and fill from file secure_tempname */
> 			end = doc_get_max_offset(bdm->bfwin->current_document);
> 			suc6 = g_file_get_contents(secure_tempname, &buf, NULL, NULL);
> 			if (suc6 && buf) {
> 				if (strlen(buf)) {
> 					doc_replace_text(bdm->bfwin->current_document, buf, 0, end);
> 				}
> 				g_free(buf);
> 			}
> 		}
> 		if (secure_tempname) remove_secure_dir_and_filename(secure_tempname);
> 		if (secure_tempname2) remove_secure_dir_and_filename(secure_tempname2);
> 	} else {
> 		DEBUG_MSG("external_command_lcb, about to start %s\n", arr[1]);
> 		system(arr[1]);
> 	}
> 	
> 	if (bdm->bfwin->current_document->need_highlighting) {
> 	    DEBUG_MSG("external_command_lcb, need_highlighting = %d\n", bdm->bfwin->current_document->need_highlighting);
> 	    doc_highlight_full(bdm->bfwin->current_document);
> 	}
> }
> /**
>  * external_menu_rebuild:
>  * @bfwin: #Tbfwin*
>  *
>  * rebuild the browsers, external commands and outputbox menu's
>  *
>  * Return value: void
>  */
> void external_menu_rebuild(Tbfwin *bfwin) {
> 	GList *tmplist;
> 	
> 	/* first cleanup all menu's */
> 	tmplist = g_list_first(bfwin->menu_external);
> 	while (tmplist) {
> 		Tbfw_dynmenu *bdm = (Tbfw_dynmenu *)tmplist->data;
> 		DEBUG_MSG("external_menu_rebuild,destroying,bfwin=%p,bdm=%p,menuitem=%p\n",bfwin,bdm,bdm->menuitem);
> 		gtk_widget_destroy(bdm->menuitem);
> 		g_free(bdm);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	g_list_free(bfwin->menu_external);
> 	bfwin->menu_external = NULL;
> 
> 	tmplist = g_list_first(bfwin->menu_outputbox);
> 	while (tmplist) {
> 		gtk_widget_destroy(BFW_DYNMENU(tmplist->data)->menuitem);
> 		g_free(BFW_DYNMENU(tmplist->data));
> 		tmplist = g_list_next(tmplist);
> 	}
> 	g_list_free(bfwin->menu_outputbox);
> 	bfwin->menu_outputbox = NULL;
> 	
> 	if (main_v->props.ext_outputbox_in_submenu) {
> 		create_parent_and_tearoff(N_("/External/Outputbox/"), gtk_item_factory_from_widget(bfwin->menubar));
> 	}
> 	if (main_v->props.ext_commands_in_submenu) {
> 		create_parent_and_tearoff(N_("/External/Commands/"), gtk_item_factory_from_widget(bfwin->menubar));
> 	}
> 	if (main_v->props.ext_browsers_in_submenu) {
> 		create_parent_and_tearoff(N_("/External/Browsers/"), gtk_item_factory_from_widget(bfwin->menubar));
> 	}
> 
> 	if (!main_v->props.ext_browsers_in_submenu) {
> 		Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
> 		bdm->menuitem = dynamic_menu_append_spacing(bfwin,N_("/External"));
> 		bfwin->menu_external = g_list_append(bfwin->menu_external,bdm);
> 	} 
> 	tmplist = g_list_first(main_v->props.browsers);
> 	while (tmplist) {
> 		gchar **arr = tmplist->data;
> 		/*  arr[0] = name
> 		 *  arr[1] = command
> 		 */
> 		if (count_array(arr)==2) {
> 			Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
> 			gchar *tmp1;
> 			if (main_v->props.ext_browsers_in_submenu) {
> 				tmp1 = N_("/External/Browsers");
> 			} else {
> 				tmp1 = N_("/External");
> 			}
> 			bdm->bfwin = bfwin;
> 			bdm->data = arr;
> 			DEBUG_MSG("external_menu_rebuild,Adding browser %s with command %s to the menu at %s\n", arr[0], arr[1], tmp1);
> 			bdm->menuitem = create_dynamic_menuitem(bfwin,tmp1,arr[0],G_CALLBACK(browser_lcb),bdm,-1);
> 			DEBUG_MSG("external_menu_rebuild,creating,bfwin=%p,bdm=%p,menuitem=%p\n",bfwin,bdm,bdm->menuitem);
> 			bfwin->menu_external = g_list_append(bfwin->menu_external, bdm);
> 		}
> #ifdef DEBUG
> 		else {
> 			DEBUG_MSG("need count=2 for browser menu! %p has count %d\n", arr, count_array(arr));
> 		}
> #endif
> 		tmplist = g_list_next(tmplist);
> 	}
> 	
> 	if (!main_v->props.ext_commands_in_submenu) {
> 		Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
> 		bdm->menuitem = dynamic_menu_append_spacing(bfwin,N_("/External"));
> 		bfwin->menu_external = g_list_append(bfwin->menu_external,bdm);
> 	}
> 	
> 	tmplist = g_list_first(main_v->props.external_commands);
> 	while (tmplist) {
> 		gchar **arr = tmplist->data;
> 		/*  arr[0] = name
> 		 *  arr[1] = command
> 		 */
> 		if (count_array(arr)==2) {
> 			gchar *tmp1;
> 			Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
> 			if (main_v->props.ext_commands_in_submenu) {
> 				tmp1 = N_("/External/Commands");
> 			} else {
> 				tmp1 = N_("/External");
> 			}
> 			bdm->bfwin = bfwin;
> 			bdm->data = arr;
> 			bdm->menuitem = create_dynamic_menuitem(bfwin,tmp1,arr[0],G_CALLBACK(external_command_lcb),bdm,-1);
> 			bfwin->menu_external = g_list_append(bfwin->menu_external, bdm);
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 
> 	/* the outputbox */	
> 	if (!main_v->props.ext_outputbox_in_submenu) {
> 		Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
> 		bdm->menuitem = dynamic_menu_append_spacing(bfwin,N_("/External"));
> 		bfwin->menu_outputbox = g_list_append(bfwin->menu_outputbox, bdm);
> 	}
> 	
> 	tmplist = g_list_first(main_v->props.outputbox);
> 	while (tmplist) {
> 		gchar **arr = tmplist->data;
> 		/* outputbox(gchar *pattern, gint file_subpat, gint line_subpat, gint output_subpat, gchar *command, gboolean show_all_output)
> 		 * arr[0] = name
> 		 * arr[1] = pattern
> 		 * arr[2] = file subpattern
> 		 * arr[3] = line subpattern
> 		 * arr[4] = output subpattern
> 		 * arr[5] = command
> 		 * arr[6] = show_all_output
> 		 */
> 		if (count_array(arr)==7) {
> 			Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
> 			gchar *tmp1;
> 			if (main_v->props.ext_outputbox_in_submenu) {
> 				tmp1 = N_("/External/Outputbox");
> 			} else {
> 				tmp1 = N_("/External");
> 			}
> 			bdm->data = arr;
> 			bdm->bfwin = bfwin;
> 			bdm->menuitem = create_dynamic_menuitem(bfwin,tmp1,arr[0],G_CALLBACK(menu_outputbox_lcb),(gpointer)bdm,-1);
> 			bfwin->menu_outputbox = g_list_append(bfwin->menu_outputbox,bdm);
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> static void menu_current_document_encoding_change(GtkMenuItem *menuitem,Tbfw_dynmenu *bdm) {
> 	if (GTK_CHECK_MENU_ITEM(menuitem)->active) {
> 		gchar *encoding = (gchar *)bdm->data;
> 		Tbfwin *bfwin = bdm->bfwin;
> 		if (encoding && (!bfwin->current_document->encoding || strcmp(encoding,bfwin->current_document->encoding)!=0)) {
> 			if (bfwin->current_document->encoding) {
> 				g_free(bfwin->current_document->encoding);
> 			}
> 			bfwin->current_document->encoding = g_strdup(encoding);
> 			if (main_v->props.auto_set_encoding_meta) {
> 				update_encoding_meta_in_file(bfwin->current_document, bfwin->current_document->encoding);
> 			}
> 			doc_set_statusbar_editmode_encoding(bfwin->current_document);
> 			DEBUG_MSG("menu_current_document_encoding_change, set to %s\n", encoding);
> 		}
> 	}
> }
> 
> void encoding_menu_rebuild(Tbfwin *bfwin) {
> 	GSList *group=NULL;
> 	GtkWidget *parent_menu;
> 	GList *tmplist;
> 	tmplist = g_list_first(bfwin->menu_encodings);
> 	while (tmplist) {
> 		Tbfw_dynmenu *bdm = tmplist->data;
> 		gtk_widget_destroy(GTK_WIDGET(bdm->menuitem));
> 		g_free(bdm);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	g_list_free(bfwin->menu_encodings);
> 	bfwin->menu_encodings = NULL;
> 
> 	tmplist = g_list_last(main_v->props.encodings);
> 	parent_menu = gtk_item_factory_get_widget(gtk_item_factory_from_widget(bfwin->menubar), N_("/Document/Character Encoding"));
> 	while (tmplist) {
> 		gchar **strarr = (gchar **)tmplist->data;
> 		if (count_array(strarr)==2) {
> 			Tbfw_dynmenu *bdm = g_new(Tbfw_dynmenu,1);
> 			bdm->menuitem = gtk_radio_menu_item_new_with_label(group, strarr[0]);
> 			bdm->data = strarr[1];
> 			bdm->bfwin = bfwin;
> 			g_signal_connect(G_OBJECT(bdm->menuitem), "activate",G_CALLBACK(menu_current_document_encoding_change), (gpointer) bdm);
> 			gtk_widget_show(bdm->menuitem);
> 			gtk_menu_insert(GTK_MENU(parent_menu), bdm->menuitem, 1);
> 			group = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(bdm->menuitem));
> 			bfwin->menu_encodings = g_list_append(bfwin->menu_encodings, bdm);
> 		}
> 		tmplist = g_list_previous(tmplist);
> 	}
> }
> 
> void menu_current_document_set_toggle_wo_activate(Tbfwin *bfwin, Tfiletype *filetype, gchar *encoding) {
> 	Tbfw_dynmenu *bdm = find_bfw_dynmenu_by_data_in_list(bfwin->menu_filetypes, filetype);
> 	if (bdm && filetype && bdm->menuitem && !GTK_CHECK_MENU_ITEM(bdm->menuitem)->active) {
> 		DEBUG_MSG("setting widget from hlset %p active\n", bfwin->current_document->hl);
> 		g_signal_handler_disconnect(G_OBJECT(bdm->menuitem),bdm->signal_id);
> 		gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM(bdm->menuitem), TRUE);
> 		bdm->signal_id = g_signal_connect(G_OBJECT(bdm->menuitem), "activate",G_CALLBACK(menu_current_document_type_change), (gpointer) bdm);
> 	}
> #ifdef DEBUG
> 	 else {
> 	 	DEBUG_MSG("widget from filetype %p is already active, or filetype does not have a widget!!\n", bfwin->current_document->hl);
> 	 }
> #endif
> 	if (encoding) {
> 		GList *tmplist;
> 		tmplist = g_list_first(main_v->props.encodings);
> 		while (tmplist) {
> 			gchar **tmparr = (gchar **)tmplist->data;
> 			if (strcmp(tmparr[1], encoding)==0) {
> 				Tbfw_dynmenu *bdm = find_bfw_dynmenu_by_data_in_list(bfwin->menu_encodings, tmparr[1]);
> 				if (bdm) {
> 					g_signal_handlers_block_matched(G_OBJECT(bdm->menuitem), G_SIGNAL_MATCH_FUNC,
> 							0, 0, NULL, menu_current_document_encoding_change, NULL);
> 					gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(bdm->menuitem),TRUE);
> 					g_signal_handlers_unblock_matched(G_OBJECT(bdm->menuitem), G_SIGNAL_MATCH_FUNC,
> 							0, 0, NULL, menu_current_document_encoding_change, NULL);
> 				}
> 				break;
> 			}
> 			tmplist = g_list_next(tmplist);	
> 		}
> 	}
> }
> 
> 
> /***************/
> /* custom menu */
> /***************/
> #define MAX_TEXT_ENTRY 10
> typedef struct {
> 	GtkWidget *dialog;
> 	GtkWidget *textentry[MAX_TEXT_ENTRY];
> 	gint type;
> 	gchar **array;
> 	Tbfwin *bfwin;
> } Tcust_con_struc;
> 
> typedef struct {
> 	GtkItemFactoryEntry entry;
> 	gint type;
> 	gchar **array;
> 	Tbfwin *bfwin;
> } Tcmenu_entry;
> 
> /*
> instead of having one list where both insert and replace types have their
> place, I changed that to 2 arraylists:
> main_v->props.cmenu_insert
> main_v->props.cmenu_replace
> 
> ** for insert **
> array[0] = title / menupath
> array[1] = formatstring before, containing %0, %1... that should be replaced by the 
> 				values from the dialog
> array[2] = formatstring after
> array[3] = number of variables from the dialog
> array[4..] = the description of those variables
> 
> ** for replace **
> array[0] = title / menupath
> array[1] = search pattern, containing %0 etc.
> array[2] = replace pattern, containing %0 etc.
> array[3] = replace where:
> 							0 = from beginning
> 							1 = from cursor
> 							2 = selection (selection required)
> 							3 = all open documents
> 							4 = ask
> array[4] = replace type:
> 							0 = normal
> 							1 = regular expression
> array[5] = case sensitivity:
> 							0 = no
> 							1 = yes
> array[6] = number of variables from the dialog
> array[7..] = the description of those variables
> */
> 
> static void cust_con_struc_dialog_destroy_lcb(GtkWidget *widget, Tcust_con_struc *ccs) {
> 	window_destroy(ccs->dialog);
> 	g_free(ccs);
> }
> 
> static void cust_con_struc_dialog_cancel_lcb(GtkWidget *widget, gpointer data) {
> 	cust_con_struc_dialog_destroy_lcb(NULL, data);
> }
> 
> static void cust_con_struc_dialog_ok_lcb(GtkWidget *widget, Tcust_con_struc *ccs) {
> 	Tconvert_table *table, *tmpt;
> 	gint num_vars, i;
> 
> 	DEBUG_MSG("cust_con_struc_dialog_ok_lcb, ccs at %p\n", ccs);
> 	DEBUG_MSG("cust_con_struc_dialog_ok_lcb, array at %p, &array[0]=%p\n", ccs->array, &ccs->array[0]);
> 	DEBUG_MSG("cust_con_struc_dialog_ok_lcb, array[0] at %p, *array=%p\n", ccs->array[0], *ccs->array);
> 	if (ccs->type == 0) {
> 		gchar *before=NULL, *after=NULL;
> 		num_vars = atoi(ccs->array[3]);
> 		DEBUG_MSG("cust_con_struc_dialog_ok_lcb, num_vars=%d, ccs->array[3]=%s\n", num_vars, ccs->array[3]);
> 		table = tmpt = g_new(Tconvert_table, num_vars+2);
> 		tmpt->my_int = '%';
> 		tmpt->my_char = g_strdup("%");
> 		tmpt++;
> 		for (i=0; i<num_vars; i++) {
> 			DEBUG_MSG("cust_con_struc_dialog_ok_lcb, tmpt=%p, i=%d\n", tmpt, i);
> 			tmpt->my_int = 48 + i;
> 			tmpt->my_char = gtk_editable_get_chars(GTK_EDITABLE(ccs->textentry[i]), 0, -1);
> 			tmpt++;
> 		}
> 		DEBUG_MSG("cust_con_struc_dialog_ok_lcb, setting tmpt(%p) to NULL\n", tmpt);
> 		tmpt->my_char = NULL;
> 
> 		if (strlen(ccs->array[1])) {
> 			DEBUG_MSG("cust_con_struc_dialog_ok_lcb, ccs->array[1]=%s\n",ccs->array[1] );
> 			before = replace_string_printflike(ccs->array[1], table);
> 		}
> 		if (strlen(ccs->array[2])) {
> 			after = replace_string_printflike(ccs->array[2], table);
> 		}
> 		doc_insert_two_strings(ccs->bfwin->current_document, before, after);
> 		doc_scroll_to_cursor(ccs->bfwin->current_document);
> 		
> 		tmpt = table;
> 		while (tmpt->my_char) {
> 			DEBUG_MSG("cust_con_struc_dialog_ok_lcb, tmpt=%p, about to free(%p) %s\n", tmpt, tmpt->my_char, tmpt->my_char);
> 			g_free(tmpt->my_char);
> 			tmpt++;
> 		}
> 		g_free(table);
> 
> 		if (before) {
> 			g_free(before);
> 		}
> 		if (after) {
> 			g_free(after);
> 		}
> 	} else {
> 		gchar *search=NULL, *replace=NULL;
> 		num_vars = atoi(ccs->array[6]);
> 		table = tmpt = g_new(Tconvert_table, num_vars+1);
> 		for (i=0; i<num_vars; i++) {
> 			tmpt->my_int = 48 + i;
> 			tmpt->my_char = gtk_editable_get_chars(GTK_EDITABLE(ccs->textentry[i]), 0, -1);
> 			tmpt++;
> 		}
> 		tmpt->my_char = NULL;
> 		if (strlen(ccs->array[1])) {
> 			DEBUG_MSG("cust_con_struc_dialog_ok_lcb, ccs->array[1]=%s\n",ccs->array[1] );
> 			search = replace_string_printflike(ccs->array[1], table);
> 		}
> 		if (strlen(ccs->array[2])) {
> 			replace = replace_string_printflike(ccs->array[2], table);
> 		} else {
> 			replace = g_strdup("");
> 		}
> 		snr2_run_extern_replace(ccs->bfwin->current_document, search, atoi(ccs->array[3]),
> 				atoi(ccs->array[4]), atoi(ccs->array[5]), replace, TRUE);
> 		
> 		tmpt = table;
> 		while (tmpt->my_char) {
> 			g_free(tmpt->my_char);
> 			tmpt++;
> 		}
> 		g_free(table);
> 		
> 		if (search) {
> 			g_free(search);
> 		}
> 		if (replace) {
> 			g_free(replace);
> 		} 
> 	}
> 	cust_con_struc_dialog_cancel_lcb(NULL, ccs);
> }
> 
> static void cust_con_struc_dialog(Tbfwin *bfwin, gchar **array, gint type) {
> 	Tcust_con_struc *ccs;
> 	GtkWidget *vbox, *table, *hbox, *okb, *cancb;
> 	gint i, num_vars;
> 
> 	ccs = g_malloc(sizeof(Tcust_con_struc));
> 	ccs->type = type;
> 	ccs->bfwin = bfwin;
> 	DEBUG_MSG("cust_con_struc_dialog_cb, ccs at %p\n", ccs);
> 	ccs->array = array;
> 	DEBUG_MSG("cust_con_struc_dialog_cb, array at %p, &array[0]=%p\n", ccs->array, &ccs->array[0]);
> 	DEBUG_MSG("cust_con_struc_dialog_cb, array[0] at %p, *array=%p\n", ccs->array[0], *ccs->array);
> 	ccs->dialog = window_full2(ccs->array[0], GTK_WIN_POS_MOUSE,  
> 			5, G_CALLBACK(cust_con_struc_dialog_destroy_lcb), ccs, TRUE, NULL);
> 	vbox = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(ccs->dialog), vbox);
> 	DEBUG_MSG("cust_con_struc_dialog_cb, ccs->array[0]=%s\n", ccs->array[0]);
> 	
> 	if (type == 0) {
> 		num_vars = atoi(ccs->array[3]);
> 	} else {
> 		num_vars = atoi(ccs->array[6]);
> 	}
> 	DEBUG_MSG("cust_con_struc_dialog_cb, num_vars=%d\n", num_vars);
> 
>    table = gtk_table_new (num_vars, 2, FALSE);
>    gtk_table_set_row_spacings (GTK_TABLE (table), 12);
>    gtk_table_set_col_spacings (GTK_TABLE (table), 12);
>    gtk_box_pack_start (GTK_BOX (vbox), table, TRUE, TRUE, 0);
> 
>    for (i = 0; i < num_vars; i++) {
>       gchar *labelTxt = NULL;
>       
>       if (type == 0) {
>          labelTxt = g_strconcat (ccs->array[i+4], ": ", NULL);
>       } else {
>          labelTxt = g_strconcat (ccs->array[i+7], ": ", NULL); 
>       }
>       
>       ccs->textentry[i] = gtk_entry_new ();
> 		DEBUG_MSG("cust_con_struc_dialog_cb, textentry[%d]=%p\n", i, ccs->textentry[i]);
> 		bf_mnemonic_label_tad_with_alignment(labelTxt, ccs->textentry[i], 0, 0.5, table, 0, 1, i, i+1);
> 		gtk_table_attach (GTK_TABLE (table), ccs->textentry[i], 1, 2, i, i+1, GTK_EXPAND|GTK_FILL, GTK_SHRINK, 0, 0);
> 		
> 		g_free (labelTxt);
>    }
>    
> 	gtk_box_pack_start(GTK_BOX(vbox), gtk_hseparator_new(), FALSE, FALSE, 12);
> 	hbox = gtk_hbutton_box_new();
> 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
> 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 12);
> 	okb = bf_stock_ok_button(G_CALLBACK(cust_con_struc_dialog_ok_lcb), ccs);
> 	cancb = bf_stock_cancel_button(G_CALLBACK(cust_con_struc_dialog_cancel_lcb), ccs);
> 	gtk_box_pack_start(GTK_BOX(hbox),cancb , FALSE, FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(hbox),okb , FALSE, FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
> 
> 	gtk_widget_grab_focus(ccs->textentry[0]);
> 	gtk_widget_grab_default(okb);
> 	gtk_widget_show_all(ccs->dialog);
> }
> 
> 
> static void cust_menu_lcb(Tcmenu_entry *cmentry,guint callback_action,GtkWidget *widget) {
> 	if (cmentry->type == 0) {
> 		DEBUG_MSG("cust_menu_lcb, a custom insert, array[3]=%s\n", cmentry->array[3]);
> 		if (atoi(cmentry->array[3]) > 0) {
> 		     cust_con_struc_dialog(cmentry->bfwin,cmentry->array, 0);
> 		} else {
> 		     doc_insert_two_strings(cmentry->bfwin->current_document, cmentry->array[1],cmentry->array[2]);
> 		}
> 	} else {
> 		DEBUG_MSG("cust_menu_lcb, a custom replace!, cmentry->array[6]=%s\n", cmentry->array[6]);
> 		if (strcmp(cmentry->array[3], "2")==0 && !doc_has_selection(cmentry->bfwin->current_document)) {
> 			warning_dialog(cmentry->bfwin->main_window,_("This custom search and replace requires a selection"), NULL);
> 			return;
> 		}
> 		if (atoi(cmentry->array[6]) > 0) {
> 			cust_con_struc_dialog(cmentry->bfwin,cmentry->array, 1);
> 		} else {
> 		     snr2_run_extern_replace(cmentry->bfwin->current_document,cmentry->array[1], atoi(cmentry->array[3]),
> 							atoi(cmentry->array[4]), atoi(cmentry->array[5]), cmentry->array[2],TRUE);
> 		}
> 	}
> }
> 
> static Tcmenu_entry *create_cmentry(Tbfwin *bfwin,const gchar *menupath, gint count, gchar **array, GtkItemFactory *ifactory, gint type) {
> 	Tcmenu_entry *cmentry = g_malloc0(sizeof(Tcmenu_entry));
> 	cmentry->bfwin = bfwin;
> 	cmentry->entry.path = g_strdup(menupath);
> 	DEBUG_MSG("create_cmentry, entry.path=%s, count=%d\n", cmentry->entry.path, count);
> 	cmentry->entry.callback = cust_menu_lcb;
> 	cmentry->entry.callback_action = count;
> 	cmentry->array = array;
> 	cmentry->type = type;
> 	create_parent_and_tearoff(cmentry->entry.path, ifactory);
> 	gtk_item_factory_create_item(ifactory, &cmentry->entry, cmentry, 1);
> 	return cmentry;
> }
> 
> static void fill_cust_menubar(Tbfwin *bfwin) {
> 	GtkItemFactory *ifactory;
> 	gint count;
> 	gchar **splittedstring;
> 	GList *tmplist;
> 	Tcmenu_entry *cmentry;
> 
> 	ifactory = gtk_item_factory_from_widget(bfwin->menu_cmenu);
> 
> 	tmplist = g_list_first(bfwin->menu_cmenu_entries);
> 	while (tmplist) {
> 		cmentry = (Tcmenu_entry *) tmplist->data;
> 		gtk_item_factory_delete_entry(ifactory, &cmentry->entry);
> 		DEBUG_MSG("fill_cust_menubar, removed entry.path=%s\n", cmentry->entry.path);
> 		g_free(cmentry->entry.path);
> 		g_free(cmentry);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	g_list_free(bfwin->menu_cmenu_entries);
> 	bfwin->menu_cmenu_entries = NULL;
> 
> 	count = 0;
> 	tmplist = g_list_first(main_v->props.cmenu_insert);
> 	while (tmplist) {
> 		gint count2;
> 		splittedstring = (gchar **) tmplist->data;
> 		count2 = count_array(splittedstring);
> 		if (count2 >= 4) {
> 			cmentry = create_cmentry(bfwin,splittedstring[0], count, splittedstring, ifactory, 0);
> 			bfwin->menu_cmenu_entries = g_list_append(bfwin->menu_cmenu_entries, cmentry);
> 		}
> 		count++;
> 		tmplist = g_list_next(tmplist);
> 	}
> 	tmplist = g_list_first(main_v->props.cmenu_replace);
> 	while (tmplist) {
> 		gint count2;
> 		splittedstring = (gchar **) tmplist->data;
> 		count2 = count_array(splittedstring);
> 		if (count2 >= 4) {
> 			cmentry = create_cmentry(bfwin,splittedstring[0], count, splittedstring, ifactory, 1);
> 			bfwin->menu_cmenu_entries = g_list_append(bfwin->menu_cmenu_entries, cmentry);
> 		}
> 		count++;
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> static void cmenu_reset_lcb(Tbfwin *bfwin,guint callback_action,GtkWidget *widget) {
> 	GList *tmplist;
> 	rcfile_parse_custom_menu(TRUE, FALSE);
> 	tmplist = g_list_first(main_v->bfwinlist);
> 	while (tmplist) {
> 		fill_cust_menubar(BFWIN(tmplist->data));
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> static void cmenu_load_new_lcb(Tbfwin *bfwin,guint callback_action,GtkWidget *widget) {
> 	GList *tmplist;
> 	rcfile_parse_custom_menu(FALSE, TRUE);
> 	tmplist = g_list_first(main_v->bfwinlist);
> 	while (tmplist) {
> 		fill_cust_menubar(BFWIN(tmplist->data));
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> /* function declaration needed here */
> void cmenu_editor(Tbfwin *bfwin,guint callback_action,GtkWidget *widget);
> 
> void make_cust_menubar(Tbfwin *bfwin, GtkWidget *cust_handle_box) {
> 	static GtkItemFactoryEntry cust_menu[] = {
> 		{N_("/_Custom menu"), NULL, NULL, 0, "<Branch>"},
> 		{"/Custom menu/tearoff1", NULL, NULL, 0, "<Tearoff>"},
> 		{N_("/Custom menu/Edit custom menu..."), NULL, cmenu_editor, 0, NULL},
> 		{N_("/Custom menu/Reset"), NULL, cmenu_reset_lcb, 0, NULL},
> 		{N_("/Custom menu/Load new"), NULL, cmenu_load_new_lcb, 0, NULL}
> 	};
> 	GtkItemFactory *item_factory;
> 	GtkAccelGroup *accel_group;
> 	gint nmenu_items = sizeof(cust_menu) / sizeof(cust_menu[0]);
> 
> 	DEBUG_MSG("make_cust_menubar, started\n");
> 
> 	/* this should only happen once !!!!!!!!!! */
> 	accel_group = gtk_accel_group_new();
> 	item_factory = gtk_item_factory_new(GTK_TYPE_MENU_BAR, "<bluefishcustom>", accel_group);
> #ifdef ENABLE_NLS
> 	gtk_item_factory_set_translate_func(item_factory, menu_translate, "<bluefishcustom>", NULL);
> #endif
> 	gtk_item_factory_create_items(item_factory, nmenu_items, cust_menu, bfwin);
> 	gtk_window_add_accel_group(GTK_WINDOW(bfwin->main_window), accel_group);
> 
> 	bfwin->menu_cmenu = gtk_item_factory_get_widget(item_factory, "<bluefishcustom>");
> 	gtk_container_add(GTK_CONTAINER(bfwin->custom_menu_hb), bfwin->menu_cmenu);
> 	gtk_widget_show(bfwin->menu_cmenu);
> 
> 	fill_cust_menubar(bfwin);
> 
> 	DEBUG_MSG("make_cust_menubar, finished\n");
> }
> 
> /*******************************************************************/
> /*               Custom menu editor                                */
> /*******************************************************************/
> typedef struct {
> 	GtkWidget *win;
> 	GtkWidget *type[2];
> 	GtkListStore *lstore;
> 	GtkWidget *lview;
> 	GtkWidget *label1;
> 	GtkWidget *label2;
> 	GtkWidget *menupath;
> /*	GtkWidget *befv;*/
> 	GtkTextBuffer *befb;
> /*	GtkWidget *aftv;*/
> 	GtkTextBuffer *aftb;
> 	GtkWidget *num;
> 	gchar **lastarray;
> 	GtkWidget *dynvbox;
> 	GtkWidget *hboxes[MAX_TEXT_ENTRY];
> 	GtkWidget *descriptions[MAX_TEXT_ENTRY];
> 	GtkWidget *csnr_box;
> 	GtkWidget *region;
> 	GtkWidget *matching;
> 	GtkWidget *is_case_sens;
> /*	GList *worklist;*/
> 	GList *worklist_insert;
> 	GList *worklist_replace;
> 	Tbfwin *bfwin;
> } Tcmenu_editor;
> 
> static void cme_destroy_lcb(GtkWidget *widget, Tcmenu_editor* cme) {
> 	window_destroy(cme->win);
> 	free_arraylist(cme->worklist_insert);
> 	free_arraylist(cme->worklist_replace);
> 	g_free(cme);
> }
> 
> static void cme_close_lcb(GtkWidget *widget, gpointer data) {
> 	cme_destroy_lcb(NULL, data);
> }
> 
> static void cme_ok_lcb(GtkWidget *widget, Tcmenu_editor *cme) {
> 	GList *tmplist;
> 	DEBUG_MSG("cme_ok_lcb, start cmenu_insert=%p, worklist_insert=%p\n",main_v->props.cmenu_insert, cme->worklist_insert);
> 	pointer_switch_addresses((gpointer)&main_v->props.cmenu_insert, (gpointer)&cme->worklist_insert);
> 	DEBUG_MSG("cme_ok_lcb, after cmenu_insert=%p, worklist_insert=%p\n",main_v->props.cmenu_insert, cme->worklist_insert);
> 	pointer_switch_addresses((gpointer)&main_v->props.cmenu_replace, (gpointer)&cme->worklist_replace);
> 	cme_destroy_lcb(NULL, cme);
> 	tmplist = g_list_first(main_v->bfwinlist);
> 	while (tmplist) {
> 		fill_cust_menubar(BFWIN(tmplist->data));
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> static void cme_create_entries(Tcmenu_editor *cme, gint num) {
> 	gint i;
> 
> 	for (i = 0; i < MAX_TEXT_ENTRY ; i++) {
> 		if (i < num) {
> 			gtk_widget_show(cme->hboxes[i]);
> 		} else {
> 			gtk_widget_hide(cme->hboxes[i]); 
> 		}
> 	}
> }
> 
> static gboolean cme_iter_at_pointer(GtkTreeIter *iter, gpointer pointer, Tcmenu_editor *cme) {
> 	gpointer tmp;
> 	gboolean cont;
> 	cont = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(cme->lstore),iter);
> 	while (cont) {
> 		gtk_tree_model_get(GTK_TREE_MODEL(cme->lstore),iter,2,&tmp,-1);
> 		if (pointer == tmp) {
> 			return TRUE;
> 		}
> 		cont = gtk_tree_model_iter_next(GTK_TREE_MODEL(cme->lstore),iter);
> 	}
> 	return FALSE;
> }
> 
> static void cme_lview_selection_changed(GtkTreeSelection *selection, Tcmenu_editor *cme) {
> 	GtkTreeIter iter;
> 	GtkTreeModel *model;
> 	if (gtk_tree_selection_get_selected (selection,&model,&iter)) {
> 		gint num=0, i;
> 		gint type=0;
> 
> 		gtk_tree_model_get(model, &iter, 1, &type, 2, &cme->lastarray, -1);
> 		
> 		DEBUG_MSG("cme_clist_select_lcb, lastarray=%p, lastarray[0]=%s, type=%d\n", cme->lastarray, cme->lastarray[0], type);
> 
> 		DEBUG_MSG("cme_clist_select_lcb, cme->lastarray[0]=%s, [i]='%s'\n", cme->lastarray[0], cme->lastarray[1]);
> 		gtk_entry_set_text(GTK_ENTRY(cme->menupath), cme->lastarray[0]);
> 
> 		DEBUG_MSG("cme_clist_select_lcb, cme->lastarray[1]='%s'\n", cme->lastarray[1]);
> 		gtk_text_buffer_set_text(cme->befb, cme->lastarray[1], -1);
> 
> 		DEBUG_MSG("cme_clist_select_lcb, cme->lastarray[2]='%s'\n", cme->lastarray[2]);
> 		gtk_text_buffer_set_text(cme->aftb, cme->lastarray[2], -1);
> 
> 		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(cme->type[type]), TRUE);
> 		if (type == 0) {
> 			DEBUG_MSG("cme_clist_select_lcb, type=0, custom dialog\n");
> 			gtk_widget_hide(cme->csnr_box);
> 		
> 			num = atoi(cme->lastarray[3]);
> 			DEBUG_MSG("cme_clist_select_lcb, num=%d\n", num);
> 			gtk_spin_button_set_value(GTK_SPIN_BUTTON(cme->num), num);
> 	
> 			cme_create_entries(cme, num);
> 			DEBUG_MSG("cme_clist_select_lcb, %d entries created\n", num);
> 			for (i = 0 ; i < num; i++) {
> 				gtk_entry_set_text(GTK_ENTRY(cme->descriptions[i]), cme->lastarray[i+4]);
> 			}
> 			for (i = num ; i < MAX_TEXT_ENTRY; i++) {
> 				gtk_entry_set_text(GTK_ENTRY(cme->descriptions[i]), "");
> 			}
> 		} else if (type == 1) {
> 			static Tconvert_table table1[] = {{0, "0"}, {1, "1"}, {0, NULL}};
> /*			static Tconvert_table table2[] = {{0, N_("in current document")}, {1, N_("from cursor")}, {2, N_("in selection")}, {3, N_("in all open documents")}, {0,NULL}};
> 			static Tconvert_table table3[] = {{0, N_("normal")}, {1, N_("posix regular expressions")}, {2, N_("perl regular expressions")}, {0, NULL}};*/
> 			gint converti;
> 			/*gchar *convertc;*/
> 			DEBUG_MSG("cme_clist_select_lcb, type=1, custom search and replace\n");
> 			gtk_widget_show(cme->csnr_box);
> 			DEBUG_MSG("cme_clist_select_lcb, cme->lastarray[4]=%s\n", cme->lastarray[4]);
> 			
> 			/*gtk_editable_delete_text(GTK_EDITABLE(GTK_COMBO(cme->matching)->entry), 0, -1);
> 			converti = atoi(cme->lastarray[4]);
> 			convertc = table_convert_int2char(table3, converti);
> 			if (convertc) {
> 				gint pos=0;
> 				gtk_editable_insert_text(GTK_EDITABLE(GTK_COMBO(cme->matching)->entry), convertc, strlen(convertc), &pos);
> 			}*/
> 			converti = atoi(cme->lastarray[4]);
> 			gtk_option_menu_set_history(GTK_OPTION_MENU(cme->matching),converti);
> 
> 			DEBUG_MSG("cme_clist_select_lcb, cme->lastarray[5]=%s\n", cme->lastarray[5]);
> 			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(cme->is_case_sens), table_convert_char2int(table1, cme->lastarray[5], tcc2i_full_match));
> 			
> 			/*gtk_editable_delete_text(GTK_EDITABLE(GTK_COMBO(cme->region)->entry), 0, -1);
> 			converti = atoi(cme->lastarray[3]);
> 			convertc = table_convert_int2char(table2, converti);
> 			if (convertc) {
> 				gint pos=0;
> 				gtk_editable_insert_text(GTK_EDITABLE(GTK_COMBO(cme->region)->entry), convertc, strlen(convertc), &pos);
> 			}*/
> 			converti = atoi(cme->lastarray[3]);
> 			gtk_option_menu_set_history(GTK_OPTION_MENU(cme->region),converti);
> 
> 			num = atoi(cme->lastarray[6]);
> 			gtk_spin_button_set_value(GTK_SPIN_BUTTON(cme->num), num);
> 	
> 			cme_create_entries(cme, num);
> 			for (i = 0 ; i < num; i++) {
> 				gtk_entry_set_text(GTK_ENTRY(cme->descriptions[i]), cme->lastarray[i+7]);
> 			}
> 			for (i = num ; i < MAX_TEXT_ENTRY; i++) {
> 				gtk_entry_set_text(GTK_ENTRY(cme->descriptions[i]), "");
> 			}
> 		}
> 		DEBUG_MSG("cme_clist_select_lcb, finished\n");
> 	} else {
> 		gint i;
> 		gtk_entry_set_text(GTK_ENTRY(cme->menupath), "");
> 		{
> 			GtkTextIter itstart, itend;
> 			gtk_text_buffer_get_bounds(cme->befb,&itstart,&itend);
> 			gtk_text_buffer_delete(cme->befb,&itstart,&itend);
> 			gtk_text_buffer_get_bounds(cme->aftb,&itstart,&itend);
> 			gtk_text_buffer_delete(cme->aftb,&itstart,&itend);
> 		}
> 		gtk_spin_button_set_value(GTK_SPIN_BUTTON(cme->num), 0);
> 		for (i = 0 ; i < MAX_TEXT_ENTRY; i++) {
> 			gtk_entry_set_text(GTK_ENTRY(cme->descriptions[i]), "");
> 		}
> 		cme->lastarray = NULL;
> 		DEBUG_MSG("cme_clist_unselect_lcb, lastarray=%p\n", cme->lastarray);
> 	}
> }
> 
> static void cme_spin_changed_lcb(GtkWidget *widget, Tcmenu_editor *cme) {
> 	cme_create_entries(cme, gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(cme->num)));
> }
> 
> static void cme_type_changed_lcb(GtkWidget *widget, Tcmenu_editor *cme) {
> 	if (GTK_TOGGLE_BUTTON(cme->type[1])->active) {
> 		DEBUG_MSG("cme_clist_select_lcb, type[1] is active\n");
> 		gtk_widget_show(cme->csnr_box);
> 		gtk_label_set_text(GTK_LABEL(cme->label1), _("Search Pattern"));
> 		gtk_label_set_text(GTK_LABEL(cme->label2), _("Replace String"));
> 	} else {
> 		gtk_widget_hide(cme->csnr_box);
> 		gtk_label_set_text(GTK_LABEL(cme->label1), _("Formatstring Before"));
> 		gtk_label_set_text(GTK_LABEL(cme->label2), _("Formatstring After"));
> 	}
> }
> 
> static gchar **cme_create_array(Tcmenu_editor *cme, gboolean is_update) {
> 	gchar **newarray;
> 	gint num, i, type;
> 	
> 	gtk_spin_button_update(GTK_SPIN_BUTTON(cme->num));
> 	num  = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(cme->num));
> 	DEBUG_MSG("cme_create_array, num=%d\n", num);
> 	if (GTK_TOGGLE_BUTTON(cme->type[1])->active) {
> 		type = 1;
> 	} else {
> 		type = 0;
> 	}
> 	if (type == 0) {
> 		newarray = g_malloc0((num+5) * sizeof(char *));
> 	} else {
> 		newarray = g_malloc0((num+8) * sizeof(char *));
> 	}
> 	DEBUG_MSG("cme_create_array, newarray at %p\n",newarray);
> 	newarray[0] = gtk_editable_get_chars(GTK_EDITABLE(cme->menupath), 0, -1);
> 	{
> 		gboolean invalid=is_update;
> 		GList *tmplist = g_list_first(cme->worklist_insert);
> 		while (tmplist) {
> 			gchar **tmparr = (gchar **)tmplist->data;
> 			if (strcmp(tmparr[0],newarray[0])==0) {
> 				/* if it is an update they path should exist already, else is should not */
> 				invalid = (!is_update);
> 				break;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		tmplist = g_list_first(cme->worklist_replace);
> 		while (tmplist) {
> 			gchar **tmparr = (gchar **)tmplist->data;
> 			if (strcmp(tmparr[0],newarray[0])==0) {
> 				/* if it is an update they path should exist already, else is should not */
> 				invalid = (!is_update);
> 				break;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		if (invalid) {
> 			if (is_update) {
> 				warning_dialog(cme->bfwin->main_window,_("The menupath you want to update does not exist yet"), _("Try 'add' instead."));
> 			} else {
> 				warning_dialog(cme->bfwin->main_window,_("The menupath you want to add already exists."), NULL);
> 			}
> 		}
> 		if (newarray[0][0] != '/') {
> 			DEBUG_MSG("cme_create_array, menupath does not start with slash, returning NULL\n");
> 			warning_dialog(cme->bfwin->main_window,_("The menupath should start with a / character"), NULL);
> 			invalid = TRUE;
> 		}
> 		if (invalid) {
> 			g_free(newarray[0]);
> 			g_free(newarray);
> 			return (NULL);
> 		}
> 	}
> 	if (type == 0) {
> 		newarray[3] = gtk_editable_get_chars(GTK_EDITABLE(cme->num), 0, -1);
> 		for (i = 0 ; i < num; i++) {
> 			DEBUG_MSG("cme_create_array, adding descriptions[%d] to newarray[%d]\n", i, i+4);
> 			newarray[4+i] = gtk_editable_get_chars(GTK_EDITABLE(cme->descriptions[i]), 0, -1);
> 		}
> 		DEBUG_MSG("cme_create_array, setting newarray[%d] to NULL\n",i+4);
> 		newarray[4+i] = NULL;
> 	} else {
> /*		static Tconvert_table table2[] = {{0, N_("in current document")}, {1, N_("from cursor")}, {2, N_("in selection")}, {3, N_("in all open documents")}, {0,NULL}};
> 		static Tconvert_table table3[] = {{0, N_("normal")}, {1, N_("posix regular expressions")}, {2, N_("perl regular expressions")}, {0, NULL}};*/
> 		gint converti;
> /*		gchar *convertc;
> 		convertc = gtk_editable_get_chars(GTK_EDITABLE(GTK_COMBO(cme->region)->entry), 0, -1);
> 		converti = table_convert_char2int(table2, convertc, tcc2i_full_match_gettext);
> 		g_free(convertc);*/
> 		converti = gtk_option_menu_get_history(GTK_OPTION_MENU(cme->region));
> 		newarray[3] = g_strdup_printf("%d", converti);
> 
> 		/*convertc = gtk_editable_get_chars(GTK_EDITABLE(GTK_COMBO(cme->matching)->entry), 0, -1);
> 		g_free(convertc);*/
> 		converti = gtk_option_menu_get_history(GTK_OPTION_MENU(cme->matching));
> 		newarray[4] = g_strdup_printf("%d", converti);
> 		
> 		newarray[5] = g_strdup_printf("%d", GTK_TOGGLE_BUTTON(cme->is_case_sens)->active);
> 	
> 		newarray[6] = gtk_editable_get_chars(GTK_EDITABLE(cme->num), 0, -1);
> 		DEBUG_MSG("cme_create_array, newarray[6]=%s\n", newarray[6]);
> 		for (i = 0 ; i < num; i++) {
> 			DEBUG_MSG("cme_create_array, adding descriptions[%d] to newarray[%d]\n", i, i+7);
> 			newarray[7+i] = gtk_editable_get_chars(GTK_EDITABLE(cme->descriptions[i]), 0, -1);
> 		}
> 		DEBUG_MSG("cme_create_array, setting newarray[%d] to NULL\n",i+7);
> 		newarray[7+i] = NULL;
> 	}
> 	{
> 		GtkTextIter itstart, itend;
> 		gtk_text_buffer_get_bounds(cme->befb,&itstart,&itend);
> 		newarray[1] = gtk_text_buffer_get_text(cme->befb,&itstart,&itend, FALSE);
> 		gtk_text_buffer_get_bounds(cme->aftb,&itstart,&itend);
> 		newarray[2] = gtk_text_buffer_get_text(cme->aftb,&itstart,&itend, FALSE);
> 	}
> 
> 	return newarray;
> }
> 
> static void cme_add_lcb(GtkWidget *widget, Tcmenu_editor *cme) {
> 	gchar **newarray;
> 	newarray = cme_create_array(cme, FALSE);
> 	if (newarray != NULL){
> 		GtkTreeIter iter;
> 		GtkTreeSelection *gtsel;
> 		gint type = GTK_TOGGLE_BUTTON(cme->type[1])->active;
> 		DEBUG_MSG("cme_add_lcb, adding %p with type %d\n",newarray,type);
> 		if (type == 0) {
> 			cme->worklist_insert = g_list_append(cme->worklist_insert, newarray);
> 		} else {
> 			cme->worklist_replace = g_list_append(cme->worklist_replace, newarray);
> 		}
> 		gtk_list_store_append(GTK_LIST_STORE(cme->lstore),&iter);
> 		gtk_list_store_set(GTK_LIST_STORE(cme->lstore),&iter,0,newarray[0],1,type,2,newarray,-1);
> 		cme->lastarray = newarray;
> 		gtsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(cme->lview));
> 		gtk_tree_selection_select_iter(gtsel,&iter);
> 	}
> }
> 
> static void cme_update_lcb(GtkWidget *widget, Tcmenu_editor *cme) {
> 	gchar **newarray;
> 	if (cme->lastarray == NULL) {
> 		cme_add_lcb(NULL, cme);
> 		return;
> 	}
> 	newarray = cme_create_array(cme, TRUE);
> 	if (newarray) {
> 		GtkTreeIter iter;
> 		if (cme_iter_at_pointer(&iter, cme->lastarray, cme)) {
> 			gint newtype, oldtype;
> 			gtk_tree_model_get(GTK_TREE_MODEL(cme->lstore),&iter,1,&oldtype,-1);
> 			newtype = GTK_TOGGLE_BUTTON(cme->type[1])->active;
> 			gtk_list_store_set(GTK_LIST_STORE(cme->lstore),&iter,0,newarray[0],1,newtype,2,newarray,-1);
> 			if (oldtype == 0) {
> 				if (newtype == 1) {
> 					cme->worklist_insert = g_list_remove(cme->worklist_insert, cme->lastarray);
> 					cme->worklist_replace = g_list_append(cme->worklist_replace, newarray);
> 				} else {
> 					GList *tmplist = g_list_find(cme->worklist_insert,cme->lastarray);
> 					tmplist->data = newarray;
> 				}
> 			} else if (oldtype == 1) {
> 				if (newtype == 0) {
> 					cme->worklist_replace = g_list_remove(cme->worklist_replace, cme->lastarray);
> 					cme->worklist_insert = g_list_append(cme->worklist_insert, newarray);
> 				} else {
> 					GList *tmplist = g_list_find(cme->worklist_replace,cme->lastarray);
> 					tmplist->data = newarray;
> 				}
> 			}
> 		} else {
> 			DEBUG_MSG("cme_update_lcb, cannot find iter for pointer %p\n",cme->lastarray);
> 		}
> 		g_strfreev(cme->lastarray);
> 		cme->lastarray = newarray;
> 	} else {
> 		DEBUG_MSG ("cme_update_lcb, no new array, cancelled\n");
> 	}
> 	DEBUG_MSG ("cme_update_lcb finished\n");
> }
> 
> static void cme_delete_lcb(GtkWidget *widget, Tcmenu_editor *cme) {
> 	if (cme->lastarray) {
> 		GtkTreeIter iter;
> 		if (cme_iter_at_pointer(&iter, cme->lastarray, cme)) {
> 			gint type;
> 			DEBUG_MSG("cme_delete_lcb, removing from listmodel\n");
> 			gtk_tree_model_get(GTK_TREE_MODEL(cme->lstore),&iter,1,&type,-1);
> 			if (type == 0) {
> 				cme->worklist_insert = g_list_remove(cme->worklist_insert, cme->lastarray);
> 			} else if (type == 1) {
> 				cme->worklist_replace = g_list_remove(cme->worklist_replace, cme->lastarray);
> 			} else {
> 				DEBUG_MSG("NOT removed from lists, type=%d ???\n",type);
> 			}
> 			if (type == 1 || type == 0) {
> 				g_strfreev(cme->lastarray);
> 			}
> 			/* removing the iter will call cme_clist_unselect_lcb which will set the lastarray to NULL
> 			therefore we will do this as last action */
> 			gtk_list_store_remove(GTK_LIST_STORE(cme->lstore),&iter);
> 		} else {
> 			DEBUG_MSG("NOT REMOVED, no iter can be found for pointer %p?!?\n",cme->lastarray);
> 		}
> 		DEBUG_MSG("cme_delete_lcb, setting lastarray NULL\n");
> 		cme->lastarray = NULL;
> 	} else {
> 		DEBUG_MSG("cme_delete_lcb, lastarray=NULL, nothing to delete\n");
> 	}
> }
> 
> gint menu_entry_sort(gchar ** a,gchar ** b) {
> 	return strcmp(a[0],b[0]);
> }
> 
> void cmenu_editor(Tbfwin *bfwin,guint callback_action,GtkWidget *widget) {
> 	Tcmenu_editor *cme;
> 	GtkWidget *hbox, *vbox, *frame, *vbox2, *vbox3, *hbox2, *label, *toolbar;
> 	GList *tmplist;
> 	gint i;
> 	gchar *tmpstr;
> 	
> 	cme = g_malloc0(sizeof(Tcmenu_editor));
> 	cme->bfwin = bfwin;
> 	DEBUG_MSG("cmenu_editor, cme is at %p\n", cme);
> 	cme->win = window_full2(_("Custom Menu Editor"), GTK_WIN_POS_CENTER, 
> 							0, G_CALLBACK(cme_destroy_lcb), cme, TRUE, bfwin->main_window);
> 
> 	vbox = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(cme->win), vbox);
> 	
> 	toolbar = gtk_toolbar_new();
> 	gtk_toolbar_set_orientation(GTK_TOOLBAR(toolbar), GTK_ORIENTATION_HORIZONTAL);
> 	gtk_toolbar_set_icon_size(GTK_TOOLBAR(toolbar), GTK_ICON_SIZE_SMALL_TOOLBAR);
> 	gtk_box_pack_start(GTK_BOX(vbox), toolbar, FALSE, FALSE, 0);
> 	
> 	gtk_toolbar_insert_stock(GTK_TOOLBAR(toolbar), GTK_STOCK_ADD, _("Add New Menu Entry"),
> 								NULL, G_CALLBACK(cme_add_lcb), cme, -1);
> 	gtk_toolbar_insert_stock(GTK_TOOLBAR(toolbar), GTK_STOCK_APPLY, _("Apply Changes"),
> 								NULL, G_CALLBACK(cme_update_lcb), cme, -1);
> 	gtk_toolbar_insert_stock(GTK_TOOLBAR(toolbar), GTK_STOCK_DELETE, _("Delete Menu Entry"),
> 								NULL, G_CALLBACK(cme_delete_lcb), cme, -1);
> 	gtk_toolbar_append_space(GTK_TOOLBAR(toolbar));
> 	gtk_toolbar_insert_stock(GTK_TOOLBAR(toolbar), GTK_STOCK_CLOSE, _("Close Discards Changes"),
> 								NULL, G_CALLBACK(cme_close_lcb), cme, -1);
> 	gtk_toolbar_insert_stock(GTK_TOOLBAR(toolbar), GTK_STOCK_SAVE, _("Save Changes and Exit"),
> 								NULL, G_CALLBACK(cme_ok_lcb), cme, -1);
> 	
> 	vbox2 = gtk_vbox_new(FALSE, 12);
> 	gtk_container_set_border_width(GTK_CONTAINER(vbox2), 6);
> 	gtk_box_pack_start(GTK_BOX(vbox), vbox2, TRUE, TRUE, 0);							
> 	/* upper area */
> 	hbox = gtk_hbox_new(FALSE, 12);
> 	gtk_box_pack_start(GTK_BOX(vbox2), hbox, FALSE, TRUE, 6);
> 
> 	label = gtk_label_new_with_mnemonic(_("_Menu Path:"));
> 	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, TRUE, 0);
> 	cme->menupath = gtk_entry_new();
> 	gtk_label_set_mnemonic_widget(GTK_LABEL(label), cme->menupath);
> 	gtk_box_pack_start(GTK_BOX(hbox),cme->menupath , TRUE, TRUE, 0);
> 	
> 	hbox = gtk_hbox_new(FALSE, 12);
> 	gtk_box_pack_start(GTK_BOX(vbox2), hbox, TRUE, TRUE, 6);
> 
> 	/* clist & type area */
> 	vbox3 = gtk_vbox_new(FALSE, 12);	
> 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, TRUE, TRUE, 0);
> 	{
> 		GtkWidget *scrolwin;
> 		GtkTreeViewColumn *column;
> 		GtkTreeSelection *select;
> 		GtkCellRenderer *renderer = gtk_cell_renderer_text_new ();
> 
> 		cme->lstore = gtk_list_store_new (3, G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_POINTER);
> 		cme->lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(cme->lstore));
> 
> 		column = gtk_tree_view_column_new_with_attributes (_("Menu path"), renderer,"text", 0,NULL);
> 		gtk_tree_view_append_column (GTK_TREE_VIEW(cme->lview), column);
> 
> 		scrolwin = gtk_scrolled_window_new(NULL, NULL);
> 		gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
> 
> 		DEBUG_MSG("cmenu_editor, created lstore and lview\n");
> 		gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolwin), cme->lview);
> 		gtk_widget_set_size_request(scrolwin, 180, 250);
> 		gtk_box_pack_start(GTK_BOX(vbox3), scrolwin, TRUE, TRUE, 0);
> 		
> 		select = gtk_tree_view_get_selection(GTK_TREE_VIEW(cme->lview));
> 		g_signal_connect(G_OBJECT(select), "changed",G_CALLBACK(cme_lview_selection_changed),cme);
> 	}
> 
> 	/* dynamic entries area */
> 	vbox3 = gtk_vbox_new(FALSE, 0);	
> 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, TRUE, TRUE, 0);
> 
> 	hbox2 = gtk_hbox_new(FALSE, 12); 
> 	label = gtk_label_new_with_mnemonic(_("Number of _Variables:"));
> 	gtk_box_pack_start(GTK_BOX(hbox2), label, FALSE, FALSE, 0);		
> 	cme->num = spinbut_with_value(NULL, 0, MAX_TEXT_ENTRY, 1,1);
> 	g_signal_connect(GTK_OBJECT(cme->num), "changed", G_CALLBACK(cme_spin_changed_lcb), cme);
> 	gtk_label_set_mnemonic_widget(GTK_LABEL(label), cme->num);
> 	gtk_box_pack_start(GTK_BOX(hbox2),cme->num , FALSE, FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox3), hbox2, FALSE, FALSE, 0);
> 	
> 	frame = gtk_frame_new(_("Variables"));
> 	gtk_box_pack_end(GTK_BOX(vbox3), frame, TRUE, TRUE, 0);
> 	cme->dynvbox = gtk_vbox_new(FALSE, 2);	
> 	gtk_container_add(GTK_CONTAINER(frame), cme->dynvbox);
> 	for (i = 0; i <  MAX_TEXT_ENTRY; i++) {
> 		cme->hboxes[i] = gtk_hbox_new(FALSE, 0);
> 		gtk_box_pack_start(GTK_BOX(cme->dynvbox), cme->hboxes[i], FALSE, FALSE, 0);
> 		tmpstr = g_strdup_printf("%%%d: ", i);
> 		gtk_box_pack_start(GTK_BOX(cme->hboxes[i]), gtk_label_new(tmpstr), FALSE, FALSE, 0);
> 		g_free(tmpstr);
> 		cme->descriptions[i] = gtk_entry_new();
> 		gtk_box_pack_start(GTK_BOX(cme->hboxes[i]), cme->descriptions[i], TRUE, TRUE, 0);
> 	}
> 
> 	/* lower area */
> 	/* before and after text area */
> 	vbox3 = gtk_vbox_new(FALSE, 6);
> 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, TRUE, TRUE, 0);
> 	
> 	cme->type[0] = gtk_radio_button_new_with_mnemonic(NULL, _("Custom Dialo_g"));
> 	gtk_box_pack_start(GTK_BOX(vbox3), cme->type[0], FALSE, TRUE, 0);
> 	cme->type[1] = gtk_radio_button_new_with_mnemonic_from_widget(GTK_RADIO_BUTTON(cme->type[0]), _("Custom Replace"));
> 	gtk_box_pack_start(GTK_BOX(vbox3), cme->type[1], FALSE, TRUE, 0);
> 
> 	g_signal_connect(GTK_OBJECT(cme->type[0]), "toggled", G_CALLBACK(cme_type_changed_lcb), cme);
> 	
> 	/* csnr area */
> 	cme->csnr_box = gtk_vbox_new(FALSE, 6);
> 	gtk_box_pack_start(GTK_BOX(vbox3), cme->csnr_box, FALSE, TRUE, 12);
> 
> 	hbox2 = gtk_hbox_new(FALSE, 12);
> 	gtk_box_pack_start(GTK_BOX(cme->csnr_box), hbox2, FALSE, TRUE, 0);
> 	
> 	label = gtk_label_new_with_mnemonic(_("_Replace:"));
> 	gtk_box_pack_start(GTK_BOX(hbox2), label, FALSE, FALSE, 0);
> 	{
> 		gchar *whereoptions[] = {N_("in current document"),N_("from cursor"),N_("in selection"),N_("in all open documents"), NULL};
> 		cme->region = optionmenu_with_value(whereoptions, 0);
> 	}
> 	gtk_box_pack_start(GTK_BOX(hbox2),cme->region , TRUE, TRUE, 3);
> 	gtk_label_set_mnemonic_widget(GTK_LABEL(label), cme->region);
> 
> 	hbox2 = gtk_hbox_new(FALSE, 12);
> 	gtk_box_pack_start(GTK_BOX(cme->csnr_box), hbox2, TRUE, TRUE, 0);
> 	label = gtk_label_new_with_mnemonic(_("Matc_hing:"));
> 	gtk_box_pack_start(GTK_BOX(hbox2), label, FALSE, FALSE, 0);
> 	{
> 		gchar *matchactions[] = {N_("normal"), N_("posix regular expressions"),	N_("perl regular expressions"), NULL};
> 		cme->matching = optionmenu_with_value(matchactions, 0);
> 	}
> 	gtk_box_pack_start(GTK_BOX(hbox2),cme->matching , TRUE, TRUE, 3);
> 	gtk_label_set_mnemonic_widget(GTK_LABEL(label), cme->matching);
> 	
> 	cme->is_case_sens = boxed_checkbut_with_value(_("Case Se_nsitive"), 0, cme->csnr_box);
> 
> 	{
> 		GtkWidget *scrolwin, *textview;
> 		cme->label1 = gtk_label_new_with_mnemonic("");
> 		gtk_box_pack_start(GTK_BOX(vbox3), cme->label1, FALSE, FALSE, 0);
> 
> 		scrolwin = textview_buffer_in_scrolwin(&textview, -1, -1, NULL, GTK_WRAP_NONE);
> 		cme->befb = gtk_text_view_get_buffer(GTK_TEXT_VIEW(textview));
> 		gtk_box_pack_start(GTK_BOX(vbox3), scrolwin, TRUE, TRUE, 0);
> 
> 		cme->label2 = gtk_label_new_with_mnemonic("");
> 		gtk_box_pack_start(GTK_BOX(vbox3), cme->label2, FALSE, FALSE, 0);
> 		
> 		scrolwin = textview_buffer_in_scrolwin(&textview, -1, -1, NULL, GTK_WRAP_NONE);
> 		cme->aftb = gtk_text_view_get_buffer(GTK_TEXT_VIEW(textview));
> 		gtk_box_pack_start(GTK_BOX(vbox3), scrolwin, TRUE, TRUE, 0);
> 	}
> 	
> 	/* ready !! */
> 	cme->worklist_insert = duplicate_arraylist(main_v->props.cmenu_insert);
> 	cme->worklist_replace = duplicate_arraylist(main_v->props.cmenu_replace);
> 	cme->worklist_insert = g_list_sort(cme->worklist_insert, (GCompareFunc)menu_entry_sort);
> 	cme->worklist_replace = g_list_sort(cme->worklist_replace, (GCompareFunc)menu_entry_sort);
> 	{
> 		GtkTreeIter iter;
> 		tmplist = g_list_first(cme->worklist_insert);
> 		while (tmplist) {
> 			DEBUG_MSG("cmenu_editor, adding type 0 '%s'\n", *(gchar **)tmplist->data);
> 			gtk_list_store_append(GTK_LIST_STORE(cme->lstore), &iter);
> 			gtk_list_store_set(GTK_LIST_STORE(cme->lstore), &iter, 0, *(gchar **)tmplist->data, 1, 0, 2, tmplist->data, -1); /* the name , the type, the pointer */
> 			tmplist = g_list_next(tmplist);
> 		}
> 		tmplist = g_list_first(cme->worklist_replace);
> 		while (tmplist) {
> 			DEBUG_MSG("cmenu_editor, adding type 1 '%s'\n", *(gchar **)tmplist->data);
> 			gtk_list_store_append(GTK_LIST_STORE(cme->lstore), &iter);
> 			gtk_list_store_set(GTK_LIST_STORE(cme->lstore), &iter, 0, *(gchar **)tmplist->data, 1, 1, 2, tmplist->data, -1); /* the name , the type, the pointer */
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	gtk_widget_show_all(cme->win);
> 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(cme->type[0]), TRUE);
> 	cme_type_changed_lcb(NULL, cme);
> }
> 
> /*************************************************************************/
1,2270c1,2260
< /* Bluefish HTML Editor
<  * preferences.c - the preferences code
<  *
<  * Copyright (C) 2002-2005 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< /* #define DEBUG */
< 
< #include <gtk/gtk.h>
< #include <string.h>        /* strcmp() */
< 
< #include "bluefish.h"
< #include "bf_lib.h"        /* list_switch_order() */
< #include "document.h"
< #include "filebrowser.h"
< #include "gtk_easy.h"
< #include "gui.h"
< #include "highlight.h"
< #include "menu.h"
< #include "pixmap.h"
< #include "stringlist.h"    /* duplicate_arraylist*/
< 
< enum {
< 	view_html_toolbar,
< 	view_custom_menu,
< 	view_main_toolbar,
< 	view_left_panel,
< 	view_line_numbers,
< 	filebrowser_two_pane_view,
< 	filebrowser_unknown_icon,
< 	filebrowser_dir_icon,
< 	editor_show_splash_screen,    /* show splash screen at start-up */
< 	editor_show_quickbar_warning, /* show warning about empty quickbar at startup */
< 	editor_font_string,         /* editor font */
< 	editor_tab_width,           /* editor tabwidth */
< 	editor_indent_wspaces,
< 	editor_smart_cursor,
< 	tab_font_string,            /* notebook tabs font */
< 	highlight_num_lines_count,  /* number of lines to highlight in continous highlighting */	
< 	defaulthighlight,           /* highlight documents by default */
< #ifdef HAVE_PCRE_UTF8
< 	highlight_utf8,             /* enable PCRE UTF-8 support */
< #endif /* HAVE_PCRE_UTF8 */
< 	transient_htdialogs,        /* set html dialogs transient ro the main window */
< 	restore_dimensions,
< 	left_panel_width,
< 	left_panel_left,
< 	main_window_h,              /* main window height */
< 	main_window_w,              /* main window width */
< 	max_recent_files,           /* length of Open Recent list */
< 	max_dir_history,            /* length of directory history */
< 	backup_file,                /* wheather to use a backup file */
< 	backup_filestring,          /* the string to append to the backup file */
< 	backup_abort_action,        /* if the backup fails, continue 'save', 'abort' save, or 'ask' user */
< 	backup_cleanuponclose,      /* remove the backupfile after close ? */
< 	image_thumbnailstring,      /* string to append to thumbnail filenames */
< 	image_thumbnailtype,        /* fileformat to use for thumbnails, "jpeg" or "png" can be handled by gdkpixbuf*/
< 	image_thumbnailsizing_type,	/* scaling ratio=0, fixed width=1, height=2, width+height (discard aspect ratio)=3 */
< 	image_thumbnailsizing_val1,	/* the width, height or ratio, depending on the value above */
< 	image_thumbnailsizing_val2, /* height if the type=3 */
< 	image_thumnailformatstring, /* like <a href="%r"><img src="%t"></a> or more advanced */
< 	allow_multi_instances,      /* allow multiple instances of the same file */
< 	modified_check_type,        /* 0=no check, 1=by mtime and size, 2=by mtime, 3=by size, 4,5,...not implemented (md5sum?) */
< 	num_undo_levels,            /* number of undo levels per document */
< 	clear_undo_on_save,         /* clear all undo information on file save */
< 	newfile_default_encoding,   /* if you open a new file, what encoding will it use */
< 	auto_set_encoding_meta,     /* auto set metatag for the encoding */
< 	auto_update_meta_author,
< 	auto_update_meta_date,
< 	auto_update_meta_generator,
< 	ext_browsers_in_submenu,
< 	ext_commands_in_submenu,
< 	ext_outputbox_in_submenu,
< 	bookmarks_default_store,
< 	bookmarks_filename_mode,
< 	document_tabposition,
< 	leftpanel_tabposition,
< 	default_basedir,
< 	/* not yet in use */
< 	image_editor_cline,         /* image editor commandline */
< 	full_p,                     /* use </p> */
< 	full_li,                    /* use </li> */
< 	allow_css,                  /* CSS allowed */
< 	allow_dep,                  /* allow <FONT>... */
< 	format_by_context,          /* use <strong> instead of <b>, <emphasis instead of <i> etc. (W3C reccomendation) */
< 	xhtml,                      /* write <br /> */
< 	allow_ruby,                 /* allow <ruby> */
< 	allow_h4,                   /* allow <Q>... */
< 	allow_frames,               /* allow <FRAME> */
< 	force_dtd,                  /* write <!DOCTYPE...> */
< 	dtd_url,                    /* URL in DTD */
< 	xml_start,                  /* <?XML...> */
< 	lowercase_tags,             /* use lowercase tags */
< 	word_wrap,                  /* use wordwrap */
< 	autoindent,                 /* autoindent code */
< 	drop_at_drop_pos,           /* drop at drop position instead of cursor position */
< 	link_management,            /* perform link management */
< 	html_ver,
< 	cust_menu,                  /* entries in the custom menu */
< #ifdef WITH_SPC
< 	/* spell checker options */
< 	cfg_spc_cline,              /* spell checker command line */
< 	cfg_spc_lang,               /* language */
< 	spc_accept_compound,        /* accept compound words ? */
< 	spc_use_esc_chars,          /* specify aditional characters that may be part of a word ? */
< 	spc_esc_chars,              /* which ones ? */
< 	spc_use_pers_dict,          /* use a personal dictionary */
< 	spc_pers_dict,              /* which one ? */
<    spc_use_input_encoding,      /* use input encoding */
<    spc_input_encoding,          /* wich one ? */
<    spc_output_html_chars,       /* output html chars ? (like &aacute,)*/
< #endif
< 	/* key conversion */
< 	conv_ctrl_enter,            /* convert control-enter key press */
< 	ctrl_enter_text,            /* inserted text */
< 	conv_shift_enter,           /* convert shift-enter key press */
< 	shift_enter_text,           /* inserted text */
< 	conv_special_char,          /* convert ctrl-'<','>','&' */
< #ifdef WITH_MSG_QUEUE
< 	open_in_running_bluefish,   /* open commandline documents in already running session*/
< #endif /* WITH_MSG_QUEUE */
< #ifdef HAVE_GNOME_VFS
< 	server_zope_compat,
< #endif /* HAVE_GNOME_VFS */
< 	property_num_max
< };
< 
< enum {
< 	browsers,
< 	external_commands,
< 	filetypes,
< 	filefilters,
< 	highlight_patterns,
< 	outputbox,
< 	lists_num_max
< };
< 
< typedef struct {
< 	GtkListStore *lstore;
< 	GtkWidget *lview;
< 	int insertloc;
< 	GList **thelist;
< } Tlistpref;
< 
< typedef struct {
< 	GtkListStore *lstore;
< 	GtkWidget *lview;
< 	GtkWidget *entry[6];
< 	GtkWidget *popmenu;
< 	GtkWidget *check;
< 	GtkWidget *radio[9];
< 	gchar **curstrarr;
< 	const gchar *selected_filetype;
< } Thighlightpatterndialog;
< 
< typedef struct {
< 	GtkWidget *prefs[property_num_max];
< 	GList *lists[lists_num_max];
< 	GtkWidget *win;
< 	GtkWidget *noteb;
< 	Tlistpref ftd;
< 	Tlistpref ffd;
< 	Thighlightpatterndialog hpd;
< 	Tlistpref bd;
< 	Tlistpref ed;
< 	Tlistpref od;
< } Tprefdialog;
< 
< typedef enum {
< 	string_none,
< 	string_file,
< 	string_font,
< 	string_color
< } Tprefstringtype;
< 
< /* type 0/1=text, 2=toggle */
< static void pref_create_column(GtkTreeView *treeview, gint type, GCallback func, gpointer data, const gchar *title, gint num) {
< 	GtkTreeViewColumn *column;
< 	GtkCellRenderer *renderer;
< 	if (type == 1 || type == 0) {
< 		renderer = gtk_cell_renderer_text_new();
< 		g_object_set(G_OBJECT(renderer), "editable", TRUE, NULL);
< 		g_signal_connect(G_OBJECT(renderer), "edited", func, data);
< 	} else {
< 		renderer = gtk_cell_renderer_toggle_new();
< 		g_object_set(G_OBJECT(renderer), "activatable", TRUE, NULL);
< 		g_signal_connect(G_OBJECT(renderer), "toggled", func, data);
< 	}
< 	column = gtk_tree_view_column_new_with_attributes(title, renderer,(type ==1) ? "text" : "active" ,num,NULL);
< 	gtk_tree_view_append_column(GTK_TREE_VIEW(treeview), column);
< }
< /* 3 entries must have len 3, but in reality it will be 4, because there is a NULL pointer appended */
< static gchar **pref_create_empty_strarr(gint len) {
< 	gchar **strarr = g_malloc0((len+1)*sizeof(gchar *));
< 	gint i;
< 	strarr[0] = g_strdup(_("Untitled"));
< 	for (i=1;i<len;i++) {
< 		strarr[i] = g_strdup("");
< 	}
< 	strarr[len] = NULL;
< 	return strarr;
< }
< /* type 0=escapedtext, 1=text, 2=toggle */
< static void pref_apply_change(GtkListStore *lstore, gint pointerindex, gint type, gchar *path, gchar *newval, gint index) {
< 	gchar **strarr;
< 	GtkTreeIter iter;
< 	GtkTreePath* tpath = gtk_tree_path_new_from_string(path);
< 	if (tpath && gtk_tree_model_get_iter(GTK_TREE_MODEL(lstore),&iter,tpath)) {
< 		gtk_tree_model_get(GTK_TREE_MODEL(lstore), &iter, pointerindex, &strarr, -1);
< 		DEBUG_MSG("pref_apply_change, lstore=%p, index=%d, type=%d, got strarr=%p\n",lstore,index,type,strarr);
< 		if (type ==1) {
< 			gtk_list_store_set(GTK_LIST_STORE(lstore),&iter,index,newval,-1);
< 		} else {
< 			gtk_list_store_set(GTK_LIST_STORE(lstore),&iter,index,(newval[0] == '1'),-1);
< 		}
< 		if (strarr[index]) {
< 			DEBUG_MSG("pref_apply_change, old value for strarr[%d] was %s\n",index,strarr[index]);
< 			g_free(strarr[index]);
< 		}
< 		if (type == 0) {
< 			strarr[index] = unescape_string(newval, FALSE);
< 		} else {
< 			strarr[index] = g_strdup(newval);
< 		}
< 		DEBUG_MSG("pref_apply_change, strarr[%d] now is %s\n",index,strarr[index]);
< 	} else {
< 		DEBUG_MSG("ERROR: path %s was not converted to tpath(%p) or iter (lstore=%p)\n",path,tpath,lstore);
< 	}
< 	gtk_tree_path_free(tpath);
< }
< static void pref_delete_strarr(Tprefdialog *pd, Tlistpref *lp, gint pointercolumn) {
< 	GtkTreeIter iter;
< 	GtkTreeSelection *select;
< 	lp->insertloc = -1;
< 	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(lp->lview));
< 	if (gtk_tree_selection_get_selected (select,NULL,&iter)) {
< 		gchar **strarr;
< 		gtk_tree_model_get(GTK_TREE_MODEL(lp->lstore), &iter, pointercolumn, &strarr, -1);
< 		gtk_list_store_remove(GTK_LIST_STORE(lp->lstore),&iter);
< 		*lp->thelist = g_list_remove(*lp->thelist, strarr);
< 		g_strfreev(strarr);
< 	}
< }
< 
< static void listpref_row_inserted(GtkTreeModel *treemodel,GtkTreePath *arg1,GtkTreeIter *arg2,Tlistpref *lp) {
< 	gint *indices = gtk_tree_path_get_indices(arg1);
< 	if (indices) {
< 		lp->insertloc = indices[0];
< 		DEBUG_MSG("reorderable_row_inserted, insertloc=%d\n",lp->insertloc);
< 	}
< }
< static void listpref_row_deleted(GtkTreeModel *treemodel,GtkTreePath *arg1,Tlistpref *lp) {
< 	if (lp->insertloc > -1) {
< 		gint *indices = gtk_tree_path_get_indices(arg1);
< 		if (indices) {
< 			GList *lprepend, *ldelete;
< 			gint deleteloc = indices[0];
< 			if (deleteloc > lp->insertloc) deleteloc--;
< 			DEBUG_MSG("reorderable_row_deleted, deleteloc=%d, insertloc=%d, listlen=%d\n",deleteloc,lp->insertloc,g_list_length(*lp->thelist));
< 			*lp->thelist = g_list_first(*lp->thelist);
< 			lprepend = g_list_nth(*lp->thelist,lp->insertloc);
< 			ldelete = g_list_nth(*lp->thelist,deleteloc);
< 			if (ldelete && (ldelete != lprepend)) {
< 				gpointer data = ldelete->data;
< 				*lp->thelist = g_list_remove(*lp->thelist, data);
< 				if (lprepend == NULL) {
< 					DEBUG_MSG("lprepend=NULL, appending %s to the list\n",((gchar **)data)[0]);
< 					*lp->thelist = g_list_append(g_list_last(*lp->thelist), data);
< 				} else {
< 					DEBUG_MSG("lprepend %s, ldelete %s\n",((gchar **)lprepend->data)[0], ((gchar **)data)[0]);
< 					*lp->thelist = g_list_prepend(lprepend, data);
< 				}
< 				*lp->thelist = g_list_first(*lp->thelist);
< 			} else {
< 				DEBUG_MSG("listpref_row_deleted, ERROR: ldelete %p, lprepend %p\n", ldelete, lprepend);
< 			}
< 		}
< 		lp->insertloc = -1;
< 	}
< }
< 
< static void font_dialog_response_lcb(GtkDialog *fsd,gint response,GtkWidget *entry) {
< 	DEBUG_MSG("font_dialog_response_lcb, response=%d\n", response);
< 	if (response == GTK_RESPONSE_OK) {
< 		gchar *fontname;
< 		fontname = gtk_font_selection_dialog_get_font_name(GTK_FONT_SELECTION_DIALOG(fsd));
< 		gtk_entry_set_text(GTK_ENTRY(entry), fontname);
< 		g_free(fontname);
< 	}
< 	gtk_widget_destroy(GTK_WIDGET(fsd));
< }
< 
< static void font_button_lcb(GtkWidget *wid, GtkWidget *entry) {
< 	GtkWidget *fsd;
< 	const gchar *fontname;
< 	fsd = gtk_font_selection_dialog_new(_("Select font"));
< 	fontname = gtk_entry_get_text(GTK_ENTRY(entry)); /* do NOT free, this is an internal pointer */
< 	if (strlen(fontname)) {
< 		gtk_font_selection_dialog_set_font_name(GTK_FONT_SELECTION_DIALOG(fsd), fontname);
< 	}
< 	g_signal_connect(GTK_OBJECT(fsd),"response",G_CALLBACK(font_dialog_response_lcb),entry);
< 	gtk_window_set_transient_for(GTK_WINDOW(GTK_DIALOG(fsd)), GTK_WINDOW(gtk_widget_get_toplevel(entry)));
< 	gtk_window_set_modal(GTK_WINDOW(GTK_DIALOG(fsd)), TRUE);
< 	gtk_window_set_destroy_with_parent(GTK_WINDOW(GTK_DIALOG(fsd)), TRUE);
< 	gtk_widget_show(fsd);
< }
< 
< static GtkWidget *prefs_string(const gchar *title, const gchar *curval, GtkWidget *box, Tprefdialog *pd, Tprefstringtype prefstringtype) {
< 	GtkWidget *hbox, *return_widget;
< 
< 	hbox = gtk_hbox_new(FALSE,3);
< 	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 3);
< 	gtk_box_pack_start(GTK_BOX(hbox), gtk_label_new(title), FALSE, FALSE, 3);
< 	return_widget = boxed_entry_with_text(curval, 1023, hbox);
< 	if (prefstringtype == file) {
< 		gtk_box_pack_start(GTK_BOX(hbox), file_but_new(return_widget, 1, NULL), FALSE, FALSE, 3);
< 	} else if (prefstringtype == font) {
< 		GtkWidget *but = bf_gtkstock_button(GTK_STOCK_SELECT_FONT, G_CALLBACK(font_button_lcb), return_widget);
< 		gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, FALSE, 3);
< 	}
< 	return return_widget;
< }
< 
< static GtkWidget *prefs_combo(const gchar *title, const gchar *curval, GtkWidget *box, Tprefdialog *pd, GList *poplist, gboolean editable) {
< 	GtkWidget *return_widget;
< 	GtkWidget *hbox;
< 
< 	hbox = gtk_hbox_new(FALSE,3);
< 	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 3);
< 	gtk_box_pack_start(GTK_BOX(hbox), gtk_label_new(title), FALSE, FALSE, 3);
< 	return_widget = boxed_combo_with_popdown(curval, poplist, editable, hbox);
< 	return return_widget;
< }
< 
< static GtkWidget *prefs_integer(const gchar *title, const gint curval, GtkWidget *box, Tprefdialog *pd, gfloat lower, gfloat upper) {
< 	GtkWidget *return_widget;
< 	GtkWidget *hbox;
< 	GtkObject *adjust;
< 	gfloat step_increment, page_increment;
< 
< 	step_increment = (upper - lower)/1000;
< 	if (step_increment < 1) {
< 		step_increment = 1;
< 	}
< 	page_increment = (upper - lower)/20;
< 	if (page_increment < 10) {
< 		page_increment = 10;
< 	}
< 	hbox = gtk_hbox_new(FALSE,3);
< 	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 3);
< 	adjust = gtk_adjustment_new((1.0 * curval), lower, upper, step_increment ,page_increment , 0);
< 	return_widget = gtk_spin_button_new(GTK_ADJUSTMENT(adjust), 0.1, 0);
< 	gtk_box_pack_start(GTK_BOX(hbox), gtk_label_new(title), FALSE, FALSE, 3);
< 	gtk_box_pack_start(GTK_BOX(hbox), return_widget, TRUE, TRUE, 3);
< 	return return_widget;
< }
< 
< 
< /*************************/
< /* GENERAL FUNCTIONS     */
< /*************************/
< /* static GList *general_poplist(GList *arraylist, gint required_items, gint poplist_label_index) {
< 	GList *tmplist, *poplist=NULL;
< 	
< 	tmplist = g_list_first(arraylist);
< 	while(tmplist){
< 		gchar **strarr =(gchar **)tmplist->data;
< 		if (count_array(strarr) >= required_items) poplist = g_list_append(poplist, strarr[poplist_label_index]);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return poplist;
< }*/
< /*
< static void generic_selection_changed_cb(GtkTreeSelection *selection
< 	, GtkWidget **entry, void (*apply_func)(), Tprefdialog *pd,gint whichlist, gint numentries, gchar ***newcurstrarr){
< 	GtkTreeIter iter;
< 	GtkTreeModel *model;
< 	DEBUG_MSG("generic_selection_changed_cb, started\n");
< 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
< 		gchar *value;
< 		GList *tmplist = g_list_first(pd->lists[whichlist]);
< 		gtk_tree_model_get(model, &iter, 0, &value, -1);
< 		apply_func(pd);
< 		while (tmplist) {
< 			gchar **strarr =(gchar **)tmplist->data;
< 			if (strcmp(strarr[0],value)==0) {
< 				gint i;
< 				for (i=0;i<numentries;i++) {
< 					gtk_entry_set_text(GTK_ENTRY(entry[i]), strarr[i]);
< 				}
< 				DEBUG_MSG("generic_selection_changed_cb, newcurstrarr(%p) is now %p\n", newcurstrarr, *newcurstrarr);
< 				*newcurstrarr = strarr;
< 				DEBUG_MSG("generic_selection_changed_cb, newcurstrarr(%p) set to %p (check %p)\n", newcurstrarr, strarr, *newcurstrarr);
< 				return;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	} else {
< 		DEBUG_MSG("generic_selection_changed_cb, no selection ?!?!\n");
< 	}
< }
< 
< static gchar **generic_create_strarr(gint numitems, GtkWidget **entries, gboolean force_firstitem_strlen) {
< 	gint i;
< 	gchar **strarr = g_malloc((numitems+1)*sizeof(gchar *));
< 	for (i=0;i<numitems;i++) {
< 		strarr[i] = gtk_editable_get_chars(GTK_EDITABLE(entries[i]), 0, -1);
< 	}
< 	strarr[numitems] = NULL;
< 	if (strlen(strarr[0])) {
< 		return strarr;
< 	} else {
< 		g_strfreev(strarr);
< 		return NULL;
< 	}
< }*/
< 
< /**********************************************************/
< /* FILETYPE, FILTERS AND HIGHLIGHT PATTERNS FUNCTIONS     */
< /**********************************************************/
< 
< /* static void add_new_general_lcb(Tprefdialog *pd, GtkWidget *entry, gint numentries, gint whichlist, GtkListStore *lstore) {
< 	gchar *newtype = gtk_editable_get_chars(GTK_EDITABLE(entry),0,-1);
< 	DEBUG_MSG("add_new_general_lcb, newtype=%s\n", newtype);
< 	if (strlen(newtype)) {
< 		gint i;
< 		gchar **strarr = g_malloc((numentries+1)*sizeof(gchar *));
< 		strarr[0] = newtype;
< 		for (i=1;i<numentries;i++) {
< 			strarr[i] = g_strdup("");
< 		}
< 		strarr[i] = NULL;
< 		pd->lists[whichlist] = g_list_append(pd->lists[whichlist], strarr);
< 		{
< 			GtkTreeIter iter;
< 			gtk_list_store_append(GTK_LIST_STORE(lstore), &iter);
< 			for (i=0;i<numentries;i++) {
< 				gtk_list_store_set(GTK_LIST_STORE(lstore),&iter,i,strarr[i],-1);
< 			}
< 		}
< 	} else {
< 		g_free(newtype);
< 	}
< } */
< /*
< static gchar **filetype_create_strarr(Tprefdialog *pd) {
< 	gchar **strarr;
< 	gchar *escaped, *tmp;
< 	tmp = gtk_editable_get_chars(GTK_EDITABLE(pd->ftd.entry[0]),0,-1);
< 	if (strlen(tmp)) {
< 		strarr = g_malloc(8*sizeof(gchar *));
< 		strarr[0] = tmp;
< 		strarr[1] = gtk_editable_get_chars(GTK_EDITABLE(pd->ftd.entry[1]),0,-1);
< 		escaped = gtk_editable_get_chars(GTK_EDITABLE(pd->ftd.entry[2]),0,-1);
< 		strarr[2] = unescape_string(escaped, FALSE);
< 		g_free(escaped);
< 		strarr[3] = gtk_editable_get_chars(GTK_EDITABLE(pd->ftd.entry[3]),0,-1);
< 		strarr[4] = g_strdup(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(pd->ftd.entry[4])) ? "1" : "0");
< 		strarr[5] = gtk_editable_get_chars(GTK_EDITABLE(pd->ftd.entry[5]),0,-1);
< 		strarr[6] = g_strdup("1");
< 		strarr[7] = NULL;
< 		DEBUG_MSG("filetype_create_strarr, created at %p\n", strarr);
< 		return strarr;
< 	} else {
< 		g_free(tmp);
< 		return NULL;
< 	}
< }
< 
< static void set_filetype_strarr_in_list(GtkTreeIter *iter, gchar **strarr, Tprefdialog *pd) {
< 	gint arrcount;
< 	arrcount = count_array(strarr);
< 	if (arrcount==7) {
< 		gchar *escaped;
< 		DEBUG_MSG("set_filetype_strarr_in_list, escaping %s\n",strarr[2]);
< 		escaped = escape_string(strarr[2],FALSE);
< 		DEBUG_MSG("set_filetype_strarr_in_list, 4=%d, string was %s\n",(strarr[4][0] != '0'), strarr[4]);
< 		gtk_list_store_set(GTK_LIST_STORE(pd->ftd.lstore), iter
< 			,0,strarr[0]
< 			,1,strarr[1]
< 			,2,escaped
< 			,3,strarr[3]
< 			,4,(strarr[4][0] != '0')
< 			,5,strarr[5]
< 			,6,strarr[6]
< 			,7,strarr
< 			,-1);
< 		g_free(escaped);
< 	}
< }
< 
< static void filetype_apply_changes(Tprefdialog *pd) {
< 	DEBUG_MSG("filetype_apply_changes, started\n");
< 	if (pd->ftd.curstrarr) {
< 		GtkTreeIter iter;
< 		gboolean retval;
< 		GList *tmplist;
< 		tmplist = g_list_first(pd->lists[filetypes]);
< 		while (tmplist) {
< 			if (tmplist->data == pd->ftd.curstrarr) {
< 				g_strfreev(pd->ftd.curstrarr);
< 				tmplist->data = filetype_create_strarr(pd);
< 				pd->ftd.curstrarr = tmplist->data;
< 				DEBUG_MSG("filetype_apply_changes, applied changes to pd->lists new curstrarr=%p\n", pd->ftd.curstrarr);
< 				break;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		
< 		retval = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->ftd.lstore),&iter);
< 		DEBUG_MSG("filetype_apply_changes, searching for '%s' in liststore\n",pd->ftd.curstrarr[0]);
< 		while (retval) {
< 			gchar *curval;
< 			gtk_tree_model_get(GTK_TREE_MODEL(pd->ftd.lstore),&iter,0,&curval,-1);
< 			if (strcmp(curval,pd->ftd.curstrarr[0])==0) {
< 				DEBUG_MSG("filetype_apply_changes, found it, set listore 0=%s,1=%s,...\n", pd->ftd.curstrarr[0], pd->ftd.curstrarr[1]);
< 				set_filetype_strarr_in_list(&iter,pd->ftd.curstrarr,pd);
< 				break;
< 			}
< 			retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->ftd.lstore),&iter);
< 		}
< 	} else {
< 		DEBUG_MSG("filetype_apply_changes, no curstrarr, nothing to apply\n");
< 	}
< }
< 
< static void filetype_selection_changed_cb(GtkTreeSelection *selection, Tprefdialog *pd) {
< 	GtkTreeIter iter;
< 	GtkTreeModel *model;
< 	DEBUG_MSG("filetype_selection_changed_cb, started\n");
< 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
< 		gchar *filetype;
< 		GList *tmplist = g_list_first(pd->lists[filetypes]);
< 		gtk_tree_model_get(model, &iter, 0, &filetype, -1);
< 		filetype_apply_changes(pd);
< 		while (tmplist) {
< 			gchar **strarr =(gchar **)tmplist->data;
< 			DEBUG_MSG("filetype_selection_changed_cb, searching for '%s'\n",filetype);
< 			if (strcmp(strarr[0],filetype)==0) {
< 				gchar *escaped = escape_string(strarr[2],FALSE);
< 				gtk_entry_set_text(GTK_ENTRY(pd->ftd.entry[0]), strarr[0]);
< 				gtk_entry_set_text(GTK_ENTRY(pd->ftd.entry[1]), strarr[1]);
< 				gtk_entry_set_text(GTK_ENTRY(pd->ftd.entry[2]), escaped);
< 				gtk_entry_set_text(GTK_ENTRY(pd->ftd.entry[3]), strarr[3]);
< 				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->ftd.entry[4]), (strarr[4][0] != '0'));
< 				gtk_entry_set_text(GTK_ENTRY(pd->ftd.entry[5]), strarr[5]);
< 				pd->ftd.curstrarr = strarr;
< 				g_free(escaped);
< 				return;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		DEBUG_MSG("filetype_selection_changed_cb, NOTHING FOUND ?!?!?\n");
< 	} else {
< 		DEBUG_MSG("filetype_selection_changed_cb, no selection ?!?!\n");
< 	}
< }
< */
< static void set_filetype_strarr_in_list(GtkTreeIter *iter, gchar **strarr, Tprefdialog *pd) {
< 	gint arrcount;
< 	arrcount = count_array(strarr);
< 	if (arrcount==7) {
< 		gchar *escaped;
< 		escaped = escape_string(strarr[2],FALSE);
< 		gtk_list_store_set(GTK_LIST_STORE(pd->ftd.lstore), iter
< 				,0,strarr[0],1,strarr[1],2,escaped,3,strarr[3]
< 				,4,(strarr[4][0] != '0'),5,strarr[5],6,strarr[6]
< 				,7,strarr,-1);
< 		g_free(escaped);
< 	}
< }
< static void filetype_apply_change(Tprefdialog *pd, gint type, gchar *path, gchar *newval, gint index) {
< 	pref_apply_change(pd->ftd.lstore,7,type,path,newval,index);
< }
< static void filetype_0_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	filetype_apply_change(pd, 1, path, newtext, 0);
< }
< static void filetype_1_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	filetype_apply_change(pd, 1, path, newtext, 1);
< }
< static void filetype_2_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	filetype_apply_change(pd, 1, path, newtext, 2);
< }
< static void filetype_3_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	filetype_apply_change(pd, 1, path, newtext, 3);
< }
< static void filetype_4_toggled_lcb(GtkCellRendererToggle *cellrenderertoggle,gchar *path,Tprefdialog *pd) {
< 	gchar *val = g_strdup(cellrenderertoggle->active ? "0" : "1");
< 	filetype_apply_change(pd, 2, path, val, 4);
< 	g_free(val);
< }
< static void filetype_5_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	filetype_apply_change(pd, 1, path, newtext, 5);
< }
< static void filetype_6_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	if (strlen(newtext)==1 && newtext[0] >= '0' && newtext[0] <= '2') {
< 		filetype_apply_change(pd, 1, path, newtext, 6);
< 	}
< }
< 
< static void add_new_filetype_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	gchar **strarr;
< 	GtkTreeIter iter;
< 	strarr = pref_create_empty_strarr(7);
< 	gtk_list_store_append(GTK_LIST_STORE(pd->ftd.lstore), &iter);
< 	set_filetype_strarr_in_list(&iter, strarr,pd);
< 	pd->lists[filetypes] = g_list_append(pd->lists[filetypes], strarr);
< 	pd->ftd.insertloc = -1;
< }
< static void delete_filetype_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	pref_delete_strarr(pd, &pd->ftd, 7);
< }
< 
< static void create_filetype_gui(Tprefdialog *pd, GtkWidget *vbox1) {
< 	GtkWidget *hbox, *but, *scrolwin;
< 	pd->lists[filetypes] = duplicate_arraylist(main_v->props.filetypes);
< 	pd->ftd.lstore = gtk_list_store_new (8,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_POINTER);
< 	pd->ftd.lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(pd->ftd.lstore));
< 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 1, G_CALLBACK(filetype_0_edited_lcb), pd, _("Label"), 0);
< 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 1, G_CALLBACK(filetype_1_edited_lcb), pd, _("Extensions"), 1);
< 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 1, G_CALLBACK(filetype_2_edited_lcb), pd, _("Update chars"), 2);
< 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 1, G_CALLBACK(filetype_3_edited_lcb), pd, _("Icon"), 3);
< 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 2, G_CALLBACK(filetype_4_toggled_lcb), pd, _("Editable"), 4);
< 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 1, G_CALLBACK(filetype_5_edited_lcb), pd, _("Content regex"), 5);
< 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 1, G_CALLBACK(filetype_6_edited_lcb), pd, _("Auto close tags mode"), 6);
< 
< 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin),GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
< 	gtk_container_add(GTK_CONTAINER(scrolwin), pd->ftd.lview);
< 	gtk_widget_set_size_request(scrolwin, 150, 190);
< 	gtk_box_pack_start(GTK_BOX(vbox1), scrolwin, TRUE, TRUE, 2);
< 	
< /*	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->ftd.lview));
< 	gtk_tree_selection_set_mode (select, GTK_SELECTION_SINGLE);
< 	g_signal_connect(G_OBJECT(select), "changed",G_CALLBACK(filetype_selection_changed_cb),pd);*/
< 	{
< 		GList *tmplist = g_list_first(pd->lists[filetypes]);
< 		while (tmplist) {
< 			gint arrcount;
< 			gchar **strarr = (gchar **)tmplist->data;
< 			arrcount = count_array(strarr);
< 			if (arrcount==7) {
< 				GtkTreeIter iter;
< 				gtk_list_store_append(GTK_LIST_STORE(pd->ftd.lstore), &iter);
< 				set_filetype_strarr_in_list(&iter, strarr,pd);
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	gtk_tree_view_set_reorderable(GTK_TREE_VIEW(pd->ftd.lview), TRUE);
< 	pd->ftd.thelist = &pd->lists[filetypes];
< 	pd->ftd.insertloc = -1;
< 	g_signal_connect(G_OBJECT(pd->ftd.lstore), "row-inserted", G_CALLBACK(listpref_row_inserted), &pd->ftd);
< 	g_signal_connect(G_OBJECT(pd->ftd.lstore), "row-deleted", G_CALLBACK(listpref_row_deleted), &pd->ftd);
< 
< 	hbox = gtk_hbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox1),hbox, TRUE, TRUE, 2);
< 	but = bf_gtkstock_button(GTK_STOCK_ADD, G_CALLBACK(add_new_filetype_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
< 	but = bf_gtkstock_button(GTK_STOCK_DELETE, G_CALLBACK(delete_filetype_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
< }
< /*
< static gchar **filefilter_create_strarr(Tprefdialog *pd) {
< 	gchar **strarr = g_malloc(4*sizeof(gchar *));
< 	strarr[0] = gtk_editable_get_chars(GTK_EDITABLE(pd->ffd.entry[0]), 0, -1);
< 	if (GTK_TOGGLE_BUTTON(pd->ffd.check)->active){
< 			strarr[1] = g_strdup("0");
< 		} else {
< 			strarr[1] = g_strdup("1");
< 		}
< 	strarr[2] = gtk_editable_get_chars(GTK_EDITABLE(pd->ffd.entry[1]), 0, -1);
< 	strarr[3] = NULL;
< 	return strarr;
< }
< 
< static void filefilter_apply_changes(Tprefdialog *pd) {
< 	DEBUG_MSG("filefilters_apply_changes, started\n");
< 	if (pd->ffd.curstrarr) {
< 		gchar **strarr;
< 		strarr = filefilter_create_strarr(pd);
< 		if (strarr) {
< 			GList *tmplist;
< 			GtkTreeIter iter;
< 			gboolean retval = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->ffd.lstore),&iter);
< 			while (retval) {
< 				gchar *curval;
< 				gtk_tree_model_get(GTK_TREE_MODEL(pd->ffd.lstore),&iter,0,&curval,-1);
< 				if (strcmp(curval,pd->ffd.curstrarr[0])==0) {
< 					gtk_list_store_set(GTK_LIST_STORE(pd->ffd.lstore), &iter
< 						,0,strarr[0]
< 						,1,(strarr[1][0] == '0')
< 						,2,strarr[2]
< 						,-1);
< 					DEBUG_MSG("filefilters_apply_changes, changed in tree model\n");
< 					break;
< 				}
< 				retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->ffd.lstore),&iter);
< 			}
< 
< 			tmplist = g_list_first(pd->lists[filefilters]);
< 			while (tmplist) {
< 				if (tmplist->data == pd->ffd.curstrarr) {
< 					g_strfreev(pd->ffd.curstrarr);
< 					tmplist->data = strarr;
< 					pd->ffd.curstrarr = strarr;
< 					DEBUG_MSG("filefilters_apply_changes, changed custrarr\n");
< 					break;
< 				}
< 				tmplist = g_list_next(tmplist);
< 			}
< 		} else {
< 			DEBUG_MSG("filefilters_apply_changes, NO strarr!!\n");
< 		}
< 	} else {
< 		DEBUG_MSG("filefilters_apply_changes, NO curstrarr!!\n");
< 	}
< }
< 
< static void add_new_filefilter_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	gchar **strarr;
< 	strarr = filefilter_create_strarr(pd);
< 	if (strarr) {
< 		GtkTreeIter iter;
< 		pd->lists[filefilters] = g_list_append(pd->lists[filefilters], strarr);
< 		gtk_list_store_append(GTK_LIST_STORE(pd->ffd.lstore), &iter);
< 		gtk_list_store_set(GTK_LIST_STORE(pd->ffd.lstore), &iter
< 				,0,strarr[0]
< 				,1,(strarr[1][0]=='0')
< 				,2,strarr[2]
< 				,-1);
< 	}
< }
< static void filefilter_selection_changed_cb(GtkTreeSelection *selection, Tprefdialog *pd) {
< 	GtkTreeIter iter;
< 	GtkTreeModel *model;
< 	DEBUG_MSG("filefilter_selection_changed_cb, curstrarr=%p, &curstrarr=%p\n", pd->ftd.curstrarr, &pd->ffd.curstrarr);
< 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
< 		gchar *filefilter;
< 		GList *tmplist = g_list_first(pd->lists[filefilters]);
< 		gtk_tree_model_get(model, &iter, 0, &filefilter, -1);
< 		filefilter_apply_changes(pd);
< 		while (tmplist) {
< 			gchar **strarr =(gchar **)tmplist->data;
< 			if (strcmp(strarr[0],filefilter)==0) {
< 				gtk_entry_set_text(GTK_ENTRY(pd->ffd.entry[0]), strarr[0]);
< 				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->ffd.check), (strarr[1][0] == '0'));
< 				gtk_entry_set_text(GTK_ENTRY(pd->ffd.entry[1]), strarr[2]);
< 				pd->ffd.curstrarr = strarr;
< 				DEBUG_MSG("filefilter_selection_changed_cb, found %s, curstrarr=%p\n", filefilter, strarr);
< 				return;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		DEBUG_MSG("filefilter_selection_changed_cb, could not find the selected text %s\n", filefilter);
< 	} else {
< 		DEBUG_MSG("filefilter_selection_changed_cb, no selection ?!?!\n");
< 	}
< }*/
< static void set_filefilter_strarr_in_list(GtkTreeIter *iter, gchar **strarr, Tprefdialog *pd) {
< 	gint arrcount;
< 	arrcount = count_array(strarr);
< 	if (arrcount==3) {
< 		gtk_list_store_set(GTK_LIST_STORE(pd->ffd.lstore), iter
< 				,0,strarr[0],1,(strarr[1][0] != '0'),2,strarr[2],3,strarr,-1);
< 	} else {
< 		DEBUG_MSG("ERROR: set_filefilter_strarr_in_list, arraycount != 3 !!!!!!\n");
< 	}
< }
< static void filefilter_apply_change(Tprefdialog *pd, gint type, gchar *path, gchar *newval, gint index) {
< 	DEBUG_MSG("filefilter_apply_change,lstore=%p,path=%s,newval=%s,index=%d\n",pd->ffd.lstore,path,newval,index);
< 	pref_apply_change(pd->ffd.lstore,3,type,path,newval,index);
< }
< static void filefilter_0_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	filefilter_apply_change(pd, 1, path, newtext, 0);
< }
< static void filefilter_1_toggled_lcb(GtkCellRendererToggle *cellrenderertoggle,gchar *path,Tprefdialog *pd) {
< 	gchar *val = g_strdup(cellrenderertoggle->active ? "0" : "1");
< 	filefilter_apply_change(pd, 2, path, val, 1);
< 	g_free(val);
< }
< static void filefilter_2_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	filefilter_apply_change(pd, 1, path, newtext, 2);
< }
< static void add_new_filefilter_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	gchar **strarr;
< 	GtkTreeIter iter;
< 	strarr = pref_create_empty_strarr(3);
< 	gtk_list_store_append(GTK_LIST_STORE(pd->ffd.lstore), &iter);
< 	set_filefilter_strarr_in_list(&iter, strarr,pd);
< 	pd->lists[filefilters] = g_list_append(pd->lists[filefilters], strarr);
< 	pd->ffd.insertloc = -1;
< }
< 
< static void delete_filefilter_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	pref_delete_strarr(pd, &pd->ffd, 3);
< }
< static void create_filefilter_gui(Tprefdialog *pd, GtkWidget *vbox1) {
< 	GtkWidget *hbox, *but, *scrolwin;
< 	pd->lists[filefilters] = duplicate_arraylist(main_v->props.filefilters);
< 	pd->ffd.lstore = gtk_list_store_new (4,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_STRING,G_TYPE_POINTER);
< 	pd->ffd.lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(pd->ffd.lstore));
< 	pref_create_column(GTK_TREE_VIEW(pd->ffd.lview), 1, G_CALLBACK(filefilter_0_edited_lcb), pd, _("Label"), 0);
< 	pref_create_column(GTK_TREE_VIEW(pd->ffd.lview), 2, G_CALLBACK(filefilter_1_toggled_lcb), pd, _("Inverse filter"), 1);
< 	pref_create_column(GTK_TREE_VIEW(pd->ffd.lview), 1, G_CALLBACK(filefilter_2_edited_lcb), pd, _("Filetypes in filter"), 2);
< 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin),GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
< 	gtk_container_add(GTK_CONTAINER(scrolwin), pd->ffd.lview);
< 	gtk_widget_set_size_request(scrolwin, 150, 190);
< 	gtk_box_pack_start(GTK_BOX(vbox1), scrolwin, TRUE, TRUE, 2);
< 	{
< 		GList *tmplist = g_list_first(pd->lists[filefilters]);
< 		while (tmplist) {
< 			gchar **strarr = (gchar **)tmplist->data;
< 			if (count_array(strarr)==3) {
< 				GtkTreeIter iter;
< 				gtk_list_store_append(GTK_LIST_STORE(pd->ffd.lstore), &iter);
< 				set_filefilter_strarr_in_list(&iter, strarr,pd);
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	gtk_tree_view_set_reorderable(GTK_TREE_VIEW(pd->ffd.lview), TRUE);
< 	pd->ffd.thelist = &pd->lists[filefilters];
< 	pd->ffd.insertloc = -1;
< 	g_signal_connect(G_OBJECT(pd->ffd.lstore), "row-inserted", G_CALLBACK(listpref_row_inserted), &pd->ffd);
< 	g_signal_connect(G_OBJECT(pd->ffd.lstore), "row-deleted", G_CALLBACK(listpref_row_deleted), &pd->ffd);
< 
< 	hbox = gtk_hbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox1),hbox, TRUE, TRUE, 2);
< 	but = bf_gtkstock_button(GTK_STOCK_ADD, G_CALLBACK(add_new_filefilter_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
< 	but = bf_gtkstock_button(GTK_STOCK_DELETE, G_CALLBACK(delete_filefilter_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);	
< }
< 
< static gchar **highlightpattern_create_strarr(Tprefdialog *pd) {
< 	gchar **strarr;
< 	strarr = g_malloc(12*sizeof(gchar *));
< 	strarr[0] = g_strdup(pd->hpd.selected_filetype);
< 	strarr[1] = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[0]),0,-1);
< 	DEBUG_MSG("highlightpattern_create_strarr for %s-%s at %p\n",strarr[0],strarr[1],strarr);
< 	if (GTK_TOGGLE_BUTTON(pd->hpd.check)->active){
< 		strarr[2] = g_strdup("0");
< 	} else {
< 		strarr[2] = g_strdup("1");
< 	}
< 	strarr[3] = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[1]),0,-1);
< 	strarr[4] = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[2]),0,-1);
< 	if (GTK_TOGGLE_BUTTON(pd->hpd.radio[0])->active){
< 		strarr[5] = g_strdup("1");
< 	} else if (GTK_TOGGLE_BUTTON(pd->hpd.radio[1])->active) {
< 		strarr[5] = g_strdup("2");
< 	} else {
< 		strarr[5] = g_strdup("3");
< 	}
< 	strarr[6] = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[3]),0,-1);
< 	strarr[7] = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[4]),0,-1);
< 	strarr[8] = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[5]),0,-1);
< 	if (GTK_TOGGLE_BUTTON(pd->hpd.radio[3])->active){
< 		strarr[9] = g_strdup("0");
< 	} else if (GTK_TOGGLE_BUTTON(pd->hpd.radio[4])->active) {
< 		strarr[9] = g_strdup("1");
< 	} else {
< 		strarr[9] = g_strdup("2");
< 	}
< 	if (GTK_TOGGLE_BUTTON(pd->hpd.radio[6])->active){
< 		strarr[10] = g_strdup("0");
< 	} else if (GTK_TOGGLE_BUTTON(pd->hpd.radio[7])->active) {
< 		strarr[10] = g_strdup("1");
< 	} else {
< 		strarr[10] = g_strdup("2");
< 	}
< 	strarr[11] = NULL;
< 	DEBUG_MSG("highlightpattern_create_strarr, strarr at %p with count %d\n", strarr, count_array(strarr));
< 	return strarr;
< }
< 
< static void highlightpattern_apply_changes(Tprefdialog *pd) {
< 	DEBUG_MSG("highlightpattern_apply_changes, started\n");
< 	if (pd->hpd.curstrarr) {
< 		GList *tmplist;
< 		tmplist = g_list_first(pd->lists[highlight_patterns]);
< 		while (tmplist) {
< 			if (tmplist->data == pd->hpd.curstrarr) {
< 				DEBUG_MSG("highlightpattern_apply_changes, curstrarr==tmplist->data==%p\n", tmplist->data);
< 				g_strfreev(tmplist->data);
< 				tmplist->data = highlightpattern_create_strarr(pd);
< 				pd->hpd.curstrarr = tmplist->data;
< 				DEBUG_MSG("highlightpattern_apply_changes, new strarr for %s-%s\n",pd->hpd.curstrarr[0],pd->hpd.curstrarr[1]);
< 				return;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		DEBUG_MSG("highlightpattern_apply_changes, nothing found for curstrarr %p?!?\n", pd->hpd.curstrarr);
< 	}
< 	DEBUG_MSG("highlightpattern_apply_changes, no curstrarr, nothing to apply\n");
< }
< 
< static void highlightpattern_fill_from_selected_filetype(Tprefdialog *pd) {
< 	DEBUG_MSG("highlightpattern_popmenu_activate, applied changes, about to clear liststore\n");
< 	gtk_list_store_clear(GTK_LIST_STORE(pd->hpd.lstore));
< 	if (pd->hpd.selected_filetype) {
< 		GList *tmplist;
< 		tmplist = g_list_first(pd->lists[highlight_patterns]);
< 		DEBUG_MSG("highlightpattern_popmenu_activate, about to fill for filetype %s (tmplist=%p)\n",pd->hpd.selected_filetype,tmplist);
< 		/* fill list model here */
< 		while (tmplist) {
< 			gchar **strarr =(gchar **)tmplist->data;
< 			if (count_array(strarr) ==11 && strarr[0]) {
< 				DEBUG_MSG("found entry with filetype %s\n",strarr[0]);
< 				if (strcmp(strarr[0], pd->hpd.selected_filetype)==0) {
< 					GtkTreeIter iter;
< 					DEBUG_MSG("highlightpattern_popmenu_activate, appending pattern %s with filetype %s\n",strarr[1],strarr[0]);
< 					gtk_list_store_append(GTK_LIST_STORE(pd->hpd.lstore), &iter);
< 					gtk_list_store_set(GTK_LIST_STORE(pd->hpd.lstore), &iter, 0, strarr[1], -1);
< 				}
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	pd->hpd.curstrarr = NULL;
< 	gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[0]), "");
< 	gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[1]), "");
< 	gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[2]), "");
< 	gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[3]), "");
< 	gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[4]), "");
< 	gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[5]), "");
< 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.check), FALSE);
< 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[0]),TRUE);
< 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[3]),TRUE);
< 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[6]),TRUE);
< }
< 
< static void highlightpattern_popmenu_activate(GtkMenuItem *menuitem,Tprefdialog *pd) {
< 	DEBUG_MSG("highlightpattern_popmenu_activate, pd=%p, menuitem=%p\n", pd, menuitem);
< 	highlightpattern_apply_changes(pd);
< 	pd->hpd.curstrarr = NULL;
< 	if (menuitem) {
< 		pd->hpd.selected_filetype = gtk_label_get_text(GTK_LABEL(GTK_BIN(menuitem)->child));
< 	}
< 	highlightpattern_fill_from_selected_filetype(pd);
< }
< 
< static void add_new_highlightpattern_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	gchar *pattern = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[0]),0,-1);
< 	if (pattern && pd->hpd.selected_filetype && strlen(pattern) && strlen(pd->hpd.selected_filetype)) {
< 		gchar **strarr = highlightpattern_create_strarr(pd);
< 		DEBUG_MSG("add_new_highlightpattern_lcb, appending strarr %p to list\n", strarr);
< 		pd->lists[highlight_patterns] = g_list_append(pd->lists[highlight_patterns], strarr);
< 		pd->hpd.curstrarr = NULL;
< 		{
< 			GtkTreeIter iter;
< 			GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->hpd.lview));
< 			DEBUG_MSG("add_new_highlightpattern_lcb, appending to lview\n");
< 			gtk_list_store_append(GTK_LIST_STORE(pd->hpd.lstore), &iter);
< 			gtk_list_store_set(GTK_LIST_STORE(pd->hpd.lstore), &iter, 0, strarr[1], -1);
< 			gtk_tree_selection_select_iter(selection,&iter);
< 		}
< /*		gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[0]), "");*/
< 	} else {
< 		g_free(pattern);
< 	}
< }
< 
< static void highlightpattern_selection_changed_cb(GtkTreeSelection *selection, Tprefdialog *pd) {
< 	GtkTreeIter iter;
< 	GtkTreeModel *model;
< 	DEBUG_MSG("highlightpattern_selection_changed_cb, started\n");
< 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
< 		gchar *pattern;
< 		GList *tmplist = g_list_first(pd->lists[highlight_patterns]);
< /*		GtkWidget *menuitem = gtk_menu_get_active(GTK_MENU( gtk_option_menu_get_menu(GTK_OPTION_MENU(pd->hpd.popmenu)) ));*/
< 		gtk_tree_model_get(model, &iter, 0, &pattern, -1);
< 		DEBUG_MSG("highlightpattern_selection_changed_cb, selected=%s\n",pattern);
< 		highlightpattern_apply_changes(pd);
< 		pd->hpd.curstrarr = NULL;
< 		DEBUG_MSG("changed applied, searching for the data of the new selection\n");
< 		while (tmplist) {
< 			gchar **strarr =(gchar **)tmplist->data;
< #ifdef DEBUG
< 			if (strarr == NULL){
< 				DEBUG_MSG("strarr== NULL !!!!!!!!!!!!!!!\n");
< 			}
< #endif
< 			if (strcmp(strarr[1], pattern)==0 && strcmp(strarr[0], pd->hpd.selected_filetype)==0) {
< 				DEBUG_MSG("highlightpattern_selection_changed_cb, found strarr=%p\n", strarr);
< 				DEBUG_MSG("0=%s, 1=%s, 2=%s, 3=%s, 4=%s\n",strarr[0],strarr[1],strarr[2],strarr[3],strarr[4]);
< 				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.check), (strarr[2][0] == '0'));
< 				gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[0]), strarr[1]);
< 				gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[1]), strarr[3]);
< 				gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[2]), strarr[4]);
< 				if (strarr[5][0] == '3') {
< 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[2]),TRUE);
< 				} else if (strarr[5][0] == '2') {
< 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[1]),TRUE);
< 				} else {
< 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[0]),TRUE);
< 				}
< 				gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[3]), strarr[6]);
< 				gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[4]), strarr[7]);
< 				gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[5]), strarr[8]);
< 				if (strarr[9][0] == '2') {
< 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[5]),TRUE);
< 				} else if (strarr[9][0] == '1') {
< 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[4]),TRUE);
< 				} else {
< 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[3]),TRUE);
< 				}
< 				DEBUG_MSG("strarr[10]=%s, \n",strarr[10]);
< 				if (strarr[10][0] == '2') {
< 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[8]),TRUE);
< 				} else if (strarr[10][0] == '1') {
< 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[7]),TRUE);
< 				} else {
< 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[6]),TRUE);
< 				}
< 				pd->hpd.curstrarr = strarr;
< 				break;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		g_free(pattern);
< 	} else {
< 		DEBUG_MSG("no selection, returning..\n");
< 	}
< }
< static void highlightpattern_type_toggled(GtkToggleButton *togglebutton,Tprefdialog *pd){
< 	DEBUG_MSG("highlightpattern_type_toggled, started\n");
< 	if (GTK_TOGGLE_BUTTON(pd->hpd.radio[0])->active) {
< 		gtk_widget_set_sensitive(pd->hpd.entry[2], TRUE);
< 	} else {
< 		gtk_widget_set_sensitive(pd->hpd.entry[2], FALSE);
< 	}
< 	DEBUG_MSG("highlightpattern_type_toggled, done\n");
< }
< static void highlightpattern_up_clicked_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	GtkTreeIter iter;
< 	GtkTreeModel *model;
< 	gchar *pattern;
< 
< 	GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->hpd.lview));
< 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
< 		GList *previous=NULL, *tmplist = g_list_first(pd->lists[highlight_patterns]);
< 		gtk_tree_model_get(model, &iter, 0, &pattern, -1);
< 		DEBUG_MSG("highlightpattern_up_clicked_lcb, selected=%s\n",pattern);
< 		while (tmplist) {
< 			gchar **strarr =(gchar **)tmplist->data;
< 			if (strcmp(strarr[0], pd->hpd.selected_filetype)==0) {
< 				DEBUG_MSG("highlightpattern_up_clicked_lcb, comparing %s+%s for filetype %s\n",strarr[1], pattern,pd->hpd.selected_filetype);
< 				if (strcmp(strarr[1], pattern)==0) {
< 					DEBUG_MSG("highlightpattern_up_clicked_lcb, found %s, previous=%p, tmplist=%p\n",strarr[1],previous,tmplist);
< 					if (previous) {
< 						DEBUG_MSG("highlightpattern_up_clicked_lcb, switch list order %s <-> %s\n",((gchar **)tmplist->data)[1], ((gchar **)previous->data)[1]);
< 						list_switch_order(tmplist, previous);
< 						highlightpattern_popmenu_activate(NULL, pd);
< 					}
< 					return;
< 				}
< 				previous = tmplist;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< }
< static void highlightpattern_down_clicked_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	GtkTreeIter iter;
< 	GtkTreeModel *model;
< 	gchar *pattern;
< 	GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->hpd.lview));
< 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
< 		GList *tmplist = g_list_first(pd->lists[highlight_patterns]);
< 		gtk_tree_model_get(model, &iter, 0, &pattern, -1);
< 		while (tmplist) {
< 			gchar **strarr =(gchar **)tmplist->data;
< 			if (strcmp(strarr[1], pattern)==0 && strcmp(strarr[0], pd->hpd.selected_filetype)==0) {
< 				if (tmplist->next) {
< 					list_switch_order(tmplist, tmplist->next);
< 					highlightpattern_popmenu_activate(NULL, pd);
< 					return;
< 				}
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< }
< static void highlightpattern_delete_clicked_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	GtkTreeIter iter;
< 	GtkTreeModel *model;
< 	gchar *pattern;
< 	GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->hpd.lview));
< 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
< 		GList *tmplist = g_list_first(pd->lists[highlight_patterns]);
< 		gtk_tree_model_get(model, &iter, 0, &pattern, -1);
< 		while (tmplist) {
< 			gchar **strarr =(gchar **)tmplist->data;
< 			if (strcmp(strarr[1], pattern)==0 && strcmp(strarr[0], pd->hpd.selected_filetype)==0) {
< 				pd->hpd.curstrarr = NULL;
< 				pd->lists[highlight_patterns] = g_list_remove(pd->lists[highlight_patterns], strarr);
< 				g_strfreev(strarr);
< 				highlightpattern_popmenu_activate(NULL, pd);
< 				return;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< }
< 
< static void highlightpattern_gui_rebuild_filetype_popup(Tprefdialog *pd) {
< 	GList *tmplist;
< 	GtkWidget *menu, *menuitem;
< 	gtk_option_menu_remove_menu(GTK_OPTION_MENU(pd->hpd.popmenu));
< 	menu = gtk_menu_new();
< 	gtk_option_menu_set_menu(GTK_OPTION_MENU(pd->hpd.popmenu), menu);
< 	gtk_widget_show(menu);
< 	tmplist = g_list_first(pd->lists[filetypes]);
< 	while (tmplist) {
< 		gchar **arr = (gchar **)tmplist->data;
< 		if (count_array(arr)>=3) {
< 			if (strcmp(arr[0], "objectfile") != 0 && strcmp(arr[0], "webimage") != 0 
< 				&& strcmp(arr[0], "image") != 0 && strcmp(arr[0], "bfproject") != 0) {				
< 				
< 				menuitem = gtk_menu_item_new_with_label(arr[0]);
< 				DEBUG_MSG("highlightpattern_gui_rebuild_filetype_popup, menuitem=%p for %s\n", menuitem, arr[0]);
< 				g_signal_connect(GTK_OBJECT(menuitem), "activate",G_CALLBACK(highlightpattern_popmenu_activate),pd);
< 				gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
< 				gtk_widget_show(menuitem);
< 			}
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< static void highlightpattern_reset_clicked_lcb(GtkWidget *button, Tprefdialog *pd) {
< #ifndef WIN32	
< 	gchar *defaultfile = return_first_existing_filename(PKGDATADIR"highlighting.default",
< 									"data/highlighting.default",
< 									"../data/highlighting.default",NULL);
< #else
< 	gchar *pkgtmp = g_strdup("");
< 	printf("preferences.c:1155\n");
< 	pkgtmp = g_strconcat(pkgtmp,PKG_DATA_DIR,"highlighting.default",NULL);
< 	gchar *defaultfile = return_first_existing_filename(pkgtmp,
< 									"data/highlighting.default",
< 									"../data/highlighting.default",NULL);
< 	g_free(pkgtmp);
< #endif
< 	if (defaultfile) {
< 		/* get current selected filetype && create array to compare to*/
< 		gchar **compare = array_from_arglist(pd->hpd.selected_filetype, NULL);
< 		DEBUG_MSG("highlightpattern_reset_clicked_lcb, defaultfile=%s\n",defaultfile);
< 		/* delete filetype from arraylist */
< 		pd->lists[highlight_patterns] = arraylist_delete_identical(pd->lists[highlight_patterns], compare, 1, TRUE);
< 		/* load filetype from default file */
< 		pd->lists[highlight_patterns] = arraylist_append_identical_from_file(pd->lists[highlight_patterns], defaultfile, compare, 1, TRUE);
< 		g_strfreev(compare);
< 		/* re-load selected filetype in preferences gui */
< 		DEBUG_MSG("highlightpattern_reset_clicked_lcb, about to rebuild gui\n");
< 		highlightpattern_fill_from_selected_filetype(pd);
< 		g_free (defaultfile);
< 	}
< }
< 
< static void create_highlightpattern_gui(Tprefdialog *pd, GtkWidget *vbox1) {
< 	GtkWidget *hbox, *but, *vbox3;
< 	pd->lists[highlight_patterns] = duplicate_arraylist(main_v->props.highlight_patterns);
< 	
< 	DEBUG_MSG("create_highlightpattern_gui, pd=%p, pd->lists[highlight_patterns]=%p\n", pd, pd->lists[highlight_patterns]);
< 	hbox = gtk_hbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox1), hbox, FALSE, FALSE, 3);
< 
< 	gtk_box_pack_start(GTK_BOX(hbox),gtk_label_new(_("filetype")),FALSE, FALSE, 3);
< 	pd->hpd.popmenu = gtk_option_menu_new();
< 	gtk_option_menu_set_menu(GTK_OPTION_MENU(pd->hpd.popmenu), gtk_menu_new());
< 	highlightpattern_gui_rebuild_filetype_popup(pd);
< 	gtk_box_pack_start(GTK_BOX(hbox),pd->hpd.popmenu,TRUE, TRUE, 3);
< 	but = gtk_button_new_with_label(_("Reset"));
< 	g_signal_connect(G_OBJECT(but), "clicked", G_CALLBACK(highlightpattern_reset_clicked_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox),but,FALSE, FALSE, 3);
< 
< 	hbox = gtk_hbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox1), hbox, TRUE, TRUE, 3);
< 	pd->hpd.entry[0] = boxed_full_entry(_("Pattern name"), NULL, 500, hbox);
< 
< 	but = bf_gtkstock_button(GTK_STOCK_ADD, G_CALLBACK(add_new_highlightpattern_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, TRUE, 3);
< 	but = bf_gtkstock_button(GTK_STOCK_DELETE, G_CALLBACK(highlightpattern_delete_clicked_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, FALSE, 1);
< 	
< 	hbox = gtk_hbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox1), hbox, TRUE, TRUE, 0);
< 
< 	pd->hpd.lstore = gtk_list_store_new (1, G_TYPE_STRING);
< 	pd->hpd.lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(pd->hpd.lstore));
< 	{
< 		GtkTreeViewColumn *column;
< 		GtkWidget *scrolwin;
< 		GtkTreeSelection *select;
< 	   GtkCellRenderer *renderer = gtk_cell_renderer_text_new ();
< 
< 		column = gtk_tree_view_column_new_with_attributes (_("Pattern"), renderer,"text", 0,NULL);
< 		gtk_tree_view_append_column (GTK_TREE_VIEW(pd->hpd.lview), column);
< 		scrolwin = gtk_scrolled_window_new(NULL, NULL);
< 		gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
< 		gtk_container_add(GTK_CONTAINER(scrolwin), pd->hpd.lview);
< 		gtk_box_pack_start(GTK_BOX(hbox), scrolwin, FALSE, TRUE, 2);
< 		
< 		select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->hpd.lview));
< 		g_signal_connect(G_OBJECT(select), "changed",G_CALLBACK(highlightpattern_selection_changed_cb),pd);
< 	}
< 
< 	vbox3 = gtk_vbox_new(FALSE, 2);
< 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, FALSE, FALSE, 2);
< 	/* pack up and down buttons here */
< 
< 	but = bf_gtkstock_button(GTK_STOCK_GO_UP, G_CALLBACK(highlightpattern_up_clicked_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(vbox3), but, FALSE, FALSE, 1);
< 	but = bf_gtkstock_button(GTK_STOCK_GO_DOWN, G_CALLBACK(highlightpattern_down_clicked_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(vbox3), but, FALSE, FALSE, 1);
< 	
< 	vbox3 = gtk_vbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, TRUE, TRUE, 2);
< 
< 	pd->hpd.radio[0] = gtk_radio_button_new_with_label(NULL, _("Start pattern and end pattern"));
< 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[0], TRUE, TRUE, 0);
< 	pd->hpd.radio[1] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(pd->hpd.radio[0]), _("Only start pattern"));
< 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[1], TRUE, TRUE, 0);
< 	pd->hpd.radio[2] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(pd->hpd.radio[0]), _("Subpattern from parent"));
< 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[2], TRUE, TRUE, 0);
< 	g_signal_connect(G_OBJECT(pd->hpd.radio[0]), "toggled", G_CALLBACK(highlightpattern_type_toggled), pd);
< 	g_signal_connect(G_OBJECT(pd->hpd.radio[1]), "toggled", G_CALLBACK(highlightpattern_type_toggled), pd);
< 	g_signal_connect(G_OBJECT(pd->hpd.radio[2]), "toggled", G_CALLBACK(highlightpattern_type_toggled), pd);
< 
< 	pd->hpd.entry[1] = boxed_full_entry(_("Start pattern"), NULL, 4000, vbox3);
< 	pd->hpd.entry[2] = boxed_full_entry(_("End pattern"), NULL, 4000, vbox3);
< 	pd->hpd.check = boxed_checkbut_with_value(_("Case sensitive matching"), FALSE, vbox3);
< 	pd->hpd.entry[3] = boxed_full_entry(_("Parentmatch"), NULL, 300, vbox3);
< 	pd->hpd.entry[4] = prefs_string(_("Foreground color"), "", vbox3, pd, string_color);
< 	pd->hpd.entry[5] = prefs_string(_("Background color"), "", vbox3, pd, string_color);
< 
< 	hbox = gtk_hbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox1), hbox, TRUE, TRUE, 0);
< 	
< 	vbox3 = gtk_vbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, TRUE, TRUE, 0);
< 	
< 	pd->hpd.radio[3] = gtk_radio_button_new_with_label(NULL, _("don't change weight"));
< 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[3], TRUE, TRUE, 0);
< 	pd->hpd.radio[4] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(pd->hpd.radio[3]), _("force non-bold weight"));
< 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[4], TRUE, TRUE, 0);
< 	pd->hpd.radio[5] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(pd->hpd.radio[3]), _("force bold weight"));
< 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[5], TRUE, TRUE, 0);
< 
< 	vbox3 = gtk_vbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, TRUE, TRUE, 0);
< 
< 	pd->hpd.radio[6] = gtk_radio_button_new_with_label(NULL, _("don't change style"));
< 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[6], TRUE, TRUE, 0);
< 	pd->hpd.radio[7] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(pd->hpd.radio[6]), _("force non-italic style"));
< 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[7], TRUE, TRUE, 0);
< 	pd->hpd.radio[8] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(pd->hpd.radio[6]), _("force italic style"));
< 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[8], TRUE, TRUE, 0);
< }
< /*
< static gchar **browser_create_strarr(Tprefdialog *pd) {
< 	return generic_create_strarr(2, pd->bd.entry, TRUE);
< }
< 
< static void browsers_apply_changes(Tprefdialog *pd) {
< 	DEBUG_MSG("browsers_apply_changes, started\n");
< 	if (pd->bd.curstrarr) {
< 		gchar **strarr;
< 		strarr = browser_create_strarr(pd);
< 		if (strarr) {
< 			GList *tmplist;
< 			GtkTreeIter iter;
< 			gboolean retval = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->bd.lstore),&iter);
< 			while (retval) {
< 				gchar *curval;
< 				gtk_tree_model_get(GTK_TREE_MODEL(pd->bd.lstore),&iter,0,&curval,-1);
< 				if (strcmp(curval,pd->bd.curstrarr[0])==0) {
< 					gtk_list_store_set(GTK_LIST_STORE(pd->bd.lstore), &iter
< 						,0,strarr[0]
< 						,1,strarr[1]
< 						,-1);
< 					DEBUG_MSG("browsers_apply_changes, changed in tree model\n");
< 					break;
< 				}
< 				retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->bd.lstore),&iter);
< 			}
< 
< 			tmplist = g_list_first(pd->lists[browsers]);
< 			while (tmplist) {
< 				if (tmplist->data == pd->bd.curstrarr) {
< 					g_strfreev(pd->bd.curstrarr);
< 					tmplist->data = strarr;
< 					pd->bd.curstrarr = strarr;
< 					DEBUG_MSG("browsers_apply_changes, changed custrarr\n");
< 					break;
< 				}
< 				tmplist = g_list_next(tmplist);
< 			}
< 		} else {
< 			DEBUG_MSG("browsers_apply_changes, strarr=NULL!!\n");
< 		}
< 	} else {
< 		DEBUG_MSG("browsers_apply_changes, NO curstrarr!!\n");
< 	}
< }
< 
< static void add_new_browser_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	gchar **strarr;
< 	strarr = browser_create_strarr(pd);
< 	if (strarr) {
< 		GtkTreeIter iter;
< 		pd->lists[browsers] = g_list_append(pd->lists[browsers], strarr);
< 		gtk_list_store_append(GTK_LIST_STORE(pd->bd.lstore), &iter);
< 		gtk_list_store_set(GTK_LIST_STORE(pd->bd.lstore), &iter
< 				,0,strarr[0]
< 				,1,strarr[1]
< 				,-1);
< 	}
< }
< 
< static void delete_browser_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	if (pd->bd.curstrarr) {
< 		GtkTreeIter iter;
< 		gboolean retval= gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->bd.lstore),&iter);
< 		while (retval) {
< 			gchar *curval;
< 			gtk_tree_model_get(GTK_TREE_MODEL(pd->bd.lstore),&iter,0,&curval,-1);
< 			if (strcmp(curval,pd->bd.curstrarr[0])==0) {
< 				gtk_list_store_remove(GTK_LIST_STORE(pd->bd.lstore),&iter);
< 				break;
< 			}
< 			retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->bd.lstore),&iter);
< 		}
< 		pd->lists[browsers] = g_list_remove(pd->lists[browsers],pd->bd.curstrarr);
< 	}
< }
< 
< static void set_default_browser_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	if (pd->bd.curstrarr) {
< 		GtkTreeIter iter;
< 		gboolean retval=gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->bd.lstore),&iter);
< 		while (retval) {
< 			gchar *curval;
< 			gtk_tree_model_get(GTK_TREE_MODEL(pd->bd.lstore),&iter,0,&curval,-1);
< 			if (strcmp((char *)curval,pd->bd.curstrarr[0])==0) {
<                                 gtk_list_store_remove((pd->bd.lstore),&iter);
< 				break;
< 			}
< 			retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->bd.lstore),&iter);
< 		}
<                 gtk_list_store_insert((pd->bd.lstore),&iter,0); 
< 		gtk_list_store_set(GTK_LIST_STORE(pd->bd.lstore), &iter
< 						,0,pd->bd.curstrarr[0]
< 						,1,pd->bd.curstrarr[1]
< 						,-1);
< 		pd->lists[browsers] = g_list_remove(pd->lists[browsers],pd->bd.curstrarr);
< 		pd->lists[browsers] = g_list_insert(pd->lists[browsers],pd->bd.curstrarr,0);
< 	}
< }
< static void browser_selection_changed_cb(GtkTreeSelection *selection, Tprefdialog *pd) {
< 	DEBUG_MSG("browser_selection_changed_cb, curstrarr=%p, &curstrarr=%p\n", pd->ftd.curstrarr, &pd->bd.curstrarr);
< 	generic_selection_changed_cb(selection,pd->bd.entry,browsers_apply_changes,pd,browsers,2,&pd->bd.curstrarr);
< 	DEBUG_MSG("browser_selection_changed_cb, curstrarr=%p, &curstrarr=%p\n", pd->ftd.curstrarr, &pd->bd.curstrarr);
< }*/
< static void set_browser_strarr_in_list(GtkTreeIter *iter, gchar **strarr, Tprefdialog *pd) {
< 	gint arrcount = count_array(strarr);
< 	if (arrcount==2) {
< 		gtk_list_store_set(GTK_LIST_STORE(pd->bd.lstore), iter
< 				,0,strarr[0],1,strarr[1],2,strarr,-1);
< 	} else {
< 		DEBUG_MSG("ERROR: set_browser_strarr_in_list, arraycount != 2 !!!!!!\n");
< 	}
< }
< static void browser_apply_change(Tprefdialog *pd, gint type, gchar *path, gchar *newval, gint index) {
< 	pref_apply_change(pd->bd.lstore,2,type,path,newval,index);
< }
< static void browser_0_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	browser_apply_change(pd, 1, path, newtext, 0);
< }
< static void browser_1_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	browser_apply_change(pd, 1, path, newtext, 1);
< }
< static void add_new_browser_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	gchar **strarr;
< 	GtkTreeIter iter;
< 	strarr = pref_create_empty_strarr(2);
< 	gtk_list_store_append(GTK_LIST_STORE(pd->bd.lstore), &iter);
< 	set_browser_strarr_in_list(&iter, strarr,pd);
< 	pd->lists[browsers] = g_list_append(pd->lists[browsers], strarr);
< 	pd->bd.insertloc = -1;
< }
< static void delete_browser_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	pref_delete_strarr(pd, &pd->bd, 2);
< }
< static void create_browsers_gui(Tprefdialog *pd, GtkWidget *vbox1) {
< 	GtkWidget *hbox, *but, *scrolwin;
< 	pd->lists[browsers] = duplicate_arraylist(main_v->props.browsers);
< 	pd->bd.lstore = gtk_list_store_new (3,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_POINTER);
< 	pd->bd.lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(pd->bd.lstore));
< 	pref_create_column(GTK_TREE_VIEW(pd->bd.lview), 1, G_CALLBACK(browser_0_edited_lcb), pd, _("Label"), 0);
< 	pref_create_column(GTK_TREE_VIEW(pd->bd.lview), 1, G_CALLBACK(browser_1_edited_lcb), pd, _("Command"), 1);
< 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin),GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
< 	gtk_container_add(GTK_CONTAINER(scrolwin), pd->bd.lview);
< 	gtk_widget_set_size_request(scrolwin, 150, 190);
< 	gtk_box_pack_start(GTK_BOX(vbox1), scrolwin, TRUE, TRUE, 2);
< 	{
< 		GList *tmplist = g_list_first(pd->lists[browsers]);
< 		while (tmplist) {
< 			gchar **strarr = (gchar **)tmplist->data;
< 			GtkTreeIter iter;
< 			gtk_list_store_append(GTK_LIST_STORE(pd->bd.lstore), &iter);
< 			set_browser_strarr_in_list(&iter, strarr,pd);
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	gtk_tree_view_set_reorderable(GTK_TREE_VIEW(pd->bd.lview), TRUE);
< 	pd->bd.thelist = &pd->lists[browsers];
< 	pd->bd.insertloc = -1;
< 	g_signal_connect(G_OBJECT(pd->bd.lstore), "row-inserted", G_CALLBACK(listpref_row_inserted), &pd->bd);
< 	g_signal_connect(G_OBJECT(pd->bd.lstore), "row-deleted", G_CALLBACK(listpref_row_deleted), &pd->bd);
< 
< 	hbox = gtk_hbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox1),hbox, TRUE, TRUE, 2);
< 	but = bf_gtkstock_button(GTK_STOCK_ADD, G_CALLBACK(add_new_browser_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
< 	but = bf_gtkstock_button(GTK_STOCK_DELETE, G_CALLBACK(delete_browser_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);	
< }
< /*
< static gchar **external_create_strarr(Tprefdialog *pd) {
< 	return generic_create_strarr(2, pd->ed.entry, TRUE);
< }
< 
< static void externals_apply_changes(Tprefdialog *pd) {
< 	DEBUG_MSG("externals_apply_changes, started\n");
< 	if (pd->ed.curstrarr) {
< 		gchar **strarr;
< 		strarr = external_create_strarr(pd);
< 		if (strarr) {
< 			GList *tmplist;
< 			GtkTreeIter iter;
< 			gboolean retval = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->ed.lstore),&iter);
< 			while (retval) {
< 				gchar *curval;
< 				gtk_tree_model_get(GTK_TREE_MODEL(pd->ed.lstore),&iter,0,&curval,-1);
< 				if (strcmp(curval,pd->ed.curstrarr[0])==0) {
< 					gtk_list_store_set(GTK_LIST_STORE(pd->ed.lstore), &iter
< 						,0,strarr[0]
< 						,1,strarr[1]
< 						,-1);
< 					DEBUG_MSG("externals_apply_changes, changed in tree model\n");
< 					break;
< 				}
< 				retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->ed.lstore),&iter);
< 			}
< 
< 			tmplist = g_list_first(pd->lists[external_commands]);
< 			while (tmplist) {
< 				if (tmplist->data == pd->ed.curstrarr) {
< 					g_strfreev(pd->ed.curstrarr);
< 					tmplist->data = strarr;
< 					pd->ed.curstrarr = strarr;
< 					DEBUG_MSG("externals_apply_changes, changed custrarr\n");
< 					break;
< 				}
< 				tmplist = g_list_next(tmplist);
< 			}
< 		} else {
< 			DEBUG_MSG("externals_apply_changes, NO strarr!!\n");
< 		}
< 	} else {
< 		DEBUG_MSG("externals_apply_changes, NO curstrarr!!\n");
< 	}
< }
< 
< static void external_selection_changed_cb(GtkTreeSelection *selection, Tprefdialog *pd) {
< 	DEBUG_MSG("external_selection_changed_cb, started\n");
< 	generic_selection_changed_cb(selection,pd->ed.entry,externals_apply_changes,pd,external_commands,2,&pd->ed.curstrarr);
< }
< 
< static void add_new_external_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	gchar **strarr;
< 	strarr = external_create_strarr(pd);
< 	if (strarr) {
< 		GtkTreeIter iter;
< 		pd->lists[external_commands] = g_list_append(pd->lists[external_commands], strarr);
< 		gtk_list_store_append(GTK_LIST_STORE(pd->ed.lstore), &iter);
< 		gtk_list_store_set(GTK_LIST_STORE(pd->ed.lstore), &iter
< 				,0,strarr[0]
< 				,1,strarr[1]
< 				,-1);
< 	}
< }
< 
< static void delete_external_commands_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	GtkTreeSelection *select;
< 	GtkTreeIter iter;
< 	gboolean retval;
< 
< 	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->ed.lview));
< 	retval = gtk_tree_selection_get_selected (select,NULL,&iter);
< 	if(retval) {
< 		gchar *curval;
< 		GList *work = NULL;
< 		gchar **curstrarr;
< 		
< 		gtk_tree_model_get(GTK_TREE_MODEL(pd->ed.lstore),&iter,0,&curval,-1);
< 		gtk_list_store_remove(pd->ed.lstore,&iter);
< 		work = pd->lists[external_commands];
< 		while(work) {
< 			curstrarr = work->data;
< 			if (strcmp(curval,curstrarr[0])==0) {
< 				pd->lists[external_commands] = g_list_remove(pd->lists[external_commands],curstrarr);
< 				break;
< 			}
< 			work = g_list_next(work);
< 		}
< 		g_free(curval);
< 	}
< }*/
< 
< static void set_external_commands_strarr_in_list(GtkTreeIter *iter, gchar **strarr, Tprefdialog *pd) {
< 	gint arrcount = count_array(strarr);
< 	if (arrcount==2) {
< 		gtk_list_store_set(GTK_LIST_STORE(pd->ed.lstore), iter
< 				,0,strarr[0],1,strarr[1],2,strarr,-1);
< 	} else {
< 		DEBUG_MSG("ERROR: set_external_command_strarr_in_list, arraycount != 2 !!!!!!\n");
< 	}
< }
< static void external_commands_apply_change(Tprefdialog *pd, gint type, gchar *path, gchar *newval, gint index) {
< 	pref_apply_change(pd->ed.lstore,2,type,path,newval,index);
< }
< static void external_commands_0_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	external_commands_apply_change(pd, 1, path, newtext, 0);
< }
< static void external_commands_1_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	external_commands_apply_change(pd, 1, path, newtext, 1);
< }
< static void add_new_external_commands_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	gchar **strarr;
< 	GtkTreeIter iter;
< 	strarr = pref_create_empty_strarr(2);
< 	gtk_list_store_append(GTK_LIST_STORE(pd->ed.lstore), &iter);
< 	set_external_commands_strarr_in_list(&iter, strarr,pd);
< 	pd->lists[external_commands] = g_list_append(pd->lists[external_commands], strarr);
< 	pd->ed.insertloc = -1;
< }
< static void delete_external_commands_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	pref_delete_strarr(pd, &pd->ed, 2);
< }
< static void create_externals_gui(Tprefdialog *pd, GtkWidget *vbox1) {
< 	GtkWidget *hbox, *but, *scrolwin;
< 	pd->lists[external_commands] = duplicate_arraylist(main_v->props.external_commands);
< 	pd->ed.lstore = gtk_list_store_new (3,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_POINTER);
< 	pd->ed.lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(pd->ed.lstore));
< 	pref_create_column(GTK_TREE_VIEW(pd->ed.lview), 1, G_CALLBACK(external_commands_0_edited_lcb), pd, _("Label"), 0);
< 	pref_create_column(GTK_TREE_VIEW(pd->ed.lview), 1, G_CALLBACK(external_commands_1_edited_lcb), pd, _("Command"), 1);
< 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin),GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
< 	gtk_container_add(GTK_CONTAINER(scrolwin), pd->ed.lview);
< 	gtk_widget_set_size_request(scrolwin, 120, 190);
< 	gtk_box_pack_start(GTK_BOX(vbox1), scrolwin, TRUE, TRUE, 2);
< 	{
< 		GList *tmplist = g_list_first(pd->lists[external_commands]);
< 		while (tmplist) {
< 			gchar **strarr = (gchar **)tmplist->data;
< 			GtkTreeIter iter;
< 			gtk_list_store_append(GTK_LIST_STORE(pd->ed.lstore), &iter);
< 			set_external_commands_strarr_in_list(&iter, strarr,pd);
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	gtk_tree_view_set_reorderable(GTK_TREE_VIEW(pd->ed.lview), TRUE);
< 	pd->ed.thelist = &pd->lists[external_commands];
< 	pd->ed.insertloc = -1;
< 	g_signal_connect(G_OBJECT(pd->ed.lstore), "row-inserted", G_CALLBACK(listpref_row_inserted), &pd->ed);
< 	g_signal_connect(G_OBJECT(pd->ed.lstore), "row-deleted", G_CALLBACK(listpref_row_deleted), &pd->ed);
< 	gtk_box_pack_start(GTK_BOX(vbox1),gtk_label_new(_("%s for current filename (any command)\n%i for input and %f for output filename (filters)")), TRUE, TRUE, 2);
< 	hbox = gtk_hbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox1),hbox, TRUE, TRUE, 2);
< 	but = bf_gtkstock_button(GTK_STOCK_ADD, G_CALLBACK(add_new_external_commands_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
< 	but = bf_gtkstock_button(GTK_STOCK_DELETE, G_CALLBACK(delete_external_commands_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);	
< }
< /*
< static gchar **outputbox_create_strarr(Tprefdialog *pd) {
< 	gchar **strarr = g_malloc(8*sizeof(gchar *));
< 	strarr[0] = gtk_editable_get_chars(GTK_EDITABLE(pd->od.entry[0]), 0, -1);
< 	strarr[1] = gtk_editable_get_chars(GTK_EDITABLE(pd->od.entry[1]), 0, -1);
< 	strarr[2] = gtk_editable_get_chars(GTK_EDITABLE(pd->od.entry[2]), 0, -1);
< 	strarr[3] = gtk_editable_get_chars(GTK_EDITABLE(pd->od.entry[3]), 0, -1);
< 	strarr[4] = gtk_editable_get_chars(GTK_EDITABLE(pd->od.entry[4]), 0, -1);
< 	strarr[5] = gtk_editable_get_chars(GTK_EDITABLE(pd->od.entry[5]), 0, -1);
< 	strarr[6] = g_strdup((GTK_TOGGLE_BUTTON(pd->od.check)->active) ? "1" : "0");
< 	strarr[7] = NULL;
< 	return strarr;
< }
< static void outputbox_apply_changes(Tprefdialog *pd) {
< 	if (pd->od.curstrarr) {
< 		gchar **strarr;
< 		strarr = outputbox_create_strarr(pd);
< 		if (strarr) {
< 			GList *tmplist;
< 			GtkTreeIter iter;
< 			gboolean retval = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->od.lstore),&iter);
< 			while (retval) {
< 				gchar *curval;
< 				gtk_tree_model_get(GTK_TREE_MODEL(pd->od.lstore),&iter,0,&curval,-1);
< 				if (strcmp(curval,pd->od.curstrarr[0])==0) {
< 					gtk_list_store_set(GTK_LIST_STORE(pd->od.lstore), &iter
< 						,0,strarr[0]
< 						,1,strarr[1]
< 						,2,strarr[2]
< 						,3,strarr[3]
< 						,4,strarr[4]
< 						,5,strarr[5]
< 						,6,strarr[6]
< 						,-1);
< 					break;
< 				}
< 				retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->od.lstore),&iter);
< 			}
< 
< 			tmplist = g_list_first(pd->lists[outputbox]);
< 			while (tmplist) {
< 				if (tmplist->data == pd->od.curstrarr) {
< 					g_strfreev(pd->od.curstrarr);
< 					tmplist->data = strarr;
< 					pd->od.curstrarr = strarr;
< 					break;
< 				}
< 				tmplist = g_list_next(tmplist);
< 			}
< 		} else {
< 			DEBUG_MSG("outputbox_apply_changes, NO strarr!!\n");
< 		}
< 	} else {
< 		DEBUG_MSG("outputbox_apply_changes, NO curstrarr!!\n");
< 	}
< }	
< static void add_new_outputbox_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	gchar **strarr;
< 	strarr = outputbox_create_strarr(pd);
< 	if (strarr) {
< 		GtkTreeIter iter;
< 		pd->lists[outputbox] = g_list_append(pd->lists[outputbox], strarr);
< 		gtk_list_store_append(GTK_LIST_STORE(pd->od.lstore), &iter);
< 		gtk_list_store_set(GTK_LIST_STORE(pd->od.lstore), &iter
< 						,0,strarr[0]
< 						,1,strarr[1]
< 						,2,strarr[2]
< 						,3,strarr[3]
< 						,4,strarr[4]
< 						,5,strarr[5]
< 						,6,strarr[6]
< 						,-1);
< 	}
< }
< 
< static void outputbox_selection_changed_cb(GtkTreeSelection *selection, Tprefdialog *pd) {
< 	GtkTreeIter iter;
< 	GtkTreeModel *model;
< 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
< 		gchar *name;
< 		GList *tmplist = g_list_first(pd->lists[outputbox]);
< 		gtk_tree_model_get(model, &iter, 0, &name, -1);
< 		outputbox_apply_changes(pd);
< 		while (tmplist) {
< 			gchar **strarr =(gchar **)tmplist->data;
< 			if (strcmp(strarr[0],name)==0) {
< 				gtk_entry_set_text(GTK_ENTRY(pd->od.entry[0]), strarr[0]);
< 				gtk_entry_set_text(GTK_ENTRY(pd->od.entry[1]), strarr[1]);
< 				gtk_entry_set_text(GTK_ENTRY(pd->od.entry[2]), strarr[2]);
< 				gtk_entry_set_text(GTK_ENTRY(pd->od.entry[3]), strarr[3]);
< 				gtk_entry_set_text(GTK_ENTRY(pd->od.entry[4]), strarr[4]);
< 				gtk_entry_set_text(GTK_ENTRY(pd->od.entry[5]), strarr[5]);
< 				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->od.check), (strarr[6][0] == '1'));
< 				pd->od.curstrarr = strarr;
< 				return;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	} else {
< 		DEBUG_MSG("outputbox_selection_changed_cb, no selection ?!?!\n");
< 	}
< }
< */
< static void set_outputbox_strarr_in_list(GtkTreeIter *iter, gchar **strarr, Tprefdialog *pd) {
< 	gint arrcount;
< 	arrcount = count_array(strarr);
< 	if (arrcount==7) {
< 		gtk_list_store_set(GTK_LIST_STORE(pd->od.lstore), iter
< 				,0,strarr[0],1,strarr[1],2,strarr[2],3,strarr[3]
< 				,4,strarr[4],5,strarr[5],6,(strarr[6][0] != '0')
< 				,7,strarr,-1);
< 	}
< }
< static void outputbox_apply_change(Tprefdialog *pd, gint type, gchar *path, gchar *newval, gint index) {
< 	pref_apply_change(pd->od.lstore,7,type,path,newval,index);
< }
< static void outputbox_0_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	outputbox_apply_change(pd, 1, path, newtext, 0);
< }
< static void outputbox_1_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	outputbox_apply_change(pd, 1, path, newtext, 1);
< }
< static void outputbox_2_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	outputbox_apply_change(pd, 1, path, newtext, 2);
< }
< static void outputbox_3_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	outputbox_apply_change(pd, 1, path, newtext, 3);
< }
< static void outputbox_4_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	outputbox_apply_change(pd, 1, path, newtext, 4);
< }
< static void outputbox_5_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
< 	outputbox_apply_change(pd, 1, path, newtext, 5);
< }
< static void outputbox_6_toggled_lcb(GtkCellRendererToggle *cellrenderertoggle,gchar *path,Tprefdialog *pd) {
< 	gchar *val = g_strdup(cellrenderertoggle->active ? "0" : "1");
< 	outputbox_apply_change(pd, 2, path, val, 6);
< 	g_free(val);
< }
< static void add_new_outputbox_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	gchar **strarr;
< 	GtkTreeIter iter;
< 	strarr = pref_create_empty_strarr(7);
< 	gtk_list_store_append(GTK_LIST_STORE(pd->od.lstore), &iter);
< 	set_outputbox_strarr_in_list(&iter, strarr,pd);
< 	pd->lists[outputbox] = g_list_append(pd->lists[outputbox], strarr);
< 	pd->od.insertloc = -1;
< }
< static void delete_outputbox_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	pref_delete_strarr(pd, &pd->od, 7);
< }
< 
< static void create_outputbox_gui(Tprefdialog *pd, GtkWidget *vbox1) {
< 	GtkWidget *hbox, *but, *scrolwin;
< 	pd->lists[outputbox] = duplicate_arraylist(main_v->props.outputbox);
< 	pd->od.lstore = gtk_list_store_new (8,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER);
< 	pd->od.lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(pd->od.lstore));
< 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 1, G_CALLBACK(outputbox_0_edited_lcb), pd, _("Name"), 0);
< 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 1, G_CALLBACK(outputbox_1_edited_lcb), pd, _("Pattern"), 1);
< 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 1, G_CALLBACK(outputbox_2_edited_lcb), pd, _("File #"), 2);
< 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 1, G_CALLBACK(outputbox_3_edited_lcb), pd, _("Line #"), 3);
< 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 1, G_CALLBACK(outputbox_4_edited_lcb), pd, _("Output #"), 4);
< 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 1, G_CALLBACK(outputbox_5_edited_lcb), pd, _("Command"), 5);
< 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 2, G_CALLBACK(outputbox_6_toggled_lcb), pd, _("Show all output"), 6);
< 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin),GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
< 	gtk_container_add(GTK_CONTAINER(scrolwin), pd->od.lview);
< 	gtk_widget_set_size_request(scrolwin, 150, 190);
< 	gtk_box_pack_start(GTK_BOX(vbox1), scrolwin, TRUE, TRUE, 2);
< 	{
< 		GList *tmplist = g_list_first(pd->lists[outputbox]);
< 		while (tmplist) {
< 			gint arrcount;
< 			gchar **strarr = (gchar **)tmplist->data;
< 			arrcount = count_array(strarr);
< 			if (arrcount==7) {
< 				GtkTreeIter iter;
< 				gtk_list_store_append(GTK_LIST_STORE(pd->od.lstore), &iter);
< 				set_outputbox_strarr_in_list(&iter, strarr,pd);
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	gtk_tree_view_set_reorderable(GTK_TREE_VIEW(pd->od.lview), TRUE);
< 	pd->od.thelist = &pd->lists[outputbox];
< 	pd->od.insertloc = -1;
< 	g_signal_connect(G_OBJECT(pd->od.lstore), "row-inserted", G_CALLBACK(listpref_row_inserted), &pd->od);
< 	g_signal_connect(G_OBJECT(pd->od.lstore), "row-deleted", G_CALLBACK(listpref_row_deleted), &pd->od);
< 
< 	hbox = gtk_hbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox1),hbox, TRUE, TRUE, 2);
< 	but = bf_gtkstock_button(GTK_STOCK_ADD, G_CALLBACK(add_new_outputbox_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
< 	but = bf_gtkstock_button(GTK_STOCK_DELETE, G_CALLBACK(delete_outputbox_lcb), pd);
< 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
< }
< 
< /**************************************/
< /* MAIN DIALOG FUNCTIONS              */
< /**************************************/
< 
< static void preferences_destroy_lcb(GtkWidget * widget, Tprefdialog *pd) {
< 	GtkTreeSelection *select;
< 	DEBUG_MSG("preferences_destroy_lcb, started\n");
< 
< 	free_arraylist(pd->lists[filetypes]);
< 	free_arraylist(pd->lists[filefilters]);
< 	free_arraylist(pd->lists[highlight_patterns]);
< 	free_arraylist(pd->lists[browsers]);
< 	free_arraylist(pd->lists[external_commands]);
< 	pd->lists[filetypes] = NULL;
< 	pd->lists[filefilters] = NULL;
< 	pd->lists[highlight_patterns] = NULL;
< 	pd->lists[browsers] = NULL;
< 	pd->lists[external_commands] = NULL;
< 
< /*	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->ftd.lview));
< 	g_signal_handlers_destroy(G_OBJECT(select));*/
< 	DEBUG_MSG("preferences_destroy_lcb, destroying handlers for lstore %p\n",pd->ftd.lstore);
< 	g_signal_handlers_destroy(G_OBJECT(pd->ftd.lstore));
< 
< 	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->ffd.lview));
< 	g_signal_handlers_destroy(G_OBJECT(select));
< 
< 	g_signal_handlers_destroy(G_OBJECT(pd->hpd.popmenu));
< /*	g_signal_handlers_destroy(G_OBJECT(GTK_COMBO(pd->bd.combo)->list));*/
< 	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->bd.lview));
< 	g_signal_handlers_destroy(G_OBJECT(select));
< /*	g_signal_handlers_destroy(G_OBJECT(GTK_COMBO(pd->ed.combo)->list));*/
< 	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->ed.lview));
< 	g_signal_handlers_destroy(G_OBJECT(select));
< 	DEBUG_MSG("preferences_destroy_lcb, about to destroy the window\n");
< 	window_destroy(pd->win);
< 	g_free(pd);
< }
< static void preferences_apply(Tprefdialog *pd) {
< #ifndef NOSPLASH
< 	integer_apply(&main_v->props.show_splash_screen, pd->prefs[editor_show_splash_screen], TRUE);
< #endif /* #ifndef NOSPLASH */
< 	integer_apply(&main_v->props.show_quickbar_tip, pd->prefs[editor_show_quickbar_warning], TRUE);
< 	string_apply(&main_v->props.editor_font_string, pd->prefs[editor_font_string]);
< 	integer_apply(&main_v->props.editor_tab_width, pd->prefs[editor_tab_width], FALSE);
< 	integer_apply(&main_v->props.editor_smart_cursor, pd->prefs[editor_smart_cursor], TRUE);
< 	integer_apply(&main_v->props.editor_indent_wspaces, pd->prefs[editor_indent_wspaces], TRUE);
< 	integer_apply(&main_v->props.word_wrap, pd->prefs[word_wrap], TRUE);
< 	integer_apply(&main_v->props.view_line_numbers, pd->prefs[view_line_numbers], TRUE);
< 	integer_apply(&main_v->props.defaulthighlight, pd->prefs[defaulthighlight], TRUE);
< #ifdef HAVE_PCRE_UTF8
< 	integer_apply(&main_v->props.highlight_utf8, pd->prefs[highlight_utf8], TRUE);
< #endif /* HAVE_PCRE_UTF8 */
< 	integer_apply(&main_v->props.highlight_num_lines_count, pd->prefs[highlight_num_lines_count], FALSE);
< 
< 	integer_apply(&main_v->props.bookmarks_default_store, pd->prefs[bookmarks_default_store], TRUE);
< 	main_v->props.bookmarks_filename_mode = gtk_option_menu_get_history(GTK_OPTION_MENU(pd->prefs[bookmarks_filename_mode]));
< 
< 	integer_apply(&main_v->props.xhtml, pd->prefs[xhtml], TRUE);
< 	if (main_v->props.xhtml) {
< 		main_v->props.lowercase_tags = 1;
< 		main_v->props.allow_dep = 0;
< 	} else {
< 		integer_apply(&main_v->props.lowercase_tags, pd->prefs[lowercase_tags], TRUE);
< 		integer_apply(&main_v->props.allow_dep, pd->prefs[allow_dep], TRUE);
< 	}
< 	integer_apply(&main_v->props.auto_update_meta_author, pd->prefs[auto_update_meta_author], TRUE);
< 	integer_apply(&main_v->props.auto_update_meta_date, pd->prefs[auto_update_meta_date], TRUE);
< 	integer_apply(&main_v->props.auto_update_meta_generator, pd->prefs[auto_update_meta_generator], TRUE);
< 	
< 	string_apply(&main_v->props.newfile_default_encoding, GTK_COMBO(pd->prefs[newfile_default_encoding])->entry);
< 	integer_apply(&main_v->props.auto_set_encoding_meta, pd->prefs[auto_set_encoding_meta], TRUE);
< 	integer_apply(&main_v->props.backup_file, pd->prefs[backup_file], TRUE);
< 	string_apply(&main_v->props.backup_filestring, pd->prefs[backup_filestring]);
< 	main_v->props.backup_abort_action = gtk_option_menu_get_history(GTK_OPTION_MENU(pd->prefs[backup_abort_action]));
< 	integer_apply(&main_v->props.backup_cleanuponclose, pd->prefs[backup_cleanuponclose], TRUE);
< 	integer_apply(&main_v->props.num_undo_levels, pd->prefs[num_undo_levels], FALSE);
< 	integer_apply(&main_v->props.clear_undo_on_save, pd->prefs[clear_undo_on_save], TRUE);
< 	integer_apply(&main_v->props.allow_multi_instances, pd->prefs[allow_multi_instances], TRUE);
< #ifdef WITH_MSG_QUEUE
< 	integer_apply(&main_v->props.open_in_running_bluefish, pd->prefs[open_in_running_bluefish], TRUE);
< #endif
< 	main_v->props.modified_check_type = gtk_option_menu_get_history(GTK_OPTION_MENU(pd->prefs[modified_check_type]));
< 	integer_apply(&main_v->props.max_recent_files, pd->prefs[max_recent_files], FALSE);
< 	
< 	integer_apply(&main_v->props.restore_dimensions, pd->prefs[restore_dimensions], TRUE);
< 	if (!main_v->props.restore_dimensions) {
< 		integer_apply(&main_v->props.left_panel_width, pd->prefs[left_panel_width], FALSE);
< 		integer_apply(&main_v->globses.main_window_h, pd->prefs[main_window_h], FALSE);
< 		integer_apply(&main_v->globses.main_window_w, pd->prefs[main_window_w], FALSE);
< 	}
< 	string_apply(&main_v->props.tab_font_string, pd->prefs[tab_font_string]);
< 	main_v->props.document_tabposition = gtk_option_menu_get_history(GTK_OPTION_MENU(pd->prefs[document_tabposition]));
< 	main_v->props.leftpanel_tabposition = gtk_option_menu_get_history(GTK_OPTION_MENU(pd->prefs[leftpanel_tabposition]));
< 	main_v->props.left_panel_left = gtk_option_menu_get_history(GTK_OPTION_MENU(pd->prefs[left_panel_left]));
< 
< /*	integer_apply(&main_v->props.view_main_toolbar, pd->prefs[view_main_toolbar], TRUE);
< 	integer_apply(&main_v->props.view_left_panel, pd->prefs[view_left_panel], TRUE);
< 	integer_apply(&main_v->props.view_custom_menu, pd->prefs[view_custom_menu], TRUE);
< 	integer_apply(&main_v->props.view_html_toolbar, pd->prefs[view_html_toolbar], TRUE);*/
< 	integer_apply(&main_v->props.transient_htdialogs, pd->prefs[transient_htdialogs], TRUE);
< 	
< 	integer_apply(&main_v->props.ext_browsers_in_submenu, pd->prefs[ext_browsers_in_submenu], TRUE);
< 	integer_apply(&main_v->props.ext_commands_in_submenu, pd->prefs[ext_commands_in_submenu], TRUE);
< 	integer_apply(&main_v->props.ext_outputbox_in_submenu, pd->prefs[ext_outputbox_in_submenu], TRUE);
< 
< 	string_apply(&main_v->props.default_basedir, pd->prefs[default_basedir]);
< 	integer_apply(&main_v->props.filebrowser_two_pane_view, pd->prefs[filebrowser_two_pane_view], TRUE);
< 	string_apply(&main_v->props.filebrowser_unknown_icon, pd->prefs[filebrowser_unknown_icon]);
< 	string_apply(&main_v->props.filebrowser_dir_icon, pd->prefs[filebrowser_dir_icon]);
< 	
< 	string_apply(&main_v->props.image_thumbnailstring, pd->prefs[image_thumbnailstring]);
< 	string_apply(&main_v->props.image_thumbnailtype, GTK_COMBO(pd->prefs[image_thumbnailtype])->entry);
< 
< #ifdef HAVE_GNOME_VFS
< 	integer_apply(&main_v->props.server_zope_compat, pd->prefs[server_zope_compat], TRUE);
< #endif
< 
< 	/*filetype_apply_changes(pd);*/
< 	/*filefilter_apply_changes(pd);*/
< 	highlightpattern_apply_changes(pd);
< 	/*browsers_apply_changes(pd);*/
< 	/*externals_apply_changes(pd);*/
< 	/*outputbox_apply_changes(pd);*/
< 
< 	free_arraylist(main_v->props.filetypes);
< 	main_v->props.filetypes = duplicate_arraylist(pd->lists[filetypes]);
< 
< 	free_arraylist(main_v->props.filefilters);
< 	main_v->props.filefilters = duplicate_arraylist(pd->lists[filefilters]);
< 
< 	free_arraylist(main_v->props.highlight_patterns);
< 	main_v->props.highlight_patterns = duplicate_arraylist(pd->lists[highlight_patterns]);
< 	
< 	free_arraylist(main_v->props.browsers);
< 	main_v->props.browsers = duplicate_arraylist(pd->lists[browsers]);
< 	
< 	free_arraylist(main_v->props.external_commands);
< 	main_v->props.external_commands = duplicate_arraylist(pd->lists[external_commands]);
< 	
< 	free_arraylist(main_v->props.outputbox);
< 	main_v->props.outputbox	 = duplicate_arraylist(pd->lists[outputbox]);
< 
< 	/* apply the changes to highlighting patterns and filetypes to the running program */
< 	filetype_highlighting_rebuild(TRUE);
< 	filebrowser_filters_rebuild();
< 	
< 	all_documents_apply_settings();
< 	{
< 		GList *tmplist = g_list_first(main_v->bfwinlist);
< 		while (tmplist) {
< 			Tbfwin *bfwin = BFWIN(tmplist->data);
< 			DEBUG_MSG("preferences_ok_clicked_lcb, calling encoding_menu_rebuild\n");
< 			encoding_menu_rebuild(bfwin);
< 			external_menu_rebuild(bfwin); /* browsers is also rebuild here! */
< 			filetype_menu_rebuild(bfwin,NULL);
< 			DEBUG_MSG("preferences_ok_clicked_lcb, calling gui_apply_settings\n");
< 			gui_apply_settings(bfwin);
< 			left_panel_rebuild(bfwin);
< 			DEBUG_MSG("preferences_ok_clicked_lcb, calling doc_force_activate\n");
< 			doc_force_activate(bfwin->current_document);
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< }
< 
< static void preferences_cancel_clicked_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	preferences_destroy_lcb(NULL, pd);
< }
< static void preferences_apply_clicked_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	preferences_apply(pd);
< }
< static void preferences_ok_clicked_lcb(GtkWidget *wid, Tprefdialog *pd) {
< 	preferences_apply(pd);
< 	preferences_destroy_lcb(NULL, pd);
< }
< 
< static void restore_dimensions_toggled_lcb(GtkToggleButton *togglebutton,Tprefdialog *pd) {
< 	gtk_widget_set_sensitive(pd->prefs[left_panel_width], !togglebutton->active);
< 	gtk_widget_set_sensitive(pd->prefs[main_window_h], !togglebutton->active);
< 	gtk_widget_set_sensitive(pd->prefs[main_window_w], !togglebutton->active);
< }
< static void create_backup_toggled_lcb(GtkToggleButton *togglebutton,Tprefdialog *pd) {
< 	gtk_widget_set_sensitive(pd->prefs[backup_filestring], togglebutton->active);
< 	gtk_widget_set_sensitive(pd->prefs[backup_abort_action], togglebutton->active);
< }
< 
< static void preferences_dialog() {
< 	Tprefdialog *pd;
< 	GtkWidget *dvbox, *frame, *vbox1, *vbox2;
< 	gchar *notebooktabpositions[] = {N_("left"), N_("right"), N_("top"), N_("bottom"), NULL};
< 	gchar *panellocations[] = {N_("right"), N_("left"), NULL};
< 	gchar *modified_check_types[] = {N_("no check"), N_("check mtime and size"), N_("check mtime"), N_("check size"), NULL};
< 
< 	pd = g_new0(Tprefdialog,1);
< 	pd->win = window_full(_("Edit preferences"), GTK_WIN_POS_NONE, 0, G_CALLBACK(preferences_destroy_lcb), pd, TRUE);
< 	
< 	dvbox = gtk_vbox_new(FALSE, 5);
< 	gtk_container_add(GTK_CONTAINER(pd->win), dvbox);
< 	pd->noteb = gtk_notebook_new();
< 	gtk_notebook_set_homogeneous_tabs(GTK_NOTEBOOK(pd->noteb), TRUE);
< 	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(pd->noteb), GTK_POS_LEFT);
< 	
< 	gtk_box_pack_start(GTK_BOX(dvbox), pd->noteb, TRUE, TRUE, 0);
< 
< 	vbox1 = gtk_vbox_new(FALSE, 5);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Editor"),150,TRUE));
< 
< 	frame = gtk_frame_new(_("Editor startup options"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 
< #ifndef NOSPLASH
< 	pd->prefs[editor_show_splash_screen] = boxed_checkbut_with_value(_("Show splash-screen"), main_v->props.show_splash_screen, vbox2);
< #endif /* #ifndef NOSPLASH */
< 	pd->prefs[editor_show_quickbar_warning] = boxed_checkbut_with_value(_("Show empty quickbar warning"), main_v->props.show_quickbar_tip, vbox2);
< 	
< 	frame = gtk_frame_new(_("Editor options"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 	
< 	pd->prefs[editor_font_string] = prefs_string(_("Font"), main_v->props.editor_font_string, vbox2, pd, string_font);
< 	pd->prefs[editor_tab_width] = prefs_integer(_("Tab width"), main_v->props.editor_tab_width, vbox2, pd, 1, 50);
< 	pd->prefs[editor_smart_cursor] = boxed_checkbut_with_value(_("Smart cursor positioning"), main_v->props.editor_smart_cursor, vbox2);
< 	pd->prefs[editor_indent_wspaces] = boxed_checkbut_with_value(_("Use spaces to indent, not tabs"), main_v->props.editor_indent_wspaces, vbox2);
< 	pd->prefs[word_wrap] = boxed_checkbut_with_value(_("Word wrap default"), main_v->props.word_wrap, vbox2);
< 	pd->prefs[view_line_numbers] = boxed_checkbut_with_value(_("Line numbers by default"), main_v->props.view_line_numbers, vbox2);
< 	pd->prefs[defaulthighlight] = boxed_checkbut_with_value(_("Highlight syntax by default"), main_v->props.defaulthighlight, vbox2);
< #ifdef HAVE_PCRE_UTF8
< 	pd->prefs[highlight_utf8] = boxed_checkbut_with_value(_("Enable highlighting PCRE UTF-8 support"), main_v->props.highlight_utf8, vbox2);
< #endif /* HAVE_PCRE_UTF8 */
< 	pd->prefs[highlight_num_lines_count] = prefs_integer(_("Highlight # lines"), main_v->props.highlight_num_lines_count, vbox2, pd, 1, 8);
< 
< 	frame = gtk_frame_new(_("Undo"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 
< 	pd->prefs[num_undo_levels] = prefs_integer(_("Undo history size"), main_v->props.num_undo_levels, vbox2, pd, 50, 10000);
< 	pd->prefs[clear_undo_on_save] = boxed_checkbut_with_value(_("Clear undo history on save"), main_v->props.clear_undo_on_save, vbox2);
< 	
< 	frame = gtk_frame_new(_("Bookmark options"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 	
< 	pd->prefs[bookmarks_default_store] = boxed_checkbut_with_value(_("Make permanent by default"), main_v->props.bookmarks_default_store, vbox2);
< 	{
< 		gchar *actions[] = {N_("full path"), N_("path from basedir"), N_("filename"), NULL};
< 		pd->prefs[bookmarks_filename_mode] = boxed_optionmenu_with_value(_("Bookmarks filename display"), main_v->props.bookmarks_filename_mode, vbox2, actions);
< 	}
< 
< 	vbox1 = gtk_vbox_new(FALSE, 5);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("HTML"),154,TRUE));
< 
< 	frame = gtk_frame_new(_("HTML options"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 	
< 	pd->prefs[lowercase_tags] = boxed_checkbut_with_value(_("Lowercase HTML tags"), main_v->props.lowercase_tags, vbox2);
< 	pd->prefs[allow_dep] = boxed_checkbut_with_value(_("Use deprecated tags (e.g. <font> and <nobr>)"), main_v->props.allow_dep, vbox2);
< 	pd->prefs[xhtml] = boxed_checkbut_with_value(_("Use XHTML style tags (<br />)"), main_v->props.xhtml, vbox2);
< 	pd->prefs[auto_update_meta_author] = boxed_checkbut_with_value(_("Automatically update author meta tag"), main_v->props.auto_update_meta_author, vbox2);
< 	pd->prefs[auto_update_meta_date] = boxed_checkbut_with_value(_("Automatically update date meta tag"), main_v->props.auto_update_meta_date, vbox2);
< 	pd->prefs[auto_update_meta_generator] = boxed_checkbut_with_value(_("Automatically update generator meta tag"), main_v->props.auto_update_meta_generator, vbox2);
< 	
< 	vbox1 = gtk_vbox_new(FALSE, 5);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Files"),152,TRUE));
< 
< 	frame = gtk_frame_new(_("Encoding"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 	{
< 		GList *tmplist, *poplist = g_list_append(NULL, "");
< 		tmplist = g_list_first(main_v->props.encodings);
< 		while (tmplist) {
< 			gchar **strarr = (gchar **)tmplist->data;
< 			poplist = g_list_append(poplist, strarr[1]);
< 			tmplist = g_list_next(tmplist);
< 		}
< 		pd->prefs[newfile_default_encoding] = prefs_combo(_("Default character set"),main_v->props.newfile_default_encoding, vbox2, pd, poplist, TRUE);
< 		g_list_free(poplist);
< 	}	
< 	pd->prefs[auto_set_encoding_meta] = boxed_checkbut_with_value(_("Auto set <meta> encoding tag on change"), main_v->props.auto_set_encoding_meta, vbox2);
< 
< 	frame = gtk_frame_new(_("Backup"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 	pd->prefs[backup_file] = boxed_checkbut_with_value(_("Create backup on save"), main_v->props.backup_file, vbox2);
< 	pd->prefs[backup_filestring] = prefs_string(_("Backup file suffix"), main_v->props.backup_filestring, vbox2, pd, string_none);
< 	{
< 		gchar *failureactions[] = {N_("save"), N_("abort"), N_("ask"), NULL};
< 		pd->prefs[backup_abort_action] = boxed_optionmenu_with_value(_("Action on backup failure"), main_v->props.backup_abort_action, vbox2, failureactions);
< 	}
< 	pd->prefs[backup_cleanuponclose] = boxed_checkbut_with_value(_("Remove backupfile on close"), main_v->props.backup_cleanuponclose, vbox2);
< 	create_backup_toggled_lcb(GTK_TOGGLE_BUTTON(pd->prefs[backup_file]), pd);
< 	g_signal_connect(G_OBJECT(pd->prefs[backup_file]), "toggled", G_CALLBACK(create_backup_toggled_lcb), pd);
< 
< 	frame = gtk_frame_new(_("Misc"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 
< 	pd->prefs[allow_multi_instances] = boxed_checkbut_with_value(_("Allow multi instances of a file"), main_v->props.allow_multi_instances, vbox2);
< #ifdef WITH_MSG_QUEUE
< 	pd->prefs[open_in_running_bluefish] = boxed_checkbut_with_value(_("Open files in already running bluefish window"),main_v->props.open_in_running_bluefish, vbox2);
< #endif /* WITH_MSG_QUEUE */		
< 	pd->prefs[modified_check_type] = boxed_optionmenu_with_value(_("File modified on disk check "), main_v->props.modified_check_type, vbox2, modified_check_types);
< 	pd->prefs[max_recent_files] = prefs_integer(_("Number of files in 'Open recent'"), main_v->props.max_recent_files, vbox2, pd, 3, 100);
< 
< 	frame = gtk_frame_new(_("File browser"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 	pd->prefs[default_basedir] = prefs_string(_("Default basedir"), main_v->props.default_basedir, vbox2, pd, string_none);
< 	pd->prefs[filebrowser_two_pane_view] = boxed_checkbut_with_value(_("Use separate file and directory view"), main_v->props.filebrowser_two_pane_view, vbox2);
< 	pd->prefs[filebrowser_unknown_icon] = prefs_string(_("Unknown icon"), main_v->props.filebrowser_unknown_icon, vbox2, pd, string_file);
< 	pd->prefs[filebrowser_dir_icon] = prefs_string(_("Directory icon"), main_v->props.filebrowser_dir_icon, vbox2, pd, string_file);
< 
< 	vbox1 = gtk_vbox_new(FALSE, 5);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("User interface"), 156,TRUE));
< 
< 	frame = gtk_frame_new(_("Dimensions"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 	pd->prefs[restore_dimensions] = boxed_checkbut_with_value(_("Restore last used dimensions"), main_v->props.restore_dimensions, vbox2);
< 	pd->prefs[left_panel_width] = prefs_integer(_("Initial sidebar width"), main_v->props.left_panel_width, vbox2, pd, 1, 4000);
< 	pd->prefs[main_window_h] = prefs_integer(_("Initial window height"), main_v->globses.main_window_h, vbox2, pd, 1, 4000);
< 	pd->prefs[main_window_w] = prefs_integer(_("Initial window width"), main_v->globses.main_window_w, vbox2, pd, 1, 4000);
< 	restore_dimensions_toggled_lcb(GTK_TOGGLE_BUTTON(pd->prefs[restore_dimensions]), pd);
< 	g_signal_connect(G_OBJECT(pd->prefs[restore_dimensions]), "toggled", G_CALLBACK(restore_dimensions_toggled_lcb), pd);
< 
< 	frame = gtk_frame_new(_("General"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 
< /*	pd->prefs[view_main_toolbar] = boxed_checkbut_with_value(_("Show main toolbar by default"), main_v->props.view_main_toolbar, vbox2);
< 	pd->prefs[view_left_panel] = boxed_checkbut_with_value(_("Show sidebar by default"), main_v->props.view_left_panel, vbox2);
< 	pd->prefs[view_custom_menu] = boxed_checkbut_with_value(_("Show custom menu by default"), main_v->props.view_custom_menu, vbox2);
< 	pd->prefs[view_html_toolbar] = boxed_checkbut_with_value(_("Show HTML toolbar by default"), main_v->props.view_html_toolbar, vbox2);*/
< 	pd->prefs[transient_htdialogs] = boxed_checkbut_with_value(_("Make HTML dialogs transient"), main_v->props.transient_htdialogs, vbox2);
< 
< 	pd->prefs[ext_browsers_in_submenu] = boxed_checkbut_with_value(_("External browsers in submenu"), main_v->props.ext_browsers_in_submenu, vbox2);
< 	pd->prefs[ext_commands_in_submenu] = boxed_checkbut_with_value(_("External commands in submenu"), main_v->props.ext_commands_in_submenu, vbox2);
< 	pd->prefs[ext_outputbox_in_submenu] = boxed_checkbut_with_value(_("External outputbox in submenu"), main_v->props.ext_outputbox_in_submenu, vbox2);
< 	
< 	pd->prefs[tab_font_string] = prefs_string(_("Notebook tab font (leave empty for gtk default)"), main_v->props.tab_font_string, vbox2, pd, string_font);
< 	
< 	pd->prefs[document_tabposition] = boxed_optionmenu_with_value(_("Document notebook tab position"), main_v->props.document_tabposition, vbox2, notebooktabpositions);
< 	pd->prefs[leftpanel_tabposition] = boxed_optionmenu_with_value(_("Sidebar notebook tab position"), main_v->props.leftpanel_tabposition, vbox2, notebooktabpositions);
< 	pd->prefs[left_panel_left] = boxed_optionmenu_with_value(_("Sidebar location"), main_v->props.left_panel_left, vbox2, panellocations);
< 
< 	vbox1 = gtk_vbox_new(FALSE, 5);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Images"), 155,TRUE));
< 
< 	frame = gtk_frame_new(_("Thumbnails"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 	pd->prefs[image_thumbnailstring] = prefs_string(_("Thumbnail suffix"), main_v->props.image_thumbnailstring, vbox2, pd, string_none);
< 	{
< 		GList *poplist = g_list_append(NULL, "png");
< 		poplist = g_list_append(poplist, "jpeg");
< 		pd->prefs[image_thumbnailtype] = prefs_combo(_("Thumbnail filetype"),main_v->props.image_thumbnailtype, vbox2, pd, poplist, FALSE);
< 		g_list_free(poplist);
< 	}
< 
< 	vbox1 = gtk_vbox_new(FALSE, 5);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Filetypes"), 153,TRUE));
< 
< 	frame = gtk_frame_new(_("Filetypes"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 
< 	create_filetype_gui(pd, vbox2);
< 	
< 	frame = gtk_frame_new(_("Filefilters"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 	
< 	create_filefilter_gui(pd, vbox2);
< 
< 	vbox1 = gtk_vbox_new(FALSE, 5);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Syntax highlighting"), 158,TRUE));
< 
< 	frame = gtk_frame_new(_("Patterns"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 
< 	create_highlightpattern_gui(pd, vbox2);
< 
< 	vbox1 = gtk_vbox_new(FALSE, 5);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("External programs"), 151,TRUE));
< 
< 	frame = gtk_frame_new(_("Browsers"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 
< 	create_browsers_gui(pd, vbox2);
< 
< 	frame = gtk_frame_new(_("Utilities and filters"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 
< 	create_externals_gui(pd, vbox2);
< 
< 	vbox1 = gtk_vbox_new(FALSE, 5);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Output parsers"), 157,TRUE));
< 	
< 	frame = gtk_frame_new(_("Outputbox"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 	
< 	create_outputbox_gui(pd, vbox2);
< 
< #ifdef HAVE_GNOME_VFS
< 	vbox1 = gtk_vbox_new(FALSE, 5);
< 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Servers"), 0,TRUE));
< 	
< 	frame = gtk_frame_new(_("Remote servers"));
< 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
< 	
< 	pd->prefs[server_zope_compat] = boxed_checkbut_with_value(_("Zope compatibility mode"), main_v->props.server_zope_compat, vbox2);
< #endif
< 
< 	/* end, create buttons for dialog now */
< 	{
< 		GtkWidget *ahbox, *but;
< 		ahbox = gtk_hbutton_box_new();
< 		gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
< 		gtk_button_box_set_spacing(GTK_BUTTON_BOX(ahbox), 12);
< 
< 		gtk_box_pack_start(GTK_BOX(dvbox), ahbox, FALSE, FALSE, 0);
< 		but = bf_gtkstock_button(GTK_STOCK_APPLY, G_CALLBACK(preferences_apply_clicked_lcb), pd);
< 		gtk_box_pack_start(GTK_BOX(ahbox), but, TRUE, TRUE, 0);
< 
< 		but = bf_stock_cancel_button(G_CALLBACK(preferences_cancel_clicked_lcb), pd);
< 		gtk_box_pack_start(GTK_BOX(ahbox), but, TRUE, TRUE, 0);
< 
< 		but = bf_stock_ok_button(G_CALLBACK(preferences_ok_clicked_lcb), pd);
< 		gtk_box_pack_start(GTK_BOX(ahbox), but, TRUE, TRUE, 0);
< 		gtk_window_set_default(GTK_WINDOW(pd->win), but);
< 	}
< 	gtk_widget_show_all(pd->win);
< }
< 
< void open_preferences_cb(GtkWidget *wid, gpointer data) {
< 	preferences_dialog();
< }
< 
< void open_preferences_menu_cb(gpointer callback_data,guint action,GtkWidget *widget) {
< 	preferences_dialog();
< }
---
> /* Bluefish HTML Editor
>  * preferences.c - the preferences code
>  *
>  * Copyright (C) 2002-2005 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> /* #define DEBUG */
> 
> #include <gtk/gtk.h>
> #include <string.h>        /* strcmp() */
> 
> #include "bluefish.h"
> #include "bf_lib.h"        /* list_switch_order() */
> #include "document.h"
> #include "filebrowser.h"
> #include "gtk_easy.h"
> #include "gui.h"
> #include "highlight.h"
> #include "menu.h"
> #include "pixmap.h"
> #include "stringlist.h"    /* duplicate_arraylist*/
> 
> enum {
> 	view_html_toolbar,
> 	view_custom_menu,
> 	view_main_toolbar,
> 	view_left_panel,
> 	view_line_numbers,
> 	filebrowser_two_pane_view,
> 	filebrowser_unknown_icon,
> 	filebrowser_dir_icon,
> 	editor_show_splash_screen,    /* show splash screen at start-up */
> 	editor_show_quickbar_warning, /* show warning about empty quickbar at startup */
> 	editor_font_string,         /* editor font */
> 	editor_tab_width,           /* editor tabwidth */
> 	editor_indent_wspaces,
> 	editor_smart_cursor,
> 	tab_font_string,            /* notebook tabs font */
> 	highlight_num_lines_count,  /* number of lines to highlight in continous highlighting */	
> 	defaulthighlight,           /* highlight documents by default */
> #ifdef HAVE_PCRE_UTF8
> 	highlight_utf8,             /* enable PCRE UTF-8 support */
> #endif /* HAVE_PCRE_UTF8 */
> 	transient_htdialogs,        /* set html dialogs transient ro the main window */
> 	restore_dimensions,
> 	left_panel_width,
> 	left_panel_left,
> 	main_window_h,              /* main window height */
> 	main_window_w,              /* main window width */
> 	max_recent_files,           /* length of Open Recent list */
> 	max_dir_history,            /* length of directory history */
> 	backup_file,                /* wheather to use a backup file */
> 	backup_filestring,          /* the string to append to the backup file */
> 	backup_abort_action,        /* if the backup fails, continue 'save', 'abort' save, or 'ask' user */
> 	backup_cleanuponclose,      /* remove the backupfile after close ? */
> 	image_thumbnailstring,      /* string to append to thumbnail filenames */
> 	image_thumbnailtype,        /* fileformat to use for thumbnails, "jpeg" or "png" can be handled by gdkpixbuf*/
> 	image_thumbnailsizing_type,	/* scaling ratio=0, fixed width=1, height=2, width+height (discard aspect ratio)=3 */
> 	image_thumbnailsizing_val1,	/* the width, height or ratio, depending on the value above */
> 	image_thumbnailsizing_val2, /* height if the type=3 */
> 	image_thumnailformatstring, /* like <a href="%r"><img src="%t"></a> or more advanced */
> 	allow_multi_instances,      /* allow multiple instances of the same file */
> 	modified_check_type,        /* 0=no check, 1=by mtime and size, 2=by mtime, 3=by size, 4,5,...not implemented (md5sum?) */
> 	num_undo_levels,            /* number of undo levels per document */
> 	clear_undo_on_save,         /* clear all undo information on file save */
> 	newfile_default_encoding,   /* if you open a new file, what encoding will it use */
> 	auto_set_encoding_meta,     /* auto set metatag for the encoding */
> 	auto_update_meta_author,
> 	auto_update_meta_date,
> 	auto_update_meta_generator,
> 	ext_browsers_in_submenu,
> 	ext_commands_in_submenu,
> 	ext_outputbox_in_submenu,
> 	bookmarks_default_store,
> 	bookmarks_filename_mode,
> 	document_tabposition,
> 	leftpanel_tabposition,
> 	default_basedir,
> 	/* not yet in use */
> 	image_editor_cline,         /* image editor commandline */
> 	full_p,                     /* use </p> */
> 	full_li,                    /* use </li> */
> 	allow_css,                  /* CSS allowed */
> 	allow_dep,                  /* allow <FONT>... */
> 	format_by_context,          /* use <strong> instead of <b>, <emphasis instead of <i> etc. (W3C reccomendation) */
> 	xhtml,                      /* write <br /> */
> 	allow_ruby,                 /* allow <ruby> */
> 	allow_h4,                   /* allow <Q>... */
> 	allow_frames,               /* allow <FRAME> */
> 	force_dtd,                  /* write <!DOCTYPE...> */
> 	dtd_url,                    /* URL in DTD */
> 	xml_start,                  /* <?XML...> */
> 	lowercase_tags,             /* use lowercase tags */
> 	word_wrap,                  /* use wordwrap */
> 	autoindent,                 /* autoindent code */
> 	drop_at_drop_pos,           /* drop at drop position instead of cursor position */
> 	link_management,            /* perform link management */
> 	html_ver,
> 	cust_menu,                  /* entries in the custom menu */
> #ifdef WITH_SPC
> 	/* spell checker options */
> 	cfg_spc_cline,              /* spell checker command line */
> 	cfg_spc_lang,               /* language */
> 	spc_accept_compound,        /* accept compound words ? */
> 	spc_use_esc_chars,          /* specify aditional characters that may be part of a word ? */
> 	spc_esc_chars,              /* which ones ? */
> 	spc_use_pers_dict,          /* use a personal dictionary */
> 	spc_pers_dict,              /* which one ? */
>    spc_use_input_encoding,      /* use input encoding */
>    spc_input_encoding,          /* wich one ? */
>    spc_output_html_chars,       /* output html chars ? (like &aacute,)*/
> #endif
> 	/* key conversion */
> 	conv_ctrl_enter,            /* convert control-enter key press */
> 	ctrl_enter_text,            /* inserted text */
> 	conv_shift_enter,           /* convert shift-enter key press */
> 	shift_enter_text,           /* inserted text */
> 	conv_special_char,          /* convert ctrl-'<','>','&' */
> #ifdef WITH_MSG_QUEUE
> 	open_in_running_bluefish,   /* open commandline documents in already running session*/
> #endif /* WITH_MSG_QUEUE */
> #ifdef HAVE_GNOME_VFS
> 	server_zope_compat,
> #endif /* HAVE_GNOME_VFS */
> 	property_num_max
> };
> 
> enum {
> 	browsers,
> 	external_commands,
> 	filetypes,
> 	filefilters,
> 	highlight_patterns,
> 	outputbox,
> 	lists_num_max
> };
> 
> typedef struct {
> 	GtkListStore *lstore;
> 	GtkWidget *lview;
> 	int insertloc;
> 	GList **thelist;
> } Tlistpref;
> 
> typedef struct {
> 	GtkListStore *lstore;
> 	GtkWidget *lview;
> 	GtkWidget *entry[6];
> 	GtkWidget *popmenu;
> 	GtkWidget *check;
> 	GtkWidget *radio[9];
> 	gchar **curstrarr;
> 	const gchar *selected_filetype;
> } Thighlightpatterndialog;
> 
> typedef struct {
> 	GtkWidget *prefs[property_num_max];
> 	GList *lists[lists_num_max];
> 	GtkWidget *win;
> 	GtkWidget *noteb;
> 	Tlistpref ftd;
> 	Tlistpref ffd;
> 	Thighlightpatterndialog hpd;
> 	Tlistpref bd;
> 	Tlistpref ed;
> 	Tlistpref od;
> } Tprefdialog;
> 
> typedef enum {
> 	string_none,
> 	string_file,
> 	string_font,
> 	string_color
> } Tprefstringtype;
> 
> /* type 0/1=text, 2=toggle */
> static void pref_create_column(GtkTreeView *treeview, gint type, GCallback func, gpointer data, const gchar *title, gint num) {
> 	GtkTreeViewColumn *column;
> 	GtkCellRenderer *renderer;
> 	if (type == 1 || type == 0) {
> 		renderer = gtk_cell_renderer_text_new();
> 		g_object_set(G_OBJECT(renderer), "editable", TRUE, NULL);
> 		g_signal_connect(G_OBJECT(renderer), "edited", func, data);
> 	} else {
> 		renderer = gtk_cell_renderer_toggle_new();
> 		g_object_set(G_OBJECT(renderer), "activatable", TRUE, NULL);
> 		g_signal_connect(G_OBJECT(renderer), "toggled", func, data);
> 	}
> 	column = gtk_tree_view_column_new_with_attributes(title, renderer,(type ==1) ? "text" : "active" ,num,NULL);
> 	gtk_tree_view_append_column(GTK_TREE_VIEW(treeview), column);
> }
> /* 3 entries must have len 3, but in reality it will be 4, because there is a NULL pointer appended */
> static gchar **pref_create_empty_strarr(gint len) {
> 	gchar **strarr = g_malloc0((len+1)*sizeof(gchar *));
> 	gint i;
> 	strarr[0] = g_strdup(_("Untitled"));
> 	for (i=1;i<len;i++) {
> 		strarr[i] = g_strdup("");
> 	}
> 	strarr[len] = NULL;
> 	return strarr;
> }
> /* type 0=escapedtext, 1=text, 2=toggle */
> static void pref_apply_change(GtkListStore *lstore, gint pointerindex, gint type, gchar *path, gchar *newval, gint index) {
> 	gchar **strarr;
> 	GtkTreeIter iter;
> 	GtkTreePath* tpath = gtk_tree_path_new_from_string(path);
> 	if (tpath && gtk_tree_model_get_iter(GTK_TREE_MODEL(lstore),&iter,tpath)) {
> 		gtk_tree_model_get(GTK_TREE_MODEL(lstore), &iter, pointerindex, &strarr, -1);
> 		DEBUG_MSG("pref_apply_change, lstore=%p, index=%d, type=%d, got strarr=%p\n",lstore,index,type,strarr);
> 		if (type ==1) {
> 			gtk_list_store_set(GTK_LIST_STORE(lstore),&iter,index,newval,-1);
> 		} else {
> 			gtk_list_store_set(GTK_LIST_STORE(lstore),&iter,index,(newval[0] == '1'),-1);
> 		}
> 		if (strarr[index]) {
> 			DEBUG_MSG("pref_apply_change, old value for strarr[%d] was %s\n",index,strarr[index]);
> 			g_free(strarr[index]);
> 		}
> 		if (type == 0) {
> 			strarr[index] = unescape_string(newval, FALSE);
> 		} else {
> 			strarr[index] = g_strdup(newval);
> 		}
> 		DEBUG_MSG("pref_apply_change, strarr[%d] now is %s\n",index,strarr[index]);
> 	} else {
> 		DEBUG_MSG("ERROR: path %s was not converted to tpath(%p) or iter (lstore=%p)\n",path,tpath,lstore);
> 	}
> 	gtk_tree_path_free(tpath);
> }
> static void pref_delete_strarr(Tprefdialog *pd, Tlistpref *lp, gint pointercolumn) {
> 	GtkTreeIter iter;
> 	GtkTreeSelection *select;
> 	lp->insertloc = -1;
> 	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(lp->lview));
> 	if (gtk_tree_selection_get_selected (select,NULL,&iter)) {
> 		gchar **strarr;
> 		gtk_tree_model_get(GTK_TREE_MODEL(lp->lstore), &iter, pointercolumn, &strarr, -1);
> 		gtk_list_store_remove(GTK_LIST_STORE(lp->lstore),&iter);
> 		*lp->thelist = g_list_remove(*lp->thelist, strarr);
> 		g_strfreev(strarr);
> 	}
> }
> 
> static void listpref_row_inserted(GtkTreeModel *treemodel,GtkTreePath *arg1,GtkTreeIter *arg2,Tlistpref *lp) {
> 	gint *indices = gtk_tree_path_get_indices(arg1);
> 	if (indices) {
> 		lp->insertloc = indices[0];
> 		DEBUG_MSG("reorderable_row_inserted, insertloc=%d\n",lp->insertloc);
> 	}
> }
> static void listpref_row_deleted(GtkTreeModel *treemodel,GtkTreePath *arg1,Tlistpref *lp) {
> 	if (lp->insertloc > -1) {
> 		gint *indices = gtk_tree_path_get_indices(arg1);
> 		if (indices) {
> 			GList *lprepend, *ldelete;
> 			gint deleteloc = indices[0];
> 			if (deleteloc > lp->insertloc) deleteloc--;
> 			DEBUG_MSG("reorderable_row_deleted, deleteloc=%d, insertloc=%d, listlen=%d\n",deleteloc,lp->insertloc,g_list_length(*lp->thelist));
> 			*lp->thelist = g_list_first(*lp->thelist);
> 			lprepend = g_list_nth(*lp->thelist,lp->insertloc);
> 			ldelete = g_list_nth(*lp->thelist,deleteloc);
> 			if (ldelete && (ldelete != lprepend)) {
> 				gpointer data = ldelete->data;
> 				*lp->thelist = g_list_remove(*lp->thelist, data);
> 				if (lprepend == NULL) {
> 					DEBUG_MSG("lprepend=NULL, appending %s to the list\n",((gchar **)data)[0]);
> 					*lp->thelist = g_list_append(g_list_last(*lp->thelist), data);
> 				} else {
> 					DEBUG_MSG("lprepend %s, ldelete %s\n",((gchar **)lprepend->data)[0], ((gchar **)data)[0]);
> 					*lp->thelist = g_list_prepend(lprepend, data);
> 				}
> 				*lp->thelist = g_list_first(*lp->thelist);
> 			} else {
> 				DEBUG_MSG("listpref_row_deleted, ERROR: ldelete %p, lprepend %p\n", ldelete, lprepend);
> 			}
> 		}
> 		lp->insertloc = -1;
> 	}
> }
> 
> static void font_dialog_response_lcb(GtkDialog *fsd,gint response,GtkWidget *entry) {
> 	DEBUG_MSG("font_dialog_response_lcb, response=%d\n", response);
> 	if (response == GTK_RESPONSE_OK) {
> 		gchar *fontname;
> 		fontname = gtk_font_selection_dialog_get_font_name(GTK_FONT_SELECTION_DIALOG(fsd));
> 		gtk_entry_set_text(GTK_ENTRY(entry), fontname);
> 		g_free(fontname);
> 	}
> 	gtk_widget_destroy(GTK_WIDGET(fsd));
> }
> 
> static void font_button_lcb(GtkWidget *wid, GtkWidget *entry) {
> 	GtkWidget *fsd;
> 	const gchar *fontname;
> 	fsd = gtk_font_selection_dialog_new(_("Select font"));
> 	fontname = gtk_entry_get_text(GTK_ENTRY(entry)); /* do NOT free, this is an internal pointer */
> 	if (strlen(fontname)) {
> 		gtk_font_selection_dialog_set_font_name(GTK_FONT_SELECTION_DIALOG(fsd), fontname);
> 	}
> 	g_signal_connect(GTK_OBJECT(fsd),"response",G_CALLBACK(font_dialog_response_lcb),entry);
> 	gtk_window_set_transient_for(GTK_WINDOW(GTK_DIALOG(fsd)), GTK_WINDOW(gtk_widget_get_toplevel(entry)));
> 	gtk_window_set_modal(GTK_WINDOW(GTK_DIALOG(fsd)), TRUE);
> 	gtk_window_set_destroy_with_parent(GTK_WINDOW(GTK_DIALOG(fsd)), TRUE);
> 	gtk_widget_show(fsd);
> }
> 
> static GtkWidget *prefs_string(const gchar *title, const gchar *curval, GtkWidget *box, Tprefdialog *pd, Tprefstringtype prefstringtype) {
> 	GtkWidget *hbox, *return_widget;
> 
> 	hbox = gtk_hbox_new(FALSE,3);
> 	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 3);
> 	gtk_box_pack_start(GTK_BOX(hbox), gtk_label_new(title), FALSE, FALSE, 3);
> 	return_widget = boxed_entry_with_text(curval, 1023, hbox);
> 	if (prefstringtype == file) {
> 		gtk_box_pack_start(GTK_BOX(hbox), file_but_new(return_widget, 1, NULL), FALSE, FALSE, 3);
> 	} else if (prefstringtype == font) {
> 		GtkWidget *but = bf_gtkstock_button(GTK_STOCK_SELECT_FONT, G_CALLBACK(font_button_lcb), return_widget);
> 		gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, FALSE, 3);
> 	}
> 	return return_widget;
> }
> 
> static GtkWidget *prefs_combo(const gchar *title, const gchar *curval, GtkWidget *box, Tprefdialog *pd, GList *poplist, gboolean editable) {
> 	GtkWidget *return_widget;
> 	GtkWidget *hbox;
> 
> 	hbox = gtk_hbox_new(FALSE,3);
> 	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 3);
> 	gtk_box_pack_start(GTK_BOX(hbox), gtk_label_new(title), FALSE, FALSE, 3);
> 	return_widget = boxed_combo_with_popdown(curval, poplist, editable, hbox);
> 	return return_widget;
> }
> 
> static GtkWidget *prefs_integer(const gchar *title, const gint curval, GtkWidget *box, Tprefdialog *pd, gfloat lower, gfloat upper) {
> 	GtkWidget *return_widget;
> 	GtkWidget *hbox;
> 	GtkObject *adjust;
> 	gfloat step_increment, page_increment;
> 
> 	step_increment = (upper - lower)/1000;
> 	if (step_increment < 1) {
> 		step_increment = 1;
> 	}
> 	page_increment = (upper - lower)/20;
> 	if (page_increment < 10) {
> 		page_increment = 10;
> 	}
> 	hbox = gtk_hbox_new(FALSE,3);
> 	gtk_box_pack_start(GTK_BOX(box), hbox, FALSE, FALSE, 3);
> 	adjust = gtk_adjustment_new((1.0 * curval), lower, upper, step_increment ,page_increment , 0);
> 	return_widget = gtk_spin_button_new(GTK_ADJUSTMENT(adjust), 0.1, 0);
> 	gtk_box_pack_start(GTK_BOX(hbox), gtk_label_new(title), FALSE, FALSE, 3);
> 	gtk_box_pack_start(GTK_BOX(hbox), return_widget, TRUE, TRUE, 3);
> 	return return_widget;
> }
> 
> 
> /*************************/
> /* GENERAL FUNCTIONS     */
> /*************************/
> /* static GList *general_poplist(GList *arraylist, gint required_items, gint poplist_label_index) {
> 	GList *tmplist, *poplist=NULL;
> 	
> 	tmplist = g_list_first(arraylist);
> 	while(tmplist){
> 		gchar **strarr =(gchar **)tmplist->data;
> 		if (count_array(strarr) >= required_items) poplist = g_list_append(poplist, strarr[poplist_label_index]);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return poplist;
> }*/
> /*
> static void generic_selection_changed_cb(GtkTreeSelection *selection
> 	, GtkWidget **entry, void (*apply_func)(), Tprefdialog *pd,gint whichlist, gint numentries, gchar ***newcurstrarr){
> 	GtkTreeIter iter;
> 	GtkTreeModel *model;
> 	DEBUG_MSG("generic_selection_changed_cb, started\n");
> 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
> 		gchar *value;
> 		GList *tmplist = g_list_first(pd->lists[whichlist]);
> 		gtk_tree_model_get(model, &iter, 0, &value, -1);
> 		apply_func(pd);
> 		while (tmplist) {
> 			gchar **strarr =(gchar **)tmplist->data;
> 			if (strcmp(strarr[0],value)==0) {
> 				gint i;
> 				for (i=0;i<numentries;i++) {
> 					gtk_entry_set_text(GTK_ENTRY(entry[i]), strarr[i]);
> 				}
> 				DEBUG_MSG("generic_selection_changed_cb, newcurstrarr(%p) is now %p\n", newcurstrarr, *newcurstrarr);
> 				*newcurstrarr = strarr;
> 				DEBUG_MSG("generic_selection_changed_cb, newcurstrarr(%p) set to %p (check %p)\n", newcurstrarr, strarr, *newcurstrarr);
> 				return;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	} else {
> 		DEBUG_MSG("generic_selection_changed_cb, no selection ?!?!\n");
> 	}
> }
> 
> static gchar **generic_create_strarr(gint numitems, GtkWidget **entries, gboolean force_firstitem_strlen) {
> 	gint i;
> 	gchar **strarr = g_malloc((numitems+1)*sizeof(gchar *));
> 	for (i=0;i<numitems;i++) {
> 		strarr[i] = gtk_editable_get_chars(GTK_EDITABLE(entries[i]), 0, -1);
> 	}
> 	strarr[numitems] = NULL;
> 	if (strlen(strarr[0])) {
> 		return strarr;
> 	} else {
> 		g_strfreev(strarr);
> 		return NULL;
> 	}
> }*/
> 
> /**********************************************************/
> /* FILETYPE, FILTERS AND HIGHLIGHT PATTERNS FUNCTIONS     */
> /**********************************************************/
> 
> /* static void add_new_general_lcb(Tprefdialog *pd, GtkWidget *entry, gint numentries, gint whichlist, GtkListStore *lstore) {
> 	gchar *newtype = gtk_editable_get_chars(GTK_EDITABLE(entry),0,-1);
> 	DEBUG_MSG("add_new_general_lcb, newtype=%s\n", newtype);
> 	if (strlen(newtype)) {
> 		gint i;
> 		gchar **strarr = g_malloc((numentries+1)*sizeof(gchar *));
> 		strarr[0] = newtype;
> 		for (i=1;i<numentries;i++) {
> 			strarr[i] = g_strdup("");
> 		}
> 		strarr[i] = NULL;
> 		pd->lists[whichlist] = g_list_append(pd->lists[whichlist], strarr);
> 		{
> 			GtkTreeIter iter;
> 			gtk_list_store_append(GTK_LIST_STORE(lstore), &iter);
> 			for (i=0;i<numentries;i++) {
> 				gtk_list_store_set(GTK_LIST_STORE(lstore),&iter,i,strarr[i],-1);
> 			}
> 		}
> 	} else {
> 		g_free(newtype);
> 	}
> } */
> /*
> static gchar **filetype_create_strarr(Tprefdialog *pd) {
> 	gchar **strarr;
> 	gchar *escaped, *tmp;
> 	tmp = gtk_editable_get_chars(GTK_EDITABLE(pd->ftd.entry[0]),0,-1);
> 	if (strlen(tmp)) {
> 		strarr = g_malloc(8*sizeof(gchar *));
> 		strarr[0] = tmp;
> 		strarr[1] = gtk_editable_get_chars(GTK_EDITABLE(pd->ftd.entry[1]),0,-1);
> 		escaped = gtk_editable_get_chars(GTK_EDITABLE(pd->ftd.entry[2]),0,-1);
> 		strarr[2] = unescape_string(escaped, FALSE);
> 		g_free(escaped);
> 		strarr[3] = gtk_editable_get_chars(GTK_EDITABLE(pd->ftd.entry[3]),0,-1);
> 		strarr[4] = g_strdup(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(pd->ftd.entry[4])) ? "1" : "0");
> 		strarr[5] = gtk_editable_get_chars(GTK_EDITABLE(pd->ftd.entry[5]),0,-1);
> 		strarr[6] = g_strdup("1");
> 		strarr[7] = NULL;
> 		DEBUG_MSG("filetype_create_strarr, created at %p\n", strarr);
> 		return strarr;
> 	} else {
> 		g_free(tmp);
> 		return NULL;
> 	}
> }
> 
> static void set_filetype_strarr_in_list(GtkTreeIter *iter, gchar **strarr, Tprefdialog *pd) {
> 	gint arrcount;
> 	arrcount = count_array(strarr);
> 	if (arrcount==7) {
> 		gchar *escaped;
> 		DEBUG_MSG("set_filetype_strarr_in_list, escaping %s\n",strarr[2]);
> 		escaped = escape_string(strarr[2],FALSE);
> 		DEBUG_MSG("set_filetype_strarr_in_list, 4=%d, string was %s\n",(strarr[4][0] != '0'), strarr[4]);
> 		gtk_list_store_set(GTK_LIST_STORE(pd->ftd.lstore), iter
> 			,0,strarr[0]
> 			,1,strarr[1]
> 			,2,escaped
> 			,3,strarr[3]
> 			,4,(strarr[4][0] != '0')
> 			,5,strarr[5]
> 			,6,strarr[6]
> 			,7,strarr
> 			,-1);
> 		g_free(escaped);
> 	}
> }
> 
> static void filetype_apply_changes(Tprefdialog *pd) {
> 	DEBUG_MSG("filetype_apply_changes, started\n");
> 	if (pd->ftd.curstrarr) {
> 		GtkTreeIter iter;
> 		gboolean retval;
> 		GList *tmplist;
> 		tmplist = g_list_first(pd->lists[filetypes]);
> 		while (tmplist) {
> 			if (tmplist->data == pd->ftd.curstrarr) {
> 				g_strfreev(pd->ftd.curstrarr);
> 				tmplist->data = filetype_create_strarr(pd);
> 				pd->ftd.curstrarr = tmplist->data;
> 				DEBUG_MSG("filetype_apply_changes, applied changes to pd->lists new curstrarr=%p\n", pd->ftd.curstrarr);
> 				break;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		
> 		retval = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->ftd.lstore),&iter);
> 		DEBUG_MSG("filetype_apply_changes, searching for '%s' in liststore\n",pd->ftd.curstrarr[0]);
> 		while (retval) {
> 			gchar *curval;
> 			gtk_tree_model_get(GTK_TREE_MODEL(pd->ftd.lstore),&iter,0,&curval,-1);
> 			if (strcmp(curval,pd->ftd.curstrarr[0])==0) {
> 				DEBUG_MSG("filetype_apply_changes, found it, set listore 0=%s,1=%s,...\n", pd->ftd.curstrarr[0], pd->ftd.curstrarr[1]);
> 				set_filetype_strarr_in_list(&iter,pd->ftd.curstrarr,pd);
> 				break;
> 			}
> 			retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->ftd.lstore),&iter);
> 		}
> 	} else {
> 		DEBUG_MSG("filetype_apply_changes, no curstrarr, nothing to apply\n");
> 	}
> }
> 
> static void filetype_selection_changed_cb(GtkTreeSelection *selection, Tprefdialog *pd) {
> 	GtkTreeIter iter;
> 	GtkTreeModel *model;
> 	DEBUG_MSG("filetype_selection_changed_cb, started\n");
> 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
> 		gchar *filetype;
> 		GList *tmplist = g_list_first(pd->lists[filetypes]);
> 		gtk_tree_model_get(model, &iter, 0, &filetype, -1);
> 		filetype_apply_changes(pd);
> 		while (tmplist) {
> 			gchar **strarr =(gchar **)tmplist->data;
> 			DEBUG_MSG("filetype_selection_changed_cb, searching for '%s'\n",filetype);
> 			if (strcmp(strarr[0],filetype)==0) {
> 				gchar *escaped = escape_string(strarr[2],FALSE);
> 				gtk_entry_set_text(GTK_ENTRY(pd->ftd.entry[0]), strarr[0]);
> 				gtk_entry_set_text(GTK_ENTRY(pd->ftd.entry[1]), strarr[1]);
> 				gtk_entry_set_text(GTK_ENTRY(pd->ftd.entry[2]), escaped);
> 				gtk_entry_set_text(GTK_ENTRY(pd->ftd.entry[3]), strarr[3]);
> 				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->ftd.entry[4]), (strarr[4][0] != '0'));
> 				gtk_entry_set_text(GTK_ENTRY(pd->ftd.entry[5]), strarr[5]);
> 				pd->ftd.curstrarr = strarr;
> 				g_free(escaped);
> 				return;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		DEBUG_MSG("filetype_selection_changed_cb, NOTHING FOUND ?!?!?\n");
> 	} else {
> 		DEBUG_MSG("filetype_selection_changed_cb, no selection ?!?!\n");
> 	}
> }
> */
> static void set_filetype_strarr_in_list(GtkTreeIter *iter, gchar **strarr, Tprefdialog *pd) {
> 	gint arrcount;
> 	arrcount = count_array(strarr);
> 	if (arrcount==7) {
> 		gchar *escaped;
> 		escaped = escape_string(strarr[2],FALSE);
> 		gtk_list_store_set(GTK_LIST_STORE(pd->ftd.lstore), iter
> 				,0,strarr[0],1,strarr[1],2,escaped,3,strarr[3]
> 				,4,(strarr[4][0] != '0'),5,strarr[5],6,strarr[6]
> 				,7,strarr,-1);
> 		g_free(escaped);
> 	}
> }
> static void filetype_apply_change(Tprefdialog *pd, gint type, gchar *path, gchar *newval, gint index) {
> 	pref_apply_change(pd->ftd.lstore,7,type,path,newval,index);
> }
> static void filetype_0_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	filetype_apply_change(pd, 1, path, newtext, 0);
> }
> static void filetype_1_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	filetype_apply_change(pd, 1, path, newtext, 1);
> }
> static void filetype_2_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	filetype_apply_change(pd, 1, path, newtext, 2);
> }
> static void filetype_3_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	filetype_apply_change(pd, 1, path, newtext, 3);
> }
> static void filetype_4_toggled_lcb(GtkCellRendererToggle *cellrenderertoggle,gchar *path,Tprefdialog *pd) {
> 	gchar *val = g_strdup(cellrenderertoggle->active ? "0" : "1");
> 	filetype_apply_change(pd, 2, path, val, 4);
> 	g_free(val);
> }
> static void filetype_5_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	filetype_apply_change(pd, 1, path, newtext, 5);
> }
> static void filetype_6_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	if (strlen(newtext)==1 && newtext[0] >= '0' && newtext[0] <= '2') {
> 		filetype_apply_change(pd, 1, path, newtext, 6);
> 	}
> }
> 
> static void add_new_filetype_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	gchar **strarr;
> 	GtkTreeIter iter;
> 	strarr = pref_create_empty_strarr(7);
> 	gtk_list_store_append(GTK_LIST_STORE(pd->ftd.lstore), &iter);
> 	set_filetype_strarr_in_list(&iter, strarr,pd);
> 	pd->lists[filetypes] = g_list_append(pd->lists[filetypes], strarr);
> 	pd->ftd.insertloc = -1;
> }
> static void delete_filetype_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	pref_delete_strarr(pd, &pd->ftd, 7);
> }
> 
> static void create_filetype_gui(Tprefdialog *pd, GtkWidget *vbox1) {
> 	GtkWidget *hbox, *but, *scrolwin;
> 	pd->lists[filetypes] = duplicate_arraylist(main_v->props.filetypes);
> 	pd->ftd.lstore = gtk_list_store_new (8,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_POINTER);
> 	pd->ftd.lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(pd->ftd.lstore));
> 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 1, G_CALLBACK(filetype_0_edited_lcb), pd, _("Label"), 0);
> 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 1, G_CALLBACK(filetype_1_edited_lcb), pd, _("Extensions"), 1);
> 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 1, G_CALLBACK(filetype_2_edited_lcb), pd, _("Update chars"), 2);
> 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 1, G_CALLBACK(filetype_3_edited_lcb), pd, _("Icon"), 3);
> 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 2, G_CALLBACK(filetype_4_toggled_lcb), pd, _("Editable"), 4);
> 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 1, G_CALLBACK(filetype_5_edited_lcb), pd, _("Content regex"), 5);
> 	pref_create_column(GTK_TREE_VIEW(pd->ftd.lview), 1, G_CALLBACK(filetype_6_edited_lcb), pd, _("Auto close tags mode"), 6);
> 
> 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin),GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
> 	gtk_container_add(GTK_CONTAINER(scrolwin), pd->ftd.lview);
> 	gtk_widget_set_size_request(scrolwin, 150, 190);
> 	gtk_box_pack_start(GTK_BOX(vbox1), scrolwin, TRUE, TRUE, 2);
> 	
> /*	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->ftd.lview));
> 	gtk_tree_selection_set_mode (select, GTK_SELECTION_SINGLE);
> 	g_signal_connect(G_OBJECT(select), "changed",G_CALLBACK(filetype_selection_changed_cb),pd);*/
> 	{
> 		GList *tmplist = g_list_first(pd->lists[filetypes]);
> 		while (tmplist) {
> 			gint arrcount;
> 			gchar **strarr = (gchar **)tmplist->data;
> 			arrcount = count_array(strarr);
> 			if (arrcount==7) {
> 				GtkTreeIter iter;
> 				gtk_list_store_append(GTK_LIST_STORE(pd->ftd.lstore), &iter);
> 				set_filetype_strarr_in_list(&iter, strarr,pd);
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	gtk_tree_view_set_reorderable(GTK_TREE_VIEW(pd->ftd.lview), TRUE);
> 	pd->ftd.thelist = &pd->lists[filetypes];
> 	pd->ftd.insertloc = -1;
> 	g_signal_connect(G_OBJECT(pd->ftd.lstore), "row-inserted", G_CALLBACK(listpref_row_inserted), &pd->ftd);
> 	g_signal_connect(G_OBJECT(pd->ftd.lstore), "row-deleted", G_CALLBACK(listpref_row_deleted), &pd->ftd);
> 
> 	hbox = gtk_hbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox1),hbox, TRUE, TRUE, 2);
> 	but = bf_gtkstock_button(GTK_STOCK_ADD, G_CALLBACK(add_new_filetype_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
> 	but = bf_gtkstock_button(GTK_STOCK_DELETE, G_CALLBACK(delete_filetype_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
> }
> /*
> static gchar **filefilter_create_strarr(Tprefdialog *pd) {
> 	gchar **strarr = g_malloc(4*sizeof(gchar *));
> 	strarr[0] = gtk_editable_get_chars(GTK_EDITABLE(pd->ffd.entry[0]), 0, -1);
> 	if (GTK_TOGGLE_BUTTON(pd->ffd.check)->active){
> 			strarr[1] = g_strdup("0");
> 		} else {
> 			strarr[1] = g_strdup("1");
> 		}
> 	strarr[2] = gtk_editable_get_chars(GTK_EDITABLE(pd->ffd.entry[1]), 0, -1);
> 	strarr[3] = NULL;
> 	return strarr;
> }
> 
> static void filefilter_apply_changes(Tprefdialog *pd) {
> 	DEBUG_MSG("filefilters_apply_changes, started\n");
> 	if (pd->ffd.curstrarr) {
> 		gchar **strarr;
> 		strarr = filefilter_create_strarr(pd);
> 		if (strarr) {
> 			GList *tmplist;
> 			GtkTreeIter iter;
> 			gboolean retval = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->ffd.lstore),&iter);
> 			while (retval) {
> 				gchar *curval;
> 				gtk_tree_model_get(GTK_TREE_MODEL(pd->ffd.lstore),&iter,0,&curval,-1);
> 				if (strcmp(curval,pd->ffd.curstrarr[0])==0) {
> 					gtk_list_store_set(GTK_LIST_STORE(pd->ffd.lstore), &iter
> 						,0,strarr[0]
> 						,1,(strarr[1][0] == '0')
> 						,2,strarr[2]
> 						,-1);
> 					DEBUG_MSG("filefilters_apply_changes, changed in tree model\n");
> 					break;
> 				}
> 				retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->ffd.lstore),&iter);
> 			}
> 
> 			tmplist = g_list_first(pd->lists[filefilters]);
> 			while (tmplist) {
> 				if (tmplist->data == pd->ffd.curstrarr) {
> 					g_strfreev(pd->ffd.curstrarr);
> 					tmplist->data = strarr;
> 					pd->ffd.curstrarr = strarr;
> 					DEBUG_MSG("filefilters_apply_changes, changed custrarr\n");
> 					break;
> 				}
> 				tmplist = g_list_next(tmplist);
> 			}
> 		} else {
> 			DEBUG_MSG("filefilters_apply_changes, NO strarr!!\n");
> 		}
> 	} else {
> 		DEBUG_MSG("filefilters_apply_changes, NO curstrarr!!\n");
> 	}
> }
> 
> static void add_new_filefilter_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	gchar **strarr;
> 	strarr = filefilter_create_strarr(pd);
> 	if (strarr) {
> 		GtkTreeIter iter;
> 		pd->lists[filefilters] = g_list_append(pd->lists[filefilters], strarr);
> 		gtk_list_store_append(GTK_LIST_STORE(pd->ffd.lstore), &iter);
> 		gtk_list_store_set(GTK_LIST_STORE(pd->ffd.lstore), &iter
> 				,0,strarr[0]
> 				,1,(strarr[1][0]=='0')
> 				,2,strarr[2]
> 				,-1);
> 	}
> }
> static void filefilter_selection_changed_cb(GtkTreeSelection *selection, Tprefdialog *pd) {
> 	GtkTreeIter iter;
> 	GtkTreeModel *model;
> 	DEBUG_MSG("filefilter_selection_changed_cb, curstrarr=%p, &curstrarr=%p\n", pd->ftd.curstrarr, &pd->ffd.curstrarr);
> 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
> 		gchar *filefilter;
> 		GList *tmplist = g_list_first(pd->lists[filefilters]);
> 		gtk_tree_model_get(model, &iter, 0, &filefilter, -1);
> 		filefilter_apply_changes(pd);
> 		while (tmplist) {
> 			gchar **strarr =(gchar **)tmplist->data;
> 			if (strcmp(strarr[0],filefilter)==0) {
> 				gtk_entry_set_text(GTK_ENTRY(pd->ffd.entry[0]), strarr[0]);
> 				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->ffd.check), (strarr[1][0] == '0'));
> 				gtk_entry_set_text(GTK_ENTRY(pd->ffd.entry[1]), strarr[2]);
> 				pd->ffd.curstrarr = strarr;
> 				DEBUG_MSG("filefilter_selection_changed_cb, found %s, curstrarr=%p\n", filefilter, strarr);
> 				return;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		DEBUG_MSG("filefilter_selection_changed_cb, could not find the selected text %s\n", filefilter);
> 	} else {
> 		DEBUG_MSG("filefilter_selection_changed_cb, no selection ?!?!\n");
> 	}
> }*/
> static void set_filefilter_strarr_in_list(GtkTreeIter *iter, gchar **strarr, Tprefdialog *pd) {
> 	gint arrcount;
> 	arrcount = count_array(strarr);
> 	if (arrcount==3) {
> 		gtk_list_store_set(GTK_LIST_STORE(pd->ffd.lstore), iter
> 				,0,strarr[0],1,(strarr[1][0] != '0'),2,strarr[2],3,strarr,-1);
> 	} else {
> 		DEBUG_MSG("ERROR: set_filefilter_strarr_in_list, arraycount != 3 !!!!!!\n");
> 	}
> }
> static void filefilter_apply_change(Tprefdialog *pd, gint type, gchar *path, gchar *newval, gint index) {
> 	DEBUG_MSG("filefilter_apply_change,lstore=%p,path=%s,newval=%s,index=%d\n",pd->ffd.lstore,path,newval,index);
> 	pref_apply_change(pd->ffd.lstore,3,type,path,newval,index);
> }
> static void filefilter_0_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	filefilter_apply_change(pd, 1, path, newtext, 0);
> }
> static void filefilter_1_toggled_lcb(GtkCellRendererToggle *cellrenderertoggle,gchar *path,Tprefdialog *pd) {
> 	gchar *val = g_strdup(cellrenderertoggle->active ? "0" : "1");
> 	filefilter_apply_change(pd, 2, path, val, 1);
> 	g_free(val);
> }
> static void filefilter_2_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	filefilter_apply_change(pd, 1, path, newtext, 2);
> }
> static void add_new_filefilter_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	gchar **strarr;
> 	GtkTreeIter iter;
> 	strarr = pref_create_empty_strarr(3);
> 	gtk_list_store_append(GTK_LIST_STORE(pd->ffd.lstore), &iter);
> 	set_filefilter_strarr_in_list(&iter, strarr,pd);
> 	pd->lists[filefilters] = g_list_append(pd->lists[filefilters], strarr);
> 	pd->ffd.insertloc = -1;
> }
> 
> static void delete_filefilter_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	pref_delete_strarr(pd, &pd->ffd, 3);
> }
> static void create_filefilter_gui(Tprefdialog *pd, GtkWidget *vbox1) {
> 	GtkWidget *hbox, *but, *scrolwin;
> 	pd->lists[filefilters] = duplicate_arraylist(main_v->props.filefilters);
> 	pd->ffd.lstore = gtk_list_store_new (4,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_STRING,G_TYPE_POINTER);
> 	pd->ffd.lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(pd->ffd.lstore));
> 	pref_create_column(GTK_TREE_VIEW(pd->ffd.lview), 1, G_CALLBACK(filefilter_0_edited_lcb), pd, _("Label"), 0);
> 	pref_create_column(GTK_TREE_VIEW(pd->ffd.lview), 2, G_CALLBACK(filefilter_1_toggled_lcb), pd, _("Inverse filter"), 1);
> 	pref_create_column(GTK_TREE_VIEW(pd->ffd.lview), 1, G_CALLBACK(filefilter_2_edited_lcb), pd, _("Filetypes in filter"), 2);
> 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin),GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
> 	gtk_container_add(GTK_CONTAINER(scrolwin), pd->ffd.lview);
> 	gtk_widget_set_size_request(scrolwin, 150, 190);
> 	gtk_box_pack_start(GTK_BOX(vbox1), scrolwin, TRUE, TRUE, 2);
> 	{
> 		GList *tmplist = g_list_first(pd->lists[filefilters]);
> 		while (tmplist) {
> 			gchar **strarr = (gchar **)tmplist->data;
> 			if (count_array(strarr)==3) {
> 				GtkTreeIter iter;
> 				gtk_list_store_append(GTK_LIST_STORE(pd->ffd.lstore), &iter);
> 				set_filefilter_strarr_in_list(&iter, strarr,pd);
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	gtk_tree_view_set_reorderable(GTK_TREE_VIEW(pd->ffd.lview), TRUE);
> 	pd->ffd.thelist = &pd->lists[filefilters];
> 	pd->ffd.insertloc = -1;
> 	g_signal_connect(G_OBJECT(pd->ffd.lstore), "row-inserted", G_CALLBACK(listpref_row_inserted), &pd->ffd);
> 	g_signal_connect(G_OBJECT(pd->ffd.lstore), "row-deleted", G_CALLBACK(listpref_row_deleted), &pd->ffd);
> 
> 	hbox = gtk_hbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox1),hbox, TRUE, TRUE, 2);
> 	but = bf_gtkstock_button(GTK_STOCK_ADD, G_CALLBACK(add_new_filefilter_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
> 	but = bf_gtkstock_button(GTK_STOCK_DELETE, G_CALLBACK(delete_filefilter_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);	
> }
> 
> static gchar **highlightpattern_create_strarr(Tprefdialog *pd) {
> 	gchar **strarr;
> 	strarr = g_malloc(12*sizeof(gchar *));
> 	strarr[0] = g_strdup(pd->hpd.selected_filetype);
> 	strarr[1] = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[0]),0,-1);
> 	DEBUG_MSG("highlightpattern_create_strarr for %s-%s at %p\n",strarr[0],strarr[1],strarr);
> 	if (GTK_TOGGLE_BUTTON(pd->hpd.check)->active){
> 		strarr[2] = g_strdup("0");
> 	} else {
> 		strarr[2] = g_strdup("1");
> 	}
> 	strarr[3] = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[1]),0,-1);
> 	strarr[4] = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[2]),0,-1);
> 	if (GTK_TOGGLE_BUTTON(pd->hpd.radio[0])->active){
> 		strarr[5] = g_strdup("1");
> 	} else if (GTK_TOGGLE_BUTTON(pd->hpd.radio[1])->active) {
> 		strarr[5] = g_strdup("2");
> 	} else {
> 		strarr[5] = g_strdup("3");
> 	}
> 	strarr[6] = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[3]),0,-1);
> 	strarr[7] = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[4]),0,-1);
> 	strarr[8] = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[5]),0,-1);
> 	if (GTK_TOGGLE_BUTTON(pd->hpd.radio[3])->active){
> 		strarr[9] = g_strdup("0");
> 	} else if (GTK_TOGGLE_BUTTON(pd->hpd.radio[4])->active) {
> 		strarr[9] = g_strdup("1");
> 	} else {
> 		strarr[9] = g_strdup("2");
> 	}
> 	if (GTK_TOGGLE_BUTTON(pd->hpd.radio[6])->active){
> 		strarr[10] = g_strdup("0");
> 	} else if (GTK_TOGGLE_BUTTON(pd->hpd.radio[7])->active) {
> 		strarr[10] = g_strdup("1");
> 	} else {
> 		strarr[10] = g_strdup("2");
> 	}
> 	strarr[11] = NULL;
> 	DEBUG_MSG("highlightpattern_create_strarr, strarr at %p with count %d\n", strarr, count_array(strarr));
> 	return strarr;
> }
> 
> static void highlightpattern_apply_changes(Tprefdialog *pd) {
> 	DEBUG_MSG("highlightpattern_apply_changes, started\n");
> 	if (pd->hpd.curstrarr) {
> 		GList *tmplist;
> 		tmplist = g_list_first(pd->lists[highlight_patterns]);
> 		while (tmplist) {
> 			if (tmplist->data == pd->hpd.curstrarr) {
> 				DEBUG_MSG("highlightpattern_apply_changes, curstrarr==tmplist->data==%p\n", tmplist->data);
> 				g_strfreev(tmplist->data);
> 				tmplist->data = highlightpattern_create_strarr(pd);
> 				pd->hpd.curstrarr = tmplist->data;
> 				DEBUG_MSG("highlightpattern_apply_changes, new strarr for %s-%s\n",pd->hpd.curstrarr[0],pd->hpd.curstrarr[1]);
> 				return;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		DEBUG_MSG("highlightpattern_apply_changes, nothing found for curstrarr %p?!?\n", pd->hpd.curstrarr);
> 	}
> 	DEBUG_MSG("highlightpattern_apply_changes, no curstrarr, nothing to apply\n");
> }
> 
> static void highlightpattern_fill_from_selected_filetype(Tprefdialog *pd) {
> 	DEBUG_MSG("highlightpattern_popmenu_activate, applied changes, about to clear liststore\n");
> 	gtk_list_store_clear(GTK_LIST_STORE(pd->hpd.lstore));
> 	if (pd->hpd.selected_filetype) {
> 		GList *tmplist;
> 		tmplist = g_list_first(pd->lists[highlight_patterns]);
> 		DEBUG_MSG("highlightpattern_popmenu_activate, about to fill for filetype %s (tmplist=%p)\n",pd->hpd.selected_filetype,tmplist);
> 		/* fill list model here */
> 		while (tmplist) {
> 			gchar **strarr =(gchar **)tmplist->data;
> 			if (count_array(strarr) ==11 && strarr[0]) {
> 				DEBUG_MSG("found entry with filetype %s\n",strarr[0]);
> 				if (strcmp(strarr[0], pd->hpd.selected_filetype)==0) {
> 					GtkTreeIter iter;
> 					DEBUG_MSG("highlightpattern_popmenu_activate, appending pattern %s with filetype %s\n",strarr[1],strarr[0]);
> 					gtk_list_store_append(GTK_LIST_STORE(pd->hpd.lstore), &iter);
> 					gtk_list_store_set(GTK_LIST_STORE(pd->hpd.lstore), &iter, 0, strarr[1], -1);
> 				}
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	pd->hpd.curstrarr = NULL;
> 	gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[0]), "");
> 	gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[1]), "");
> 	gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[2]), "");
> 	gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[3]), "");
> 	gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[4]), "");
> 	gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[5]), "");
> 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.check), FALSE);
> 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[0]),TRUE);
> 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[3]),TRUE);
> 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[6]),TRUE);
> }
> 
> static void highlightpattern_popmenu_activate(GtkMenuItem *menuitem,Tprefdialog *pd) {
> 	DEBUG_MSG("highlightpattern_popmenu_activate, pd=%p, menuitem=%p\n", pd, menuitem);
> 	highlightpattern_apply_changes(pd);
> 	pd->hpd.curstrarr = NULL;
> 	if (menuitem) {
> 		pd->hpd.selected_filetype = gtk_label_get_text(GTK_LABEL(GTK_BIN(menuitem)->child));
> 	}
> 	highlightpattern_fill_from_selected_filetype(pd);
> }
> 
> static void add_new_highlightpattern_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	gchar *pattern = gtk_editable_get_chars(GTK_EDITABLE(pd->hpd.entry[0]),0,-1);
> 	if (pattern && pd->hpd.selected_filetype && strlen(pattern) && strlen(pd->hpd.selected_filetype)) {
> 		gchar **strarr = highlightpattern_create_strarr(pd);
> 		DEBUG_MSG("add_new_highlightpattern_lcb, appending strarr %p to list\n", strarr);
> 		pd->lists[highlight_patterns] = g_list_append(pd->lists[highlight_patterns], strarr);
> 		pd->hpd.curstrarr = NULL;
> 		{
> 			GtkTreeIter iter;
> 			GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->hpd.lview));
> 			DEBUG_MSG("add_new_highlightpattern_lcb, appending to lview\n");
> 			gtk_list_store_append(GTK_LIST_STORE(pd->hpd.lstore), &iter);
> 			gtk_list_store_set(GTK_LIST_STORE(pd->hpd.lstore), &iter, 0, strarr[1], -1);
> 			gtk_tree_selection_select_iter(selection,&iter);
> 		}
> /*		gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[0]), "");*/
> 	} else {
> 		g_free(pattern);
> 	}
> }
> 
> static void highlightpattern_selection_changed_cb(GtkTreeSelection *selection, Tprefdialog *pd) {
> 	GtkTreeIter iter;
> 	GtkTreeModel *model;
> 	DEBUG_MSG("highlightpattern_selection_changed_cb, started\n");
> 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
> 		gchar *pattern;
> 		GList *tmplist = g_list_first(pd->lists[highlight_patterns]);
> /*		GtkWidget *menuitem = gtk_menu_get_active(GTK_MENU( gtk_option_menu_get_menu(GTK_OPTION_MENU(pd->hpd.popmenu)) ));*/
> 		gtk_tree_model_get(model, &iter, 0, &pattern, -1);
> 		DEBUG_MSG("highlightpattern_selection_changed_cb, selected=%s\n",pattern);
> 		highlightpattern_apply_changes(pd);
> 		pd->hpd.curstrarr = NULL;
> 		DEBUG_MSG("changed applied, searching for the data of the new selection\n");
> 		while (tmplist) {
> 			gchar **strarr =(gchar **)tmplist->data;
> #ifdef DEBUG
> 			if (strarr == NULL){
> 				DEBUG_MSG("strarr== NULL !!!!!!!!!!!!!!!\n");
> 			}
> #endif
> 			if (strcmp(strarr[1], pattern)==0 && strcmp(strarr[0], pd->hpd.selected_filetype)==0) {
> 				DEBUG_MSG("highlightpattern_selection_changed_cb, found strarr=%p\n", strarr);
> 				DEBUG_MSG("0=%s, 1=%s, 2=%s, 3=%s, 4=%s\n",strarr[0],strarr[1],strarr[2],strarr[3],strarr[4]);
> 				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.check), (strarr[2][0] == '0'));
> 				gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[0]), strarr[1]);
> 				gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[1]), strarr[3]);
> 				gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[2]), strarr[4]);
> 				if (strarr[5][0] == '3') {
> 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[2]),TRUE);
> 				} else if (strarr[5][0] == '2') {
> 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[1]),TRUE);
> 				} else {
> 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[0]),TRUE);
> 				}
> 				gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[3]), strarr[6]);
> 				gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[4]), strarr[7]);
> 				gtk_entry_set_text(GTK_ENTRY(pd->hpd.entry[5]), strarr[8]);
> 				if (strarr[9][0] == '2') {
> 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[5]),TRUE);
> 				} else if (strarr[9][0] == '1') {
> 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[4]),TRUE);
> 				} else {
> 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[3]),TRUE);
> 				}
> 				DEBUG_MSG("strarr[10]=%s, \n",strarr[10]);
> 				if (strarr[10][0] == '2') {
> 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[8]),TRUE);
> 				} else if (strarr[10][0] == '1') {
> 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[7]),TRUE);
> 				} else {
> 					gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->hpd.radio[6]),TRUE);
> 				}
> 				pd->hpd.curstrarr = strarr;
> 				break;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		g_free(pattern);
> 	} else {
> 		DEBUG_MSG("no selection, returning..\n");
> 	}
> }
> static void highlightpattern_type_toggled(GtkToggleButton *togglebutton,Tprefdialog *pd){
> 	DEBUG_MSG("highlightpattern_type_toggled, started\n");
> 	if (GTK_TOGGLE_BUTTON(pd->hpd.radio[0])->active) {
> 		gtk_widget_set_sensitive(pd->hpd.entry[2], TRUE);
> 	} else {
> 		gtk_widget_set_sensitive(pd->hpd.entry[2], FALSE);
> 	}
> 	DEBUG_MSG("highlightpattern_type_toggled, done\n");
> }
> static void highlightpattern_up_clicked_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	GtkTreeIter iter;
> 	GtkTreeModel *model;
> 	gchar *pattern;
> 
> 	GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->hpd.lview));
> 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
> 		GList *previous=NULL, *tmplist = g_list_first(pd->lists[highlight_patterns]);
> 		gtk_tree_model_get(model, &iter, 0, &pattern, -1);
> 		DEBUG_MSG("highlightpattern_up_clicked_lcb, selected=%s\n",pattern);
> 		while (tmplist) {
> 			gchar **strarr =(gchar **)tmplist->data;
> 			if (strcmp(strarr[0], pd->hpd.selected_filetype)==0) {
> 				DEBUG_MSG("highlightpattern_up_clicked_lcb, comparing %s+%s for filetype %s\n",strarr[1], pattern,pd->hpd.selected_filetype);
> 				if (strcmp(strarr[1], pattern)==0) {
> 					DEBUG_MSG("highlightpattern_up_clicked_lcb, found %s, previous=%p, tmplist=%p\n",strarr[1],previous,tmplist);
> 					if (previous) {
> 						DEBUG_MSG("highlightpattern_up_clicked_lcb, switch list order %s <-> %s\n",((gchar **)tmplist->data)[1], ((gchar **)previous->data)[1]);
> 						list_switch_order(tmplist, previous);
> 						highlightpattern_popmenu_activate(NULL, pd);
> 					}
> 					return;
> 				}
> 				previous = tmplist;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> }
> static void highlightpattern_down_clicked_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	GtkTreeIter iter;
> 	GtkTreeModel *model;
> 	gchar *pattern;
> 	GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->hpd.lview));
> 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
> 		GList *tmplist = g_list_first(pd->lists[highlight_patterns]);
> 		gtk_tree_model_get(model, &iter, 0, &pattern, -1);
> 		while (tmplist) {
> 			gchar **strarr =(gchar **)tmplist->data;
> 			if (strcmp(strarr[1], pattern)==0 && strcmp(strarr[0], pd->hpd.selected_filetype)==0) {
> 				if (tmplist->next) {
> 					list_switch_order(tmplist, tmplist->next);
> 					highlightpattern_popmenu_activate(NULL, pd);
> 					return;
> 				}
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> }
> static void highlightpattern_delete_clicked_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	GtkTreeIter iter;
> 	GtkTreeModel *model;
> 	gchar *pattern;
> 	GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->hpd.lview));
> 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
> 		GList *tmplist = g_list_first(pd->lists[highlight_patterns]);
> 		gtk_tree_model_get(model, &iter, 0, &pattern, -1);
> 		while (tmplist) {
> 			gchar **strarr =(gchar **)tmplist->data;
> 			if (strcmp(strarr[1], pattern)==0 && strcmp(strarr[0], pd->hpd.selected_filetype)==0) {
> 				pd->hpd.curstrarr = NULL;
> 				pd->lists[highlight_patterns] = g_list_remove(pd->lists[highlight_patterns], strarr);
> 				g_strfreev(strarr);
> 				highlightpattern_popmenu_activate(NULL, pd);
> 				return;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> }
> 
> static void highlightpattern_gui_rebuild_filetype_popup(Tprefdialog *pd) {
> 	GList *tmplist;
> 	GtkWidget *menu, *menuitem;
> 	gtk_option_menu_remove_menu(GTK_OPTION_MENU(pd->hpd.popmenu));
> 	menu = gtk_menu_new();
> 	gtk_option_menu_set_menu(GTK_OPTION_MENU(pd->hpd.popmenu), menu);
> 	gtk_widget_show(menu);
> 	tmplist = g_list_first(pd->lists[filetypes]);
> 	while (tmplist) {
> 		gchar **arr = (gchar **)tmplist->data;
> 		if (count_array(arr)>=3) {
> 			if (strcmp(arr[0], "objectfile") != 0 && strcmp(arr[0], "webimage") != 0 
> 				&& strcmp(arr[0], "image") != 0 && strcmp(arr[0], "bfproject") != 0) {				
> 				
> 				menuitem = gtk_menu_item_new_with_label(arr[0]);
> 				DEBUG_MSG("highlightpattern_gui_rebuild_filetype_popup, menuitem=%p for %s\n", menuitem, arr[0]);
> 				g_signal_connect(GTK_OBJECT(menuitem), "activate",G_CALLBACK(highlightpattern_popmenu_activate),pd);
> 				gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
> 				gtk_widget_show(menuitem);
> 			}
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> static void highlightpattern_reset_clicked_lcb(GtkWidget *button, Tprefdialog *pd) {
> 	gchar *defaultfile = return_first_existing_filename(PKGDATADIR"highlighting.default",
> 									"data/highlighting.default",
> 									"../data/highlighting.default",NULL);
> 	if (defaultfile) {
> 		/* get current selected filetype && create array to compare to*/
> 		gchar **compare = array_from_arglist(pd->hpd.selected_filetype, NULL);
> 		DEBUG_MSG("highlightpattern_reset_clicked_lcb, defaultfile=%s\n",defaultfile);
> 		/* delete filetype from arraylist */
> 		pd->lists[highlight_patterns] = arraylist_delete_identical(pd->lists[highlight_patterns], compare, 1, TRUE);
> 		/* load filetype from default file */
> 		pd->lists[highlight_patterns] = arraylist_append_identical_from_file(pd->lists[highlight_patterns], defaultfile, compare, 1, TRUE);
> 		g_strfreev(compare);
> 		/* re-load selected filetype in preferences gui */
> 		DEBUG_MSG("highlightpattern_reset_clicked_lcb, about to rebuild gui\n");
> 		highlightpattern_fill_from_selected_filetype(pd);
> 		g_free (defaultfile);
> 	}
> }
> 
> static void create_highlightpattern_gui(Tprefdialog *pd, GtkWidget *vbox1) {
> 	GtkWidget *hbox, *but, *vbox3;
> 	pd->lists[highlight_patterns] = duplicate_arraylist(main_v->props.highlight_patterns);
> 	
> 	DEBUG_MSG("create_highlightpattern_gui, pd=%p, pd->lists[highlight_patterns]=%p\n", pd, pd->lists[highlight_patterns]);
> 	hbox = gtk_hbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox1), hbox, FALSE, FALSE, 3);
> 
> 	gtk_box_pack_start(GTK_BOX(hbox),gtk_label_new(_("filetype")),FALSE, FALSE, 3);
> 	pd->hpd.popmenu = gtk_option_menu_new();
> 	gtk_option_menu_set_menu(GTK_OPTION_MENU(pd->hpd.popmenu), gtk_menu_new());
> 	highlightpattern_gui_rebuild_filetype_popup(pd);
> 	gtk_box_pack_start(GTK_BOX(hbox),pd->hpd.popmenu,TRUE, TRUE, 3);
> 	but = gtk_button_new_with_label(_("Reset"));
> 	g_signal_connect(G_OBJECT(but), "clicked", G_CALLBACK(highlightpattern_reset_clicked_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox),but,FALSE, FALSE, 3);
> 
> 	hbox = gtk_hbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox1), hbox, TRUE, TRUE, 3);
> 	pd->hpd.entry[0] = boxed_full_entry(_("Pattern name"), NULL, 500, hbox);
> 
> 	but = bf_gtkstock_button(GTK_STOCK_ADD, G_CALLBACK(add_new_highlightpattern_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, TRUE, 3);
> 	but = bf_gtkstock_button(GTK_STOCK_DELETE, G_CALLBACK(highlightpattern_delete_clicked_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, FALSE, 1);
> 	
> 	hbox = gtk_hbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox1), hbox, TRUE, TRUE, 0);
> 
> 	pd->hpd.lstore = gtk_list_store_new (1, G_TYPE_STRING);
> 	pd->hpd.lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(pd->hpd.lstore));
> 	{
> 		GtkTreeViewColumn *column;
> 		GtkWidget *scrolwin;
> 		GtkTreeSelection *select;
> 	   GtkCellRenderer *renderer = gtk_cell_renderer_text_new ();
> 
> 		column = gtk_tree_view_column_new_with_attributes (_("Pattern"), renderer,"text", 0,NULL);
> 		gtk_tree_view_append_column (GTK_TREE_VIEW(pd->hpd.lview), column);
> 		scrolwin = gtk_scrolled_window_new(NULL, NULL);
> 		gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
> 		gtk_container_add(GTK_CONTAINER(scrolwin), pd->hpd.lview);
> 		gtk_box_pack_start(GTK_BOX(hbox), scrolwin, FALSE, TRUE, 2);
> 		
> 		select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->hpd.lview));
> 		g_signal_connect(G_OBJECT(select), "changed",G_CALLBACK(highlightpattern_selection_changed_cb),pd);
> 	}
> 
> 	vbox3 = gtk_vbox_new(FALSE, 2);
> 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, FALSE, FALSE, 2);
> 	/* pack up and down buttons here */
> 
> 	but = bf_gtkstock_button(GTK_STOCK_GO_UP, G_CALLBACK(highlightpattern_up_clicked_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(vbox3), but, FALSE, FALSE, 1);
> 	but = bf_gtkstock_button(GTK_STOCK_GO_DOWN, G_CALLBACK(highlightpattern_down_clicked_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(vbox3), but, FALSE, FALSE, 1);
> 	
> 	vbox3 = gtk_vbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, TRUE, TRUE, 2);
> 
> 	pd->hpd.radio[0] = gtk_radio_button_new_with_label(NULL, _("Start pattern and end pattern"));
> 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[0], TRUE, TRUE, 0);
> 	pd->hpd.radio[1] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(pd->hpd.radio[0]), _("Only start pattern"));
> 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[1], TRUE, TRUE, 0);
> 	pd->hpd.radio[2] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(pd->hpd.radio[0]), _("Subpattern from parent"));
> 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[2], TRUE, TRUE, 0);
> 	g_signal_connect(G_OBJECT(pd->hpd.radio[0]), "toggled", G_CALLBACK(highlightpattern_type_toggled), pd);
> 	g_signal_connect(G_OBJECT(pd->hpd.radio[1]), "toggled", G_CALLBACK(highlightpattern_type_toggled), pd);
> 	g_signal_connect(G_OBJECT(pd->hpd.radio[2]), "toggled", G_CALLBACK(highlightpattern_type_toggled), pd);
> 
> 	pd->hpd.entry[1] = boxed_full_entry(_("Start pattern"), NULL, 4000, vbox3);
> 	pd->hpd.entry[2] = boxed_full_entry(_("End pattern"), NULL, 4000, vbox3);
> 	pd->hpd.check = boxed_checkbut_with_value(_("Case sensitive matching"), FALSE, vbox3);
> 	pd->hpd.entry[3] = boxed_full_entry(_("Parentmatch"), NULL, 300, vbox3);
> 	pd->hpd.entry[4] = prefs_string(_("Foreground color"), "", vbox3, pd, string_color);
> 	pd->hpd.entry[5] = prefs_string(_("Background color"), "", vbox3, pd, string_color);
> 
> 	hbox = gtk_hbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox1), hbox, TRUE, TRUE, 0);
> 	
> 	vbox3 = gtk_vbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, TRUE, TRUE, 0);
> 	
> 	pd->hpd.radio[3] = gtk_radio_button_new_with_label(NULL, _("don't change weight"));
> 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[3], TRUE, TRUE, 0);
> 	pd->hpd.radio[4] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(pd->hpd.radio[3]), _("force non-bold weight"));
> 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[4], TRUE, TRUE, 0);
> 	pd->hpd.radio[5] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(pd->hpd.radio[3]), _("force bold weight"));
> 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[5], TRUE, TRUE, 0);
> 
> 	vbox3 = gtk_vbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(hbox), vbox3, TRUE, TRUE, 0);
> 
> 	pd->hpd.radio[6] = gtk_radio_button_new_with_label(NULL, _("don't change style"));
> 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[6], TRUE, TRUE, 0);
> 	pd->hpd.radio[7] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(pd->hpd.radio[6]), _("force non-italic style"));
> 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[7], TRUE, TRUE, 0);
> 	pd->hpd.radio[8] = gtk_radio_button_new_with_label_from_widget(GTK_RADIO_BUTTON(pd->hpd.radio[6]), _("force italic style"));
> 	gtk_box_pack_start(GTK_BOX(vbox3),pd->hpd.radio[8], TRUE, TRUE, 0);
> }
> /*
> static gchar **browser_create_strarr(Tprefdialog *pd) {
> 	return generic_create_strarr(2, pd->bd.entry, TRUE);
> }
> 
> static void browsers_apply_changes(Tprefdialog *pd) {
> 	DEBUG_MSG("browsers_apply_changes, started\n");
> 	if (pd->bd.curstrarr) {
> 		gchar **strarr;
> 		strarr = browser_create_strarr(pd);
> 		if (strarr) {
> 			GList *tmplist;
> 			GtkTreeIter iter;
> 			gboolean retval = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->bd.lstore),&iter);
> 			while (retval) {
> 				gchar *curval;
> 				gtk_tree_model_get(GTK_TREE_MODEL(pd->bd.lstore),&iter,0,&curval,-1);
> 				if (strcmp(curval,pd->bd.curstrarr[0])==0) {
> 					gtk_list_store_set(GTK_LIST_STORE(pd->bd.lstore), &iter
> 						,0,strarr[0]
> 						,1,strarr[1]
> 						,-1);
> 					DEBUG_MSG("browsers_apply_changes, changed in tree model\n");
> 					break;
> 				}
> 				retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->bd.lstore),&iter);
> 			}
> 
> 			tmplist = g_list_first(pd->lists[browsers]);
> 			while (tmplist) {
> 				if (tmplist->data == pd->bd.curstrarr) {
> 					g_strfreev(pd->bd.curstrarr);
> 					tmplist->data = strarr;
> 					pd->bd.curstrarr = strarr;
> 					DEBUG_MSG("browsers_apply_changes, changed custrarr\n");
> 					break;
> 				}
> 				tmplist = g_list_next(tmplist);
> 			}
> 		} else {
> 			DEBUG_MSG("browsers_apply_changes, strarr=NULL!!\n");
> 		}
> 	} else {
> 		DEBUG_MSG("browsers_apply_changes, NO curstrarr!!\n");
> 	}
> }
> 
> static void add_new_browser_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	gchar **strarr;
> 	strarr = browser_create_strarr(pd);
> 	if (strarr) {
> 		GtkTreeIter iter;
> 		pd->lists[browsers] = g_list_append(pd->lists[browsers], strarr);
> 		gtk_list_store_append(GTK_LIST_STORE(pd->bd.lstore), &iter);
> 		gtk_list_store_set(GTK_LIST_STORE(pd->bd.lstore), &iter
> 				,0,strarr[0]
> 				,1,strarr[1]
> 				,-1);
> 	}
> }
> 
> static void delete_browser_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	if (pd->bd.curstrarr) {
> 		GtkTreeIter iter;
> 		gboolean retval= gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->bd.lstore),&iter);
> 		while (retval) {
> 			gchar *curval;
> 			gtk_tree_model_get(GTK_TREE_MODEL(pd->bd.lstore),&iter,0,&curval,-1);
> 			if (strcmp(curval,pd->bd.curstrarr[0])==0) {
> 				gtk_list_store_remove(GTK_LIST_STORE(pd->bd.lstore),&iter);
> 				break;
> 			}
> 			retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->bd.lstore),&iter);
> 		}
> 		pd->lists[browsers] = g_list_remove(pd->lists[browsers],pd->bd.curstrarr);
> 	}
> }
> 
> static void set_default_browser_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	if (pd->bd.curstrarr) {
> 		GtkTreeIter iter;
> 		gboolean retval=gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->bd.lstore),&iter);
> 		while (retval) {
> 			gchar *curval;
> 			gtk_tree_model_get(GTK_TREE_MODEL(pd->bd.lstore),&iter,0,&curval,-1);
> 			if (strcmp((char *)curval,pd->bd.curstrarr[0])==0) {
>                                 gtk_list_store_remove((pd->bd.lstore),&iter);
> 				break;
> 			}
> 			retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->bd.lstore),&iter);
> 		}
>                 gtk_list_store_insert((pd->bd.lstore),&iter,0); 
> 		gtk_list_store_set(GTK_LIST_STORE(pd->bd.lstore), &iter
> 						,0,pd->bd.curstrarr[0]
> 						,1,pd->bd.curstrarr[1]
> 						,-1);
> 		pd->lists[browsers] = g_list_remove(pd->lists[browsers],pd->bd.curstrarr);
> 		pd->lists[browsers] = g_list_insert(pd->lists[browsers],pd->bd.curstrarr,0);
> 	}
> }
> static void browser_selection_changed_cb(GtkTreeSelection *selection, Tprefdialog *pd) {
> 	DEBUG_MSG("browser_selection_changed_cb, curstrarr=%p, &curstrarr=%p\n", pd->ftd.curstrarr, &pd->bd.curstrarr);
> 	generic_selection_changed_cb(selection,pd->bd.entry,browsers_apply_changes,pd,browsers,2,&pd->bd.curstrarr);
> 	DEBUG_MSG("browser_selection_changed_cb, curstrarr=%p, &curstrarr=%p\n", pd->ftd.curstrarr, &pd->bd.curstrarr);
> }*/
> static void set_browser_strarr_in_list(GtkTreeIter *iter, gchar **strarr, Tprefdialog *pd) {
> 	gint arrcount = count_array(strarr);
> 	if (arrcount==2) {
> 		gtk_list_store_set(GTK_LIST_STORE(pd->bd.lstore), iter
> 				,0,strarr[0],1,strarr[1],2,strarr,-1);
> 	} else {
> 		DEBUG_MSG("ERROR: set_browser_strarr_in_list, arraycount != 2 !!!!!!\n");
> 	}
> }
> static void browser_apply_change(Tprefdialog *pd, gint type, gchar *path, gchar *newval, gint index) {
> 	pref_apply_change(pd->bd.lstore,2,type,path,newval,index);
> }
> static void browser_0_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	browser_apply_change(pd, 1, path, newtext, 0);
> }
> static void browser_1_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	browser_apply_change(pd, 1, path, newtext, 1);
> }
> static void add_new_browser_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	gchar **strarr;
> 	GtkTreeIter iter;
> 	strarr = pref_create_empty_strarr(2);
> 	gtk_list_store_append(GTK_LIST_STORE(pd->bd.lstore), &iter);
> 	set_browser_strarr_in_list(&iter, strarr,pd);
> 	pd->lists[browsers] = g_list_append(pd->lists[browsers], strarr);
> 	pd->bd.insertloc = -1;
> }
> static void delete_browser_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	pref_delete_strarr(pd, &pd->bd, 2);
> }
> static void create_browsers_gui(Tprefdialog *pd, GtkWidget *vbox1) {
> 	GtkWidget *hbox, *but, *scrolwin;
> 	pd->lists[browsers] = duplicate_arraylist(main_v->props.browsers);
> 	pd->bd.lstore = gtk_list_store_new (3,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_POINTER);
> 	pd->bd.lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(pd->bd.lstore));
> 	pref_create_column(GTK_TREE_VIEW(pd->bd.lview), 1, G_CALLBACK(browser_0_edited_lcb), pd, _("Label"), 0);
> 	pref_create_column(GTK_TREE_VIEW(pd->bd.lview), 1, G_CALLBACK(browser_1_edited_lcb), pd, _("Command"), 1);
> 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin),GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
> 	gtk_container_add(GTK_CONTAINER(scrolwin), pd->bd.lview);
> 	gtk_widget_set_size_request(scrolwin, 150, 190);
> 	gtk_box_pack_start(GTK_BOX(vbox1), scrolwin, TRUE, TRUE, 2);
> 	{
> 		GList *tmplist = g_list_first(pd->lists[browsers]);
> 		while (tmplist) {
> 			gchar **strarr = (gchar **)tmplist->data;
> 			GtkTreeIter iter;
> 			gtk_list_store_append(GTK_LIST_STORE(pd->bd.lstore), &iter);
> 			set_browser_strarr_in_list(&iter, strarr,pd);
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	gtk_tree_view_set_reorderable(GTK_TREE_VIEW(pd->bd.lview), TRUE);
> 	pd->bd.thelist = &pd->lists[browsers];
> 	pd->bd.insertloc = -1;
> 	g_signal_connect(G_OBJECT(pd->bd.lstore), "row-inserted", G_CALLBACK(listpref_row_inserted), &pd->bd);
> 	g_signal_connect(G_OBJECT(pd->bd.lstore), "row-deleted", G_CALLBACK(listpref_row_deleted), &pd->bd);
> 
> 	hbox = gtk_hbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox1),hbox, TRUE, TRUE, 2);
> 	but = bf_gtkstock_button(GTK_STOCK_ADD, G_CALLBACK(add_new_browser_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
> 	but = bf_gtkstock_button(GTK_STOCK_DELETE, G_CALLBACK(delete_browser_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);	
> }
> /*
> static gchar **external_create_strarr(Tprefdialog *pd) {
> 	return generic_create_strarr(2, pd->ed.entry, TRUE);
> }
> 
> static void externals_apply_changes(Tprefdialog *pd) {
> 	DEBUG_MSG("externals_apply_changes, started\n");
> 	if (pd->ed.curstrarr) {
> 		gchar **strarr;
> 		strarr = external_create_strarr(pd);
> 		if (strarr) {
> 			GList *tmplist;
> 			GtkTreeIter iter;
> 			gboolean retval = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->ed.lstore),&iter);
> 			while (retval) {
> 				gchar *curval;
> 				gtk_tree_model_get(GTK_TREE_MODEL(pd->ed.lstore),&iter,0,&curval,-1);
> 				if (strcmp(curval,pd->ed.curstrarr[0])==0) {
> 					gtk_list_store_set(GTK_LIST_STORE(pd->ed.lstore), &iter
> 						,0,strarr[0]
> 						,1,strarr[1]
> 						,-1);
> 					DEBUG_MSG("externals_apply_changes, changed in tree model\n");
> 					break;
> 				}
> 				retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->ed.lstore),&iter);
> 			}
> 
> 			tmplist = g_list_first(pd->lists[external_commands]);
> 			while (tmplist) {
> 				if (tmplist->data == pd->ed.curstrarr) {
> 					g_strfreev(pd->ed.curstrarr);
> 					tmplist->data = strarr;
> 					pd->ed.curstrarr = strarr;
> 					DEBUG_MSG("externals_apply_changes, changed custrarr\n");
> 					break;
> 				}
> 				tmplist = g_list_next(tmplist);
> 			}
> 		} else {
> 			DEBUG_MSG("externals_apply_changes, NO strarr!!\n");
> 		}
> 	} else {
> 		DEBUG_MSG("externals_apply_changes, NO curstrarr!!\n");
> 	}
> }
> 
> static void external_selection_changed_cb(GtkTreeSelection *selection, Tprefdialog *pd) {
> 	DEBUG_MSG("external_selection_changed_cb, started\n");
> 	generic_selection_changed_cb(selection,pd->ed.entry,externals_apply_changes,pd,external_commands,2,&pd->ed.curstrarr);
> }
> 
> static void add_new_external_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	gchar **strarr;
> 	strarr = external_create_strarr(pd);
> 	if (strarr) {
> 		GtkTreeIter iter;
> 		pd->lists[external_commands] = g_list_append(pd->lists[external_commands], strarr);
> 		gtk_list_store_append(GTK_LIST_STORE(pd->ed.lstore), &iter);
> 		gtk_list_store_set(GTK_LIST_STORE(pd->ed.lstore), &iter
> 				,0,strarr[0]
> 				,1,strarr[1]
> 				,-1);
> 	}
> }
> 
> static void delete_external_commands_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	GtkTreeSelection *select;
> 	GtkTreeIter iter;
> 	gboolean retval;
> 
> 	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->ed.lview));
> 	retval = gtk_tree_selection_get_selected (select,NULL,&iter);
> 	if(retval) {
> 		gchar *curval;
> 		GList *work = NULL;
> 		gchar **curstrarr;
> 		
> 		gtk_tree_model_get(GTK_TREE_MODEL(pd->ed.lstore),&iter,0,&curval,-1);
> 		gtk_list_store_remove(pd->ed.lstore,&iter);
> 		work = pd->lists[external_commands];
> 		while(work) {
> 			curstrarr = work->data;
> 			if (strcmp(curval,curstrarr[0])==0) {
> 				pd->lists[external_commands] = g_list_remove(pd->lists[external_commands],curstrarr);
> 				break;
> 			}
> 			work = g_list_next(work);
> 		}
> 		g_free(curval);
> 	}
> }*/
> 
> static void set_external_commands_strarr_in_list(GtkTreeIter *iter, gchar **strarr, Tprefdialog *pd) {
> 	gint arrcount = count_array(strarr);
> 	if (arrcount==2) {
> 		gtk_list_store_set(GTK_LIST_STORE(pd->ed.lstore), iter
> 				,0,strarr[0],1,strarr[1],2,strarr,-1);
> 	} else {
> 		DEBUG_MSG("ERROR: set_external_command_strarr_in_list, arraycount != 2 !!!!!!\n");
> 	}
> }
> static void external_commands_apply_change(Tprefdialog *pd, gint type, gchar *path, gchar *newval, gint index) {
> 	pref_apply_change(pd->ed.lstore,2,type,path,newval,index);
> }
> static void external_commands_0_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	external_commands_apply_change(pd, 1, path, newtext, 0);
> }
> static void external_commands_1_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	external_commands_apply_change(pd, 1, path, newtext, 1);
> }
> static void add_new_external_commands_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	gchar **strarr;
> 	GtkTreeIter iter;
> 	strarr = pref_create_empty_strarr(2);
> 	gtk_list_store_append(GTK_LIST_STORE(pd->ed.lstore), &iter);
> 	set_external_commands_strarr_in_list(&iter, strarr,pd);
> 	pd->lists[external_commands] = g_list_append(pd->lists[external_commands], strarr);
> 	pd->ed.insertloc = -1;
> }
> static void delete_external_commands_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	pref_delete_strarr(pd, &pd->ed, 2);
> }
> static void create_externals_gui(Tprefdialog *pd, GtkWidget *vbox1) {
> 	GtkWidget *hbox, *but, *scrolwin;
> 	pd->lists[external_commands] = duplicate_arraylist(main_v->props.external_commands);
> 	pd->ed.lstore = gtk_list_store_new (3,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_POINTER);
> 	pd->ed.lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(pd->ed.lstore));
> 	pref_create_column(GTK_TREE_VIEW(pd->ed.lview), 1, G_CALLBACK(external_commands_0_edited_lcb), pd, _("Label"), 0);
> 	pref_create_column(GTK_TREE_VIEW(pd->ed.lview), 1, G_CALLBACK(external_commands_1_edited_lcb), pd, _("Command"), 1);
> 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin),GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
> 	gtk_container_add(GTK_CONTAINER(scrolwin), pd->ed.lview);
> 	gtk_widget_set_size_request(scrolwin, 120, 190);
> 	gtk_box_pack_start(GTK_BOX(vbox1), scrolwin, TRUE, TRUE, 2);
> 	{
> 		GList *tmplist = g_list_first(pd->lists[external_commands]);
> 		while (tmplist) {
> 			gchar **strarr = (gchar **)tmplist->data;
> 			GtkTreeIter iter;
> 			gtk_list_store_append(GTK_LIST_STORE(pd->ed.lstore), &iter);
> 			set_external_commands_strarr_in_list(&iter, strarr,pd);
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	gtk_tree_view_set_reorderable(GTK_TREE_VIEW(pd->ed.lview), TRUE);
> 	pd->ed.thelist = &pd->lists[external_commands];
> 	pd->ed.insertloc = -1;
> 	g_signal_connect(G_OBJECT(pd->ed.lstore), "row-inserted", G_CALLBACK(listpref_row_inserted), &pd->ed);
> 	g_signal_connect(G_OBJECT(pd->ed.lstore), "row-deleted", G_CALLBACK(listpref_row_deleted), &pd->ed);
> 	gtk_box_pack_start(GTK_BOX(vbox1),gtk_label_new(_("%s for current filename (any command)\n%i for input and %f for output filename (filters)")), TRUE, TRUE, 2);
> 	hbox = gtk_hbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox1),hbox, TRUE, TRUE, 2);
> 	but = bf_gtkstock_button(GTK_STOCK_ADD, G_CALLBACK(add_new_external_commands_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
> 	but = bf_gtkstock_button(GTK_STOCK_DELETE, G_CALLBACK(delete_external_commands_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);	
> }
> /*
> static gchar **outputbox_create_strarr(Tprefdialog *pd) {
> 	gchar **strarr = g_malloc(8*sizeof(gchar *));
> 	strarr[0] = gtk_editable_get_chars(GTK_EDITABLE(pd->od.entry[0]), 0, -1);
> 	strarr[1] = gtk_editable_get_chars(GTK_EDITABLE(pd->od.entry[1]), 0, -1);
> 	strarr[2] = gtk_editable_get_chars(GTK_EDITABLE(pd->od.entry[2]), 0, -1);
> 	strarr[3] = gtk_editable_get_chars(GTK_EDITABLE(pd->od.entry[3]), 0, -1);
> 	strarr[4] = gtk_editable_get_chars(GTK_EDITABLE(pd->od.entry[4]), 0, -1);
> 	strarr[5] = gtk_editable_get_chars(GTK_EDITABLE(pd->od.entry[5]), 0, -1);
> 	strarr[6] = g_strdup((GTK_TOGGLE_BUTTON(pd->od.check)->active) ? "1" : "0");
> 	strarr[7] = NULL;
> 	return strarr;
> }
> static void outputbox_apply_changes(Tprefdialog *pd) {
> 	if (pd->od.curstrarr) {
> 		gchar **strarr;
> 		strarr = outputbox_create_strarr(pd);
> 		if (strarr) {
> 			GList *tmplist;
> 			GtkTreeIter iter;
> 			gboolean retval = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(pd->od.lstore),&iter);
> 			while (retval) {
> 				gchar *curval;
> 				gtk_tree_model_get(GTK_TREE_MODEL(pd->od.lstore),&iter,0,&curval,-1);
> 				if (strcmp(curval,pd->od.curstrarr[0])==0) {
> 					gtk_list_store_set(GTK_LIST_STORE(pd->od.lstore), &iter
> 						,0,strarr[0]
> 						,1,strarr[1]
> 						,2,strarr[2]
> 						,3,strarr[3]
> 						,4,strarr[4]
> 						,5,strarr[5]
> 						,6,strarr[6]
> 						,-1);
> 					break;
> 				}
> 				retval = gtk_tree_model_iter_next(GTK_TREE_MODEL(pd->od.lstore),&iter);
> 			}
> 
> 			tmplist = g_list_first(pd->lists[outputbox]);
> 			while (tmplist) {
> 				if (tmplist->data == pd->od.curstrarr) {
> 					g_strfreev(pd->od.curstrarr);
> 					tmplist->data = strarr;
> 					pd->od.curstrarr = strarr;
> 					break;
> 				}
> 				tmplist = g_list_next(tmplist);
> 			}
> 		} else {
> 			DEBUG_MSG("outputbox_apply_changes, NO strarr!!\n");
> 		}
> 	} else {
> 		DEBUG_MSG("outputbox_apply_changes, NO curstrarr!!\n");
> 	}
> }	
> static void add_new_outputbox_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	gchar **strarr;
> 	strarr = outputbox_create_strarr(pd);
> 	if (strarr) {
> 		GtkTreeIter iter;
> 		pd->lists[outputbox] = g_list_append(pd->lists[outputbox], strarr);
> 		gtk_list_store_append(GTK_LIST_STORE(pd->od.lstore), &iter);
> 		gtk_list_store_set(GTK_LIST_STORE(pd->od.lstore), &iter
> 						,0,strarr[0]
> 						,1,strarr[1]
> 						,2,strarr[2]
> 						,3,strarr[3]
> 						,4,strarr[4]
> 						,5,strarr[5]
> 						,6,strarr[6]
> 						,-1);
> 	}
> }
> 
> static void outputbox_selection_changed_cb(GtkTreeSelection *selection, Tprefdialog *pd) {
> 	GtkTreeIter iter;
> 	GtkTreeModel *model;
> 	if (gtk_tree_selection_get_selected(selection, &model, &iter)) {
> 		gchar *name;
> 		GList *tmplist = g_list_first(pd->lists[outputbox]);
> 		gtk_tree_model_get(model, &iter, 0, &name, -1);
> 		outputbox_apply_changes(pd);
> 		while (tmplist) {
> 			gchar **strarr =(gchar **)tmplist->data;
> 			if (strcmp(strarr[0],name)==0) {
> 				gtk_entry_set_text(GTK_ENTRY(pd->od.entry[0]), strarr[0]);
> 				gtk_entry_set_text(GTK_ENTRY(pd->od.entry[1]), strarr[1]);
> 				gtk_entry_set_text(GTK_ENTRY(pd->od.entry[2]), strarr[2]);
> 				gtk_entry_set_text(GTK_ENTRY(pd->od.entry[3]), strarr[3]);
> 				gtk_entry_set_text(GTK_ENTRY(pd->od.entry[4]), strarr[4]);
> 				gtk_entry_set_text(GTK_ENTRY(pd->od.entry[5]), strarr[5]);
> 				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(pd->od.check), (strarr[6][0] == '1'));
> 				pd->od.curstrarr = strarr;
> 				return;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	} else {
> 		DEBUG_MSG("outputbox_selection_changed_cb, no selection ?!?!\n");
> 	}
> }
> */
> static void set_outputbox_strarr_in_list(GtkTreeIter *iter, gchar **strarr, Tprefdialog *pd) {
> 	gint arrcount;
> 	arrcount = count_array(strarr);
> 	if (arrcount==7) {
> 		gtk_list_store_set(GTK_LIST_STORE(pd->od.lstore), iter
> 				,0,strarr[0],1,strarr[1],2,strarr[2],3,strarr[3]
> 				,4,strarr[4],5,strarr[5],6,(strarr[6][0] != '0')
> 				,7,strarr,-1);
> 	}
> }
> static void outputbox_apply_change(Tprefdialog *pd, gint type, gchar *path, gchar *newval, gint index) {
> 	pref_apply_change(pd->od.lstore,7,type,path,newval,index);
> }
> static void outputbox_0_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	outputbox_apply_change(pd, 1, path, newtext, 0);
> }
> static void outputbox_1_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	outputbox_apply_change(pd, 1, path, newtext, 1);
> }
> static void outputbox_2_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	outputbox_apply_change(pd, 1, path, newtext, 2);
> }
> static void outputbox_3_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	outputbox_apply_change(pd, 1, path, newtext, 3);
> }
> static void outputbox_4_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	outputbox_apply_change(pd, 1, path, newtext, 4);
> }
> static void outputbox_5_edited_lcb(GtkCellRendererText *cellrenderertext,gchar *path,gchar *newtext,Tprefdialog *pd) {
> 	outputbox_apply_change(pd, 1, path, newtext, 5);
> }
> static void outputbox_6_toggled_lcb(GtkCellRendererToggle *cellrenderertoggle,gchar *path,Tprefdialog *pd) {
> 	gchar *val = g_strdup(cellrenderertoggle->active ? "0" : "1");
> 	outputbox_apply_change(pd, 2, path, val, 6);
> 	g_free(val);
> }
> static void add_new_outputbox_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	gchar **strarr;
> 	GtkTreeIter iter;
> 	strarr = pref_create_empty_strarr(7);
> 	gtk_list_store_append(GTK_LIST_STORE(pd->od.lstore), &iter);
> 	set_outputbox_strarr_in_list(&iter, strarr,pd);
> 	pd->lists[outputbox] = g_list_append(pd->lists[outputbox], strarr);
> 	pd->od.insertloc = -1;
> }
> static void delete_outputbox_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	pref_delete_strarr(pd, &pd->od, 7);
> }
> 
> static void create_outputbox_gui(Tprefdialog *pd, GtkWidget *vbox1) {
> 	GtkWidget *hbox, *but, *scrolwin;
> 	pd->lists[outputbox] = duplicate_arraylist(main_v->props.outputbox);
> 	pd->od.lstore = gtk_list_store_new (8,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER);
> 	pd->od.lview = gtk_tree_view_new_with_model(GTK_TREE_MODEL(pd->od.lstore));
> 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 1, G_CALLBACK(outputbox_0_edited_lcb), pd, _("Name"), 0);
> 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 1, G_CALLBACK(outputbox_1_edited_lcb), pd, _("Pattern"), 1);
> 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 1, G_CALLBACK(outputbox_2_edited_lcb), pd, _("File #"), 2);
> 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 1, G_CALLBACK(outputbox_3_edited_lcb), pd, _("Line #"), 3);
> 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 1, G_CALLBACK(outputbox_4_edited_lcb), pd, _("Output #"), 4);
> 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 1, G_CALLBACK(outputbox_5_edited_lcb), pd, _("Command"), 5);
> 	pref_create_column(GTK_TREE_VIEW(pd->od.lview), 2, G_CALLBACK(outputbox_6_toggled_lcb), pd, _("Show all output"), 6);
> 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin),GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);
> 	gtk_container_add(GTK_CONTAINER(scrolwin), pd->od.lview);
> 	gtk_widget_set_size_request(scrolwin, 150, 190);
> 	gtk_box_pack_start(GTK_BOX(vbox1), scrolwin, TRUE, TRUE, 2);
> 	{
> 		GList *tmplist = g_list_first(pd->lists[outputbox]);
> 		while (tmplist) {
> 			gint arrcount;
> 			gchar **strarr = (gchar **)tmplist->data;
> 			arrcount = count_array(strarr);
> 			if (arrcount==7) {
> 				GtkTreeIter iter;
> 				gtk_list_store_append(GTK_LIST_STORE(pd->od.lstore), &iter);
> 				set_outputbox_strarr_in_list(&iter, strarr,pd);
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	gtk_tree_view_set_reorderable(GTK_TREE_VIEW(pd->od.lview), TRUE);
> 	pd->od.thelist = &pd->lists[outputbox];
> 	pd->od.insertloc = -1;
> 	g_signal_connect(G_OBJECT(pd->od.lstore), "row-inserted", G_CALLBACK(listpref_row_inserted), &pd->od);
> 	g_signal_connect(G_OBJECT(pd->od.lstore), "row-deleted", G_CALLBACK(listpref_row_deleted), &pd->od);
> 
> 	hbox = gtk_hbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox1),hbox, TRUE, TRUE, 2);
> 	but = bf_gtkstock_button(GTK_STOCK_ADD, G_CALLBACK(add_new_outputbox_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
> 	but = bf_gtkstock_button(GTK_STOCK_DELETE, G_CALLBACK(delete_outputbox_lcb), pd);
> 	gtk_box_pack_start(GTK_BOX(hbox),but, FALSE, FALSE, 2);
> }
> 
> /**************************************/
> /* MAIN DIALOG FUNCTIONS              */
> /**************************************/
> 
> static void preferences_destroy_lcb(GtkWidget * widget, Tprefdialog *pd) {
> 	GtkTreeSelection *select;
> 	DEBUG_MSG("preferences_destroy_lcb, started\n");
> 
> 	free_arraylist(pd->lists[filetypes]);
> 	free_arraylist(pd->lists[filefilters]);
> 	free_arraylist(pd->lists[highlight_patterns]);
> 	free_arraylist(pd->lists[browsers]);
> 	free_arraylist(pd->lists[external_commands]);
> 	pd->lists[filetypes] = NULL;
> 	pd->lists[filefilters] = NULL;
> 	pd->lists[highlight_patterns] = NULL;
> 	pd->lists[browsers] = NULL;
> 	pd->lists[external_commands] = NULL;
> 
> /*	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->ftd.lview));
> 	g_signal_handlers_destroy(G_OBJECT(select));*/
> 	DEBUG_MSG("preferences_destroy_lcb, destroying handlers for lstore %p\n",pd->ftd.lstore);
> 	g_signal_handlers_destroy(G_OBJECT(pd->ftd.lstore));
> 
> 	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->ffd.lview));
> 	g_signal_handlers_destroy(G_OBJECT(select));
> 
> 	g_signal_handlers_destroy(G_OBJECT(pd->hpd.popmenu));
> /*	g_signal_handlers_destroy(G_OBJECT(GTK_COMBO(pd->bd.combo)->list));*/
> 	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->bd.lview));
> 	g_signal_handlers_destroy(G_OBJECT(select));
> /*	g_signal_handlers_destroy(G_OBJECT(GTK_COMBO(pd->ed.combo)->list));*/
> 	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(pd->ed.lview));
> 	g_signal_handlers_destroy(G_OBJECT(select));
> 	DEBUG_MSG("preferences_destroy_lcb, about to destroy the window\n");
> 	window_destroy(pd->win);
> 	g_free(pd);
> }
> static void preferences_apply(Tprefdialog *pd) {
> #ifndef NOSPLASH
> 	integer_apply(&main_v->props.show_splash_screen, pd->prefs[editor_show_splash_screen], TRUE);
> #endif /* #ifndef NOSPLASH */
> 	integer_apply(&main_v->props.show_quickbar_tip, pd->prefs[editor_show_quickbar_warning], TRUE);
> 	string_apply(&main_v->props.editor_font_string, pd->prefs[editor_font_string]);
> 	integer_apply(&main_v->props.editor_tab_width, pd->prefs[editor_tab_width], FALSE);
> 	integer_apply(&main_v->props.editor_smart_cursor, pd->prefs[editor_smart_cursor], TRUE);
> 	integer_apply(&main_v->props.editor_indent_wspaces, pd->prefs[editor_indent_wspaces], TRUE);
> 	integer_apply(&main_v->props.word_wrap, pd->prefs[word_wrap], TRUE);
> 	integer_apply(&main_v->props.view_line_numbers, pd->prefs[view_line_numbers], TRUE);
> 	integer_apply(&main_v->props.defaulthighlight, pd->prefs[defaulthighlight], TRUE);
> #ifdef HAVE_PCRE_UTF8
> 	integer_apply(&main_v->props.highlight_utf8, pd->prefs[highlight_utf8], TRUE);
> #endif /* HAVE_PCRE_UTF8 */
> 	integer_apply(&main_v->props.highlight_num_lines_count, pd->prefs[highlight_num_lines_count], FALSE);
> 
> 	integer_apply(&main_v->props.bookmarks_default_store, pd->prefs[bookmarks_default_store], TRUE);
> 	main_v->props.bookmarks_filename_mode = gtk_option_menu_get_history(GTK_OPTION_MENU(pd->prefs[bookmarks_filename_mode]));
> 
> 	integer_apply(&main_v->props.xhtml, pd->prefs[xhtml], TRUE);
> 	if (main_v->props.xhtml) {
> 		main_v->props.lowercase_tags = 1;
> 		main_v->props.allow_dep = 0;
> 	} else {
> 		integer_apply(&main_v->props.lowercase_tags, pd->prefs[lowercase_tags], TRUE);
> 		integer_apply(&main_v->props.allow_dep, pd->prefs[allow_dep], TRUE);
> 	}
> 	integer_apply(&main_v->props.auto_update_meta_author, pd->prefs[auto_update_meta_author], TRUE);
> 	integer_apply(&main_v->props.auto_update_meta_date, pd->prefs[auto_update_meta_date], TRUE);
> 	integer_apply(&main_v->props.auto_update_meta_generator, pd->prefs[auto_update_meta_generator], TRUE);
> 	
> 	string_apply(&main_v->props.newfile_default_encoding, GTK_COMBO(pd->prefs[newfile_default_encoding])->entry);
> 	integer_apply(&main_v->props.auto_set_encoding_meta, pd->prefs[auto_set_encoding_meta], TRUE);
> 	integer_apply(&main_v->props.backup_file, pd->prefs[backup_file], TRUE);
> 	string_apply(&main_v->props.backup_filestring, pd->prefs[backup_filestring]);
> 	main_v->props.backup_abort_action = gtk_option_menu_get_history(GTK_OPTION_MENU(pd->prefs[backup_abort_action]));
> 	integer_apply(&main_v->props.backup_cleanuponclose, pd->prefs[backup_cleanuponclose], TRUE);
> 	integer_apply(&main_v->props.num_undo_levels, pd->prefs[num_undo_levels], FALSE);
> 	integer_apply(&main_v->props.clear_undo_on_save, pd->prefs[clear_undo_on_save], TRUE);
> 	integer_apply(&main_v->props.allow_multi_instances, pd->prefs[allow_multi_instances], TRUE);
> #ifdef WITH_MSG_QUEUE
> 	integer_apply(&main_v->props.open_in_running_bluefish, pd->prefs[open_in_running_bluefish], TRUE);
> #endif
> 	main_v->props.modified_check_type = gtk_option_menu_get_history(GTK_OPTION_MENU(pd->prefs[modified_check_type]));
> 	integer_apply(&main_v->props.max_recent_files, pd->prefs[max_recent_files], FALSE);
> 	
> 	integer_apply(&main_v->props.restore_dimensions, pd->prefs[restore_dimensions], TRUE);
> 	if (!main_v->props.restore_dimensions) {
> 		integer_apply(&main_v->props.left_panel_width, pd->prefs[left_panel_width], FALSE);
> 		integer_apply(&main_v->globses.main_window_h, pd->prefs[main_window_h], FALSE);
> 		integer_apply(&main_v->globses.main_window_w, pd->prefs[main_window_w], FALSE);
> 	}
> 	string_apply(&main_v->props.tab_font_string, pd->prefs[tab_font_string]);
> 	main_v->props.document_tabposition = gtk_option_menu_get_history(GTK_OPTION_MENU(pd->prefs[document_tabposition]));
> 	main_v->props.leftpanel_tabposition = gtk_option_menu_get_history(GTK_OPTION_MENU(pd->prefs[leftpanel_tabposition]));
> 	main_v->props.left_panel_left = gtk_option_menu_get_history(GTK_OPTION_MENU(pd->prefs[left_panel_left]));
> 
> /*	integer_apply(&main_v->props.view_main_toolbar, pd->prefs[view_main_toolbar], TRUE);
> 	integer_apply(&main_v->props.view_left_panel, pd->prefs[view_left_panel], TRUE);
> 	integer_apply(&main_v->props.view_custom_menu, pd->prefs[view_custom_menu], TRUE);
> 	integer_apply(&main_v->props.view_html_toolbar, pd->prefs[view_html_toolbar], TRUE);*/
> 	integer_apply(&main_v->props.transient_htdialogs, pd->prefs[transient_htdialogs], TRUE);
> 	
> 	integer_apply(&main_v->props.ext_browsers_in_submenu, pd->prefs[ext_browsers_in_submenu], TRUE);
> 	integer_apply(&main_v->props.ext_commands_in_submenu, pd->prefs[ext_commands_in_submenu], TRUE);
> 	integer_apply(&main_v->props.ext_outputbox_in_submenu, pd->prefs[ext_outputbox_in_submenu], TRUE);
> 
> 	string_apply(&main_v->props.default_basedir, pd->prefs[default_basedir]);
> 	integer_apply(&main_v->props.filebrowser_two_pane_view, pd->prefs[filebrowser_two_pane_view], TRUE);
> 	string_apply(&main_v->props.filebrowser_unknown_icon, pd->prefs[filebrowser_unknown_icon]);
> 	string_apply(&main_v->props.filebrowser_dir_icon, pd->prefs[filebrowser_dir_icon]);
> 	
> 	string_apply(&main_v->props.image_thumbnailstring, pd->prefs[image_thumbnailstring]);
> 	string_apply(&main_v->props.image_thumbnailtype, GTK_COMBO(pd->prefs[image_thumbnailtype])->entry);
> 
> #ifdef HAVE_GNOME_VFS
> 	integer_apply(&main_v->props.server_zope_compat, pd->prefs[server_zope_compat], TRUE);
> #endif
> 
> 	/*filetype_apply_changes(pd);*/
> 	/*filefilter_apply_changes(pd);*/
> 	highlightpattern_apply_changes(pd);
> 	/*browsers_apply_changes(pd);*/
> 	/*externals_apply_changes(pd);*/
> 	/*outputbox_apply_changes(pd);*/
> 
> 	free_arraylist(main_v->props.filetypes);
> 	main_v->props.filetypes = duplicate_arraylist(pd->lists[filetypes]);
> 
> 	free_arraylist(main_v->props.filefilters);
> 	main_v->props.filefilters = duplicate_arraylist(pd->lists[filefilters]);
> 
> 	free_arraylist(main_v->props.highlight_patterns);
> 	main_v->props.highlight_patterns = duplicate_arraylist(pd->lists[highlight_patterns]);
> 	
> 	free_arraylist(main_v->props.browsers);
> 	main_v->props.browsers = duplicate_arraylist(pd->lists[browsers]);
> 	
> 	free_arraylist(main_v->props.external_commands);
> 	main_v->props.external_commands = duplicate_arraylist(pd->lists[external_commands]);
> 	
> 	free_arraylist(main_v->props.outputbox);
> 	main_v->props.outputbox	 = duplicate_arraylist(pd->lists[outputbox]);
> 
> 	/* apply the changes to highlighting patterns and filetypes to the running program */
> 	filetype_highlighting_rebuild(TRUE);
> 	filebrowser_filters_rebuild();
> 	
> 	all_documents_apply_settings();
> 	{
> 		GList *tmplist = g_list_first(main_v->bfwinlist);
> 		while (tmplist) {
> 			Tbfwin *bfwin = BFWIN(tmplist->data);
> 			DEBUG_MSG("preferences_ok_clicked_lcb, calling encoding_menu_rebuild\n");
> 			encoding_menu_rebuild(bfwin);
> 			external_menu_rebuild(bfwin); /* browsers is also rebuild here! */
> 			filetype_menu_rebuild(bfwin,NULL);
> 			DEBUG_MSG("preferences_ok_clicked_lcb, calling gui_apply_settings\n");
> 			gui_apply_settings(bfwin);
> 			left_panel_rebuild(bfwin);
> 			DEBUG_MSG("preferences_ok_clicked_lcb, calling doc_force_activate\n");
> 			doc_force_activate(bfwin->current_document);
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> }
> 
> static void preferences_cancel_clicked_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	preferences_destroy_lcb(NULL, pd);
> }
> static void preferences_apply_clicked_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	preferences_apply(pd);
> }
> static void preferences_ok_clicked_lcb(GtkWidget *wid, Tprefdialog *pd) {
> 	preferences_apply(pd);
> 	preferences_destroy_lcb(NULL, pd);
> }
> 
> static void restore_dimensions_toggled_lcb(GtkToggleButton *togglebutton,Tprefdialog *pd) {
> 	gtk_widget_set_sensitive(pd->prefs[left_panel_width], !togglebutton->active);
> 	gtk_widget_set_sensitive(pd->prefs[main_window_h], !togglebutton->active);
> 	gtk_widget_set_sensitive(pd->prefs[main_window_w], !togglebutton->active);
> }
> static void create_backup_toggled_lcb(GtkToggleButton *togglebutton,Tprefdialog *pd) {
> 	gtk_widget_set_sensitive(pd->prefs[backup_filestring], togglebutton->active);
> 	gtk_widget_set_sensitive(pd->prefs[backup_abort_action], togglebutton->active);
> }
> 
> static void preferences_dialog() {
> 	Tprefdialog *pd;
> 	GtkWidget *dvbox, *frame, *vbox1, *vbox2;
> 	gchar *notebooktabpositions[] = {N_("left"), N_("right"), N_("top"), N_("bottom"), NULL};
> 	gchar *panellocations[] = {N_("right"), N_("left"), NULL};
> 	gchar *modified_check_types[] = {N_("no check"), N_("check mtime and size"), N_("check mtime"), N_("check size"), NULL};
> 
> 	pd = g_new0(Tprefdialog,1);
> 	pd->win = window_full(_("Edit preferences"), GTK_WIN_POS_NONE, 0, G_CALLBACK(preferences_destroy_lcb), pd, TRUE);
> 	
> 	dvbox = gtk_vbox_new(FALSE, 5);
> 	gtk_container_add(GTK_CONTAINER(pd->win), dvbox);
> 	pd->noteb = gtk_notebook_new();
> 	gtk_notebook_set_homogeneous_tabs(GTK_NOTEBOOK(pd->noteb), TRUE);
> 	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(pd->noteb), GTK_POS_LEFT);
> 	
> 	gtk_box_pack_start(GTK_BOX(dvbox), pd->noteb, TRUE, TRUE, 0);
> 
> 	vbox1 = gtk_vbox_new(FALSE, 5);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Editor"),150,TRUE));
> 
> 	frame = gtk_frame_new(_("Editor startup options"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 
> #ifndef NOSPLASH
> 	pd->prefs[editor_show_splash_screen] = boxed_checkbut_with_value(_("Show splash-screen"), main_v->props.show_splash_screen, vbox2);
> #endif /* #ifndef NOSPLASH */
> 	pd->prefs[editor_show_quickbar_warning] = boxed_checkbut_with_value(_("Show empty quickbar warning"), main_v->props.show_quickbar_tip, vbox2);
> 	
> 	frame = gtk_frame_new(_("Editor options"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 	
> 	pd->prefs[editor_font_string] = prefs_string(_("Font"), main_v->props.editor_font_string, vbox2, pd, string_font);
> 	pd->prefs[editor_tab_width] = prefs_integer(_("Tab width"), main_v->props.editor_tab_width, vbox2, pd, 1, 50);
> 	pd->prefs[editor_smart_cursor] = boxed_checkbut_with_value(_("Smart cursor positioning"), main_v->props.editor_smart_cursor, vbox2);
> 	pd->prefs[editor_indent_wspaces] = boxed_checkbut_with_value(_("Use spaces to indent, not tabs"), main_v->props.editor_indent_wspaces, vbox2);
> 	pd->prefs[word_wrap] = boxed_checkbut_with_value(_("Word wrap default"), main_v->props.word_wrap, vbox2);
> 	pd->prefs[view_line_numbers] = boxed_checkbut_with_value(_("Line numbers by default"), main_v->props.view_line_numbers, vbox2);
> 	pd->prefs[defaulthighlight] = boxed_checkbut_with_value(_("Highlight syntax by default"), main_v->props.defaulthighlight, vbox2);
> #ifdef HAVE_PCRE_UTF8
> 	pd->prefs[highlight_utf8] = boxed_checkbut_with_value(_("Enable highlighting PCRE UTF-8 support"), main_v->props.highlight_utf8, vbox2);
> #endif /* HAVE_PCRE_UTF8 */
> 	pd->prefs[highlight_num_lines_count] = prefs_integer(_("Highlight # lines"), main_v->props.highlight_num_lines_count, vbox2, pd, 1, 8);
> 
> 	frame = gtk_frame_new(_("Undo"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 
> 	pd->prefs[num_undo_levels] = prefs_integer(_("Undo history size"), main_v->props.num_undo_levels, vbox2, pd, 50, 10000);
> 	pd->prefs[clear_undo_on_save] = boxed_checkbut_with_value(_("Clear undo history on save"), main_v->props.clear_undo_on_save, vbox2);
> 	
> 	frame = gtk_frame_new(_("Bookmark options"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 	
> 	pd->prefs[bookmarks_default_store] = boxed_checkbut_with_value(_("Make permanent by default"), main_v->props.bookmarks_default_store, vbox2);
> 	{
> 		gchar *actions[] = {N_("full path"), N_("path from basedir"), N_("filename"), NULL};
> 		pd->prefs[bookmarks_filename_mode] = boxed_optionmenu_with_value(_("Bookmarks filename display"), main_v->props.bookmarks_filename_mode, vbox2, actions);
> 	}
> 
> 	vbox1 = gtk_vbox_new(FALSE, 5);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("HTML"),154,TRUE));
> 
> 	frame = gtk_frame_new(_("HTML options"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 	
> 	pd->prefs[lowercase_tags] = boxed_checkbut_with_value(_("Lowercase HTML tags"), main_v->props.lowercase_tags, vbox2);
> 	pd->prefs[allow_dep] = boxed_checkbut_with_value(_("Use deprecated tags (e.g. <font> and <nobr>)"), main_v->props.allow_dep, vbox2);
> 	pd->prefs[xhtml] = boxed_checkbut_with_value(_("Use XHTML style tags (<br />)"), main_v->props.xhtml, vbox2);
> 	pd->prefs[auto_update_meta_author] = boxed_checkbut_with_value(_("Automatically update author meta tag"), main_v->props.auto_update_meta_author, vbox2);
> 	pd->prefs[auto_update_meta_date] = boxed_checkbut_with_value(_("Automatically update date meta tag"), main_v->props.auto_update_meta_date, vbox2);
> 	pd->prefs[auto_update_meta_generator] = boxed_checkbut_with_value(_("Automatically update generator meta tag"), main_v->props.auto_update_meta_generator, vbox2);
> 	
> 	vbox1 = gtk_vbox_new(FALSE, 5);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Files"),152,TRUE));
> 
> 	frame = gtk_frame_new(_("Encoding"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 	{
> 		GList *tmplist, *poplist = g_list_append(NULL, "");
> 		tmplist = g_list_first(main_v->props.encodings);
> 		while (tmplist) {
> 			gchar **strarr = (gchar **)tmplist->data;
> 			poplist = g_list_append(poplist, strarr[1]);
> 			tmplist = g_list_next(tmplist);
> 		}
> 		pd->prefs[newfile_default_encoding] = prefs_combo(_("Default character set"),main_v->props.newfile_default_encoding, vbox2, pd, poplist, TRUE);
> 		g_list_free(poplist);
> 	}	
> 	pd->prefs[auto_set_encoding_meta] = boxed_checkbut_with_value(_("Auto set <meta> encoding tag on change"), main_v->props.auto_set_encoding_meta, vbox2);
> 
> 	frame = gtk_frame_new(_("Backup"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 	pd->prefs[backup_file] = boxed_checkbut_with_value(_("Create backup on save"), main_v->props.backup_file, vbox2);
> 	pd->prefs[backup_filestring] = prefs_string(_("Backup file suffix"), main_v->props.backup_filestring, vbox2, pd, string_none);
> 	{
> 		gchar *failureactions[] = {N_("save"), N_("abort"), N_("ask"), NULL};
> 		pd->prefs[backup_abort_action] = boxed_optionmenu_with_value(_("Action on backup failure"), main_v->props.backup_abort_action, vbox2, failureactions);
> 	}
> 	pd->prefs[backup_cleanuponclose] = boxed_checkbut_with_value(_("Remove backupfile on close"), main_v->props.backup_cleanuponclose, vbox2);
> 	create_backup_toggled_lcb(GTK_TOGGLE_BUTTON(pd->prefs[backup_file]), pd);
> 	g_signal_connect(G_OBJECT(pd->prefs[backup_file]), "toggled", G_CALLBACK(create_backup_toggled_lcb), pd);
> 
> 	frame = gtk_frame_new(_("Misc"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 
> 	pd->prefs[allow_multi_instances] = boxed_checkbut_with_value(_("Allow multi instances of a file"), main_v->props.allow_multi_instances, vbox2);
> #ifdef WITH_MSG_QUEUE
> 	pd->prefs[open_in_running_bluefish] = boxed_checkbut_with_value(_("Open files in already running bluefish window"),main_v->props.open_in_running_bluefish, vbox2);
> #endif /* WITH_MSG_QUEUE */		
> 	pd->prefs[modified_check_type] = boxed_optionmenu_with_value(_("File modified on disk check "), main_v->props.modified_check_type, vbox2, modified_check_types);
> 	pd->prefs[max_recent_files] = prefs_integer(_("Number of files in 'Open recent'"), main_v->props.max_recent_files, vbox2, pd, 3, 100);
> 
> 	frame = gtk_frame_new(_("File browser"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 	pd->prefs[default_basedir] = prefs_string(_("Default basedir"), main_v->props.default_basedir, vbox2, pd, string_none);
> 	pd->prefs[filebrowser_two_pane_view] = boxed_checkbut_with_value(_("Use separate file and directory view"), main_v->props.filebrowser_two_pane_view, vbox2);
> 	pd->prefs[filebrowser_unknown_icon] = prefs_string(_("Unknown icon"), main_v->props.filebrowser_unknown_icon, vbox2, pd, string_file);
> 	pd->prefs[filebrowser_dir_icon] = prefs_string(_("Directory icon"), main_v->props.filebrowser_dir_icon, vbox2, pd, string_file);
> 
> 	vbox1 = gtk_vbox_new(FALSE, 5);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("User interface"), 156,TRUE));
> 
> 	frame = gtk_frame_new(_("Dimensions"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 	pd->prefs[restore_dimensions] = boxed_checkbut_with_value(_("Restore last used dimensions"), main_v->props.restore_dimensions, vbox2);
> 	pd->prefs[left_panel_width] = prefs_integer(_("Initial sidebar width"), main_v->props.left_panel_width, vbox2, pd, 1, 4000);
> 	pd->prefs[main_window_h] = prefs_integer(_("Initial window height"), main_v->globses.main_window_h, vbox2, pd, 1, 4000);
> 	pd->prefs[main_window_w] = prefs_integer(_("Initial window width"), main_v->globses.main_window_w, vbox2, pd, 1, 4000);
> 	restore_dimensions_toggled_lcb(GTK_TOGGLE_BUTTON(pd->prefs[restore_dimensions]), pd);
> 	g_signal_connect(G_OBJECT(pd->prefs[restore_dimensions]), "toggled", G_CALLBACK(restore_dimensions_toggled_lcb), pd);
> 
> 	frame = gtk_frame_new(_("General"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 
> /*	pd->prefs[view_main_toolbar] = boxed_checkbut_with_value(_("Show main toolbar by default"), main_v->props.view_main_toolbar, vbox2);
> 	pd->prefs[view_left_panel] = boxed_checkbut_with_value(_("Show sidebar by default"), main_v->props.view_left_panel, vbox2);
> 	pd->prefs[view_custom_menu] = boxed_checkbut_with_value(_("Show custom menu by default"), main_v->props.view_custom_menu, vbox2);
> 	pd->prefs[view_html_toolbar] = boxed_checkbut_with_value(_("Show HTML toolbar by default"), main_v->props.view_html_toolbar, vbox2);*/
> 	pd->prefs[transient_htdialogs] = boxed_checkbut_with_value(_("Make HTML dialogs transient"), main_v->props.transient_htdialogs, vbox2);
> 
> 	pd->prefs[ext_browsers_in_submenu] = boxed_checkbut_with_value(_("External browsers in submenu"), main_v->props.ext_browsers_in_submenu, vbox2);
> 	pd->prefs[ext_commands_in_submenu] = boxed_checkbut_with_value(_("External commands in submenu"), main_v->props.ext_commands_in_submenu, vbox2);
> 	pd->prefs[ext_outputbox_in_submenu] = boxed_checkbut_with_value(_("External outputbox in submenu"), main_v->props.ext_outputbox_in_submenu, vbox2);
> 	
> 	pd->prefs[tab_font_string] = prefs_string(_("Notebook tab font (leave empty for gtk default)"), main_v->props.tab_font_string, vbox2, pd, string_font);
> 	
> 	pd->prefs[document_tabposition] = boxed_optionmenu_with_value(_("Document notebook tab position"), main_v->props.document_tabposition, vbox2, notebooktabpositions);
> 	pd->prefs[leftpanel_tabposition] = boxed_optionmenu_with_value(_("Sidebar notebook tab position"), main_v->props.leftpanel_tabposition, vbox2, notebooktabpositions);
> 	pd->prefs[left_panel_left] = boxed_optionmenu_with_value(_("Sidebar location"), main_v->props.left_panel_left, vbox2, panellocations);
> 
> 	vbox1 = gtk_vbox_new(FALSE, 5);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Images"), 155,TRUE));
> 
> 	frame = gtk_frame_new(_("Thumbnails"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 	pd->prefs[image_thumbnailstring] = prefs_string(_("Thumbnail suffix"), main_v->props.image_thumbnailstring, vbox2, pd, string_none);
> 	{
> 		GList *poplist = g_list_append(NULL, "png");
> 		poplist = g_list_append(poplist, "jpeg");
> 		pd->prefs[image_thumbnailtype] = prefs_combo(_("Thumbnail filetype"),main_v->props.image_thumbnailtype, vbox2, pd, poplist, FALSE);
> 		g_list_free(poplist);
> 	}
> 
> 	vbox1 = gtk_vbox_new(FALSE, 5);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Filetypes"), 153,TRUE));
> 
> 	frame = gtk_frame_new(_("Filetypes"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 
> 	create_filetype_gui(pd, vbox2);
> 	
> 	frame = gtk_frame_new(_("Filefilters"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 	
> 	create_filefilter_gui(pd, vbox2);
> 
> 	vbox1 = gtk_vbox_new(FALSE, 5);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Syntax highlighting"), 158,TRUE));
> 
> 	frame = gtk_frame_new(_("Patterns"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 
> 	create_highlightpattern_gui(pd, vbox2);
> 
> 	vbox1 = gtk_vbox_new(FALSE, 5);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("External programs"), 151,TRUE));
> 
> 	frame = gtk_frame_new(_("Browsers"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 
> 	create_browsers_gui(pd, vbox2);
> 
> 	frame = gtk_frame_new(_("Utilities and filters"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 
> 	create_externals_gui(pd, vbox2);
> 
> 	vbox1 = gtk_vbox_new(FALSE, 5);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Output parsers"), 157,TRUE));
> 	
> 	frame = gtk_frame_new(_("Outputbox"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 	
> 	create_outputbox_gui(pd, vbox2);
> 
> #ifdef HAVE_GNOME_VFS
> 	vbox1 = gtk_vbox_new(FALSE, 5);
> 	gtk_notebook_append_page(GTK_NOTEBOOK(pd->noteb), vbox1, hbox_with_pix_and_text(_("Servers"), 0,TRUE));
> 	
> 	frame = gtk_frame_new(_("Remote servers"));
> 	gtk_box_pack_start(GTK_BOX(vbox1), frame, FALSE, FALSE, 5);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(frame), vbox2);
> 	
> 	pd->prefs[server_zope_compat] = boxed_checkbut_with_value(_("Zope compatibility mode"), main_v->props.server_zope_compat, vbox2);
> #endif
> 
> 	/* end, create buttons for dialog now */
> 	{
> 		GtkWidget *ahbox, *but;
> 		ahbox = gtk_hbutton_box_new();
> 		gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
> 		gtk_button_box_set_spacing(GTK_BUTTON_BOX(ahbox), 12);
> 
> 		gtk_box_pack_start(GTK_BOX(dvbox), ahbox, FALSE, FALSE, 0);
> 		but = bf_gtkstock_button(GTK_STOCK_APPLY, G_CALLBACK(preferences_apply_clicked_lcb), pd);
> 		gtk_box_pack_start(GTK_BOX(ahbox), but, TRUE, TRUE, 0);
> 
> 		but = bf_stock_cancel_button(G_CALLBACK(preferences_cancel_clicked_lcb), pd);
> 		gtk_box_pack_start(GTK_BOX(ahbox), but, TRUE, TRUE, 0);
> 
> 		but = bf_stock_ok_button(G_CALLBACK(preferences_ok_clicked_lcb), pd);
> 		gtk_box_pack_start(GTK_BOX(ahbox), but, TRUE, TRUE, 0);
> 		gtk_window_set_default(GTK_WINDOW(pd->win), but);
> 	}
> 	gtk_widget_show_all(pd->win);
> }
> 
> void open_preferences_cb(GtkWidget *wid, gpointer data) {
> 	preferences_dialog();
> }
> 
> void open_preferences_menu_cb(gpointer callback_data,guint action,GtkWidget *widget) {
> 	preferences_dialog();
> }
1,678c1,673
< /* Bluefish HTML Editor
<  * project.c - project functionality
<  *
<  * Copyright (C) 2003-2006 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< /* #define DEBUG */
< 
< #include <gtk/gtk.h>
< #include <stdlib.h>
< #include <string.h>
< #include <unistd.h>    /* unlink() */
< 
< #include "bluefish.h"
< #include "project.h"
< #include "bf_lib.h"
< #include "bookmark.h"
< #include "document.h"
< #include "filebrowser.h"
< #include "gtk_easy.h"
< #include "gui.h"
< #include "menu.h"
< #include "rcfile.h"
< #include "stringlist.h"
< 
< static void free_session(Tsessionvars *session) {
< 	free_stringlist(session->classlist);
< 	free_stringlist(session->colorlist);
< 	free_stringlist(session->targetlist);
< 	free_stringlist(session->urllist);
< 	free_stringlist(session->fontlist);
< 	free_stringlist(session->dtd_cblist);
< 	free_stringlist(session->headerlist);
< 	free_stringlist(session->positionlist);
< 	free_stringlist(session->searchlist);
< 	free_stringlist(session->replacelist);
< 	free_arraylist(session->bmarks);
< 	g_free(session);
< }
< 
< static void project_setup_initial_session(Tsessionvars *session) {
< 	session->view_html_toolbar = main_v->session->view_html_toolbar;
< 	session->view_custom_menu = main_v->session->view_custom_menu;
< 	session->view_main_toolbar = main_v->session->view_main_toolbar;
< 	session->view_left_panel = main_v->session->view_left_panel;
< }
< 
< Tbfwin *project_is_open(gchar *filename) {
< 	GList *tmplist;
< 
< #ifdef WIN32
< 	/* if (filename[0] == '/') { filename ++;} */
< #endif /* WIN32 */
< 	
< 	tmplist = g_list_first(main_v->bfwinlist);
< 	while(tmplist){
< 		if (BFWIN(tmplist->data)->project 
< 				&& BFWIN(tmplist->data)->project->filename
< 				&& strcmp(BFWIN(tmplist->data)->project->filename, filename)==0) {
< 			return BFWIN(tmplist->data);
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return NULL;
< }
< 
< static void update_project_filelist(Tbfwin *bfwin, Tproject *prj) {
< 	DEBUG_MSG("update_project_filelist, started, bfwin=%p, prj=%p\n",bfwin,prj);
< 	free_stringlist(prj->files);
< 	DEBUG_MSG("update_project_filelist, old list free'd, creating new list from documentlist %p (len=%d)\n",bfwin->documentlist,g_list_length(bfwin->documentlist));
< 	prj->files = return_filenamestringlist_from_doclist(bfwin->documentlist);
< }
< 
< static void setup_bfwin_for_project(Tbfwin *bfwin) {
< 	bfwin->session = bfwin->project->session;
< 	bfwin->bookmarkstore = bfwin->project->bookmarkstore;
< 	bmark_set_store(bfwin);
< 	bmark_reload(bfwin);
< 	filebrowser_set_basedir(bfwin, bfwin->project->basedir);
< 	recent_menu_from_list(bfwin, bfwin->project->session->recent_files, FALSE);
< 	set_project_menu_widgets(bfwin, TRUE);
< }
< 
< /* bfwin is allowed to be NULL for an empty project */
< static Tproject *create_new_project(Tbfwin *bfwin) {
< 	Tproject *prj;
< 	prj = g_new0(Tproject,1);
< 	prj->name = g_strdup(_("New project"));
< 	prj->bookmarkstore = gtk_tree_store_new(2, G_TYPE_STRING, G_TYPE_POINTER); 
< 	DEBUG_MSG("create_new_project, project=%p, bookmarkstore=%p, bfwin=%p\n",prj,prj->bookmarkstore,bfwin);
< 	if (bfwin) {
< 		DEBUG_MSG("create_new_project, new project for bfwin %p\n",bfwin);
< 		update_project_filelist(bfwin,prj);
< 		bfwin->project = prj;
< 	} else {
< 		DEBUG_MSG("create_new_project, new project, no bfwin\n");
< 	}
< 	prj->session = g_new0(Tsessionvars,1);
< 	project_setup_initial_session(prj->session);
< 
< 	/* we should copy bookmarks from the files to this session */
< 	if (bfwin && prj->files) {
< 		GList *tmplist;
< 		tmplist = g_list_first(bfwin->documentlist);
< 		while (tmplist) {
< 			bmark_clean_for_doc(DOCUMENT(tmplist->data));
< 			tmplist = g_list_next(tmplist);
< 		}
< 	
< 		tmplist = g_list_first(bfwin->session->bmarks);
< 		while (tmplist) {
< 			gchar **entry = (gchar**)tmplist->data;
< 			if (count_array(entry) > 2) {
< 				GList *tmplist2 = g_list_first(prj->files);
< 				while (tmplist2) {
< 					if (strcmp(tmplist2->data, entry[2])==0) {
< 						/* move it out of the default session into this session */
< 						bfwin->session->bmarks = g_list_remove_link(bfwin->session->bmarks,tmplist);
< 						prj->session->bmarks = g_list_concat(prj->session->bmarks, tmplist);
< 						/* no further filenames to check */
< 						tmplist2 = g_list_last(tmplist2);
< 					}
< 					tmplist2 = g_list_next(tmplist2);
< 				}
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	if (prj->files) {
< 		gint len;
< 		gchar *somefile, *prefix;
< 		len = find_common_prefixlen_in_stringlist(prj->files);
< 		somefile = (gchar *)prj->files->data;
< 		prefix = g_strndup(somefile, len);
< 		if (prefix[strlen(prefix)-1] == '/') {
< 			prj->basedir = g_strdup(prefix);
< 		} else {
< 			prj->basedir = g_path_get_dirname(prefix);
< 		}
< 		g_free(prefix);
< 	} else {
< 		prj->basedir = g_strdup("");
< 	}
< 	prj->webdir = g_strdup("");
< 	prj->template = g_strdup("");
< 	prj->word_wrap = main_v->props.word_wrap;
< 	if (bfwin) {
< 		setup_bfwin_for_project(bfwin);
< 	}
< 	return prj;
< }
< 
< gboolean project_save(Tbfwin *bfwin, gboolean save_as) {
< 	gboolean retval;
< 	DEBUG_MSG("project_save, bfwin=%p, save_as=%d\n",bfwin,save_as);
< 	if (!bfwin->project) {
< 		/* there is no project yet, we have to create one */
< 		DEBUG_MSG("project_save, bfwin=%p does not have a project yet, create one\n",bfwin);
< 		bfwin->project= create_new_project(bfwin);
<   	   bmark_reload(bfwin);
< 	}
< 	DEBUG_MSG("project_save, project=%p, num files was %d\n", bfwin->project, g_list_length(bfwin->project->files));
< 	update_project_filelist(bfwin, bfwin->project);
< /*	bfwin->project->recentfiles = limit_stringlist(bfwin->project->recentfiles, main_v->props.max_recent_files, TRUE);*/
< 	
< 	bfwin->project->session->searchlist = limit_stringlist(bfwin->project->session->searchlist, 10, TRUE);
< 	bfwin->project->session->replacelist = limit_stringlist(bfwin->project->session->replacelist, 10, TRUE);
< 	bfwin->project->session->urllist = limit_stringlist(bfwin->project->session->urllist, 10, TRUE);
< 	bmark_store_all(bfwin);
< 
< 	if (save_as || bfwin->project->filename == NULL) {
< 		gint suflen,filen;
< 		gchar *filename = NULL;
< #ifdef HAVE_ATLEAST_GTK_2_4
< 		{
< 			GtkWidget *dialog;
< /*			dialog = gtk_file_chooser_dialog_new(_("Enter Bluefish project filename"),NULL,
< 					GTK_FILE_CHOOSER_ACTION_OPEN,
< 					GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
< 					GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT,
< 					NULL);*/
< 			dialog = file_chooser_dialog(bfwin,_("Enter Bluefish project filename"),GTK_FILE_CHOOSER_ACTION_SAVE, NULL, TRUE, FALSE, "bfproject");
< 			if (gtk_dialog_run(GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
< 				filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
< 			}
< 			gtk_widget_destroy(dialog);
< 		}
< #else
< 		filename = return_file_w_title(NULL, _("Enter Bluefish project filename"));
< #endif
< 		if (!filename) {
< 			return FALSE;
< 		}
< 		if (save_as || bfwin->project->filename == NULL) {
< 			gchar *ondiskencoding = get_filename_on_disk_encoding(filename);
< 			if (g_file_test(ondiskencoding, G_FILE_TEST_EXISTS)) {
< 				gchar *tmpstr;
< 				gint retval;
< 				gchar *options[] = {_("_Cancel"), _("_Overwrite"), NULL};
< 				tmpstr = g_strdup_printf(_("A file named \"%s\" already exists."), filename);
< 				retval = multi_warning_dialog(bfwin->main_window,tmpstr, 
< 												_("Do you want to replace the existing file?"), 1, 0, options);
< 				g_free(tmpstr);
< 				if (retval == 0) {
< 					g_free(filename);
< 					g_free(ondiskencoding);
< 					return FALSE;
< 				}
< 			}
< 			g_free(ondiskencoding);
< 		}
< 		suflen = strlen(main_v->props.project_suffix);
< 		filen = strlen(filename);
< 		if (filen > suflen && strcmp(&filename[filen - suflen], main_v->props.project_suffix)==0) {
< 			bfwin->project->filename = filename;
< 		} else {
< 			bfwin->project->filename = g_strconcat(filename, main_v->props.project_suffix,NULL);
< 			g_free(filename);
< 		}
< 	}
< 	
< 	DEBUG_MSG("project_save, saving project %p to file %s\n",bfwin->project,bfwin->project->filename);
< 	retval = rcfile_save_project(bfwin->project, bfwin->project->filename);
< 	add_to_recent_list(bfwin,bfwin->project->filename, FALSE, TRUE);
< 	return retval;
< }
< 
< void set_project_menu_widgets(Tbfwin *bfwin, gboolean win_has_project) {
< 	menuitem_set_sensitive(bfwin->menubar, "/Project/Save", win_has_project);
< 	menuitem_set_sensitive(bfwin->menubar, "/Project/Save as...", win_has_project);
< 	menuitem_set_sensitive(bfwin->menubar, "/Project/Save & close", win_has_project);
< 	menuitem_set_sensitive(bfwin->menubar, "/Project/Edit Project Options...", win_has_project);
< }
< 
< void project_open_from_file(Tbfwin *bfwin, gchar *fromfilename) {
< 	Tbfwin *prwin;
< 	Tproject *prj;
< 	gboolean retval;
< 
< 	/* first we test if the project is already open */
< 	prwin = project_is_open(fromfilename);
< 	if (prwin != NULL) {
< 		DEBUG_MSG("project_open_from_file, project is open in bfwin=%p\n",prwin);
< 		gtk_window_present(GTK_WINDOW(prwin->main_window));
< 		return;
< 	}
< 
< 	prj = g_new0(Tproject,1);
< 	prj->session = g_new0(Tsessionvars,1);
< 	project_setup_initial_session(prj->session);
< 	prj->bookmarkstore = gtk_tree_store_new(2, G_TYPE_STRING, G_TYPE_POINTER); 
< 	retval = rcfile_parse_project(prj, fromfilename);
< 	if (!retval) {
< 		DEBUG_MSG("project_open_from_file, failed parsing the project at file %s\n",fromfilename);
< 		g_object_unref(prj->bookmarkstore);
< 		g_free(prj->session);
< 		g_free(prj);
< 		return;
< 	}
< 	add_to_recent_list(bfwin,fromfilename, FALSE, TRUE);
< 	prj->filename = g_strdup(fromfilename);
< 	DEBUG_MSG("project_open_from_file, basedir=%s\n",prj->basedir);
< 	if (bfwin->project == NULL && test_only_empty_doc_left(bfwin->documentlist)) {
< 		/* we will use this Bluefish window to open the project */
< 		prwin = bfwin;
< 		/* now we need to clean the session, and reset it to the session from the project */
< 		/* free_session(bfwin->session); there is no session specific to a window anymore, only a global one*/
< 		bfwin->session = prj->session;
< 		prwin->project = prj;
< 		prwin->bookmarkstore = prj->bookmarkstore;
< 		
<       gui_set_html_toolbar_visible(prwin, prj->session->view_html_toolbar, TRUE);
<       gui_set_main_toolbar_visible(prwin, prj->session->view_main_toolbar, TRUE);
<       gui_set_custom_menu_visible(prwin, prj->session->view_custom_menu, TRUE);
< 		DEBUG_MSG("project_open_from_file, calling left_panel_show_hide_toggle bfwin=%p\n",prwin);
< 		left_panel_show_hide_toggle(prwin,FALSE,prj->session->view_left_panel, TRUE);
< 		filebrowser_set_basedir(prwin, prj->basedir);
< 		DEBUG_MSG("project_open_from_file, calling docs_new_from_files for existing bfwin=%p\n",prwin);
< 		docs_new_from_files(prwin, prj->files, TRUE);
< 	} else {
< 		/* we will open a new Bluefish window for this project */
< 		DEBUG_MSG("project_open_from_file, we need a new window\n");
< 		prwin = gui_new_window(prj->files, prj);
< 		DEBUG_MSG("project_open_from_file, new window with files ready\n");
< 		gui_set_title(prwin, prwin->current_document);
< 	}
< 
< 	set_project_menu_widgets(prwin, TRUE);
< 	recent_menu_init_project(prwin);
<    bmark_reload(bfwin);
<    bmark_set_store(bfwin);
< }
< 
< static void project_open(Tbfwin *bfwin) {
< 	/* first we ask for a filename */
< 	gchar *filename = NULL;
< #ifdef HAVE_ATLEAST_GTK_2_4
< 	{
< 		GtkWidget *dialog;
< 		/*dialog = gtk_file_chooser_dialog_new(_("Select Bluefish project filename"),NULL,
< 				GTK_FILE_CHOOSER_ACTION_OPEN,
< 				GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
< 				GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
< 				NULL);*/
< 		dialog = file_chooser_dialog(bfwin, _("Select Bluefish project filename"), GTK_FILE_CHOOSER_ACTION_OPEN, NULL, TRUE, FALSE, "bfproject");
< 		if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
< 			filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
< 		}
< 		gtk_widget_destroy(dialog);
< 	}
< #else
< 	filename = return_file_w_title(NULL, _("Select Bluefish project filename"));
< #endif
< 	if (filename) {
< 		DEBUG_MSG("project_open, for filename %s\n",filename);
< 		project_open_from_file(bfwin,filename);
< 		g_free(filename);
< 	} else {
< 		DEBUG_MSG("project_open, no filename.., returning\n");
< 	}
< }
< 
< static void project_destroy(Tproject *project) {
< 	g_object_unref(G_OBJECT(project->bookmarkstore));
< 	free_stringlist(project->files);
< 	free_session(project->session);
< 	g_free(project->filename);
< 	g_free(project->name);
< 	g_free(project->basedir);
< 	g_free(project->webdir);
< 	g_free(project->template);
< 	g_free(project);
< }
< 
< static void setup_bfwin_for_nonproject(Tbfwin *bfwin) {
< 	bfwin->session = main_v->session;
< 	bfwin->bookmarkstore = main_v->bookmarkstore;
< 	bfwin->project = NULL;
< 	bmark_set_store(bfwin);
< 	gui_set_title(bfwin, bfwin->current_document);
< 	filebrowser_set_basedir(bfwin, NULL);
< 	recent_menu_from_list(bfwin, main_v->session->recent_files, FALSE);
< 	set_project_menu_widgets(bfwin, FALSE);
< }
< 
< /* 
<  * returns TRUE if the project is closed, 
<  * returns FALSE if something went wrong or was cancelled
<  */
< gboolean project_save_and_close(Tbfwin *bfwin) {
< 	gboolean dont_save = FALSE;
< 	while (!bfwin->project->filename) {
< 		gchar *text;
< 		gint retval;
< 		gchar *buttons[] = {_("Do_n't save"), GTK_STOCK_CANCEL, GTK_STOCK_SAVE, NULL};
< 		if (dont_save) {
< 			break;
< 		}
< 		DEBUG_MSG("project_save_and_close, project not named, getting action\n");
< 		/* dialog */
< 
< 		text = g_strdup(_("Do you want to save the project?"));
< 		retval = multi_query_dialog(bfwin->main_window, text, 
< 			_("If you don't save your changes they will be lost."), 2, 1, buttons);
< 		switch (retval) {
< 		case 0:
< 			/* don't save proj. save files, though */
< 			DEBUG_MSG("project_save_and_close, don't save project, but save files\n");
< 			dont_save = TRUE;
< 		break;
< 		case 1:
< 			/* cancel */
< 			DEBUG_MSG("project_save_and_close, not closing window any more");
< 			return FALSE;
< 		break;
< 		case 2:
< 			DEBUG_MSG("project_save_and_close, bringing up save project dialog\n");
< 			dont_save = project_save(bfwin, FALSE);
< 		break;
< 		default:
< 		break;
< 		}		
< 	}
< 	/* test if we should save */
< 	if (!dont_save) {
< 		gchar *backupfile = NULL;
< 		if (!project_save(bfwin, FALSE)) {
< 			DEBUG_MSG("project_save failed, returning\n");
< 			return FALSE;
< 		}
< 		add_to_recent_list(bfwin,bfwin->project->filename, TRUE, TRUE);
< 		
<         if (main_v->props.backup_cleanuponclose) {
<             backupfile = g_strconcat (bfwin->project->filename, main_v->props.backup_filestring, NULL);
<             if (file_exists_and_readable(backupfile)) {
<                 gchar * ondiskencodingbckup = get_filename_on_disk_encoding(backupfile);
< #ifdef HAVE_GNOME_VFS
<                 gnome_vfs_unlink(ondiskencodingbckup);
< #else
< 		        unlink(ondiskencodingbckup);				
< #endif
<                 g_free (ondiskencodingbckup);
<             }
<             g_free (backupfile);
<         }
< 	}
< 	bfwin_close_all_documents(bfwin, TRUE);
< 	if (!test_only_empty_doc_left(bfwin->documentlist)) {
< 		DEBUG_MSG("closing all documents failed, returning\n");
< 		return FALSE;
< 	}
< 	project_destroy(bfwin->project);
< 	setup_bfwin_for_nonproject(bfwin);
< 	DEBUG_MSG("project_save_and_close, returning TRUE\n");
< 	return TRUE;
< }
< 
< typedef enum {
< 	name,
< 	basedir,
< 	webdir,
< 	template,
< 	word_wrap,
< 	projecteditor_entries_num
< } Tprojecteditor_entries;
< 
< typedef struct {
< 	GtkWidget *win;
< 	Tbfwin *bfwin;
< 	Tproject *project;
< 	GtkWidget *entries[projecteditor_entries_num];
< 	gboolean destroy_project_on_close;
< } Tprojecteditor;
< 
< static void project_edit_destroy_lcb(GtkWidget *widget, Tprojecteditor *pred) {
< 	DEBUG_MSG("project_edit_destroy_lcb, called for pred=%p\n",pred);
< /*	gtk_widget_destroy(pred->win);*/
< 	if (pred->destroy_project_on_close) {
< 		project_destroy(pred->project);
< 		if (pred->bfwin) {
< 			setup_bfwin_for_nonproject(pred->bfwin);
< 		}
< 	}
< 	if (pred->project) {
< 		pred->project->editor = NULL;
< 	}
< 	g_free(pred);
< }
< 
< static void project_edit_cancel_clicked_lcb(GtkWidget *widget, Tprojecteditor *pred) {
< 	gtk_widget_destroy(pred->win);
< }
< 
< static void project_edit_ok_clicked_lcb(GtkWidget *widget, Tprojecteditor *pred) {
< 	Tproject *prj = pred->project;
< 	
< 	pred->destroy_project_on_close = FALSE;
< 	
< 	gtk_widget_hide(pred->win);
< 	DEBUG_MSG("project_edit_ok_clicked_lcb, Tproject at %p, bfwin at %p\n",prj,pred->bfwin);
< 	string_apply(&prj->name, pred->entries[name]);
< 	string_apply(&prj->basedir, pred->entries[basedir]);
< 	if (prj->basedir && strlen(prj->basedir)) {
< 		gchar *tmp = prj->basedir;
< 		prj->basedir = ending_slash(prj->basedir);
< 		g_free(tmp);
< 	}
< 	string_apply(&prj->webdir, pred->entries[webdir]);
< 	string_apply(&prj->template, pred->entries[template]);
< 	integer_apply(&prj->word_wrap, pred->entries[word_wrap], TRUE);
< 	DEBUG_MSG("project_edit_ok_clicked_lcb, name=%s, basedir=%s, webdir=%s\n",prj->name,prj->basedir,prj->webdir);
< 
< 	if (pred->bfwin == NULL) {
< 		pred->bfwin = gui_new_window(NULL, pred->project);
< 	} else {
< 		gui_set_title(pred->bfwin, pred->bfwin->current_document);
< 	}
< 	setup_bfwin_for_project(pred->bfwin);
< /* set_project_menu_widgets(pred->bfwin, TRUE);*/
< 	project_save(pred->bfwin,FALSE);
< 	gtk_widget_destroy(pred->win);
< }
< 
< /*
< if NULL is passed as bfwin, a new window will be created for this project once OK is clicked
< */
< void project_edit(Tbfwin *bfwin) {
< 	GtkWidget *vbox, *but, *hbox, *label, *table;
< 	gchar *wintitle = NULL;
< 	Tprojecteditor *pred;
< 
< 	if (bfwin && bfwin->project && bfwin->project->editor) {
< 		gtk_window_present(GTK_WINDOW(((Tprojecteditor *)bfwin->project->editor)->win));
< 		return;
< 	}
< 	pred = g_new(Tprojecteditor,1);
< 	if (!bfwin || !bfwin->project) {
< 		/* there is no project yet, we have to create one */
< 		DEBUG_MSG("project_edit, no project yet, create one\n");
< 		pred->project= create_new_project(bfwin);
< 		if (bfwin) {
< 			bfwin->project = pred->project;
< 		}
< 		/* id the user does not press OK, we destroy the project */
< 		pred->destroy_project_on_close = TRUE;
< 		wintitle = g_strdup(_("Create New Project"));
< 	} else {
< 		pred->destroy_project_on_close = FALSE;
< 		wintitle = g_strdup(_("Edit Project"));
< 		if (bfwin) {
< 			pred->project = bfwin->project;
< 		}
< 	}
< 	DEBUG_MSG("project_edit, Tproject at %p\n",pred->project);
< 	pred->bfwin = bfwin;
< 	pred->project->editor = pred;
< 	
< 	pred->win = window_full2(wintitle, GTK_WIN_POS_CENTER_ALWAYS, 5
< 			, G_CALLBACK(project_edit_destroy_lcb), pred, TRUE, NULL);
< 	vbox = gtk_vbox_new(FALSE,0);
< 	gtk_container_add(GTK_CONTAINER(pred->win),vbox);
< 	
< 	if (wintitle) {
< 		g_free(wintitle);
< 	}
< 	
< 	label = gtk_label_new(NULL);
< 	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, TRUE, 0);
< 	gtk_label_set_line_wrap(GTK_LABEL(label),TRUE);
< 	{
< 		gchar *message;
< 		message = g_strdup_printf(_("This project contains %d files"), g_list_length(pred->project->files));
< 		gtk_label_set_markup(GTK_LABEL(label), message);
< 		g_free(message);
< 	}
< 	
< 	table = gtk_table_new (5, 4, FALSE);
< 	gtk_table_set_col_spacings (GTK_TABLE (table), 12);
< 	gtk_table_set_row_spacings (GTK_TABLE (table), 6);	
< 	gtk_box_pack_start (GTK_BOX (vbox), table, FALSE, FALSE, 12);
< 	
< 	pred->entries[name] = entry_with_text(pred->project->name, 255);
< 	gtk_widget_set_size_request(GTK_WIDGET(pred->entries[name]), 250, -1);
< 	bf_mnemonic_label_tad_with_alignment(_("Project _Name:"), pred->entries[name], 1, 0.5, table, 0, 1, 0, 1);
< 	gtk_table_attach_defaults(GTK_TABLE(table), pred->entries[name], 2, 3, 0, 1);
< 
< 	pred->entries[basedir] = entry_with_text(pred->project->basedir, 255);
< 	bf_mnemonic_label_tad_with_alignment(_("Base _Dir:"), pred->entries[basedir], 1, 0.5, table, 0, 1, 1, 2);
< 	gtk_table_attach_defaults(GTK_TABLE(table), pred->entries[basedir], 2, 3, 1, 2);
< 
< 	pred->entries[webdir] = entry_with_text(pred->project->webdir, 255);
< 	bf_mnemonic_label_tad_with_alignment(_("_Preview URL:"), pred->entries[webdir], 1, 0.5, table, 0, 1, 2, 3);
< 	gtk_table_attach_defaults(GTK_TABLE(table), pred->entries[webdir], 2, 3, 2, 3);
< 	
< 	pred->entries[template] = entry_with_text(pred->project->template, 255);
< 	bf_mnemonic_label_tad_with_alignment(_("_Template:"), pred->entries[template], 1, 0.5, table, 0, 1, 3, 4);
< 	but = file_but_new(pred->entries[template], 1, NULL);
< 	gtk_table_attach_defaults(GTK_TABLE(table), pred->entries[template], 2, 3, 3, 4);
< 	gtk_table_attach_defaults(GTK_TABLE(table), but, 3, 4, 3, 4);
< 
< 	gtk_table_set_row_spacing(GTK_TABLE(table), 3, 18);
< 	pred->entries[word_wrap] = checkbut_with_value(_("_Word wrap by default"), pred->project->word_wrap);
< 	gtk_table_attach_defaults(GTK_TABLE(table), pred->entries[word_wrap], 0, 3, 4, 5);
< 		
< 	gtk_box_pack_start (GTK_BOX (vbox), gtk_hseparator_new(), FALSE, FALSE, 12);
< 	hbox = gtk_hbutton_box_new();
< 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
< 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 6);
< 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
< 	but = bf_stock_cancel_button(G_CALLBACK(project_edit_cancel_clicked_lcb), pred);
< 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, FALSE, 0);
< 	if (pred->destroy_project_on_close == TRUE) {
< 		but = bf_allbuttons_backend(_("Create _Project"), 1, 0, G_CALLBACK(project_edit_ok_clicked_lcb), pred);
< 	} else {
< 		but = bf_stock_ok_button(G_CALLBACK(project_edit_ok_clicked_lcb), pred);
< 	}
< 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, FALSE, 0);
< 	gtk_widget_grab_default(but);
< 	gtk_widget_show_all(pred->win);
< }
< 
< typedef struct {
< 	GtkWidget *win;
< 	GtkWidget *rad[2];
< 	Tbfwin *bfwin;
< } Tpc;
< 
< static void project_create_destroy_lcb(GtkWidget *widget, Tpc *pc) {
< 	g_free(pc);
< }
< 
< static void project_create_cancel_clicked_lcb(GtkWidget *widget, Tpc *pc) {
< 	gtk_widget_destroy(pc->win);
< }
< 
< static void project_create_ok_clicked_lcb(GtkWidget *widget, Tpc *pc) {
< 	gtk_widget_hide(pc->win);
< 	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(pc->rad[0]))) {
< 		project_edit(pc->bfwin);
< 	} else {
< 		project_edit(NULL);
< 	}
< 	gtk_widget_destroy(pc->win);
< }
< 
< 
< void project_create_gui(Tbfwin *bfwin) {
< 	GtkWidget *vbox, *hbox, *but;
< 	Tpc *pc;
< 	
< 	pc = g_new(Tpc,1);
< 	pc->bfwin = bfwin;
< 	pc->win = window_full2(_("Create project"), GTK_WIN_POS_NONE, 5
< 			, G_CALLBACK(project_create_destroy_lcb), pc, TRUE, NULL);
< 	vbox = gtk_vbox_new(FALSE,0);
< 	gtk_container_add(GTK_CONTAINER(pc->win),vbox);
< 	pc->rad[0] = boxed_radiobut_with_value(_("Create project with currently opened documents"), TRUE, NULL, vbox);
< 	pc->rad[1] = boxed_radiobut_with_value(_("Create empty project"), FALSE, GTK_RADIO_BUTTON(pc->rad[0]), vbox);
< 	hbox = gtk_hbutton_box_new();
< 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
< 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 6);
< 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);
< 	but = bf_stock_cancel_button(G_CALLBACK(project_create_cancel_clicked_lcb), pc);
< 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, TRUE, 0);
< 	but = bf_stock_ok_button(G_CALLBACK(project_create_ok_clicked_lcb), pc);
< 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, TRUE, 0);
< 	gtk_widget_show_all(pc->win);
< }
< 
< void project_menu_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
< 	DEBUG_MSG("project_menu_cb, bfwin=%p, callback_action=%d\n",bfwin,callback_action);
< 	switch (callback_action) {
< 	case 1:
< 		project_open(bfwin);
< 	break;
< 	case 2:
< 		project_save(bfwin, FALSE);
< 	break;
< 	case 3:
< 		project_save(bfwin, TRUE);
< 	break;
< 	case 4:
< 		project_save_and_close(bfwin);
< 	break;
< 	case 5:
< 		project_edit(bfwin);
< 	break;
< 	case 6:
< 		if (bfwin->project) {
< 			project_edit(NULL);
< 		} else {
< 			if (test_only_empty_doc_left(bfwin->documentlist)) {
< 				project_edit(bfwin);
< 			} else {
< 				project_create_gui(bfwin);
< 			}
< 		}
< 	break;
< 	default:
< 		DEBUG_MSG("project_menu_cb, no such callback_action %d\n",callback_action);
< 		exit(54);
< 	break;
< 	}
< }
---
> /* Bluefish HTML Editor
>  * project.c - project functionality
>  *
>  * Copyright (C) 2003-2006 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> /* #define DEBUG */
> 
> #include <gtk/gtk.h>
> #include <stdlib.h>
> #include <string.h>
> #include <unistd.h>    /* unlink() */
> 
> #include "bluefish.h"
> #include "project.h"
> #include "bf_lib.h"
> #include "bookmark.h"
> #include "document.h"
> #include "filebrowser.h"
> #include "gtk_easy.h"
> #include "gui.h"
> #include "menu.h"
> #include "rcfile.h"
> #include "stringlist.h"
> 
> static void free_session(Tsessionvars *session) {
> 	free_stringlist(session->classlist);
> 	free_stringlist(session->colorlist);
> 	free_stringlist(session->targetlist);
> 	free_stringlist(session->urllist);
> 	free_stringlist(session->fontlist);
> 	free_stringlist(session->dtd_cblist);
> 	free_stringlist(session->headerlist);
> 	free_stringlist(session->positionlist);
> 	free_stringlist(session->searchlist);
> 	free_stringlist(session->replacelist);
> 	free_arraylist(session->bmarks);
> 	g_free(session);
> }
> 
> static void project_setup_initial_session(Tsessionvars *session) {
> 	session->view_html_toolbar = main_v->session->view_html_toolbar;
> 	session->view_custom_menu = main_v->session->view_custom_menu;
> 	session->view_main_toolbar = main_v->session->view_main_toolbar;
> 	session->view_left_panel = main_v->session->view_left_panel;
> }
> 
> Tbfwin *project_is_open(gchar *filename) {
> 	GList *tmplist;
> 	tmplist = g_list_first(main_v->bfwinlist);
> 	while(tmplist){
> 		if (BFWIN(tmplist->data)->project 
> 				&& BFWIN(tmplist->data)->project->filename
> 				&& strcmp(BFWIN(tmplist->data)->project->filename, filename)==0) {
> 			return BFWIN(tmplist->data);
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return NULL;
> }
> 
> static void update_project_filelist(Tbfwin *bfwin, Tproject *prj) {
> 	DEBUG_MSG("update_project_filelist, started, bfwin=%p, prj=%p\n",bfwin,prj);
> 	free_stringlist(prj->files);
> 	DEBUG_MSG("update_project_filelist, old list free'd, creating new list from documentlist %p (len=%d)\n",bfwin->documentlist,g_list_length(bfwin->documentlist));
> 	prj->files = return_filenamestringlist_from_doclist(bfwin->documentlist);
> }
> 
> static void setup_bfwin_for_project(Tbfwin *bfwin) {
> 	bfwin->session = bfwin->project->session;
> 	bfwin->bookmarkstore = bfwin->project->bookmarkstore;
> 	bmark_set_store(bfwin);
> 	bmark_reload(bfwin);
> 	filebrowser_set_basedir(bfwin, bfwin->project->basedir);
> 	recent_menu_from_list(bfwin, bfwin->project->session->recent_files, FALSE);
> 	set_project_menu_widgets(bfwin, TRUE);
> }
> 
> /* bfwin is allowed to be NULL for an empty project */
> static Tproject *create_new_project(Tbfwin *bfwin) {
> 	Tproject *prj;
> 	prj = g_new0(Tproject,1);
> 	prj->name = g_strdup(_("New project"));
> 	prj->bookmarkstore = gtk_tree_store_new(2, G_TYPE_STRING, G_TYPE_POINTER); 
> 	DEBUG_MSG("create_new_project, project=%p, bookmarkstore=%p, bfwin=%p\n",prj,prj->bookmarkstore,bfwin);
> 	if (bfwin) {
> 		DEBUG_MSG("create_new_project, new project for bfwin %p\n",bfwin);
> 		update_project_filelist(bfwin,prj);
> 		bfwin->project = prj;
> 	} else {
> 		DEBUG_MSG("create_new_project, new project, no bfwin\n");
> 	}
> 	prj->session = g_new0(Tsessionvars,1);
> 	project_setup_initial_session(prj->session);
> 
> 	/* we should copy bookmarks from the files to this session */
> 	if (bfwin && prj->files) {
> 		GList *tmplist;
> 		tmplist = g_list_first(bfwin->documentlist);
> 		while (tmplist) {
> 			bmark_clean_for_doc(DOCUMENT(tmplist->data));
> 			tmplist = g_list_next(tmplist);
> 		}
> 	
> 		tmplist = g_list_first(bfwin->session->bmarks);
> 		while (tmplist) {
> 			gchar **entry = (gchar**)tmplist->data;
> 			if (count_array(entry) > 2) {
> 				GList *tmplist2 = g_list_first(prj->files);
> 				while (tmplist2) {
> 					if (strcmp(tmplist2->data, entry[2])==0) {
> 						/* move it out of the default session into this session */
> 						bfwin->session->bmarks = g_list_remove_link(bfwin->session->bmarks,tmplist);
> 						prj->session->bmarks = g_list_concat(prj->session->bmarks, tmplist);
> 						/* no further filenames to check */
> 						tmplist2 = g_list_last(tmplist2);
> 					}
> 					tmplist2 = g_list_next(tmplist2);
> 				}
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	if (prj->files) {
> 		gint len;
> 		gchar *somefile, *prefix;
> 		len = find_common_prefixlen_in_stringlist(prj->files);
> 		somefile = (gchar *)prj->files->data;
> 		prefix = g_strndup(somefile, len);
> 		if (prefix[strlen(prefix)-1] == '/') {
> 			prj->basedir = g_strdup(prefix);
> 		} else {
> 			prj->basedir = g_path_get_dirname(prefix);
> 		}
> 		g_free(prefix);
> 	} else {
> 		prj->basedir = g_strdup("");
> 	}
> 	prj->webdir = g_strdup("");
> 	prj->template = g_strdup("");
> 	prj->word_wrap = main_v->props.word_wrap;
> 	if (bfwin) {
> 		setup_bfwin_for_project(bfwin);
> 	}
> 	return prj;
> }
> 
> gboolean project_save(Tbfwin *bfwin, gboolean save_as) {
> 	gboolean retval;
> 	DEBUG_MSG("project_save, bfwin=%p, save_as=%d\n",bfwin,save_as);
> 	if (!bfwin->project) {
> 		/* there is no project yet, we have to create one */
> 		DEBUG_MSG("project_save, bfwin=%p does not have a project yet, create one\n",bfwin);
> 		bfwin->project= create_new_project(bfwin);
>   	   bmark_reload(bfwin);
> 	}
> 	DEBUG_MSG("project_save, project=%p, num files was %d\n", bfwin->project, g_list_length(bfwin->project->files));
> 	update_project_filelist(bfwin, bfwin->project);
> /*	bfwin->project->recentfiles = limit_stringlist(bfwin->project->recentfiles, main_v->props.max_recent_files, TRUE);*/
> 	
> 	bfwin->project->session->searchlist = limit_stringlist(bfwin->project->session->searchlist, 10, TRUE);
> 	bfwin->project->session->replacelist = limit_stringlist(bfwin->project->session->replacelist, 10, TRUE);
> 	bfwin->project->session->urllist = limit_stringlist(bfwin->project->session->urllist, 10, TRUE);
> 	bmark_store_all(bfwin);
> 
> 	if (save_as || bfwin->project->filename == NULL) {
> 		gint suflen,filen;
> 		gchar *filename = NULL;
> #ifdef HAVE_ATLEAST_GTK_2_4
> 		{
> 			GtkWidget *dialog;
> /*			dialog = gtk_file_chooser_dialog_new(_("Enter Bluefish project filename"),NULL,
> 					GTK_FILE_CHOOSER_ACTION_OPEN,
> 					GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
> 					GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT,
> 					NULL);*/
> 			dialog = file_chooser_dialog(bfwin,_("Enter Bluefish project filename"),GTK_FILE_CHOOSER_ACTION_SAVE, NULL, TRUE, FALSE, "bfproject");
> 			if (gtk_dialog_run(GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
> 				filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
> 			}
> 			gtk_widget_destroy(dialog);
> 		}
> #else
> 		filename = return_file_w_title(NULL, _("Enter Bluefish project filename"));
> #endif
> 		if (!filename) {
> 			return FALSE;
> 		}
> 		if (save_as || bfwin->project->filename == NULL) {
> 			gchar *ondiskencoding = get_filename_on_disk_encoding(filename);
> 			if (g_file_test(ondiskencoding, G_FILE_TEST_EXISTS)) {
> 				gchar *tmpstr;
> 				gint retval;
> 				gchar *options[] = {_("_Cancel"), _("_Overwrite"), NULL};
> 				tmpstr = g_strdup_printf(_("A file named \"%s\" already exists."), filename);
> 				retval = multi_warning_dialog(bfwin->main_window,tmpstr, 
> 												_("Do you want to replace the existing file?"), 1, 0, options);
> 				g_free(tmpstr);
> 				if (retval == 0) {
> 					g_free(filename);
> 					g_free(ondiskencoding);
> 					return FALSE;
> 				}
> 			}
> 			g_free(ondiskencoding);
> 		}
> 		suflen = strlen(main_v->props.project_suffix);
> 		filen = strlen(filename);
> 		if (filen > suflen && strcmp(&filename[filen - suflen], main_v->props.project_suffix)==0) {
> 			bfwin->project->filename = filename;
> 		} else {
> 			bfwin->project->filename = g_strconcat(filename, main_v->props.project_suffix,NULL);
> 			g_free(filename);
> 		}
> 	}
> 	
> 	DEBUG_MSG("project_save, saving project %p to file %s\n",bfwin->project,bfwin->project->filename);
> 	retval = rcfile_save_project(bfwin->project, bfwin->project->filename);
> 	add_to_recent_list(bfwin,bfwin->project->filename, FALSE, TRUE);
> 	return retval;
> }
> 
> void set_project_menu_widgets(Tbfwin *bfwin, gboolean win_has_project) {
> 	menuitem_set_sensitive(bfwin->menubar, "/Project/Save", win_has_project);
> 	menuitem_set_sensitive(bfwin->menubar, "/Project/Save as...", win_has_project);
> 	menuitem_set_sensitive(bfwin->menubar, "/Project/Save & close", win_has_project);
> 	menuitem_set_sensitive(bfwin->menubar, "/Project/Edit Project Options...", win_has_project);
> }
> 
> void project_open_from_file(Tbfwin *bfwin, gchar *fromfilename) {
> 	Tbfwin *prwin;
> 	Tproject *prj;
> 	gboolean retval;
> 
> 	/* first we test if the project is already open */
> 	prwin = project_is_open(fromfilename);
> 	if (prwin != NULL) {
> 		DEBUG_MSG("project_open_from_file, project is open in bfwin=%p\n",prwin);
> 		gtk_window_present(GTK_WINDOW(prwin->main_window));
> 		return;
> 	}
> 
> 	prj = g_new0(Tproject,1);
> 	prj->session = g_new0(Tsessionvars,1);
> 	project_setup_initial_session(prj->session);
> 	prj->bookmarkstore = gtk_tree_store_new(2, G_TYPE_STRING, G_TYPE_POINTER); 
> 	retval = rcfile_parse_project(prj, fromfilename);
> 	if (!retval) {
> 		DEBUG_MSG("project_open_from_file, failed parsing the project at file %s\n",fromfilename);
> 		g_object_unref(prj->bookmarkstore);
> 		g_free(prj->session);
> 		g_free(prj);
> 		return;
> 	}
> 	add_to_recent_list(bfwin,fromfilename, FALSE, TRUE);
> 	prj->filename = g_strdup(fromfilename);
> 	DEBUG_MSG("project_open_from_file, basedir=%s\n",prj->basedir);
> 	if (bfwin->project == NULL && test_only_empty_doc_left(bfwin->documentlist)) {
> 		/* we will use this Bluefish window to open the project */
> 		prwin = bfwin;
> 		/* now we need to clean the session, and reset it to the session from the project */
> 		/* free_session(bfwin->session); there is no session specific to a window anymore, only a global one*/
> 		bfwin->session = prj->session;
> 		prwin->project = prj;
> 		prwin->bookmarkstore = prj->bookmarkstore;
> 		
>       gui_set_html_toolbar_visible(prwin, prj->session->view_html_toolbar, TRUE);
>       gui_set_main_toolbar_visible(prwin, prj->session->view_main_toolbar, TRUE);
>       gui_set_custom_menu_visible(prwin, prj->session->view_custom_menu, TRUE);
> 		DEBUG_MSG("project_open_from_file, calling left_panel_show_hide_toggle bfwin=%p\n",prwin);
> 		left_panel_show_hide_toggle(prwin,FALSE,prj->session->view_left_panel, TRUE);
> 		filebrowser_set_basedir(prwin, prj->basedir);
> 		DEBUG_MSG("project_open_from_file, calling docs_new_from_files for existing bfwin=%p\n",prwin);
> 		docs_new_from_files(prwin, prj->files, TRUE);
> 	} else {
> 		/* we will open a new Bluefish window for this project */
> 		DEBUG_MSG("project_open_from_file, we need a new window\n");
> 		prwin = gui_new_window(prj->files, prj);
> 		DEBUG_MSG("project_open_from_file, new window with files ready\n");
> 		gui_set_title(prwin, prwin->current_document);
> 	}
> 
> 	set_project_menu_widgets(prwin, TRUE);
> 	recent_menu_init_project(prwin);
>    bmark_reload(bfwin);
>    bmark_set_store(bfwin);
> }
> 
> static void project_open(Tbfwin *bfwin) {
> 	/* first we ask for a filename */
> 	gchar *filename = NULL;
> #ifdef HAVE_ATLEAST_GTK_2_4
> 	{
> 		GtkWidget *dialog;
> 		/*dialog = gtk_file_chooser_dialog_new(_("Select Bluefish project filename"),NULL,
> 				GTK_FILE_CHOOSER_ACTION_OPEN,
> 				GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
> 				GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
> 				NULL);*/
> 		dialog = file_chooser_dialog(bfwin, _("Select Bluefish project filename"), GTK_FILE_CHOOSER_ACTION_OPEN, NULL, TRUE, FALSE, "bfproject");
> 		if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
> 			filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
> 		}
> 		gtk_widget_destroy(dialog);
> 	}
> #else
> 	filename = return_file_w_title(NULL, _("Select Bluefish project filename"));
> #endif
> 	if (filename) {
> 		DEBUG_MSG("project_open, for filename %s\n",filename);
> 		project_open_from_file(bfwin,filename);
> 		g_free(filename);
> 	} else {
> 		DEBUG_MSG("project_open, no filename.., returning\n");
> 	}
> }
> 
> static void project_destroy(Tproject *project) {
> 	g_object_unref(G_OBJECT(project->bookmarkstore));
> 	free_stringlist(project->files);
> 	free_session(project->session);
> 	g_free(project->filename);
> 	g_free(project->name);
> 	g_free(project->basedir);
> 	g_free(project->webdir);
> 	g_free(project->template);
> 	g_free(project);
> }
> 
> static void setup_bfwin_for_nonproject(Tbfwin *bfwin) {
> 	bfwin->session = main_v->session;
> 	bfwin->bookmarkstore = main_v->bookmarkstore;
> 	bfwin->project = NULL;
> 	bmark_set_store(bfwin);
> 	gui_set_title(bfwin, bfwin->current_document);
> 	filebrowser_set_basedir(bfwin, NULL);
> 	recent_menu_from_list(bfwin, main_v->session->recent_files, FALSE);
> 	set_project_menu_widgets(bfwin, FALSE);
> }
> 
> /* 
>  * returns TRUE if the project is closed, 
>  * returns FALSE if something went wrong or was cancelled
>  */
> gboolean project_save_and_close(Tbfwin *bfwin) {
> 	gboolean dont_save = FALSE;
> 	while (!bfwin->project->filename) {
> 		gchar *text;
> 		gint retval;
> 		gchar *buttons[] = {_("Do_n't save"), GTK_STOCK_CANCEL, GTK_STOCK_SAVE, NULL};
> 		if (dont_save) {
> 			break;
> 		}
> 		DEBUG_MSG("project_save_and_close, project not named, getting action\n");
> 		/* dialog */
> 
> 		text = g_strdup(_("Do you want to save the project?"));
> 		retval = multi_query_dialog(bfwin->main_window, text, 
> 			_("If you don't save your changes they will be lost."), 2, 1, buttons);
> 		switch (retval) {
> 		case 0:
> 			/* don't save proj. save files, though */
> 			DEBUG_MSG("project_save_and_close, don't save project, but save files\n");
> 			dont_save = TRUE;
> 		break;
> 		case 1:
> 			/* cancel */
> 			DEBUG_MSG("project_save_and_close, not closing window any more");
> 			return FALSE;
> 		break;
> 		case 2:
> 			DEBUG_MSG("project_save_and_close, bringing up save project dialog\n");
> 			dont_save = project_save(bfwin, FALSE);
> 		break;
> 		default:
> 		break;
> 		}		
> 	}
> 	/* test if we should save */
> 	if (!dont_save) {
> 		gchar *backupfile = NULL;
> 		if (!project_save(bfwin, FALSE)) {
> 			DEBUG_MSG("project_save failed, returning\n");
> 			return FALSE;
> 		}
> 		add_to_recent_list(bfwin,bfwin->project->filename, TRUE, TRUE);
> 		
>         if (main_v->props.backup_cleanuponclose) {
>             backupfile = g_strconcat (bfwin->project->filename, main_v->props.backup_filestring, NULL);
>             if (file_exists_and_readable(backupfile)) {
>                 gchar * ondiskencodingbckup = get_filename_on_disk_encoding(backupfile);
> #ifdef HAVE_GNOME_VFS
>                 gnome_vfs_unlink(ondiskencodingbckup);
> #else
> 		        unlink(ondiskencodingbckup);				
> #endif
>                 g_free (ondiskencodingbckup);
>             }
>             g_free (backupfile);
>         }
> 	}
> 	bfwin_close_all_documents(bfwin, TRUE);
> 	if (!test_only_empty_doc_left(bfwin->documentlist)) {
> 		DEBUG_MSG("closing all documents failed, returning\n");
> 		return FALSE;
> 	}
> 	project_destroy(bfwin->project);
> 	setup_bfwin_for_nonproject(bfwin);
> 	DEBUG_MSG("project_save_and_close, returning TRUE\n");
> 	return TRUE;
> }
> 
> typedef enum {
> 	name,
> 	basedir,
> 	webdir,
> 	template,
> 	word_wrap,
> 	projecteditor_entries_num
> } Tprojecteditor_entries;
> 
> typedef struct {
> 	GtkWidget *win;
> 	Tbfwin *bfwin;
> 	Tproject *project;
> 	GtkWidget *entries[projecteditor_entries_num];
> 	gboolean destroy_project_on_close;
> } Tprojecteditor;
> 
> static void project_edit_destroy_lcb(GtkWidget *widget, Tprojecteditor *pred) {
> 	DEBUG_MSG("project_edit_destroy_lcb, called for pred=%p\n",pred);
> /*	gtk_widget_destroy(pred->win);*/
> 	if (pred->destroy_project_on_close) {
> 		project_destroy(pred->project);
> 		if (pred->bfwin) {
> 			setup_bfwin_for_nonproject(pred->bfwin);
> 		}
> 	}
> 	if (pred->project) {
> 		pred->project->editor = NULL;
> 	}
> 	g_free(pred);
> }
> 
> static void project_edit_cancel_clicked_lcb(GtkWidget *widget, Tprojecteditor *pred) {
> 	gtk_widget_destroy(pred->win);
> }
> 
> static void project_edit_ok_clicked_lcb(GtkWidget *widget, Tprojecteditor *pred) {
> 	Tproject *prj = pred->project;
> 	
> 	pred->destroy_project_on_close = FALSE;
> 	
> 	gtk_widget_hide(pred->win);
> 	DEBUG_MSG("project_edit_ok_clicked_lcb, Tproject at %p, bfwin at %p\n",prj,pred->bfwin);
> 	string_apply(&prj->name, pred->entries[name]);
> 	string_apply(&prj->basedir, pred->entries[basedir]);
> 	if (prj->basedir && strlen(prj->basedir)) {
> 		gchar *tmp = prj->basedir;
> 		prj->basedir = ending_slash(prj->basedir);
> 		g_free(tmp);
> 	}
> 	string_apply(&prj->webdir, pred->entries[webdir]);
> 	string_apply(&prj->template, pred->entries[template]);
> 	integer_apply(&prj->word_wrap, pred->entries[word_wrap], TRUE);
> 	DEBUG_MSG("project_edit_ok_clicked_lcb, name=%s, basedir=%s, webdir=%s\n",prj->name,prj->basedir,prj->webdir);
> 
> 	if (pred->bfwin == NULL) {
> 		pred->bfwin = gui_new_window(NULL, pred->project);
> 	} else {
> 		gui_set_title(pred->bfwin, pred->bfwin->current_document);
> 	}
> 	setup_bfwin_for_project(pred->bfwin);
> /* set_project_menu_widgets(pred->bfwin, TRUE);*/
> 	project_save(pred->bfwin,FALSE);
> 	gtk_widget_destroy(pred->win);
> }
> 
> /*
> if NULL is passed as bfwin, a new window will be created for this project once OK is clicked
> */
> void project_edit(Tbfwin *bfwin) {
> 	GtkWidget *vbox, *but, *hbox, *label, *table;
> 	gchar *wintitle = NULL;
> 	Tprojecteditor *pred;
> 
> 	if (bfwin && bfwin->project && bfwin->project->editor) {
> 		gtk_window_present(GTK_WINDOW(((Tprojecteditor *)bfwin->project->editor)->win));
> 		return;
> 	}
> 	pred = g_new(Tprojecteditor,1);
> 	if (!bfwin || !bfwin->project) {
> 		/* there is no project yet, we have to create one */
> 		DEBUG_MSG("project_edit, no project yet, create one\n");
> 		pred->project= create_new_project(bfwin);
> 		if (bfwin) {
> 			bfwin->project = pred->project;
> 		}
> 		/* id the user does not press OK, we destroy the project */
> 		pred->destroy_project_on_close = TRUE;
> 		wintitle = g_strdup(_("Create New Project"));
> 	} else {
> 		pred->destroy_project_on_close = FALSE;
> 		wintitle = g_strdup(_("Edit Project"));
> 		if (bfwin) {
> 			pred->project = bfwin->project;
> 		}
> 	}
> 	DEBUG_MSG("project_edit, Tproject at %p\n",pred->project);
> 	pred->bfwin = bfwin;
> 	pred->project->editor = pred;
> 	
> 	pred->win = window_full2(wintitle, GTK_WIN_POS_CENTER_ALWAYS, 5
> 			, G_CALLBACK(project_edit_destroy_lcb), pred, TRUE, NULL);
> 	vbox = gtk_vbox_new(FALSE,0);
> 	gtk_container_add(GTK_CONTAINER(pred->win),vbox);
> 	
> 	if (wintitle) {
> 		g_free(wintitle);
> 	}
> 	
> 	label = gtk_label_new(NULL);
> 	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, TRUE, 0);
> 	gtk_label_set_line_wrap(GTK_LABEL(label),TRUE);
> 	{
> 		gchar *message;
> 		message = g_strdup_printf(_("This project contains %d files"), g_list_length(pred->project->files));
> 		gtk_label_set_markup(GTK_LABEL(label), message);
> 		g_free(message);
> 	}
> 	
> 	table = gtk_table_new (5, 4, FALSE);
> 	gtk_table_set_col_spacings (GTK_TABLE (table), 12);
> 	gtk_table_set_row_spacings (GTK_TABLE (table), 6);	
> 	gtk_box_pack_start (GTK_BOX (vbox), table, FALSE, FALSE, 12);
> 	
> 	pred->entries[name] = entry_with_text(pred->project->name, 255);
> 	gtk_widget_set_size_request(GTK_WIDGET(pred->entries[name]), 250, -1);
> 	bf_mnemonic_label_tad_with_alignment(_("Project _Name:"), pred->entries[name], 1, 0.5, table, 0, 1, 0, 1);
> 	gtk_table_attach_defaults(GTK_TABLE(table), pred->entries[name], 2, 3, 0, 1);
> 
> 	pred->entries[basedir] = entry_with_text(pred->project->basedir, 255);
> 	bf_mnemonic_label_tad_with_alignment(_("Base _Dir:"), pred->entries[basedir], 1, 0.5, table, 0, 1, 1, 2);
> 	gtk_table_attach_defaults(GTK_TABLE(table), pred->entries[basedir], 2, 3, 1, 2);
> 
> 	pred->entries[webdir] = entry_with_text(pred->project->webdir, 255);
> 	bf_mnemonic_label_tad_with_alignment(_("_Preview URL:"), pred->entries[webdir], 1, 0.5, table, 0, 1, 2, 3);
> 	gtk_table_attach_defaults(GTK_TABLE(table), pred->entries[webdir], 2, 3, 2, 3);
> 	
> 	pred->entries[template] = entry_with_text(pred->project->template, 255);
> 	bf_mnemonic_label_tad_with_alignment(_("_Template:"), pred->entries[template], 1, 0.5, table, 0, 1, 3, 4);
> 	but = file_but_new(pred->entries[template], 1, NULL);
> 	gtk_table_attach_defaults(GTK_TABLE(table), pred->entries[template], 2, 3, 3, 4);
> 	gtk_table_attach_defaults(GTK_TABLE(table), but, 3, 4, 3, 4);
> 
> 	gtk_table_set_row_spacing(GTK_TABLE(table), 3, 18);
> 	pred->entries[word_wrap] = checkbut_with_value(_("_Word wrap by default"), pred->project->word_wrap);
> 	gtk_table_attach_defaults(GTK_TABLE(table), pred->entries[word_wrap], 0, 3, 4, 5);
> 		
> 	gtk_box_pack_start (GTK_BOX (vbox), gtk_hseparator_new(), FALSE, FALSE, 12);
> 	hbox = gtk_hbutton_box_new();
> 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
> 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 6);
> 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
> 	but = bf_stock_cancel_button(G_CALLBACK(project_edit_cancel_clicked_lcb), pred);
> 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, FALSE, 0);
> 	if (pred->destroy_project_on_close == TRUE) {
> 		but = bf_allbuttons_backend(_("Create _Project"), 1, 0, G_CALLBACK(project_edit_ok_clicked_lcb), pred);
> 	} else {
> 		but = bf_stock_ok_button(G_CALLBACK(project_edit_ok_clicked_lcb), pred);
> 	}
> 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, FALSE, 0);
> 	gtk_widget_grab_default(but);
> 	gtk_widget_show_all(pred->win);
> }
> 
> typedef struct {
> 	GtkWidget *win;
> 	GtkWidget *rad[2];
> 	Tbfwin *bfwin;
> } Tpc;
> 
> static void project_create_destroy_lcb(GtkWidget *widget, Tpc *pc) {
> 	g_free(pc);
> }
> 
> static void project_create_cancel_clicked_lcb(GtkWidget *widget, Tpc *pc) {
> 	gtk_widget_destroy(pc->win);
> }
> 
> static void project_create_ok_clicked_lcb(GtkWidget *widget, Tpc *pc) {
> 	gtk_widget_hide(pc->win);
> 	if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(pc->rad[0]))) {
> 		project_edit(pc->bfwin);
> 	} else {
> 		project_edit(NULL);
> 	}
> 	gtk_widget_destroy(pc->win);
> }
> 
> 
> void project_create_gui(Tbfwin *bfwin) {
> 	GtkWidget *vbox, *hbox, *but;
> 	Tpc *pc;
> 	
> 	pc = g_new(Tpc,1);
> 	pc->bfwin = bfwin;
> 	pc->win = window_full2(_("Create project"), GTK_WIN_POS_NONE, 5
> 			, G_CALLBACK(project_create_destroy_lcb), pc, TRUE, NULL);
> 	vbox = gtk_vbox_new(FALSE,0);
> 	gtk_container_add(GTK_CONTAINER(pc->win),vbox);
> 	pc->rad[0] = boxed_radiobut_with_value(_("Create project with currently opened documents"), TRUE, NULL, vbox);
> 	pc->rad[1] = boxed_radiobut_with_value(_("Create empty project"), FALSE, GTK_RADIO_BUTTON(pc->rad[0]), vbox);
> 	hbox = gtk_hbutton_box_new();
> 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
> 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 6);
> 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);
> 	but = bf_stock_cancel_button(G_CALLBACK(project_create_cancel_clicked_lcb), pc);
> 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, TRUE, 0);
> 	but = bf_stock_ok_button(G_CALLBACK(project_create_ok_clicked_lcb), pc);
> 	gtk_box_pack_start(GTK_BOX(hbox), but, FALSE, TRUE, 0);
> 	gtk_widget_show_all(pc->win);
> }
> 
> void project_menu_cb(Tbfwin *bfwin,guint callback_action, GtkWidget *widget) {
> 	DEBUG_MSG("project_menu_cb, bfwin=%p, callback_action=%d\n",bfwin,callback_action);
> 	switch (callback_action) {
> 	case 1:
> 		project_open(bfwin);
> 	break;
> 	case 2:
> 		project_save(bfwin, FALSE);
> 	break;
> 	case 3:
> 		project_save(bfwin, TRUE);
> 	break;
> 	case 4:
> 		project_save_and_close(bfwin);
> 	break;
> 	case 5:
> 		project_edit(bfwin);
> 	break;
> 	case 6:
> 		if (bfwin->project) {
> 			project_edit(NULL);
> 		} else {
> 			if (test_only_empty_doc_left(bfwin->documentlist)) {
> 				project_edit(bfwin);
> 			} else {
> 				project_create_gui(bfwin);
> 			}
> 		}
> 	break;
> 	default:
> 		DEBUG_MSG("project_menu_cb, no such callback_action %d\n",callback_action);
> 		exit(54);
> 	break;
> 	}
> }
1,1063c1,968
< /* Bluefish HTML Editor
<  * rcfile.c - loading and parsing of the configfiles
<  *
<  * Copyright (C) 2000-2005 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< /* #define DEBUG */
< 
< #include <gtk/gtk.h>
< #include <sys/stat.h>
< #include <sys/types.h>
< #include <unistd.h>
< #include <fcntl.h>
< #include <errno.h>
< #include <string.h>
< #include <stdlib.h>
< #include <stdio.h>
< #include <time.h>
< 
< #include "bf_lib.h"
< #include "bluefish.h"
< #include "document.h"       /* DOCUMENT_BACKUP_ABORT_ASK */
< #include "fref.h"
< #include "highlight.h"      /* hl_reset_to_default()*/
< #include "rcfile.h"
< #include "stringlist.h"
< 
< typedef struct {
< 	void *pointer;      /* where should the value be stored? */
< 	unsigned char type; /* a=arraylist, l=stringlist, s=string, e=string with escape, i=integer, m=limiTed stringlist */
< 	gchar *identifier;  /* the string that should be in the config file for this entry */
< 	gint len;           /* used for arrays and limitedstringlists, the length the list should have (only during save),
< 	                       or the number of items the array should have (during load) */
< } Tconfig_list_item;
< 
< static GList *main_configlist=NULL;
< static GList *highlighting_configlist=NULL;
< static GList *custom_menu_configlist=NULL;
< 
< static void free_configlist(GList *configlist) {
< 	GList *tmplist = g_list_first(configlist);
< 	while(tmplist) {
< 		Tconfig_list_item *cli = tmplist->data;
< 		g_free(cli);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	g_list_free(configlist);
< }
< 
< /*this should add 1 empty entry to the configuration list */
< GList *make_config_list_item(GList * config_list, void *pointer_to_var, unsigned char type_of_var, gchar * name_of_var, gint len)
< {
< 	Tconfig_list_item *config_list_item;
< 	if (!pointer_to_var) {
< 		DEBUG_MSG("make_config_list_item, pointer to var = NULL !\n");
< 		return config_list;
< 	}
< 	config_list_item = g_malloc(sizeof(Tconfig_list_item));
< 	config_list_item->pointer = pointer_to_var;
< 	config_list_item->type = type_of_var;
< 	config_list_item->identifier = name_of_var;
< 	config_list_item->len = len;
< 	return (GList *) g_list_append(config_list, config_list_item);
< }
< 
< static void init_prop_integer(GList ** config_list, void *pointer_to_var, gchar * name_of_var, gint default_value, gboolean set_default)
< {
< 	*config_list = make_config_list_item(*config_list, pointer_to_var, 'i', name_of_var, 0);
< 	if (set_default) *(gint *)pointer_to_var = default_value;
< }
< 
< static void init_prop_string(GList ** config_list, void *pointer_to_var, gchar * name_of_var, const gchar * default_value)
< {
< 	*config_list = make_config_list_item(*config_list, pointer_to_var, 's', name_of_var, 0);
< 	if (*(gchar **) pointer_to_var == NULL) {
< 		*(gchar **) pointer_to_var = g_strdup(default_value);
< 	}
< 	DEBUG_MSG("init_prop_string, name_of_var=%s, default_value=%s, current value=%s\n", name_of_var, default_value, *(gchar **) pointer_to_var);
< }
< 
< static void init_prop_string_with_escape(GList ** config_list, void *pointer_to_var, gchar * name_of_var, gchar * default_value)
< {
< 	*config_list = make_config_list_item(*config_list, pointer_to_var, 'e', name_of_var, 0);
< 	if (*(gchar **) pointer_to_var == NULL && default_value) {
< 		*(gchar **) pointer_to_var = unescape_string(default_value, FALSE);
< 	}
< 	DEBUG_MSG("init_prop_string, name_of_var=%s, default_value=%s\n", name_of_var, default_value);
< }
< 
< static void init_prop_stringlist(GList ** config_list, void *pointer_to_var, gchar * name_of_var, gboolean setNULL)
< {
< 	*config_list = make_config_list_item(*config_list, pointer_to_var, 'l', name_of_var, 0);
< 	if (setNULL) {
< 	 	pointer_to_var = NULL;
< 	}
< }
< 
< static void init_prop_arraylist(GList ** config_list, void *pointer_to_var, gchar * name_of_var, gint len, gboolean setNULL)
< {
< 	*config_list = make_config_list_item(*config_list, pointer_to_var, 'a', name_of_var, len);
< 	if (setNULL) {
< 	 	pointer_to_var = NULL;
< 	}
< }
< 
< static void init_prop_limitedstringlist(GList ** config_list, void *pointer_to_var, gchar * name_of_var, gint len, gboolean setNULL)
< {
< 	*config_list = make_config_list_item(*config_list, pointer_to_var, 'm', name_of_var, len);
< 	if (setNULL) {
< 	 	pointer_to_var = NULL;
< 	}
< }
< 
< static gint save_config_file(GList * config_list, gchar * filename)
< {
< 	gchar *tmpstring = NULL, *tmpstring2;
< 	GList *rclist, *tmplist, *tmplist2;
< 	Tconfig_list_item *tmpitem;
< 
< 	DEBUG_MSG("save_config_file, started\n");
< 
< 	rclist = NULL;
< 
< /* We must first make a list with 1 string per item. */
< 	tmplist = g_list_first(config_list);
< 	while (tmplist != NULL) {
< 		DEBUG_MSG("save_config_file, tmpitem at %p\n", tmplist->data);
< 		tmpitem = tmplist->data;
< 		DEBUG_MSG("save_config_file, identifier=%s datatype %c\n", tmpitem->identifier,tmpitem->type);
< 		switch (tmpitem->type) {
< 		case 'i':
< 			DEBUG_MSG("save_config_file, converting \"%p\" to integer\n", tmpitem);
< 			DEBUG_MSG("save_config_file, converting \"%s %i\"\n", tmpitem->identifier, *(int *) (void *) tmpitem->pointer);
< 
< 			tmpstring = g_strdup_printf("%s %i", tmpitem->identifier, *(int *) (void *) tmpitem->pointer);
< 
< 			DEBUG_MSG("save_config_file, adding %s\n", tmpstring);
< 
< 			rclist = g_list_append(rclist, tmpstring);
< 			break;
< 		case 's':
< 			DEBUG_MSG("save_config_file, converting \"%p\" to string\n", tmpitem);
< 			DEBUG_MSG("save_config_file, converting \"%s %s\"\n", tmpitem->identifier, (gchar *) * (void **) tmpitem->pointer);
< 			if (*(void **) tmpitem->pointer) {
< 				tmpstring = g_strdup_printf("%s %s", tmpitem->identifier, (gchar *) * (void **) tmpitem->pointer);
< 
< 				DEBUG_MSG("save_config_file, adding %s\n", tmpstring);
< 
< 				rclist = g_list_append(rclist, tmpstring);
< 			}
< 			break;
< 		case 'e':
< 			DEBUG_MSG("save_config_file, converting \"%p\"\n", tmpitem);
< 			DEBUG_MSG("save_config_file, converting \"%s %s\"\n", tmpitem->identifier, (gchar *) * (void **) tmpitem->pointer);
< 			if (*(void **) tmpitem->pointer) {
< 				tmpstring2 = escape_string((gchar*)*(void**)tmpitem->pointer, FALSE);
< 				tmpstring = g_strdup_printf("%s %s", tmpitem->identifier, tmpstring2);
< 
< 				DEBUG_MSG("save_config_file, adding %s\n", tmpstring);
< 
< 				rclist = g_list_append(rclist, tmpstring);
< 				g_free(tmpstring2);
< 			}
< 			break;
< 		case 'l':
< 		case 'm': {
< 			gint max = -1; /* by setting it to -1, it will never become zero if we substract 1 every round */
< 			DEBUG_MSG("save_config_file, type %c, tmpitem(%p), &tmpitem=%p\n", tmpitem->type, tmpitem, &tmpitem);
< 			if (tmpitem->type == 'm') max = tmpitem->len;
< 			tmplist2 = g_list_last((GList *) * (void **) tmpitem->pointer);
< 			while (tmplist2 != NULL && max != 0) {
< 				tmpstring2 = (char *) tmplist2->data;
< 				DEBUG_MSG("save_config_file, tmpstring2(%p)=%s\n", tmpstring2, tmpstring2);
< 				tmpstring = g_strdup_printf("%s %s", tmpitem->identifier, tmpstring2);
< 				DEBUG_MSG("save_config_file, tmpstring(%p)=%s\n", tmpstring, tmpstring);
< #ifdef WIN32
< 				/* bf_chrrepl(tmpstring,"\\","/"); */
< #endif /* WIN32 */
< 				rclist = g_list_append(rclist, tmpstring);
< 				tmplist2 = g_list_previous(tmplist2);
< 				max--;
< 			}
< 			} break;
< 		case 'a':
< 			DEBUG_MSG("save_config_file, tmpitem(%p), &tmpitem=%p\n", tmpitem, &tmpitem);
< 			tmplist2 = g_list_last((GList *) * (void **) tmpitem->pointer);
< 			DEBUG_MSG("save_config_file, the tmplist2(%p)\n", tmplist2);
< 			while (tmplist2 != NULL) {
< 				tmpstring2 = array_to_string((char **) tmplist2->data);
< 				tmpstring = g_strdup_printf("%s %s", tmpitem->identifier, tmpstring2);
< 				DEBUG_MSG("save_config_file, tmpstring(%p)=%s\n", tmpstring, tmpstring);
< 				rclist = g_list_append(rclist, tmpstring);
< 				tmplist2 = g_list_previous(tmplist2);
< 				g_free(tmpstring2);
< 			}
< 			break;
< 		default:
< 			break;
< 		}
< 		tmplist = g_list_next(tmplist);
< 
< 	}
< 
< 	put_stringlist(filename, rclist);
< 	free_stringlist(rclist);
< 	return 1;
< }
< 
< static gboolean parse_config_file(GList * config_list, gchar * filename)
< {
< 	gboolean retval = FALSE;
< 	gchar *tmpstring = NULL, *tmpstring2;
< 	gchar **tmparray;
< 	GList *rclist, *tmplist, *tmplist2;
< 	Tconfig_list_item *tmpitem;
< 
< 	DEBUG_MSG("parse_config_file, started\n");
< 
< 	rclist = NULL;
< 	rclist = get_list(filename, rclist,FALSE);
< 	
< 	if (rclist == NULL) {
< 		DEBUG_MSG("no rclist, returning!\n");
< 		return retval;
< 	}
< 
< 	/* empty all variables that have type GList ('l') */
< 	tmplist = g_list_first(config_list);
< 	while (tmplist != NULL) {
< 		tmpitem = (Tconfig_list_item *) tmplist->data;
< 		DEBUG_MSG("parse_config_file, type=%c, identifier=%s\n", tmpitem->type, tmpitem->identifier);
< 		if (tmpitem->type == 'l' || tmpitem->type == 'a') {
< 			DEBUG_MSG("parse_config_file, freeing list before filling it\n");
< 			free_stringlist((GList *) * (void **) tmpitem->pointer);
< 			*(void **) tmpitem->pointer = (GList *)NULL;
< 		}
< 		DEBUG_MSG("parse_config_file, type=%c, identifier=%s\n", tmpitem->type, tmpitem->identifier);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	DEBUG_MSG("parse_config_file, all the type 'l' and 'a' have been emptied\n");
< 	DEBUG_MSG("parse_config_file, length rclist=%d\n", g_list_length(rclist));
< /* And now for parsing every line in the config file, first check if there is a valid identifier at the start. */
< 	tmplist = g_list_first(rclist);
< 	while (tmplist) {
< 		tmpstring = (gchar *) tmplist->data;
< 
< 		if (tmpstring != NULL) {
< 			DEBUG_MSG("parse_config_file, tmpstring=%s\n", tmpstring);
< 			g_strchug(tmpstring);
< 
< 			tmplist2 = g_list_first(config_list);
< 			while (tmplist2) {
< 				tmpitem = (Tconfig_list_item *) tmplist2->data;
< #ifdef DEVELOPMENT
< 				if (!tmpitem || !tmpitem->identifier || !tmpstring) {
< 					g_print("WARNING: almost a problem!\n");
< 				}
< #endif
< 				if (g_strncasecmp(tmpitem->identifier, tmpstring, strlen(tmpitem->identifier)) == 0) {
< 					/* we have found the correct identifier */
< 					retval = TRUE;
< 					DEBUG_MSG("parse_config_file, identifier=%s, string=%s\n", tmpitem->identifier, tmpstring);
< 					/* move pointer past the identifier */
< 					tmpstring += strlen(tmpitem->identifier);
< 					trunc_on_char(tmpstring, '\n');
< 					g_strstrip(tmpstring);
< 
< 					switch (tmpitem->type) {
< 					case 'i':
< 						*(int *) (void *) tmpitem->pointer = atoi(tmpstring);
< 						break;
< 					case 's':
< 						*(void **) tmpitem->pointer = (char *) realloc((char *) *(void **) tmpitem->pointer, strlen(tmpstring) + 1);
< 						strcpy((char *) *(void **) tmpitem->pointer, tmpstring);
< 						break;
< 					case 'e':
< 						tmpstring2 = unescape_string(tmpstring, FALSE); /* I wonder if that should be TRUE */
< 						*(void **) tmpitem->pointer = (char *) realloc((char *) *(void **) tmpitem->pointer, strlen(tmpstring2) + 1);
< 						strcpy((char *) *(void **) tmpitem->pointer, tmpstring2);
< 						g_free(tmpstring2);
< 						break;
< 					case 'l':
< 					case 'm':
< 						tmpstring2 = g_strdup(tmpstring);
< 						* (void **) tmpitem->pointer = g_list_prepend((GList *) * (void **) tmpitem->pointer, tmpstring2);
< 						DEBUG_MSG("parse_config_file, *(void **)tmpitem->pointer=%p\n", *(void **) tmpitem->pointer);
< 						break;
< 					case 'a':
< 						tmparray = string_to_array(tmpstring);
< 						if (tmpitem->len <= 0 || tmpitem->len == count_array(tmparray)) {
< 							* (void **) tmpitem->pointer = g_list_prepend((GList *) * (void **) tmpitem->pointer, tmparray);
< 						} else {
< 							DEBUG_MSG("parse_config_file, not storing array, count_array() != tmpitem->len\n");
< 							g_strfreev(tmparray);
< 						}
< 						DEBUG_MSG("parse_config_file, *(void **)tmpitem->pointer=%p\n", *(void **) tmpitem->pointer);
< 						break;
< 					default:
< 						break;
< 					}
< 					tmplist2 = g_list_last(tmplist2);
< 				}
< 				tmplist2 = g_list_next(tmplist2);
< 			}
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	DEBUG_MSG("parse_config_file, parsed all entries, freeing list read from file\n");	
< 	free_stringlist(rclist);
< 	return retval;
< }
< 
< static GList *props_init_main(GList * config_rc)
< {
< /* these are used in the gtk-2 port already */
< #ifndef NOSPLASH
< 	init_prop_integer   (&config_rc, &main_v->props.show_splash_screen, "show_splash_screen:", 1, TRUE);
< #endif /* #ifndef NOSPLASH */
< 	init_prop_integer   (&config_rc, &main_v->props.show_quickbar_tip, "show_quickbar_tip:", 1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.view_line_numbers, "view_line_numbers:", 1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.filebrowser_show_hidden_files, "fb_show_hidden_f:", 0, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.filebrowser_show_backup_files, "fb_show_backup_f:", 0, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.filebrowser_two_pane_view, "fb_two_pane_view:", 1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.filebrowser_focus_follow, "fb_focus_follow:", 1, TRUE);
< #ifndef WIN32
< 	init_prop_string    (&config_rc, &main_v->props.filebrowser_unknown_icon, "fb_unknown_icon:", PKGDATADIR"icon_unknown.png");
< 	init_prop_string    (&config_rc, &main_v->props.filebrowser_dir_icon, "fb_dir_icon:", PKGDATADIR"icon_dir.png");
< #else
< 	gchar *pkgtmp = g_strdup("");
< 	gchar *pkgtmp2 = g_strdup("");
< 	pkgtmp = g_strconcat(pkgtmp,PKG_DATA_DIR,"icon_unknown.png",NULL);
< 	pkgtmp2 = g_strconcat(pkgtmp,PKG_DATA_DIR,"icon_dir.png",NULL);
< 	init_prop_string    (&config_rc, &main_v->props.filebrowser_unknown_icon, "fb_unknown_icon:", pkgtmp);
< 	init_prop_string    (&config_rc, &main_v->props.filebrowser_dir_icon, "fb_dir_icon:", pkgtmp2);
< 	g_free(pkgtmp);
< 	g_free(pkgtmp2);
< #endif /* not WIN32 */
< 	
< 	init_prop_string    (&config_rc, &main_v->props.editor_font_string, "editor_font_string:", "courier 11");
< 	init_prop_integer   (&config_rc, &main_v->props.editor_tab_width, "editor_tab_width:", 3, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.editor_smart_cursor, "editor_smart_cursor:", 1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.editor_indent_wspaces, "editor_indent_wspaces:", 0, TRUE);
< 	init_prop_string    (&config_rc, &main_v->props.tab_font_string, "tab_font_string:", "");
< 	init_prop_arraylist (&config_rc, &main_v->props.browsers, "browsers:", 2, TRUE);
< 	init_prop_arraylist (&config_rc, &main_v->props.external_commands, "external_commands:", 2, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.highlight_num_lines_count, "highlight_num_lines_count:", 5, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.defaulthighlight, "defaulthighlight:", 1, TRUE);
< #ifdef HAVE_PCRE_UTF8
< 	init_prop_integer   (&config_rc, &main_v->props.highlight_utf8, "highlight_utf8:", 0, TRUE);
< #endif /* HAVE_PCRE_UTF8 */
< 	/* old type filetypes have a different count, they are converted below */
< 	init_prop_arraylist (&config_rc, &main_v->props.filetypes, "filetypes:", 0, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.numcharsforfiletype, "numcharsforfiletype:", 200, TRUE);
< 	init_prop_arraylist (&config_rc, &main_v->props.filefilters, "filefilters:", 3, TRUE);
< 	init_prop_string    (&config_rc, &main_v->props.last_filefilter, "last_filefilter:", "");
< 	init_prop_integer   (&config_rc, &main_v->props.transient_htdialogs, "transient_htdialogs:", 1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.restore_dimensions, "restore_dimensions:", 1, TRUE);	
< 	init_prop_integer   (&config_rc, &main_v->props.left_panel_width, "left_panel_width:", 150, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.left_panel_left, "left_panel_left:", 1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.max_recent_files, "max_recent_files:", 15, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.max_dir_history, "max_dir_history:", 10, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.backup_file,"backup_file:",1, TRUE);
< 	init_prop_string    (&config_rc, &main_v->props.backup_filestring,"backup_filestring:","~");
< 	init_prop_integer   (&config_rc, &main_v->props.backup_abort_action,"backup_abort_action:",DOCUMENT_BACKUP_ABORT_ASK, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.backup_cleanuponclose,"backup_cleanuponclose:",0, TRUE);
< 	init_prop_string    (&config_rc, &main_v->props.image_thumbnailstring, "image_thumbnailstring:", "_thumbnail");
< 	init_prop_string    (&config_rc, &main_v->props.image_thumbnailtype, "image_thumbnailtype:", "png");
< 	init_prop_integer   (&config_rc, &main_v->props.image_thumbnail_refresh_quality,"image_thumbnail_refresh_quality:",1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.image_thumbnailsizing_type,"image_thumbnailsizing_type:",0, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.image_thumbnailsizing_val1,"image_thumbnailsizing_val1:",100, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.image_thumbnailsizing_val2,"image_thumbnailsizing_val2:",100, TRUE);
< 	init_prop_string    (&config_rc, &main_v->props.image_thumnailformatstring,"image_thumnailformatstring:","<a href=\"%r\"><img src=\"%t\" width=\"%x\" height=\"%y\" border=\"0\"></a>");
< 	init_prop_integer   (&config_rc, &main_v->props.allow_multi_instances,"allow_multi_instances:",0, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.modified_check_type,"modified_check_type:",1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.num_undo_levels,"num_undo_levels:",100, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.clear_undo_on_save,"clear_undo_on_save:",0, TRUE);
< 	init_prop_string    (&config_rc, &main_v->props.newfile_default_encoding,"newfile_default_encoding:","UTF-8");
< 	init_prop_arraylist (&config_rc, &main_v->props.encodings, "encodings:", 2, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.auto_set_encoding_meta,"auto_set_encoding_meta:",1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.auto_update_meta_author,"auto_update_meta_author:",1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.auto_update_meta_date,"auto_update_meta_date:",1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.auto_update_meta_generator,"auto_update_meta_generator:",1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.encoding_search_Nbytes, "encoding_search_Nbytes:", 500, TRUE);
< 	init_prop_arraylist (&config_rc, &main_v->props.outputbox, "outputbox:", 7, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.ext_browsers_in_submenu,"ext_browsers_in_submenu:",0, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.ext_commands_in_submenu,"ext_commands_in_submenu:",1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.ext_outputbox_in_submenu,"ext_outputbox_in_submenu:",1, TRUE);
< 	init_prop_arraylist (&config_rc, &main_v->props.reference_files, "reference_files:", 2, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.bookmarks_default_store,"bookmarks_default_store:",1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.bookmarks_filename_mode,"bookmarks_filename_mode:",1, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.document_tabposition,"document_tabposition:",(gint)GTK_POS_BOTTOM, TRUE);
< 	init_prop_integer   (&config_rc, &main_v->props.leftpanel_tabposition,"leftpanel_tabposition:",(gint)GTK_POS_BOTTOM, TRUE);
< 	init_prop_string    (&config_rc, &main_v->props.default_basedir,"default_basedir:",g_get_home_dir());
< 	init_prop_string    (&config_rc, &main_v->props.project_suffix,"project_suffix:",".bfproject");
< #ifdef HAVE_LIBASPELL
< 	init_prop_string(&config_rc, &main_v->props.spell_default_lang, "spell_default_lang:", "en");
< #endif /* HAVE_LIBASPELL */
< 	/* not yet in use */
< 	init_prop_string(&config_rc, &main_v->props.image_editor_cline, "image_editor_command:", "gimp-remote -n \"%s\"&");
< 	init_prop_integer(&config_rc, &main_v->props.allow_dep, "allow_the_use_of_font:", 0, TRUE);
< 	init_prop_integer(&config_rc, &main_v->props.format_by_context, "format_by_context:", 1, TRUE);
< 	init_prop_integer(&config_rc, &main_v->props.xhtml, "use_xhtml:", 0, TRUE);
< 	init_prop_integer(&config_rc, &main_v->props.allow_ruby, "allow_the_use_of_ruby:", 0, TRUE);
< 	init_prop_integer(&config_rc, &main_v->props.force_dtd, "force_an_dtd:", 0, TRUE);
< 	init_prop_integer(&config_rc, &main_v->props.dtd_url, "url_in_dtd:", 0, TRUE);
< 	init_prop_integer(&config_rc, &main_v->props.xml_start, "xml_starting_line:", 0, TRUE);
< 	init_prop_integer(&config_rc, &main_v->props.lowercase_tags, "lowercase_tags:", 1, TRUE);
< 	init_prop_integer(&config_rc, &main_v->props.word_wrap, "word_wrap:", 0, TRUE);
< 	init_prop_integer(&config_rc, &main_v->props.autoindent, "autoindent:", 1, TRUE);
< 	init_prop_integer(&config_rc, &main_v->props.drop_at_drop_pos, "drop_at_drop_position:", 0, TRUE);
< 	init_prop_integer(&config_rc, &main_v->props.link_management, "link_management:", 1, TRUE);
< 	
< #ifdef WITH_MSG_QUEUE
< 	init_prop_integer (&config_rc, &main_v->props.open_in_running_bluefish,"open_in_running_bluefish:",1, TRUE);
< #endif
< #ifdef HAVE_GNOME_VFS
< 	init_prop_integer (&config_rc, &main_v->props.server_zope_compat,"server_zope_compat:", 0, TRUE); 
< #endif
< 	return config_rc;
< }
< 
< /* we save the value in 'days' precision, so we can divide seconds by 24*60*60
< , this way we can store it in a gint (which is the config file precision) */
< #define TIME_T_TO_GINT(time) ((gint)(time / (24*60*60)))
< 
< static gboolean config_file_is_newer(gint lasttime, const gchar *configfile) {
< 	struct stat statbuf;
< 	if(stat(configfile, &statbuf)==0) {
< 		if (TIME_T_TO_GINT(statbuf.st_mtime) >= lasttime) return TRUE;
< 	}
< 	return FALSE;
< }
< 
< /*
< static GList *arraylist_load_defaults(GList *thelist, const gchar *filename, const gchar *name) {
< 	GList *deflist,*tmplist = g_list_first(thelist);
< 	if (name) {
< 		while (tmplist) {
< 			gchar **tmparr = tmplist->data;
< 			if (strcmp(tmparr[0],name)==0) {
< 				GList *todelete = tmplist;
< 				tmplist = g_list_next(tmplist);
< 				if (tmplist) {
< 					g_list_delete_link(tmplist, todelete);
< 					g_strfreev(tmparr);
< 					g_list_free_1(todelete);
< 				} else {
< 					thelist = NULL;
< 					g_strfreev(tmparr);
< 					g_list_free(todelete);
< 				}
< 			} else {
< 				tmplist = g_list_next(tmplist);
< 			}
< 		}
< 	} else {
< 		while (tmplist) {
< 			g_strfreev((gchar **)tmplist->data);
< 			tmplist = g_list_next(tmplist);
< 		}
< 		g_list_free(thelist);
< 		thelist = NULL;
< 	}
< 	if (name) {
< 		deflist = get_list(filename,NULL,TRUE);
< 		tmplist = g_list_first(deflist);
< 		while (tmplist) {
< 			gchar **tmparr = tmplist->data;
< 			DEBUG_MSG("arraylist_load_defaults, testing if %s should be added (requested=%s)\n",tmparr[0],name);
< 			if (strcmp(tmparr[0],name)==0) {
< 				DEBUG_MSG("adding %s to thelist\n",tmparr[0]);
< 				thelist = g_list_append(thelist, duplicate_stringarray(tmparr));
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		free_arraylist(deflist);
< 	} else {
< 		thelist = get_list(filename,NULL,TRUE);
< 	}
< 	return thelist;
< }
< */
< void rcfile_parse_main(void)
< {
< 	gchar *filename;
< 
< 	DEBUG_MSG("rcfile_parse_main, started\n");
< 
< 	/* set the props struct completely empty */
< 	memset(&main_v->props, 0, sizeof(Tproperties));
< 
< 	/*Make the config_rc list ready for filling with data and set default values */
< 	main_configlist = props_init_main(NULL);
< 
< 	filename = g_strconcat(g_get_home_dir(), "/.bluefish/rcfile_v2", NULL);
< 	if (!parse_config_file(main_configlist, filename)) {
< 		/* should we initialize some things ?? */
< 	}
< 	g_free(filename);
< 	/* do some default configuration for the lists */
< 	if (main_v->props.browsers == NULL) {
< 		/* if the user does not have browsers --> set them to defaults values */
< 		gchar **arr;
< #ifndef WIN32
< 		arr = array_from_arglist(_("Galeon"), "galeon -x %s&",NULL);
< 		main_v->props.browsers = g_list_append(main_v->props.browsers,arr);
< 		arr = array_from_arglist(_("Mozilla"), "mozilla -remote 'openURL(%s, new-window)' || mozilla %s&",NULL);
< 		main_v->props.browsers = g_list_append(main_v->props.browsers,arr);
< 		arr = array_from_arglist(_("Opera"), "opera -remote 'openURL(%s,new-window)' || opera %s&",NULL);
< 		main_v->props.browsers = g_list_append(main_v->props.browsers,arr);
< 		arr = array_from_arglist(_("Netscape"), "/usr/lib/netscape/477/communicator/communicator-smotif %s&",NULL);
< 		main_v->props.browsers = g_list_append(main_v->props.browsers,arr);
< 		arr = array_from_arglist(_("Gnome default"), "gnome-moz-remote --newwin %s&",NULL);
< 		main_v->props.browsers = g_list_append(main_v->props.browsers,arr);
< #else
< 		arr = array_from_arglist(_("Firefox"), "C:/Progra~1/Mozill~1/firefox.exe -remote 'openURL(%s, new-tab)' || firefox %s&",NULL);
< 		main_v->props.browsers = g_list_append(main_v->props.browsers,arr);
< 		arr = array_from_arglist(_("Internet Explorer"), "C:/PROGRA~1/INTERN~1/IEXPLORE.EXE %s || iexplore %s",NULL);
< 		main_v->props.browsers = g_list_append(main_v->props.browsers,arr);
< #endif /* WIN32 */
< 	}
< 	{
< #ifndef WIN32
< 		gchar *defaultfile = return_first_existing_filename(PKGDATADIR"encodings.default",
< 											"data/encodings.default",
< 										"../data/encodings.default",NULL);
< #else
< 		gchar *tmp = g_strdup("");
< 		tmp = g_strconcat(tmp,PKG_DATA_DIR,"encodings.default",NULL);
< 		gchar *defaultfile = return_first_existing_filename(tmp,
< 											"data/encodings.default",
< 										"../data/encodings.default",NULL);
< #endif
< 		if (main_v->props.encodings == NULL) {
< 			/* if the user does not have encodings --> set them to defaults values */
< 			if (defaultfile) {
< 				main_v->props.encodings = get_list(defaultfile,NULL,TRUE);
< 			} else {
< #ifndef WIN32				
< 				DEBUG_MSG("Unable to find '"PKGDATADIR"encodings.default'\n");
< #else		
< 			   DEBUG_MSG("Unable to find '%s\n",tmp);
< #endif
< 			}
< 		} else {
< 			if (config_file_is_newer(main_v->globses.lasttime_encodings,defaultfile)) {
< 				main_v->props.encodings = arraylist_load_new_identifiers_from_file(main_v->props.encodings,defaultfile,1);
< 				main_v->globses.lasttime_encodings = TIME_T_TO_GINT(time(NULL));
< 			}
< 		}
< #ifdef WIN32
< 		g_free(tmp);
< #endif
< 		g_free(defaultfile);
< 	}
< 	if (main_v->props.outputbox==NULL) {
< 		/* if the user does not have outputbox settings --> set them to defaults values */
< 		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(_("make"),"([a-zA-Z0-9/_.-]+):([0-9]+):(.*)","1","2","3","make","1",NULL));
< 		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(_("weblint HTML checker"),"([a-zA-Z0-9/_.-]+) \\(([0-9:]+)\\) (.*)","1","2","3","weblint '%s'","0",NULL));
< 		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(_("tidy HTML validator"),"line ([0-9]+) column [0-9]+ - (.*)","-1","1","2","tidy -qe '%s'","0",NULL));
< 		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(_("javac"),"([a-zA-Z0-9/_.-]+):([0-9]+):(.*)","1","2","3","javac '%s'","0",NULL));
< 		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(_("xmllint XML checker"),"([a-zA-Z0-9/_.-]+)\\:([0-9]+)\\: (.*)","1","2","3","xmllint --noout --valid '%s'","0",NULL));
< 		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(_("php"),"(.*) in (/[a-zA-Z0-9/_.-]+) on line ([0-9]+)","1","2","3","php '%s'","0",NULL));
< /*		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(,NULL)); */
< 	}
< 	if (main_v->props.external_commands == NULL) {
< 		/* if the user does not have external commands --> set them to defaults values */
< 		gchar **arr;
< 		arr = array_from_arglist(_("Dos2Unix filter"), "cat '%s' | dos2unix > '%f'",NULL);
< 		main_v->props.external_commands = g_list_append(main_v->props.external_commands,arr);
< 		arr = array_from_arglist(_("Tidy cleanup filter"), "cat '%s' | tidy -utf8 -q >'%f' 2>/dev/null",NULL);
< 		main_v->props.external_commands = g_list_append(main_v->props.external_commands,arr);
< 	}
< 	{
< #ifndef WIN32
< 		gchar *defaultfile = return_first_existing_filename(PKGDATADIR"filetypes.default",
< 									"data/filetypes.default",
< 									"../data/filetypes.default",NULL);
< #else
< 		gchar *tmp = g_strdup("");
< 		tmp = g_strconcat(tmp,PKG_DATA_DIR,"filetypes.default",NULL);
< 		gchar *defaultfile = return_first_existing_filename(PKG_DATA_DIR,
< 									"data/filetypes.default",
< 									"../data/filetypes.default",NULL);
< #endif
< 		if (main_v->props.filetypes == NULL) {
< 			/* if the user does not have file-types --> set them to defaults values */
< 			if (defaultfile) {
< 				main_v->props.filetypes = get_list(defaultfile,NULL,TRUE);
< 			} else {
< #ifndef WIN32				
< 				g_print("Unable to find '"PKGDATADIR"filetypes.default'\n");
< #else
< 				g_print("Unable to find'%s\n",tmp);
< #endif
< 			}
< 		} else {
< 			if (config_file_is_newer(main_v->globses.lasttime_filetypes,defaultfile)) {
< 				main_v->props.filetypes = arraylist_load_new_identifiers_from_file(main_v->props.filetypes,defaultfile,1);
< 				main_v->globses.lasttime_filetypes = TIME_T_TO_GINT(time(NULL));
< 			}
< 		}
< #ifdef WIN32		
< 		g_free(tmp);
< #endif
< 		g_free(defaultfile);
< 	}
< 	if (main_v->props.filefilters == NULL) {
< 		/* if the user does not have file filters --> set them to defaults values */
< 		gchar **arr;
< 		arr = array_from_arglist(_("C programming"),"1","c:image", NULL);
< 		main_v->props.filefilters = g_list_append(main_v->props.filefilters, arr);
< 		arr = array_from_arglist(_("All web files"),"1", "html:php:webimage:xml:javascript:stylesheet:jsp", NULL);
< 		main_v->props.filefilters = g_list_append(main_v->props.filefilters, arr);
< 		arr = array_from_arglist(_("Java programming"),"1", "java:image:jsp", NULL);
< 		main_v->props.filefilters = g_list_append(main_v->props.filefilters, arr);
< 		arr = array_from_arglist(_("Images"),"1", "image", NULL);
< 		main_v->props.filefilters = g_list_append(main_v->props.filefilters, arr);
< 		arr = array_from_arglist(_("Hide objectfiles"),"0", "objectfile", NULL);
< 		main_v->props.filefilters = g_list_append(main_v->props.filefilters, arr);
< 	}
< 	if (main_v->props.reference_files == NULL) {
< 		gchar *userdir = g_strconcat(g_get_home_dir(), "/.bluefish/", NULL);
< 		/* if the user does not yet have any function reference files, set them to default values */
< #ifndef WIN32		
< 		fref_rescan_dir(PKGDATADIR);
< #else
< 		fref_rescan_dir(PKG_DATA_DIR);
< #endif 
< 		fref_rescan_dir(userdir);
< 		g_free(userdir);
< 	}
< 	/* for backwards compatibility with old filetypes, 
< 		before version 0.10 had length 4, 
< 		before version 0.13 had length 6 */
< 	{
< 		GList *tmplist = g_list_first(main_v->props.filetypes);
< 		while (tmplist) {
< 			gchar **orig = (gchar **)tmplist->data;
< 			if (count_array(orig)==4) {
< 				gchar **new = array_from_arglist(orig[0], orig[1], orig[2], orig[3], "1", "", "1", NULL);
< 				tmplist->data = new;
< 				g_strfreev(orig);
< 			}
< 			if (count_array(orig)==6) {
< 				gchar **new = array_from_arglist(orig[0], orig[1], orig[2], orig[3], orig[4], orig[5], "0", NULL);
< 				tmplist->data = new;
< 				if (strcmp(orig[0], "xml")==0) {
< 					new[6][0] = '1';
< 				} else if (strcmp(orig[0], "html")==0 || strcmp(orig[0], "php")==0 || strcmp(orig[0], "jsp")==0 || strcmp(orig[0], "cfml")==0) {
< 					new[6][0] = '2';
< 				}
< 				g_strfreev(orig);
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< }
< 
< static gint rcfile_save_main(void) {
< 	gchar *filename = g_strconcat(g_get_home_dir(), "/.bluefish/rcfile_v2", NULL);
< 	return save_config_file(main_configlist, filename);
< }
< /*
< static gboolean arraylist_test_identifier_exists(GList *arrlist, const gchar *name) {
< 	GList *tmplist = g_list_first(arrlist);
< 	while(tmplist) {
< 		if (strcmp(name, ((gchar **)(tmplist->data))[0])==0) {
< 			return TRUE;
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return FALSE;
< }
< */
< void rcfile_parse_highlighting(void) {
< 	gchar *filename;
< 	gchar *defaultfile;
< 
< 	DEBUG_MSG("rcfile_parse_highlighting, started\n");
< 
< 	highlighting_configlist = NULL;
< 	init_prop_arraylist(&highlighting_configlist, &main_v->props.highlight_patterns, "patterns:", 0, TRUE);
< 
< 	filename = g_strconcat(g_get_home_dir(), "/.bluefish/highlighting", NULL);
< #ifndef WIN32	
< 	defaultfile = return_first_existing_filename(PKGDATADIR"highlighting.default",
< 									"data/highlighting.default",
< 									"../data/highlighting.default",NULL);
< #else
< 	gchar *tmp = g_strdup("");
< 	tmp = g_strconcat(tmp,PKG_DATA_DIR,"highlighting.default",NULL);
< 	defaultfile = return_first_existing_filename(tmp,
< 									"data/highlighting.default",
< 									"../data/highlighting.default",NULL);
< #endif	
< 	if (!parse_config_file(highlighting_configlist, filename)) {
< 		/* init the highlighting in some way? */
< 		if (defaultfile) {
< 			main_v->props.highlight_patterns = get_list(defaultfile,NULL,TRUE);
< 		} else {
< #ifndef WIN32			
< 			g_print("Unable to find '"PKGDATADIR"highlighting.default'\n");
< #else
< 			g_print("Unable to find '%s\n",PKG_DATA_DIR);
< #endif
< 		}
< 		save_config_file(highlighting_configlist, filename);
< 		DEBUG_MSG("rcfile_parse_highlighting, done saving\n");
< 	} else {
< 		if (config_file_is_newer(main_v->globses.lasttime_highlighting,defaultfile)) {
< 			/* HERE WE SHOULD SEND A POPUP TO THE USER, SAYING THERE ARE NEW HIGHLIGHTING PATTERNS AVAILABLE, IF THEY WANT TO HAVE THEM */
< /*			main_v->props.highlight_patterns = arraylist_load_new_identifiers_from_file(main_v->props.highlight_patterns,defaultfile,2);
< 			main_v->globses.lasttime_highlighting = TIME_T_TO_GINT(time(NULL));*/
< 		}
< 	}
< #ifdef WIN32
< 	g_free(tmp);
< #endif
< 	g_free(filename);
< 	g_free(defaultfile);
< }
< 
< static gint rcfile_save_highlighting(void) {
< 	gint retval;
< 	gchar *filename = g_strconcat(g_get_home_dir(), "/.bluefish/highlighting", NULL);
< 	retval = save_config_file(highlighting_configlist, filename);
< 	g_free(filename);
< 	return retval;
< }
< 
< static void rcfile_custom_menu_load_new(gchar *defaultfile) {
< 	GList *default_insert=NULL, *default_replace=NULL, *tmp_configlist=NULL;
< 	DEBUG_MSG("rcfile_custom_menu_load_new, started!\n");
< 	init_prop_arraylist(&tmp_configlist, &default_insert, "cmenu_insert:", 0, TRUE);
< 	init_prop_arraylist(&tmp_configlist, &default_replace, "cmenu_replace:", 0, TRUE);
< 	parse_config_file(tmp_configlist, defaultfile);
< 	main_v->props.cmenu_insert = arraylist_load_new_identifiers_from_list(main_v->props.cmenu_insert, default_insert, 1);
< 	main_v->props.cmenu_replace = arraylist_load_new_identifiers_from_list(main_v->props.cmenu_replace, default_replace, 1);
< 	main_v->globses.lasttime_cust_menu = TIME_T_TO_GINT(time(NULL));
< 	free_arraylist(default_replace);
< 	free_arraylist(default_insert);
< 	free_configlist(tmp_configlist);
< }
< 
< static void rcfile_custom_menu_load_all(gboolean full_reset, gchar *defaultfile) {
< 	gchar *filename;
< 	custom_menu_configlist = NULL;
< 
< 	init_prop_arraylist(&custom_menu_configlist, &main_v->props.cust_menu, "custom_menu:", 0, TRUE);
< 	init_prop_arraylist(&custom_menu_configlist, &main_v->props.cmenu_insert, "cmenu_insert:", 0, TRUE);
< 	init_prop_arraylist(&custom_menu_configlist, &main_v->props.cmenu_replace, "cmenu_replace:", 0, TRUE);
< 
< 	filename = g_strconcat(g_get_home_dir(), "/.bluefish/custom_menu", NULL);
< 
< 	if (full_reset || !parse_config_file(custom_menu_configlist, filename) || (main_v->props.cust_menu==NULL && main_v->props.cmenu_insert==NULL && main_v->props.cmenu_replace==NULL )) {
< 		DEBUG_MSG("error parsing the custom menu file, or full_reset is set\n");
< 		/* init the custom_menu in some way? */
< 		if (defaultfile) {
< 			parse_config_file(custom_menu_configlist, defaultfile);
< 		} else {
< #ifndef WIN32			
< 			g_print("Unable to find '"PKGDATADIR"custom_menu.default'\n");
< #else
< 			g_print("defaultfile=%s\n",defaultfile);
< 			g_print("Unable to find '%scustom_menu.default'\n",PKG_DATA_DIR);
< #endif
< 		}
< 	}
< 	g_free(filename);
< 
< 	/* for backwards compatibility with older (before Bluefish 0.10) custom menu files we can convert those.. 
< 	we will not need the 'type' anymore, since we will put them in separate lists, hence the memmove() call
< 	*/
< 	DEBUG_MSG("main_v->props.cust_menu=%p\n",main_v->props.cust_menu);
< 	if (main_v->props.cust_menu) {
< 		GList *tmplist= g_list_first(main_v->props.cust_menu);
< 		while (tmplist) {
< 			gchar **strarr = (gchar **)tmplist->data;
< 			gint count = count_array(strarr);
< 			DEBUG_MSG("converting cust_menu, found count=%d\n",count);
< 			if (count >= 5 && strarr[1][0] == '0') {
< 				DEBUG_MSG("rcfile_parse_custom_menu, converting insert, 0=%s, 1=%s\n", strarr[0], strarr[1]);
< 				g_free(strarr[1]);
< 				memmove(&strarr[1], &strarr[2], (count-1) * sizeof(gchar *));
< 				main_v->props.cmenu_insert = g_list_append(main_v->props.cmenu_insert, strarr);
< 			} else if (count >= 8 && strarr[1][0] == '1') {
< 				DEBUG_MSG("rcfile_parse_custom_menu, converting replace, 0=%s, 1=%s\n", strarr[0], strarr[1]);
< 				g_free(strarr[1]);
< 				memmove(&strarr[1], &strarr[2], (count-1) * sizeof(gchar *));
< 				main_v->props.cmenu_replace = g_list_append(main_v->props.cmenu_replace, strarr);
< 			} else if (count >= 4 && count == (4+atoi(strarr[1]))) { /*  the first check avoids a segfault if count == 1 */
< 				/* a very old insert type, 0=menupath, 1=numvariables, 2=string1, 3=string2, 4... are variables 
< 				   we can re-arrange it for the new insert type */
< 				gchar *numvars = strarr[1];
< 				strarr[1] = strarr[2];
< 				strarr[2] = strarr[3];
< 				strarr[3] = numvars; /* the variables; beyond [3], are still the same */
< 				DEBUG_MSG("rcfile_parse_custom_menu, converting very old insert, 0=%s\n", strarr[0]);
< 				main_v->props.cmenu_insert = g_list_append(main_v->props.cmenu_insert, strarr);
< 			} else {
< #ifdef DEBUG
< 				if (count > 2) {
< 					g_print("rcfile_parse_custom_menu, ignoring %s with type %s (count=%d)\n",strarr[0], strarr[1], count);
< 				} else {
< 					g_print("rcfile_parse_custom_menu, ignoring invalid cust_menu entry with count=%d..\n", count);
< 				}
< #endif
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		g_list_free(main_v->props.cust_menu);
< 		main_v->props.cust_menu=NULL;
< 	}
< }
< 
< /*
<  - If LC_ALL is set and non-null, follow it.
<  - Else if LC_MESSAGES is set and non-null, follow it.
<  - Else if LANG is set and non-null, follow it.
< */
< void rcfile_parse_custom_menu(gboolean full_reset, gboolean load_new) {
< 	gchar *defaultfile, *langdefaultfile1=NULL, *langdefaultfile2=NULL, *tmp;
< 	gchar *tmp3 =NULL;
< 	const gchar *tmp2;
< 	DEBUG_MSG("rcfile_parse_custom_menu, started\n");
< 
< 	tmp2 = g_getenv("LC_ALL");
< 	if (tmp2 == NULL) {
< 		tmp2 = g_getenv("LC_MESSAGES");
< 		if (tmp2 == NULL) {
< #ifdef PLATFORM_DARWIN
< 			tmp2 = g_getenv("LANGUAGE");
< #else
< 			tmp2 = g_getenv("LANG");
< #endif
< 		}
< 	}
< 	tmp = g_strdup(tmp2);
< 	DEBUG_MSG("rcfile_parse_custom_menu, Language is: %s", tmp);
< 	if (tmp && strlen(tmp)>0) {
< 		tmp = trunc_on_char(tmp, '.');
< 		tmp = trunc_on_char(tmp, '@');
< #ifndef WIN32		
< 		langdefaultfile1 = g_strconcat(PKGDATADIR"custom_menu.",tmp,".default", NULL);
< #else
< 		langdefaultfile1 = g_strconcat(PKG_DATA_DIR,"custom_menu.",tmp,".default", NULL);
< #endif
< 		DEBUG_MSG("rcfile_parse_custom_menu, langdefaultfile1 is: %s\n", langdefaultfile1);
< 		tmp = trunc_on_char(tmp, '_');
< #ifndef WIN32		
< 		langdefaultfile2 = g_strconcat(PKGDATADIR"custom_menu.",tmp,".default", NULL);
< #else
< 		langdefaultfile2 = g_strconcat(PKG_DATA_DIR,"custom_menu.",tmp,".default", NULL);
< #endif
< 		DEBUG_MSG("rcfile_parse_custom_menu, langdefaultfile2 is: %s\n", langdefaultfile2);
< 		g_free(tmp);
< 	}
< #ifdef WIN32
< 	tmp3 = g_strconcat(PKG_DATA_DIR,"custom_menu.default",NULL);
< #else
< 	tmp3 = g_strconcat(PKGDATADIR"custom_menu.default",NULL);
< #endif
< 	if (langdefaultfile1) {
< 		defaultfile = return_first_existing_filename(langdefaultfile1, langdefaultfile2,
< 									tmp3,
< 									"data/custom_menu.default",
< 									"../data/custom_menu.default",NULL);
< 	} else {
< 		defaultfile = return_first_existing_filename(tmp3,
< 									"data/custom_menu.default",
< 									"../data/custom_menu.default",NULL);
< 	}
< g_free(tmp3);	
< 	DEBUG_MSG("rcfile_parse_custom_menu, defaultfile is: %s\n", defaultfile);
< 	
< 	if (full_reset) {
< 		free_arraylist(main_v->props.cmenu_insert);
< 		free_arraylist(main_v->props.cmenu_replace);
< 		main_v->props.cmenu_insert = NULL;
< 		main_v->props.cmenu_replace = NULL;
< 	}
< 
< 	if (load_new && !full_reset) {
< 		rcfile_custom_menu_load_new(defaultfile);
< 	} else {
< 		rcfile_custom_menu_load_all(full_reset, defaultfile);
< 	}
< 	g_free(defaultfile);
< 	g_free(langdefaultfile1);
< 	g_free(langdefaultfile2);
< }
< static gint rcfile_save_custom_menu(void) {
< 	gint retval;
< 	gchar *filename = g_strconcat(g_get_home_dir(), "/.bluefish/custom_menu", NULL);
< 	retval = save_config_file(custom_menu_configlist, filename);
< 	g_free(filename);
< 	return retval;
< }
< 
< #define DIR_MODE (S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)	/* same as 0755 */
< void rcfile_check_directory(void) {
< 	gchar *rcdir = g_strconcat(g_get_home_dir(), "/.bluefish", NULL);
< 	if (!g_file_test(rcdir, G_FILE_TEST_IS_DIR)) {
< #ifdef WIN32
< 		mkdir(rcdir);
< #else
< 		mkdir(rcdir, DIR_MODE);
< #endif		
< 	}
< 	g_free(rcdir);
< }
< 
< void rcfile_save_configfile_menu_cb(gpointer callback_data,guint action,GtkWidget *widget) {
< 	switch (action) {
< 	case 0:
< 		rcfile_save_main();
< 	break;
< 	case 1:
< 		rcfile_save_highlighting();
< 	break;
< 	case 2:
< 		rcfile_save_custom_menu();
< 	break;
< 	case 3:
< 		{
< 			gchar *shortcutfilename = g_strconcat(g_get_home_dir(), "/.bluefish/menudump_2", NULL);
< 			gtk_accel_map_save(shortcutfilename);
< 			g_free(shortcutfilename);
< 		}
< 	break;
< 	default:
< 		g_print("rcfile_save_configfile_menu_cb, unknown action %d\n", action);
< #ifdef DEBUG
< 		exit(10);
< #endif
< 	break;
< 	}
< }
< 
< void rcfile_save_all(void) {
< 	rcfile_save_main();
< 	rcfile_save_highlighting();
< 	rcfile_save_custom_menu();
< 	rcfile_save_global_session();
< }
< 
< static GList *return_globalsession_configlist(gboolean init_values) {
< 	GList *config_rc = NULL;
< 	init_prop_stringlist(&config_rc, &main_v->globses.quickbar_items, "quickbar_items:", TRUE);
< 	init_prop_integer   (&config_rc, &main_v->globses.two_pane_filebrowser_height, "two_pane_filebrowser_height:", 250, init_values);
< 	init_prop_integer   (&config_rc, &main_v->globses.main_window_h, "main_window_height:", 400, init_values);
< 	init_prop_integer   (&config_rc, &main_v->globses.main_window_w, "main_window_width:", 600, init_values); /* negative width means maximized */
< 	init_prop_integer   (&config_rc, &main_v->globses.fref_ldoubleclick_action,"fref_ldoubleclick_action:",0, init_values);
< 	init_prop_integer   (&config_rc, &main_v->globses.fref_info_type,"fref_info_type:",0, init_values);
< 	init_prop_integer   (&config_rc, &main_v->globses.lasttime_cust_menu, "lasttime_cust_menu:", 0, init_values);
< 	init_prop_integer   (&config_rc, &main_v->globses.lasttime_highlighting, "lasttime_highlighting:", 0, init_values);
< 	init_prop_integer   (&config_rc, &main_v->globses.lasttime_filetypes, "lasttime_filetypes:", 0, init_values);
< 	init_prop_integer   (&config_rc, &main_v->globses.lasttime_encodings, "lasttime_encodings:", 0, init_values);
< 	init_prop_limitedstringlist(&config_rc, &main_v->globses.recent_projects, "recent_projects:", main_v->props.max_recent_files, FALSE);
< 	return config_rc;
< }
< 
< static GList *return_session_configlist(GList *configlist, Tsessionvars *session) {
< 	init_prop_limitedstringlist(&configlist, &session->searchlist, "searchlist:", 10, FALSE);
< 	init_prop_limitedstringlist(&configlist, &session->replacelist, "replacelist:", 10, FALSE);
< 	init_prop_stringlist(&configlist, &session->classlist, "classlist:", FALSE);
< 	init_prop_stringlist(&configlist, &session->colorlist, "colorlist:", FALSE);
< 	init_prop_stringlist(&configlist, &session->targetlist, "targetlist:", FALSE);
< 	init_prop_stringlist(&configlist, &session->urllist, "urllist:", FALSE);
< 	init_prop_stringlist(&configlist, &session->fontlist, "fontlist:", FALSE);
< 	init_prop_stringlist(&configlist, &session->dtd_cblist, "dtd_cblist:", FALSE);
< 	init_prop_arraylist (&configlist, &session->bmarks, "bmarks:", 6, FALSE); /* what is the lenght for a bookmark array? */
< 	init_prop_limitedstringlist(&configlist, &session->recent_files, "recent_files:", main_v->props.max_recent_files, FALSE);
< 	init_prop_limitedstringlist(&configlist, &session->recent_dirs, "recent_dirs:", main_v->props.max_dir_history, FALSE);
< 	init_prop_string_with_escape(&configlist, &session->opendir, "opendir:", NULL);
< 	init_prop_string_with_escape(&configlist, &session->savedir, "savedir:", NULL);
< 	init_prop_integer(&configlist, &session->view_html_toolbar, "view_html_toolbar:", 1, FALSE);
< 	init_prop_integer(&configlist, &session->view_custom_menu, "view_custom_menu:", 1, FALSE);
< 	init_prop_integer(&configlist, &session->view_main_toolbar, "view_main_toolbar:", 1, FALSE);
< 	init_prop_integer(&configlist, &session->view_left_panel, "view_left_panel:", 1, FALSE);	
< 	return configlist;
< }
< 
< static GList *return_project_configlist(Tproject *project) {
< 	GList *configlist = NULL;
< 	init_prop_string(&configlist, &project->name,"name:",_("Untitled Project"));
< 	init_prop_stringlist(&configlist, &project->files, "files:", FALSE);
< 	init_prop_string_with_escape(&configlist, &project->basedir,"basedir:", NULL);
< 	init_prop_string_with_escape(&configlist, &project->webdir,"webdir:", NULL);
< 	init_prop_string(&configlist, &project->template,"template:","");
< /*	init_prop_stringlist(&configlist, &project->recentfiles, "recentfiles:", FALSE); / * should be changed to use the session->recent_files */
< 	init_prop_integer (&configlist, &project->word_wrap,"word_wrap:",1,FALSE);
< 	configlist = return_session_configlist(configlist, project->session);
< 	return configlist;
< }
< 
< gboolean rcfile_parse_project(Tproject *project, gchar *filename) {
< 	gboolean retval;
< 	GList *configlist = return_project_configlist(project);
< 	retval = parse_config_file(configlist, filename);
< 	free_configlist(configlist);
< 	return retval;
< }
< 
< gboolean rcfile_save_project(Tproject *project, gchar *filename) {
< 	gboolean retval;
< 	GList *configlist = return_project_configlist(project);
< 	DEBUG_MSG("rcfile_save_project, project %p, name='%s', basedir='%s', webdir='%s'\n",project, project->name, project->basedir, project->webdir);
< 	DEBUG_MSG("rcfile_save_project, bmarks=%p, list length=%d\n",project->session->bmarks, g_list_length(project->session->bmarks));
< 	DEBUG_MSG("rcfile_save_project, length session recent_files=%d\n",g_list_length(project->session->recent_files));
< 	retval = save_config_file(configlist, filename);
< 	free_configlist(configlist);
< 	return retval;
< }
< 
< gboolean rcfile_save_global_session(void) {
< 	gboolean retval;
< 	gchar *filename = g_strconcat(g_get_home_dir(), "/.bluefish/session", NULL);
< 	GList *configlist = return_globalsession_configlist(FALSE);
< 	configlist = return_session_configlist(configlist, main_v->session);
< 	DEBUG_MSG("rcfile_save_global_session, saving global session to %s\n",filename);
< 	DEBUG_MSG("rcfile_save_global_session, length session recent_files=%d\n",g_list_length(main_v->session->recent_files));
< 	DEBUG_MSG("rcfile_save_global_session, length session recent_projects=%d\n",g_list_length(main_v->globses.recent_projects));
< 	DEBUG_MSG("rcfile_save_global_session, main window width=%d\n",main_v->globses.main_window_w);
< 	retval = save_config_file(configlist, filename);
< 	free_configlist(configlist);
< 	g_free(filename);
< 	return TRUE;
< }
< /* should be called AFTER the normal properties are loaded, becauses return_session_configlist() uses
<  settings from main_v->props */
< gboolean rcfile_parse_global_session(void) {
< 	gboolean retval;
< 	gchar *filename;
< 	GList *configlist = return_globalsession_configlist(TRUE);
< 	configlist = return_session_configlist(configlist, main_v->session);
< 	filename = g_strconcat(g_get_home_dir(), "/.bluefish/session", NULL);
< 	if (!file_exists_and_readable(filename)) {
< 		/* versions before 0.13 did not have a separate session file, so 
< 		we'll try to load these items from rcfile_v2 */
< 		g_free(filename);
< 		filename = g_strconcat(g_get_home_dir(), "/.bluefish/rcfile_v2", NULL);
< 	}
< 	retval = parse_config_file(configlist, filename);
< 	free_configlist(configlist);
< 	g_free(filename);
< 	return retval;
< }
---
> /* Bluefish HTML Editor
>  * rcfile.c - loading and parsing of the configfiles
>  *
>  * Copyright (C) 2000-2005 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> /* #define DEBUG */
> 
> #include <gtk/gtk.h>
> #include <sys/stat.h>
> #include <sys/types.h>
> #include <unistd.h>
> #include <fcntl.h>
> #include <errno.h>
> #include <string.h>
> #include <stdlib.h>
> #include <stdio.h>
> #include <time.h>
> 
> #include "bf_lib.h"
> #include "bluefish.h"
> #include "document.h"       /* DOCUMENT_BACKUP_ABORT_ASK */
> #include "fref.h"
> #include "highlight.h"      /* hl_reset_to_default()*/
> #include "rcfile.h"
> #include "stringlist.h"
> 
> typedef struct {
> 	void *pointer;      /* where should the value be stored? */
> 	unsigned char type; /* a=arraylist, l=stringlist, s=string, e=string with escape, i=integer, m=limiTed stringlist */
> 	gchar *identifier;  /* the string that should be in the config file for this entry */
> 	gint len;           /* used for arrays and limitedstringlists, the length the list should have (only during save),
> 	                       or the number of items the array should have (during load) */
> } Tconfig_list_item;
> 
> static GList *main_configlist=NULL;
> static GList *highlighting_configlist=NULL;
> static GList *custom_menu_configlist=NULL;
> 
> static void free_configlist(GList *configlist) {
> 	GList *tmplist = g_list_first(configlist);
> 	while(tmplist) {
> 		Tconfig_list_item *cli = tmplist->data;
> 		g_free(cli);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	g_list_free(configlist);
> }
> 
> /*this should add 1 empty entry to the configuration list */
> GList *make_config_list_item(GList * config_list, void *pointer_to_var, unsigned char type_of_var, gchar * name_of_var, gint len)
> {
> 	Tconfig_list_item *config_list_item;
> 	if (!pointer_to_var) {
> 		DEBUG_MSG("make_config_list_item, pointer to var = NULL !\n");
> 		return config_list;
> 	}
> 	config_list_item = g_malloc(sizeof(Tconfig_list_item));
> 	config_list_item->pointer = pointer_to_var;
> 	config_list_item->type = type_of_var;
> 	config_list_item->identifier = name_of_var;
> 	config_list_item->len = len;
> 	return (GList *) g_list_append(config_list, config_list_item);
> }
> 
> static void init_prop_integer(GList ** config_list, void *pointer_to_var, gchar * name_of_var, gint default_value, gboolean set_default)
> {
> 	*config_list = make_config_list_item(*config_list, pointer_to_var, 'i', name_of_var, 0);
> 	if (set_default) *(gint *)pointer_to_var = default_value;
> }
> 
> static void init_prop_string(GList ** config_list, void *pointer_to_var, gchar * name_of_var, const gchar * default_value)
> {
> 	*config_list = make_config_list_item(*config_list, pointer_to_var, 's', name_of_var, 0);
> 	if (*(gchar **) pointer_to_var == NULL) {
> 		*(gchar **) pointer_to_var = g_strdup(default_value);
> 	}
> 	DEBUG_MSG("init_prop_string, name_of_var=%s, default_value=%s, current value=%s\n", name_of_var, default_value, *(gchar **) pointer_to_var);
> }
> 
> static void init_prop_string_with_escape(GList ** config_list, void *pointer_to_var, gchar * name_of_var, gchar * default_value)
> {
> 	*config_list = make_config_list_item(*config_list, pointer_to_var, 'e', name_of_var, 0);
> 	if (*(gchar **) pointer_to_var == NULL && default_value) {
> 		*(gchar **) pointer_to_var = unescape_string(default_value, FALSE);
> 	}
> 	DEBUG_MSG("init_prop_string, name_of_var=%s, default_value=%s\n", name_of_var, default_value);
> }
> 
> static void init_prop_stringlist(GList ** config_list, void *pointer_to_var, gchar * name_of_var, gboolean setNULL)
> {
> 	*config_list = make_config_list_item(*config_list, pointer_to_var, 'l', name_of_var, 0);
> 	if (setNULL) {
> 	 	pointer_to_var = NULL;
> 	}
> }
> 
> static void init_prop_arraylist(GList ** config_list, void *pointer_to_var, gchar * name_of_var, gint len, gboolean setNULL)
> {
> 	*config_list = make_config_list_item(*config_list, pointer_to_var, 'a', name_of_var, len);
> 	if (setNULL) {
> 	 	pointer_to_var = NULL;
> 	}
> }
> 
> static void init_prop_limitedstringlist(GList ** config_list, void *pointer_to_var, gchar * name_of_var, gint len, gboolean setNULL)
> {
> 	*config_list = make_config_list_item(*config_list, pointer_to_var, 'm', name_of_var, len);
> 	if (setNULL) {
> 	 	pointer_to_var = NULL;
> 	}
> }
> 
> static gint save_config_file(GList * config_list, gchar * filename)
> {
> 	gchar *tmpstring = NULL, *tmpstring2;
> 	GList *rclist, *tmplist, *tmplist2;
> 	Tconfig_list_item *tmpitem;
> 
> 	DEBUG_MSG("save_config_file, started\n");
> 
> 	rclist = NULL;
> 
> /* We must first make a list with 1 string per item. */
> 	tmplist = g_list_first(config_list);
> 	while (tmplist != NULL) {
> 		DEBUG_MSG("save_config_file, tmpitem at %p\n", tmplist->data);
> 		tmpitem = tmplist->data;
> 		DEBUG_MSG("save_config_file, identifier=%s datatype %c\n", tmpitem->identifier,tmpitem->type);
> 		switch (tmpitem->type) {
> 		case 'i':
> 			DEBUG_MSG("save_config_file, converting \"%p\" to integer\n", tmpitem);
> 			DEBUG_MSG("save_config_file, converting \"%s %i\"\n", tmpitem->identifier, *(int *) (void *) tmpitem->pointer);
> 
> 			tmpstring = g_strdup_printf("%s %i", tmpitem->identifier, *(int *) (void *) tmpitem->pointer);
> 
> 			DEBUG_MSG("save_config_file, adding %s\n", tmpstring);
> 
> 			rclist = g_list_append(rclist, tmpstring);
> 			break;
> 		case 's':
> 			DEBUG_MSG("save_config_file, converting \"%p\" to string\n", tmpitem);
> 			DEBUG_MSG("save_config_file, converting \"%s %s\"\n", tmpitem->identifier, (gchar *) * (void **) tmpitem->pointer);
> 			if (*(void **) tmpitem->pointer) {
> 				tmpstring = g_strdup_printf("%s %s", tmpitem->identifier, (gchar *) * (void **) tmpitem->pointer);
> 
> 				DEBUG_MSG("save_config_file, adding %s\n", tmpstring);
> 
> 				rclist = g_list_append(rclist, tmpstring);
> 			}
> 			break;
> 		case 'e':
> 			DEBUG_MSG("save_config_file, converting \"%p\"\n", tmpitem);
> 			DEBUG_MSG("save_config_file, converting \"%s %s\"\n", tmpitem->identifier, (gchar *) * (void **) tmpitem->pointer);
> 			if (*(void **) tmpitem->pointer) {
> 				tmpstring2 = escape_string((gchar*)*(void**)tmpitem->pointer, FALSE);
> 				tmpstring = g_strdup_printf("%s %s", tmpitem->identifier, tmpstring2);
> 
> 				DEBUG_MSG("save_config_file, adding %s\n", tmpstring);
> 
> 				rclist = g_list_append(rclist, tmpstring);
> 				g_free(tmpstring2);
> 			}
> 			break;
> 		case 'l':
> 		case 'm': {
> 			gint max = -1; /* by setting it to -1, it will never become zero if we substract 1 every round */
> 			DEBUG_MSG("save_config_file, type %c, tmpitem(%p), &tmpitem=%p\n", tmpitem->type, tmpitem, &tmpitem);
> 			if (tmpitem->type == 'm') max = tmpitem->len;
> 			tmplist2 = g_list_last((GList *) * (void **) tmpitem->pointer);
> 			while (tmplist2 != NULL && max != 0) {
> 				tmpstring2 = (char *) tmplist2->data;
> 				DEBUG_MSG("save_config_file, tmpstring2(%p)=%s\n", tmpstring2, tmpstring2);
> 				tmpstring = g_strdup_printf("%s %s", tmpitem->identifier, tmpstring2);
> 				DEBUG_MSG("save_config_file, tmpstring(%p)=%s\n", tmpstring, tmpstring);
> 				rclist = g_list_append(rclist, tmpstring);
> 				tmplist2 = g_list_previous(tmplist2);
> 				max--;
> 			}
> 			} break;
> 		case 'a':
> 			DEBUG_MSG("save_config_file, tmpitem(%p), &tmpitem=%p\n", tmpitem, &tmpitem);
> 			tmplist2 = g_list_last((GList *) * (void **) tmpitem->pointer);
> 			DEBUG_MSG("save_config_file, the tmplist2(%p)\n", tmplist2);
> 			while (tmplist2 != NULL) {
> 				tmpstring2 = array_to_string((char **) tmplist2->data);
> 				tmpstring = g_strdup_printf("%s %s", tmpitem->identifier, tmpstring2);
> 				DEBUG_MSG("save_config_file, tmpstring(%p)=%s\n", tmpstring, tmpstring);
> 				rclist = g_list_append(rclist, tmpstring);
> 				tmplist2 = g_list_previous(tmplist2);
> 				g_free(tmpstring2);
> 			}
> 			break;
> 		default:
> 			break;
> 		}
> 		tmplist = g_list_next(tmplist);
> 
> 	}
> 
> 	put_stringlist(filename, rclist);
> 	free_stringlist(rclist);
> 	return 1;
> }
> 
> static gboolean parse_config_file(GList * config_list, gchar * filename)
> {
> 	gboolean retval = FALSE;
> 	gchar *tmpstring = NULL, *tmpstring2;
> 	gchar **tmparray;
> 	GList *rclist, *tmplist, *tmplist2;
> 	Tconfig_list_item *tmpitem;
> 
> 	DEBUG_MSG("parse_config_file, started\n");
> 
> 	rclist = NULL;
> 	rclist = get_list(filename, rclist,FALSE);
> 	
> 	if (rclist == NULL) {
> 		DEBUG_MSG("no rclist, returning!\n");
> 		return retval;
> 	}
> 
> 	/* empty all variables that have type GList ('l') */
> 	tmplist = g_list_first(config_list);
> 	while (tmplist != NULL) {
> 		tmpitem = (Tconfig_list_item *) tmplist->data;
> 		DEBUG_MSG("parse_config_file, type=%c, identifier=%s\n", tmpitem->type, tmpitem->identifier);
> 		if (tmpitem->type == 'l' || tmpitem->type == 'a') {
> 			DEBUG_MSG("parse_config_file, freeing list before filling it\n");
> 			free_stringlist((GList *) * (void **) tmpitem->pointer);
> 			*(void **) tmpitem->pointer = (GList *)NULL;
> 		}
> 		DEBUG_MSG("parse_config_file, type=%c, identifier=%s\n", tmpitem->type, tmpitem->identifier);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	DEBUG_MSG("parse_config_file, all the type 'l' and 'a' have been emptied\n");
> 	DEBUG_MSG("parse_config_file, length rclist=%d\n", g_list_length(rclist));
> /* And now for parsing every line in the config file, first check if there is a valid identifier at the start. */
> 	tmplist = g_list_first(rclist);
> 	while (tmplist) {
> 		tmpstring = (gchar *) tmplist->data;
> 
> 		if (tmpstring != NULL) {
> 			DEBUG_MSG("parse_config_file, tmpstring=%s\n", tmpstring);
> 			g_strchug(tmpstring);
> 
> 			tmplist2 = g_list_first(config_list);
> 			while (tmplist2) {
> 				tmpitem = (Tconfig_list_item *) tmplist2->data;
> #ifdef DEVELOPMENT
> 				if (!tmpitem || !tmpitem->identifier || !tmpstring) {
> 					g_print("WARNING: almost a problem!\n");
> 				}
> #endif
> 				if (g_strncasecmp(tmpitem->identifier, tmpstring, strlen(tmpitem->identifier)) == 0) {
> 					/* we have found the correct identifier */
> 					retval = TRUE;
> 					DEBUG_MSG("parse_config_file, identifier=%s, string=%s\n", tmpitem->identifier, tmpstring);
> 					/* move pointer past the identifier */
> 					tmpstring += strlen(tmpitem->identifier);
> 					trunc_on_char(tmpstring, '\n');
> 					g_strstrip(tmpstring);
> 
> 					switch (tmpitem->type) {
> 					case 'i':
> 						*(int *) (void *) tmpitem->pointer = atoi(tmpstring);
> 						break;
> 					case 's':
> 						*(void **) tmpitem->pointer = (char *) realloc((char *) *(void **) tmpitem->pointer, strlen(tmpstring) + 1);
> 						strcpy((char *) *(void **) tmpitem->pointer, tmpstring);
> 						break;
> 					case 'e':
> 						tmpstring2 = unescape_string(tmpstring, FALSE); /* I wonder if that should be TRUE */
> 						*(void **) tmpitem->pointer = (char *) realloc((char *) *(void **) tmpitem->pointer, strlen(tmpstring2) + 1);
> 						strcpy((char *) *(void **) tmpitem->pointer, tmpstring2);
> 						g_free(tmpstring2);
> 						break;
> 					case 'l':
> 					case 'm':
> 						tmpstring2 = g_strdup(tmpstring);
> 						* (void **) tmpitem->pointer = g_list_prepend((GList *) * (void **) tmpitem->pointer, tmpstring2);
> 						DEBUG_MSG("parse_config_file, *(void **)tmpitem->pointer=%p\n", *(void **) tmpitem->pointer);
> 						break;
> 					case 'a':
> 						tmparray = string_to_array(tmpstring);
> 						if (tmpitem->len <= 0 || tmpitem->len == count_array(tmparray)) {
> 							* (void **) tmpitem->pointer = g_list_prepend((GList *) * (void **) tmpitem->pointer, tmparray);
> 						} else {
> 							DEBUG_MSG("parse_config_file, not storing array, count_array() != tmpitem->len\n");
> 							g_strfreev(tmparray);
> 						}
> 						DEBUG_MSG("parse_config_file, *(void **)tmpitem->pointer=%p\n", *(void **) tmpitem->pointer);
> 						break;
> 					default:
> 						break;
> 					}
> 					tmplist2 = g_list_last(tmplist2);
> 				}
> 				tmplist2 = g_list_next(tmplist2);
> 			}
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	DEBUG_MSG("parse_config_file, parsed all entries, freeing list read from file\n");	
> 	free_stringlist(rclist);
> 	return retval;
> }
> 
> static GList *props_init_main(GList * config_rc)
> {
> /* these are used in the gtk-2 port already */
> #ifndef NOSPLASH
> 	init_prop_integer   (&config_rc, &main_v->props.show_splash_screen, "show_splash_screen:", 1, TRUE);
> #endif /* #ifndef NOSPLASH */
> 	init_prop_integer   (&config_rc, &main_v->props.show_quickbar_tip, "show_quickbar_tip:", 1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.view_line_numbers, "view_line_numbers:", 1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.filebrowser_show_hidden_files, "fb_show_hidden_f:", 0, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.filebrowser_show_backup_files, "fb_show_backup_f:", 0, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.filebrowser_two_pane_view, "fb_two_pane_view:", 1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.filebrowser_focus_follow, "fb_focus_follow:", 1, TRUE);
> 	init_prop_string    (&config_rc, &main_v->props.filebrowser_unknown_icon, "fb_unknown_icon:", PKGDATADIR"icon_unknown.png");
> 	init_prop_string    (&config_rc, &main_v->props.filebrowser_dir_icon, "fb_dir_icon:", PKGDATADIR"icon_dir.png");
> 	init_prop_string    (&config_rc, &main_v->props.editor_font_string, "editor_font_string:", "courier 11");
> 	init_prop_integer   (&config_rc, &main_v->props.editor_tab_width, "editor_tab_width:", 3, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.editor_smart_cursor, "editor_smart_cursor:", 1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.editor_indent_wspaces, "editor_indent_wspaces:", 0, TRUE);
> 	init_prop_string    (&config_rc, &main_v->props.tab_font_string, "tab_font_string:", "");
> 	init_prop_arraylist (&config_rc, &main_v->props.browsers, "browsers:", 2, TRUE);
> 	init_prop_arraylist (&config_rc, &main_v->props.external_commands, "external_commands:", 2, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.highlight_num_lines_count, "highlight_num_lines_count:", 5, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.defaulthighlight, "defaulthighlight:", 1, TRUE);
> #ifdef HAVE_PCRE_UTF8
> 	init_prop_integer   (&config_rc, &main_v->props.highlight_utf8, "highlight_utf8:", 0, TRUE);
> #endif /* HAVE_PCRE_UTF8 */
> 	/* old type filetypes have a different count, they are converted below */
> 	init_prop_arraylist (&config_rc, &main_v->props.filetypes, "filetypes:", 0, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.numcharsforfiletype, "numcharsforfiletype:", 200, TRUE);
> 	init_prop_arraylist (&config_rc, &main_v->props.filefilters, "filefilters:", 3, TRUE);
> 	init_prop_string    (&config_rc, &main_v->props.last_filefilter, "last_filefilter:", "");
> 	init_prop_integer   (&config_rc, &main_v->props.transient_htdialogs, "transient_htdialogs:", 1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.restore_dimensions, "restore_dimensions:", 1, TRUE);	
> 	init_prop_integer   (&config_rc, &main_v->props.left_panel_width, "left_panel_width:", 150, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.left_panel_left, "left_panel_left:", 1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.max_recent_files, "max_recent_files:", 15, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.max_dir_history, "max_dir_history:", 10, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.backup_file,"backup_file:",1, TRUE);
> 	init_prop_string    (&config_rc, &main_v->props.backup_filestring,"backup_filestring:","~");
> 	init_prop_integer   (&config_rc, &main_v->props.backup_abort_action,"backup_abort_action:",DOCUMENT_BACKUP_ABORT_ASK, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.backup_cleanuponclose,"backup_cleanuponclose:",0, TRUE);
> 	init_prop_string    (&config_rc, &main_v->props.image_thumbnailstring, "image_thumbnailstring:", "_thumbnail");
> 	init_prop_string    (&config_rc, &main_v->props.image_thumbnailtype, "image_thumbnailtype:", "png");
> 	init_prop_integer   (&config_rc, &main_v->props.image_thumbnail_refresh_quality,"image_thumbnail_refresh_quality:",1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.image_thumbnailsizing_type,"image_thumbnailsizing_type:",0, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.image_thumbnailsizing_val1,"image_thumbnailsizing_val1:",100, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.image_thumbnailsizing_val2,"image_thumbnailsizing_val2:",100, TRUE);
> 	init_prop_string    (&config_rc, &main_v->props.image_thumnailformatstring,"image_thumnailformatstring:","<a href=\"%r\"><img src=\"%t\" width=\"%x\" height=\"%y\" border=\"0\"></a>");
> 	init_prop_integer   (&config_rc, &main_v->props.allow_multi_instances,"allow_multi_instances:",0, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.modified_check_type,"modified_check_type:",1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.num_undo_levels,"num_undo_levels:",100, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.clear_undo_on_save,"clear_undo_on_save:",0, TRUE);
> 	init_prop_string    (&config_rc, &main_v->props.newfile_default_encoding,"newfile_default_encoding:","UTF-8");
> 	init_prop_arraylist (&config_rc, &main_v->props.encodings, "encodings:", 2, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.auto_set_encoding_meta,"auto_set_encoding_meta:",1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.auto_update_meta_author,"auto_update_meta_author:",1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.auto_update_meta_date,"auto_update_meta_date:",1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.auto_update_meta_generator,"auto_update_meta_generator:",1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.encoding_search_Nbytes, "encoding_search_Nbytes:", 500, TRUE);
> 	init_prop_arraylist (&config_rc, &main_v->props.outputbox, "outputbox:", 7, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.ext_browsers_in_submenu,"ext_browsers_in_submenu:",0, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.ext_commands_in_submenu,"ext_commands_in_submenu:",1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.ext_outputbox_in_submenu,"ext_outputbox_in_submenu:",1, TRUE);
> 	init_prop_arraylist (&config_rc, &main_v->props.reference_files, "reference_files:", 2, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.bookmarks_default_store,"bookmarks_default_store:",1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.bookmarks_filename_mode,"bookmarks_filename_mode:",1, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.document_tabposition,"document_tabposition:",(gint)GTK_POS_BOTTOM, TRUE);
> 	init_prop_integer   (&config_rc, &main_v->props.leftpanel_tabposition,"leftpanel_tabposition:",(gint)GTK_POS_BOTTOM, TRUE);
> 	init_prop_string    (&config_rc, &main_v->props.default_basedir,"default_basedir:",g_get_home_dir());
> 	init_prop_string    (&config_rc, &main_v->props.project_suffix,"project_suffix:",".bfproject");
> #ifdef HAVE_LIBASPELL
> 	init_prop_string(&config_rc, &main_v->props.spell_default_lang, "spell_default_lang:", "en");
> #endif /* HAVE_LIBASPELL */
> 	/* not yet in use */
> 	init_prop_string(&config_rc, &main_v->props.image_editor_cline, "image_editor_command:", "gimp-remote -n \"%s\"&");
> 	init_prop_integer(&config_rc, &main_v->props.allow_dep, "allow_the_use_of_font:", 0, TRUE);
> 	init_prop_integer(&config_rc, &main_v->props.format_by_context, "format_by_context:", 1, TRUE);
> 	init_prop_integer(&config_rc, &main_v->props.xhtml, "use_xhtml:", 0, TRUE);
> 	init_prop_integer(&config_rc, &main_v->props.allow_ruby, "allow_the_use_of_ruby:", 0, TRUE);
> 	init_prop_integer(&config_rc, &main_v->props.force_dtd, "force_an_dtd:", 0, TRUE);
> 	init_prop_integer(&config_rc, &main_v->props.dtd_url, "url_in_dtd:", 0, TRUE);
> 	init_prop_integer(&config_rc, &main_v->props.xml_start, "xml_starting_line:", 0, TRUE);
> 	init_prop_integer(&config_rc, &main_v->props.lowercase_tags, "lowercase_tags:", 1, TRUE);
> 	init_prop_integer(&config_rc, &main_v->props.word_wrap, "word_wrap:", 0, TRUE);
> 	init_prop_integer(&config_rc, &main_v->props.autoindent, "autoindent:", 1, TRUE);
> 	init_prop_integer(&config_rc, &main_v->props.drop_at_drop_pos, "drop_at_drop_position:", 0, TRUE);
> 	init_prop_integer(&config_rc, &main_v->props.link_management, "link_management:", 1, TRUE);
> 	
> #ifdef WITH_MSG_QUEUE
> 	init_prop_integer (&config_rc, &main_v->props.open_in_running_bluefish,"open_in_running_bluefish:",1, TRUE);
> #endif
> #ifdef HAVE_GNOME_VFS
> 	init_prop_integer (&config_rc, &main_v->props.server_zope_compat,"server_zope_compat:", 0, TRUE); 
> #endif
> 	return config_rc;
> }
> 
> /* we save the value in 'days' precision, so we can divide seconds by 24*60*60
> , this way we can store it in a gint (which is the config file precision) */
> #define TIME_T_TO_GINT(time) ((gint)(time / (24*60*60)))
> 
> static gboolean config_file_is_newer(gint lasttime, const gchar *configfile) {
> 	struct stat statbuf;
> 	if(stat(configfile, &statbuf)==0) {
> 		if (TIME_T_TO_GINT(statbuf.st_mtime) >= lasttime) return TRUE;
> 	}
> 	return FALSE;
> }
> 
> /*
> static GList *arraylist_load_defaults(GList *thelist, const gchar *filename, const gchar *name) {
> 	GList *deflist,*tmplist = g_list_first(thelist);
> 	if (name) {
> 		while (tmplist) {
> 			gchar **tmparr = tmplist->data;
> 			if (strcmp(tmparr[0],name)==0) {
> 				GList *todelete = tmplist;
> 				tmplist = g_list_next(tmplist);
> 				if (tmplist) {
> 					g_list_delete_link(tmplist, todelete);
> 					g_strfreev(tmparr);
> 					g_list_free_1(todelete);
> 				} else {
> 					thelist = NULL;
> 					g_strfreev(tmparr);
> 					g_list_free(todelete);
> 				}
> 			} else {
> 				tmplist = g_list_next(tmplist);
> 			}
> 		}
> 	} else {
> 		while (tmplist) {
> 			g_strfreev((gchar **)tmplist->data);
> 			tmplist = g_list_next(tmplist);
> 		}
> 		g_list_free(thelist);
> 		thelist = NULL;
> 	}
> 	if (name) {
> 		deflist = get_list(filename,NULL,TRUE);
> 		tmplist = g_list_first(deflist);
> 		while (tmplist) {
> 			gchar **tmparr = tmplist->data;
> 			DEBUG_MSG("arraylist_load_defaults, testing if %s should be added (requested=%s)\n",tmparr[0],name);
> 			if (strcmp(tmparr[0],name)==0) {
> 				DEBUG_MSG("adding %s to thelist\n",tmparr[0]);
> 				thelist = g_list_append(thelist, duplicate_stringarray(tmparr));
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		free_arraylist(deflist);
> 	} else {
> 		thelist = get_list(filename,NULL,TRUE);
> 	}
> 	return thelist;
> }
> */
> void rcfile_parse_main(void)
> {
> 	gchar *filename;
> 
> 	DEBUG_MSG("rcfile_parse_main, started\n");
> 
> 	/* set the props struct completely empty */
> 	memset(&main_v->props, 0, sizeof(Tproperties));
> 
> 	/*Make the config_rc list ready for filling with data and set default values */
> 	main_configlist = props_init_main(NULL);
> 
> 	filename = g_strconcat(g_get_home_dir(), "/.bluefish/rcfile_v2", NULL);
> 	if (!parse_config_file(main_configlist, filename)) {
> 		/* should we initialize some things ?? */
> 	}
> 	g_free(filename);
> 	/* do some default configuration for the lists */
> 	if (main_v->props.browsers == NULL) {
> 		/* if the user does not have browsers --> set them to defaults values */
> 		gchar **arr;
> 		arr = array_from_arglist(_("Galeon"), "galeon -x %s&",NULL);
> 		main_v->props.browsers = g_list_append(main_v->props.browsers,arr);
> 		arr = array_from_arglist(_("Mozilla"), "mozilla -remote 'openURL(%s, new-window)' || mozilla %s&",NULL);
> 		main_v->props.browsers = g_list_append(main_v->props.browsers,arr);
> 		arr = array_from_arglist(_("Opera"), "opera -remote 'openURL(%s,new-window)' || opera %s&",NULL);
> 		main_v->props.browsers = g_list_append(main_v->props.browsers,arr);
> 		arr = array_from_arglist(_("Netscape"), "/usr/lib/netscape/477/communicator/communicator-smotif %s&",NULL);
> 		main_v->props.browsers = g_list_append(main_v->props.browsers,arr);
> 		arr = array_from_arglist(_("Gnome default"), "gnome-moz-remote --newwin %s&",NULL);
> 		main_v->props.browsers = g_list_append(main_v->props.browsers,arr);
> 	}
> 	{
> 		gchar *defaultfile = return_first_existing_filename(PKGDATADIR"encodings.default",
> 											"data/encodings.default",
> 										"../data/encodings.default",NULL);
> 		if (main_v->props.encodings == NULL) {
> 			/* if the user does not have encodings --> set them to defaults values */
> 			if (defaultfile) {
> 				main_v->props.encodings = get_list(defaultfile,NULL,TRUE);
> 			} else {
> 				g_print("Unable to find '"PKGDATADIR"encodings.default'\n");
> 			}
> 		} else {
> 			if (config_file_is_newer(main_v->globses.lasttime_encodings,defaultfile)) {
> 				main_v->props.encodings = arraylist_load_new_identifiers_from_file(main_v->props.encodings,defaultfile,1);
> 				main_v->globses.lasttime_encodings = TIME_T_TO_GINT(time(NULL));
> 			}
> 		}
> 		g_free(defaultfile);
> 	}
> 	if (main_v->props.outputbox==NULL) {
> 		/* if the user does not have outputbox settings --> set them to defaults values */
> 		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(_("make"),"([a-zA-Z0-9/_.-]+):([0-9]+):(.*)","1","2","3","make","1",NULL));
> 		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(_("weblint HTML checker"),"([a-zA-Z0-9/_.-]+) \\(([0-9:]+)\\) (.*)","1","2","3","weblint '%s'","0",NULL));
> 		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(_("tidy HTML validator"),"line ([0-9]+) column [0-9]+ - (.*)","-1","1","2","tidy -qe '%s'","0",NULL));
> 		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(_("javac"),"([a-zA-Z0-9/_.-]+):([0-9]+):(.*)","1","2","3","javac '%s'","0",NULL));
> 		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(_("xmllint XML checker"),"([a-zA-Z0-9/_.-]+)\\:([0-9]+)\\: (.*)","1","2","3","xmllint --noout --valid '%s'","0",NULL));
> 		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(_("php"),"(.*) in (/[a-zA-Z0-9/_.-]+) on line ([0-9]+)","1","2","3","php '%s'","0",NULL));
> /*		main_v->props.outputbox = g_list_append(main_v->props.outputbox,array_from_arglist(,NULL)); */
> 	}
> 	if (main_v->props.external_commands == NULL) {
> 		/* if the user does not have external commands --> set them to defaults values */
> 		gchar **arr;
> 		arr = array_from_arglist(_("Dos2Unix filter"), "cat '%s' | dos2unix > '%f'",NULL);
> 		main_v->props.external_commands = g_list_append(main_v->props.external_commands,arr);
> 		arr = array_from_arglist(_("Tidy cleanup filter"), "cat '%s' | tidy -utf8 -q >'%f' 2>/dev/null",NULL);
> 		main_v->props.external_commands = g_list_append(main_v->props.external_commands,arr);
> 	}
> 	{
> 		gchar *defaultfile = return_first_existing_filename(PKGDATADIR"filetypes.default",
> 									"data/filetypes.default",
> 									"../data/filetypes.default",NULL);
> 		if (main_v->props.filetypes == NULL) {
> 			/* if the user does not have file-types --> set them to defaults values */
> 			if (defaultfile) {
> 				main_v->props.filetypes = get_list(defaultfile,NULL,TRUE);
> 			} else {
> 				g_print("Unable to find '"PKGDATADIR"filetypes.default'\n");
> 			}
> 		} else {
> 			if (config_file_is_newer(main_v->globses.lasttime_filetypes,defaultfile)) {
> 				main_v->props.filetypes = arraylist_load_new_identifiers_from_file(main_v->props.filetypes,defaultfile,1);
> 				main_v->globses.lasttime_filetypes = TIME_T_TO_GINT(time(NULL));
> 			}
> 		}
> 		g_free(defaultfile);
> 	}
> 	if (main_v->props.filefilters == NULL) {
> 		/* if the user does not have file filters --> set them to defaults values */
> 		gchar **arr;
> 		arr = array_from_arglist(_("C programming"),"1","c:image", NULL);
> 		main_v->props.filefilters = g_list_append(main_v->props.filefilters, arr);
> 		arr = array_from_arglist(_("All web files"),"1", "html:php:webimage:xml:javascript:stylesheet:jsp", NULL);
> 		main_v->props.filefilters = g_list_append(main_v->props.filefilters, arr);
> 		arr = array_from_arglist(_("Java programming"),"1", "java:image:jsp", NULL);
> 		main_v->props.filefilters = g_list_append(main_v->props.filefilters, arr);
> 		arr = array_from_arglist(_("Images"),"1", "image", NULL);
> 		main_v->props.filefilters = g_list_append(main_v->props.filefilters, arr);
> 		arr = array_from_arglist(_("Hide objectfiles"),"0", "objectfile", NULL);
> 		main_v->props.filefilters = g_list_append(main_v->props.filefilters, arr);
> 	}
> 	if (main_v->props.reference_files == NULL) {
> 		gchar *userdir = g_strconcat(g_get_home_dir(), "/.bluefish/", NULL);
> 		/* if the user does not yet have any function reference files, set them to default values */
> 		fref_rescan_dir(PKGDATADIR);
> 		fref_rescan_dir(userdir);
> 		g_free(userdir);
> 	}
> 	/* for backwards compatibility with old filetypes, 
> 		before version 0.10 had length 4, 
> 		before version 0.13 had length 6 */
> 	{
> 		GList *tmplist = g_list_first(main_v->props.filetypes);
> 		while (tmplist) {
> 			gchar **orig = (gchar **)tmplist->data;
> 			if (count_array(orig)==4) {
> 				gchar **new = array_from_arglist(orig[0], orig[1], orig[2], orig[3], "1", "", "1", NULL);
> 				tmplist->data = new;
> 				g_strfreev(orig);
> 			}
> 			if (count_array(orig)==6) {
> 				gchar **new = array_from_arglist(orig[0], orig[1], orig[2], orig[3], orig[4], orig[5], "0", NULL);
> 				tmplist->data = new;
> 				if (strcmp(orig[0], "xml")==0) {
> 					new[6][0] = '1';
> 				} else if (strcmp(orig[0], "html")==0 || strcmp(orig[0], "php")==0 || strcmp(orig[0], "jsp")==0 || strcmp(orig[0], "cfml")==0) {
> 					new[6][0] = '2';
> 				}
> 				g_strfreev(orig);
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> }
> 
> static gint rcfile_save_main(void) {
> 	gchar *filename = g_strconcat(g_get_home_dir(), "/.bluefish/rcfile_v2", NULL);
> 	return save_config_file(main_configlist, filename);
> }
> /*
> static gboolean arraylist_test_identifier_exists(GList *arrlist, const gchar *name) {
> 	GList *tmplist = g_list_first(arrlist);
> 	while(tmplist) {
> 		if (strcmp(name, ((gchar **)(tmplist->data))[0])==0) {
> 			return TRUE;
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return FALSE;
> }
> */
> void rcfile_parse_highlighting(void) {
> 	gchar *filename;
> 	gchar *defaultfile;
> 
> 	DEBUG_MSG("rcfile_parse_highlighting, started\n");
> 
> 	highlighting_configlist = NULL;
> 	init_prop_arraylist(&highlighting_configlist, &main_v->props.highlight_patterns, "patterns:", 0, TRUE);
> 
> 	filename = g_strconcat(g_get_home_dir(), "/.bluefish/highlighting", NULL);
> 	defaultfile = return_first_existing_filename(PKGDATADIR"highlighting.default",
> 									"data/highlighting.default",
> 									"../data/highlighting.default",NULL);
> 	if (!parse_config_file(highlighting_configlist, filename)) {
> 		/* init the highlighting in some way? */
> 		if (defaultfile) {
> 			main_v->props.highlight_patterns = get_list(defaultfile,NULL,TRUE);
> 		} else {
> 			g_print("Unable to find '"PKGDATADIR"highlighting.default'\n");
> 		}
> 		save_config_file(highlighting_configlist, filename);
> 		DEBUG_MSG("rcfile_parse_highlighting, done saving\n");
> 	} else {
> 		if (config_file_is_newer(main_v->globses.lasttime_highlighting,defaultfile)) {
> 			/* HERE WE SHOULD SEND A POPUP TO THE USER, SAYING THERE ARE NEW HIGHLIGHTING PATTERNS AVAILABLE, IF THEY WANT TO HAVE THEM */
> /*			main_v->props.highlight_patterns = arraylist_load_new_identifiers_from_file(main_v->props.highlight_patterns,defaultfile,2);
> 			main_v->globses.lasttime_highlighting = TIME_T_TO_GINT(time(NULL));*/
> 		}
> 	}
> 	g_free(filename);
> 	g_free(defaultfile);
> }
> 
> static gint rcfile_save_highlighting(void) {
> 	gint retval;
> 	gchar *filename = g_strconcat(g_get_home_dir(), "/.bluefish/highlighting", NULL);
> 	retval = save_config_file(highlighting_configlist, filename);
> 	g_free(filename);
> 	return retval;
> }
> 
> static void rcfile_custom_menu_load_new(gchar *defaultfile) {
> 	GList *default_insert=NULL, *default_replace=NULL, *tmp_configlist=NULL;
> 	DEBUG_MSG("rcfile_custom_menu_load_new, started!\n");
> 	init_prop_arraylist(&tmp_configlist, &default_insert, "cmenu_insert:", 0, TRUE);
> 	init_prop_arraylist(&tmp_configlist, &default_replace, "cmenu_replace:", 0, TRUE);
> 	parse_config_file(tmp_configlist, defaultfile);
> 	main_v->props.cmenu_insert = arraylist_load_new_identifiers_from_list(main_v->props.cmenu_insert, default_insert, 1);
> 	main_v->props.cmenu_replace = arraylist_load_new_identifiers_from_list(main_v->props.cmenu_replace, default_replace, 1);
> 	main_v->globses.lasttime_cust_menu = TIME_T_TO_GINT(time(NULL));
> 	free_arraylist(default_replace);
> 	free_arraylist(default_insert);
> 	free_configlist(tmp_configlist);
> }
> 
> static void rcfile_custom_menu_load_all(gboolean full_reset, gchar *defaultfile) {
> 	gchar *filename;
> 	custom_menu_configlist = NULL;
> 
> 	init_prop_arraylist(&custom_menu_configlist, &main_v->props.cust_menu, "custom_menu:", 0, TRUE);
> 	init_prop_arraylist(&custom_menu_configlist, &main_v->props.cmenu_insert, "cmenu_insert:", 0, TRUE);
> 	init_prop_arraylist(&custom_menu_configlist, &main_v->props.cmenu_replace, "cmenu_replace:", 0, TRUE);
> 
> 	filename = g_strconcat(g_get_home_dir(), "/.bluefish/custom_menu", NULL);
> 
> 	if (full_reset || !parse_config_file(custom_menu_configlist, filename) || (main_v->props.cust_menu==NULL && main_v->props.cmenu_insert==NULL && main_v->props.cmenu_replace==NULL )) {
> 		DEBUG_MSG("error parsing the custom menu file, or full_reset is set\n");
> 		/* init the custom_menu in some way? */
> 		if (defaultfile) {
> 			parse_config_file(custom_menu_configlist, defaultfile);
> 		} else {
> 			g_print("Unable to find '"PKGDATADIR"custom_menu.default'\n");
> 		}
> 	}
> 	g_free(filename);
> 
> 	/* for backwards compatibility with older (before Bluefish 0.10) custom menu files we can convert those.. 
> 	we will not need the 'type' anymore, since we will put them in separate lists, hence the memmove() call
> 	*/
> 	DEBUG_MSG("main_v->props.cust_menu=%p\n",main_v->props.cust_menu);
> 	if (main_v->props.cust_menu) {
> 		GList *tmplist= g_list_first(main_v->props.cust_menu);
> 		while (tmplist) {
> 			gchar **strarr = (gchar **)tmplist->data;
> 			gint count = count_array(strarr);
> 			DEBUG_MSG("converting cust_menu, found count=%d\n",count);
> 			if (count >= 5 && strarr[1][0] == '0') {
> 				DEBUG_MSG("rcfile_parse_custom_menu, converting insert, 0=%s, 1=%s\n", strarr[0], strarr[1]);
> 				g_free(strarr[1]);
> 				memmove(&strarr[1], &strarr[2], (count-1) * sizeof(gchar *));
> 				main_v->props.cmenu_insert = g_list_append(main_v->props.cmenu_insert, strarr);
> 			} else if (count >= 8 && strarr[1][0] == '1') {
> 				DEBUG_MSG("rcfile_parse_custom_menu, converting replace, 0=%s, 1=%s\n", strarr[0], strarr[1]);
> 				g_free(strarr[1]);
> 				memmove(&strarr[1], &strarr[2], (count-1) * sizeof(gchar *));
> 				main_v->props.cmenu_replace = g_list_append(main_v->props.cmenu_replace, strarr);
> 			} else if (count >= 4 && count == (4+atoi(strarr[1]))) { /*  the first check avoids a segfault if count == 1 */
> 				/* a very old insert type, 0=menupath, 1=numvariables, 2=string1, 3=string2, 4... are variables 
> 				   we can re-arrange it for the new insert type */
> 				gchar *numvars = strarr[1];
> 				strarr[1] = strarr[2];
> 				strarr[2] = strarr[3];
> 				strarr[3] = numvars; /* the variables; beyond [3], are still the same */
> 				DEBUG_MSG("rcfile_parse_custom_menu, converting very old insert, 0=%s\n", strarr[0]);
> 				main_v->props.cmenu_insert = g_list_append(main_v->props.cmenu_insert, strarr);
> 			} else {
> #ifdef DEBUG
> 				if (count > 2) {
> 					g_print("rcfile_parse_custom_menu, ignoring %s with type %s (count=%d)\n",strarr[0], strarr[1], count);
> 				} else {
> 					g_print("rcfile_parse_custom_menu, ignoring invalid cust_menu entry with count=%d..\n", count);
> 				}
> #endif
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		g_list_free(main_v->props.cust_menu);
> 		main_v->props.cust_menu=NULL;
> 	}
> }
> 
> /*
>  - If LC_ALL is set and non-null, follow it.
>  - Else if LC_MESSAGES is set and non-null, follow it.
>  - Else if LANG is set and non-null, follow it.
> */
> void rcfile_parse_custom_menu(gboolean full_reset, gboolean load_new) {
> 	gchar *defaultfile, *langdefaultfile1=NULL, *langdefaultfile2=NULL, *tmp;
> 	const gchar *tmp2;
> 	DEBUG_MSG("rcfile_parse_custom_menu, started\n");
> 
> 	tmp2 = g_getenv("LC_ALL");
> 	if (tmp2 == NULL) {
> 		tmp2 = g_getenv("LC_MESSAGES");
> 		if (tmp2 == NULL) {
> #ifdef PLATFORM_DARWIN
> 			tmp2 = g_getenv("LANGUAGE");
> #else
> 			tmp2 = g_getenv("LANG");
> #endif
> 		}
> 	}
> 	tmp = g_strdup(tmp2);
> 	DEBUG_MSG("rcfile_parse_custom_menu, Language is: %s", tmp);
> 	if (tmp && strlen(tmp)>0) {
> 		tmp = trunc_on_char(tmp, '.');
> 		tmp = trunc_on_char(tmp, '@');
> 		langdefaultfile1 = g_strconcat(PKGDATADIR"custom_menu.",tmp,".default", NULL);
> 		DEBUG_MSG("rcfile_parse_custom_menu, langdefaultfile1 is: %s", langdefaultfile1);
> 		tmp = trunc_on_char(tmp, '_');
> 		langdefaultfile2 = g_strconcat(PKGDATADIR"custom_menu.",tmp,".default", NULL);
> 		DEBUG_MSG("rcfile_parse_custom_menu, langdefaultfile2 is: %s", langdefaultfile2);
> 		g_free(tmp);
> 	}
> 	if (langdefaultfile1) {
> 		defaultfile = return_first_existing_filename(langdefaultfile1, langdefaultfile2,
> 									PKGDATADIR"custom_menu.default",
> 									"data/custom_menu.default",
> 									"../data/custom_menu.default",NULL);
> 	} else {
> 		defaultfile = return_first_existing_filename(PKGDATADIR"custom_menu.default",
> 									"data/custom_menu.default",
> 									"../data/custom_menu.default",NULL);
> 	}
> 	DEBUG_MSG("rcfile_parse_custom_menu, defaultfile is: %s", defaultfile);
> 	
> 	if (full_reset) {
> 		free_arraylist(main_v->props.cmenu_insert);
> 		free_arraylist(main_v->props.cmenu_replace);
> 		main_v->props.cmenu_insert = NULL;
> 		main_v->props.cmenu_replace = NULL;
> 	}
> 
> 	if (load_new && !full_reset) {
> 		rcfile_custom_menu_load_new(defaultfile);
> 	} else {
> 		rcfile_custom_menu_load_all(full_reset, defaultfile);
> 	}
> 	g_free(defaultfile);
> 	g_free(langdefaultfile1);
> 	g_free(langdefaultfile2);
> }
> static gint rcfile_save_custom_menu(void) {
> 	gint retval;
> 	gchar *filename = g_strconcat(g_get_home_dir(), "/.bluefish/custom_menu", NULL);
> 	retval = save_config_file(custom_menu_configlist, filename);
> 	g_free(filename);
> 	return retval;
> }
> 
> #define DIR_MODE (S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)	/* same as 0755 */
> void rcfile_check_directory(void) {
> 	gchar *rcdir = g_strconcat(g_get_home_dir(), "/.bluefish", NULL);
> 	if (!g_file_test(rcdir, G_FILE_TEST_IS_DIR)) {
> 		mkdir(rcdir, DIR_MODE);
> 	}
> 	g_free(rcdir);
> }
> 
> void rcfile_save_configfile_menu_cb(gpointer callback_data,guint action,GtkWidget *widget) {
> 	switch (action) {
> 	case 0:
> 		rcfile_save_main();
> 	break;
> 	case 1:
> 		rcfile_save_highlighting();
> 	break;
> 	case 2:
> 		rcfile_save_custom_menu();
> 	break;
> 	case 3:
> 		{
> 			gchar *shortcutfilename = g_strconcat(g_get_home_dir(), "/.bluefish/menudump_2", NULL);
> 			gtk_accel_map_save(shortcutfilename);
> 			g_free(shortcutfilename);
> 		}
> 	break;
> 	default:
> 		g_print("rcfile_save_configfile_menu_cb, unknown action %d\n", action);
> #ifdef DEBUG
> 		exit(10);
> #endif
> 	break;
> 	}
> }
> 
> void rcfile_save_all(void) {
> 	rcfile_save_main();
> 	rcfile_save_highlighting();
> 	rcfile_save_custom_menu();
> 	rcfile_save_global_session();
> }
> 
> static GList *return_globalsession_configlist(gboolean init_values) {
> 	GList *config_rc = NULL;
> 	init_prop_stringlist(&config_rc, &main_v->globses.quickbar_items, "quickbar_items:", TRUE);
> 	init_prop_integer   (&config_rc, &main_v->globses.two_pane_filebrowser_height, "two_pane_filebrowser_height:", 250, init_values);
> 	init_prop_integer   (&config_rc, &main_v->globses.main_window_h, "main_window_height:", 400, init_values);
> 	init_prop_integer   (&config_rc, &main_v->globses.main_window_w, "main_window_width:", 600, init_values); /* negative width means maximized */
> 	init_prop_integer   (&config_rc, &main_v->globses.fref_ldoubleclick_action,"fref_ldoubleclick_action:",0, init_values);
> 	init_prop_integer   (&config_rc, &main_v->globses.fref_info_type,"fref_info_type:",0, init_values);
> 	init_prop_integer   (&config_rc, &main_v->globses.lasttime_cust_menu, "lasttime_cust_menu:", 0, init_values);
> 	init_prop_integer   (&config_rc, &main_v->globses.lasttime_highlighting, "lasttime_highlighting:", 0, init_values);
> 	init_prop_integer   (&config_rc, &main_v->globses.lasttime_filetypes, "lasttime_filetypes:", 0, init_values);
> 	init_prop_integer   (&config_rc, &main_v->globses.lasttime_encodings, "lasttime_encodings:", 0, init_values);
> 	init_prop_limitedstringlist(&config_rc, &main_v->globses.recent_projects, "recent_projects:", main_v->props.max_recent_files, FALSE);
> 	return config_rc;
> }
> 
> static GList *return_session_configlist(GList *configlist, Tsessionvars *session) {
> 	init_prop_limitedstringlist(&configlist, &session->searchlist, "searchlist:", 10, FALSE);
> 	init_prop_limitedstringlist(&configlist, &session->replacelist, "replacelist:", 10, FALSE);
> 	init_prop_stringlist(&configlist, &session->classlist, "classlist:", FALSE);
> 	init_prop_stringlist(&configlist, &session->colorlist, "colorlist:", FALSE);
> 	init_prop_stringlist(&configlist, &session->targetlist, "targetlist:", FALSE);
> 	init_prop_stringlist(&configlist, &session->urllist, "urllist:", FALSE);
> 	init_prop_stringlist(&configlist, &session->fontlist, "fontlist:", FALSE);
> 	init_prop_stringlist(&configlist, &session->dtd_cblist, "dtd_cblist:", FALSE);
> 	init_prop_arraylist (&configlist, &session->bmarks, "bmarks:", 6, FALSE); /* what is the lenght for a bookmark array? */
> 	init_prop_limitedstringlist(&configlist, &session->recent_files, "recent_files:", main_v->props.max_recent_files, FALSE);
> 	init_prop_limitedstringlist(&configlist, &session->recent_dirs, "recent_dirs:", main_v->props.max_dir_history, FALSE);
> 	init_prop_string_with_escape(&configlist, &session->opendir, "opendir:", NULL);
> 	init_prop_string_with_escape(&configlist, &session->savedir, "savedir:", NULL);
> 	init_prop_integer(&configlist, &session->view_html_toolbar, "view_html_toolbar:", 1, FALSE);
> 	init_prop_integer(&configlist, &session->view_custom_menu, "view_custom_menu:", 1, FALSE);
> 	init_prop_integer(&configlist, &session->view_main_toolbar, "view_main_toolbar:", 1, FALSE);
> 	init_prop_integer(&configlist, &session->view_left_panel, "view_left_panel:", 1, FALSE);	
> 	return configlist;
> }
> 
> static GList *return_project_configlist(Tproject *project) {
> 	GList *configlist = NULL;
> 	init_prop_string(&configlist, &project->name,"name:",_("Untitled Project"));
> 	init_prop_stringlist(&configlist, &project->files, "files:", FALSE);
> 	init_prop_string_with_escape(&configlist, &project->basedir,"basedir:", NULL);
> 	init_prop_string_with_escape(&configlist, &project->webdir,"webdir:", NULL);
> 	init_prop_string(&configlist, &project->template,"template:","");
> /*	init_prop_stringlist(&configlist, &project->recentfiles, "recentfiles:", FALSE); / * should be changed to use the session->recent_files */
> 	init_prop_integer (&configlist, &project->word_wrap,"word_wrap:",1,FALSE);
> 	configlist = return_session_configlist(configlist, project->session);
> 	return configlist;
> }
> 
> gboolean rcfile_parse_project(Tproject *project, gchar *filename) {
> 	gboolean retval;
> 	GList *configlist = return_project_configlist(project);
> 	retval = parse_config_file(configlist, filename);
> 	free_configlist(configlist);
> 	return retval;
> }
> 
> gboolean rcfile_save_project(Tproject *project, gchar *filename) {
> 	gboolean retval;
> 	GList *configlist = return_project_configlist(project);
> 	DEBUG_MSG("rcfile_save_project, project %p, name='%s', basedir='%s', webdir='%s'\n",project, project->name, project->basedir, project->webdir);
> 	DEBUG_MSG("rcfile_save_project, bmarks=%p, list length=%d\n",project->session->bmarks, g_list_length(project->session->bmarks));
> 	DEBUG_MSG("rcfile_save_project, length session recent_files=%d\n",g_list_length(project->session->recent_files));
> 	retval = save_config_file(configlist, filename);
> 	free_configlist(configlist);
> 	return retval;
> }
> 
> gboolean rcfile_save_global_session(void) {
> 	gboolean retval;
> 	gchar *filename = g_strconcat(g_get_home_dir(), "/.bluefish/session", NULL);
> 	GList *configlist = return_globalsession_configlist(FALSE);
> 	configlist = return_session_configlist(configlist, main_v->session);
> 	DEBUG_MSG("rcfile_save_global_session, saving global session to %s\n",filename);
> 	DEBUG_MSG("rcfile_save_global_session, length session recent_files=%d\n",g_list_length(main_v->session->recent_files));
> 	DEBUG_MSG("rcfile_save_global_session, length session recent_projects=%d\n",g_list_length(main_v->globses.recent_projects));
> 	DEBUG_MSG("rcfile_save_global_session, main window width=%d\n",main_v->globses.main_window_w);
> 	retval = save_config_file(configlist, filename);
> 	free_configlist(configlist);
> 	g_free(filename);
> 	return TRUE;
> }
> /* should be called AFTER the normal properties are loaded, becauses return_session_configlist() uses
>  settings from main_v->props */
> gboolean rcfile_parse_global_session(void) {
> 	gboolean retval;
> 	gchar *filename;
> 	GList *configlist = return_globalsession_configlist(TRUE);
> 	configlist = return_session_configlist(configlist, main_v->session);
> 	filename = g_strconcat(g_get_home_dir(), "/.bluefish/session", NULL);
> 	if (!file_exists_and_readable(filename)) {
> 		/* versions before 0.13 did not have a separate session file, so 
> 		we'll try to load these items from rcfile_v2 */
> 		g_free(filename);
> 		filename = g_strconcat(g_get_home_dir(), "/.bluefish/rcfile_v2", NULL);
> 	}
> 	retval = parse_config_file(configlist, filename);
> 	free_configlist(configlist);
> 	g_free(filename);
> 	return retval;
> }
1,1806c1,1796
< /* Bluefish HTML Editor
<  * snr2.c - rewrite of search 'n replace functions
<  *
<  * Copyright (C) 2000-2006 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< /*
<  * THIS IS THE BACKEND FLOW DIAGRAM
<  *
<  *                              snr2_run
<  *              ________________/ | \  \___________________________
<  *             /      / |         |  \                   \  \      \
<  *  search_bookmark  |  |         |  replace_prompt_all  |   \      \
<  *     |            /   |         |         /           /     \      \
<  *     |   search_all   |   _____replace_prompt_doc    /       \    replace_all
<  *     |     |          |  /          /               /         \     /
<  *     |     \   doc_show_result     /  replace_doc_once   replace_doc_multiple
<  *     |      \                   __/                  \         /
<  *     |  search_doc             /                   replace_backend
<  *      \________ \             /  ___________________________/
<  *               \ \           /  /
<  *                 search_backend
<  */
< /*****************************************************/
< 
< /* #define DEBUG */
< 
< #include <gtk/gtk.h>
< 
< #include "config.h"
< 
< #ifdef HAVE_STRINGS_H
< #include <strings.h>
< #endif /* HAVE_STRINGS_H */
< 
< #include <stdio.h>
< #include <string.h>
< #include <sys/types.h>    /* _before_ regex.h for freeBSD */
< #include <regex.h>        /* regcomp() */
< #include <pcre.h>         /* pcre_compile */
< 
< #ifdef HAVE_PCRE_UTF8
< #ifndef PCRE_UTF8         /* for compatibility with older libpcre's */
< #define PCRE_UTF8 0
< #endif /* PCRE_UTF8 */
< #endif /* HAVE_PCRE_UTF8 */
< 
< #include <gdk/gdkkeysyms.h> /* GDK_Return */
< 
< #include "bluefish.h"
< #include "bookmark.h"    /* bmark_add_extern() */
< #include "bf_lib.h"
< #include "document.h"    /* doc_replace_text() */
< #include "gtk_easy.h"    /* a lot of GUI functions */
< #include "gui.h"         /* switch_to_document_by_pointer() */
< #include "highlight.h"   /* doc_highlight_full() */
< #include "snr2.h"
< #include "stringlist.h"  /* add_to_history_stringlist */
< #include "undo_redo.h"   /* doc_unre_new_group */
< 
< /* Updates, May 2003, by Ruben Dorta */
< 
< typedef enum { string, uppercase, lowercase } Treplace_types;
< typedef enum { match_normal, match_posix, match_perl } Tmatch_types;
< typedef enum { beginning, cursor, selection, opened_files } Tplace_types;
< 
< typedef struct {
< 	gint start;
< 	gint end;
< 	Tdocument *doc;
< } Tsearch_all_result;
< 
< typedef struct {
< 	Tbfwin *bfwin;
< 	Tdocument *doc;
< 	Tsearch_result result;
< 	gint replace;
< 	gchar *search_pattern;
< 	gchar *replace_pattern;
< 	gint unescape;
< 	gint overlapping_search;
< 	gint prompt_before_replace;
< 	gint is_case_sens;
< 	gint replace_once;
< 	gint bookmark_results;
< 	Treplace_types replacetype_option;
< 	Tmatch_types matchtype_option;
< 	Tplace_types placetype_option;
< } Tlast_snr2;
< 
< typedef struct {
< 	gint replace;
< 	Tbfwin *bfwin;
< 	GtkWidget *window;
< 	GtkWidget *search_combo;
< 	/*GtkWidget *search_entry;*/
< 	GtkWidget *search_label;
< 	/*GtkWidget *search_scrollbox;*/
< 	GtkWidget *replace_combo;
< 	/*GtkWidget *replace_entry;*/
< 	GtkWidget *replace_label;
< 	/*GtkWidget *replace_scrollbox;*/
< 	GtkWidget *subpat_help;
< 	GtkWidget *overlapping_search;
< 	GtkWidget *prompt_before_replace;
< 	GtkWidget *is_case_sens;
< 	GtkWidget *replace_once;
< 	GtkWidget *unescape;
< 	GtkWidget *replacetype_option;
< 	GtkWidget *matchtype_option;
< 	GtkWidget *placetype_option;
< 	GtkWidget *bookmark_results;
< } Tsnr2_win;
< #define LASTSNR2(var) ((Tlast_snr2 *)(var))
< /***********************************************************/
< 
< void snr2_run(Tbfwin *bfwin,Tdocument *doc);
< 
< /***********************************************************/
< 
< void snr2_init(Tbfwin *bfwin) {
< 	Tlast_snr2 *lsnr2 = g_new0(Tlast_snr2,1);
< 	lsnr2->bfwin = bfwin;
< 	bfwin->snr2 = lsnr2;
< }
< 
< static void reset_last_snr2(Tbfwin *bfwin) {
< 	if (LASTSNR2(bfwin->snr2)->search_pattern) {
< 		g_free(LASTSNR2(bfwin->snr2)->search_pattern);
< 	}
< 	if (LASTSNR2(bfwin->snr2)->replace_pattern) {
< 		g_free(LASTSNR2(bfwin->snr2)->replace_pattern);
< 	}
< 	memset(LASTSNR2(bfwin->snr2), 0, sizeof(Tlast_snr2));
< }
< 
< /***********************************************************/
< 
< /**
<  * search_backend:
<  * @bfwin: #Tbfwin* 
<  * @search_pattern: #gchar* to search pattern
<  * @matchtype: see #Tmatch_types
<  * @is_case_sens: If the search is case sensitive, #gint
<  * @buf: #gchar* to the document buffer
<  * @byte_offset: #guint where in the buffer the search should start, in bytes, not characters
<  * @endpos: #gint where in buffer the search should end in bytes, -1 to search to end
<  * @want_submatches: #gint
<  * 
<  * Performs an actual search in a supplied buffer (#gchar*, aka string).
<  * NOTE: If want_submatches is set, tsearch_result->pmatch should be free`ed by the calling function!
<  *
<  * Return value: #Tsearch_result, contains both character and byte offsets, for wide-char-compatibility. Note values for start/end are set to -1 on error.
<  **/
< Tsearch_result search_backend(Tbfwin *bfwin, gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gchar *buf, guint byte_offset, gint endpos, gboolean want_submatches) {
< 	Tsearch_result returnvalue;
< 	int (*f) ();
< 	gint buflen, patlen, searchlen, match, i;
< 
< 	returnvalue.start = -1;
< 	returnvalue.end = -1;
< 	returnvalue.bstart = -1;
< 	returnvalue.bend = -1;
< 	returnvalue.pmatch = NULL;
< 	returnvalue.nmatch = 0;
< 	if ((!search_pattern) || (!buf)) {
< 		DEBUG_MSG("search_backend, search_pattern or buf is NULL\n");
< 		return returnvalue;
< 	}
< 	DEBUG_MSG("search_backend, starting for byte_offset=%u\n",byte_offset);
< 	if (matchtype == match_posix) {
< 		/* regex part start */
< 		regex_t reg_pat;
< 		regmatch_t *pmatch;
< 		gint nmatch, retval;
< 
< 		retval = regcomp(&reg_pat, search_pattern, (is_case_sens ? REG_EXTENDED : REG_EXTENDED | REG_ICASE));
< 		DEBUG_MSG("search_backend, regcomp retval=%d\n", retval);
< 		if (retval != 0) {
< #define ERRORSTR_SIZE 300
< 			gchar errorstr[ERRORSTR_SIZE], *errorstr2;
< 			
< 			regerror(retval,  &reg_pat, errorstr, ERRORSTR_SIZE);
< 			errorstr2 = g_strconcat(_("Regular expression error: "), errorstr, NULL);
< 			warning_dialog(bfwin->main_window,_("Search failed"), errorstr2);
< 			g_free(errorstr2);
< 			/* error compiling the search_pattern, returning the default result set,
< 			which is the 'nothing found' set */
< 			return returnvalue;
< 		}
< 		nmatch = (want_submatches) ? reg_pat.re_nsub+1 : 1;
< 		DEBUG_MSG("search_backend, expr. contains %d sub search_patterns\n", reg_pat.re_nsub );
< 		pmatch = g_malloc(nmatch*sizeof(regmatch_t));
< 		retval = regexec(&reg_pat, buf+byte_offset, nmatch, pmatch, 0);
< 		DEBUG_MSG("search_backend, regexec retval=%d\n", retval);
< 		if (retval != 0) {
< 			returnvalue.bstart = -1;
< 			returnvalue.bend = -1;
< 		} else {
< 			returnvalue.bstart = pmatch[0].rm_so + byte_offset;
< 			returnvalue.bend = pmatch[0].rm_eo + byte_offset;
< 		}
< #ifdef DEBUG
< 		{	int i;
< 			for (i=0;i<nmatch;i++) {
< 				DEBUG_MSG("search_backend, sub search_pattern %d so=%d, eo=%d\n", i, pmatch[i].rm_so, pmatch[i].rm_eo);
< 			}
< 		}
< #endif
< 		regfree(&reg_pat);
< 		if (want_submatches) {
< 			returnvalue.pmatch = pmatch;
< 			returnvalue.nmatch = nmatch;
< 			/* if want_submatches is set, pmatch should be 
< 			free`ed by the calling function! */
< 		} else {
< 			g_free(pmatch);
< 		}
< 		/* regex part end */
< 	} else if (matchtype == match_perl) {
< 		pcre *pcre_c;
< 		const char *err=NULL;
< 		int erroffset=0;
< 		int ovector[30];
< 		gint retval;
< 		pcre_c = pcre_compile(search_pattern,  
< #ifdef HAVE_PCRE_UTF8
< 				(is_case_sens ? PCRE_UTF8|PCRE_DOTALL|PCRE_MULTILINE : PCRE_UTF8|PCRE_DOTALL|PCRE_CASELESS|PCRE_MULTILINE),
< #else
< 				(is_case_sens ? PCRE_DOTALL|PCRE_MULTILINE : PCRE_DOTALL|PCRE_CASELESS|PCRE_MULTILINE),
< #endif
< 				&err,&erroffset,NULL);
< 		if (err) {
< 			gchar *errstring;
< 			errstring = g_strdup_printf(_("Regular expression error: %s at offset %d"), err, erroffset);
< 			warning_dialog(bfwin->main_window,_("Search failed"), errstring);
< 			g_free(errstring);
< 			return returnvalue;/* error compiling the search_pattern, returning the default result set,which is the 'nothing found' set */
< 		}
< 		retval = pcre_exec(pcre_c,NULL,buf+byte_offset,strlen(buf+byte_offset),0,0,ovector,30);
< 		if (retval > 0) {
< 			returnvalue.bstart = ovector[0] + byte_offset;
< 			returnvalue.bend = ovector[1] + byte_offset;
< 		} else {
< 			returnvalue.bstart = -1;
< 			returnvalue.bend = -1;
< 		}
< 		if (want_submatches) {
< 			int nmatch,i;
< 			regmatch_t *pmatch;
< 			pcre_fullinfo(pcre_c, NULL, PCRE_INFO_CAPTURECOUNT, &nmatch);
< 			DEBUG_MSG("search_backend, nmatch=%d, retval=%d\n", nmatch, retval);
< 			pmatch = g_malloc((nmatch+1)*sizeof(regmatch_t));
< 			for (i=0;i<=nmatch;i++) { /* nmatch==1 means 1 subsearch_pattern, so 2 search_patterns in total*/
< 				pmatch[i].rm_so = ovector[i*2] + byte_offset;
< 				pmatch[i].rm_eo = ovector[i*2+1] + byte_offset;
< 			}
< 			returnvalue.pmatch = pmatch;
< 			returnvalue.nmatch = retval;
< #ifdef DEBUG
< 			{	int i;
< 				for (i=0;i<returnvalue.nmatch;i++) {
< 					DEBUG_MSG("search_backend, sub search_pattern %d so=%d, eo=%d\n", i, returnvalue.pmatch[i].rm_so, returnvalue.pmatch[i].rm_eo);
< 				}
< 			}
< #endif
< 			/* if want_submatches is set, pmatch should be 
< 			free`ed by the calling function! */
< 		}
< 		pcre_free(pcre_c);
< 	} else {
< 		/* non regex part start */
< 		if (!is_case_sens) {
< 			f = strncasecmp;
< 		} else {
< 			f = strncmp;
< 		}
< 		
< 		patlen = strlen(search_pattern);
< 		if (endpos != -1) {
< 		    buflen = strlen(doc_get_chars(bfwin->current_document, byte_offset, endpos));
< 		    searchlen = (byte_offset + buflen) - patlen;
< 		} else {
< 		    buflen = strlen(buf);
< 		    searchlen = buflen - patlen;
< 		}
< 		
< 		for (i = byte_offset; i <= searchlen; i++) {
< 			match = f(&buf[i], search_pattern, patlen);
< 			if (match == 0) {
< 				returnvalue.bstart = i;
< 				returnvalue.bend = i + patlen;
< 				break;
< 			}
< 		}
< 		/* non regex part end */	
< 	}
< 	
< 	/* if we have a valid result, we now calculate the character offsets for this result */
< 	if (returnvalue.bstart >= 0 && returnvalue.bend >= 0) {
< 		/* utf8_offset_cache_reset(); */
< 		if (returnvalue.bstart >= 0) {
< 			returnvalue.start = utf8_byteoffset_to_charsoffset_cached(buf, returnvalue.bstart);
< 		}
< 		if (returnvalue.bend >= 0) {
< 			returnvalue.end = utf8_byteoffset_to_charsoffset_cached(buf, returnvalue.bend);
< 		}
< 		if (want_submatches) {
< 			int i;
< 			for (i=0;i<returnvalue.nmatch;i++) {
< 				returnvalue.pmatch[i].rm_so = utf8_byteoffset_to_charsoffset_cached(buf, returnvalue.pmatch[i].rm_so);
< 				returnvalue.pmatch[i].rm_eo = utf8_byteoffset_to_charsoffset_cached(buf, returnvalue.pmatch[i].rm_eo);
< 			}
< 		}
< 	} else {
< 		returnvalue.start = -1;
< 		returnvalue.end = -1;
< 		returnvalue.bstart = -1;
< 		returnvalue.bend = -1;
< 	}
< 
< 	DEBUG_MSG("search_backend, returning result.start=%d, result.end=%d, bstart=%d, bend=%d\n", returnvalue.start, returnvalue.end, returnvalue.bstart, returnvalue.bend);
< 	return returnvalue;
< }
< 
< /*****************************************************/
< 
< /**
<  * search_doc:
<  * @bfwin: #Tbfwin*
<  * @document: a #Tdocument to search
<  * @search_pattern: a #gchar* to the search pattern.
<  * @matchtype: see #Tmatch_types
<  * @is_case_sens: #gint
<  * @startpos: #gint offset in document buffer
<  *
<  * Perform search by calling search_backend.
<  * Updates last_snr2-values, but doesn't use them -- that is the callers duty.
<  *
<  * Return value: #Tsearch_result
<  **/
< Tsearch_result search_doc(Tbfwin *bfwin,Tdocument *document, gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gint startpos, gboolean unescape) {
< 	gchar *fulltext, *realpat;
< 	Tsearch_result result;
< 	
< 	DEBUG_MSG("search_doc, started on document %p, startpos=%d\n", document, startpos);
< 	utf8_offset_cache_reset();
< 	fulltext = doc_get_chars(document, startpos, -1);
< 	DEBUG_MSG("search_doc, fulltext=%p, search_pattern=%p\n", fulltext, search_pattern);
< 	if (unescape) {
< 		realpat = unescape_string(search_pattern, FALSE);
< 	} else {
< 		realpat = search_pattern;
< 	}
< 	result = search_backend(bfwin,realpat, matchtype, is_case_sens, fulltext, 0, -1, FALSE);
< 	if (unescape) {
< 		g_free(realpat);
< 	}
< 	g_free(fulltext);
< 	if (result.end > 0) {
< 		DEBUG_MSG("search_doc, received a result (start=%d), adding startpos (%d) to it\n", result.start, startpos);
< 		result.start += startpos;
< 		result.end += startpos;
< 		LASTSNR2(bfwin->snr2)->result.start = result.start;
< 		LASTSNR2(bfwin->snr2)->result.end = result.end;
< 		LASTSNR2(bfwin->snr2)->doc = document;
< 	} else {
< 		LASTSNR2(bfwin->snr2)->result.start = -1;
< 		LASTSNR2(bfwin->snr2)->result.end =  -1;
< 		LASTSNR2(bfwin->snr2)->doc = document;
< 	}
< 	DEBUG_MSG("search_doc, result.start=%d, result.end=%d\n", result.start, result.end);
< 	return result;
< }
< 
< /*****************************************************/
< 
< /**
<  * doc_show_result:
<  * @document: a #Tdocument
<  * @start: Selection start.
<  * @end: Selection end.
<  *
<  * Focus a document and select the supplied range.
<  *
<  * Return value: void
<  **/
< void doc_show_result(Tdocument *document, gint start, gint end) {
< 	DEBUG_MSG("doc_show_result, select from start=%d to end=%d\n",start, end);
< 	if (document != BFWIN(document->bfwin)->current_document) {
< 		switch_to_document_by_pointer(BFWIN(document->bfwin),document);
< 	}
< 	doc_select_region(document, start, end, TRUE);
< }
< 
< /*****************************************************/
< 
< /**
<  * search_all:
<  * @bfwin: #Tbfwin*
<  * @search_pattern: #gchar to search pattern
<  * @matchtype: see #Tmatch_types
<  * is_case_sens: #gint set to 0 or 1.
<  *
<  * Perform a specified search, spanning all open documents.
<  *
<  * When called several times, the search continues from where it left off last time.
<  * The current 'search-position' is stored in the internal last_snr2 structure.
<  *
<  * Return value: #Tsearch_all_result
<  **/
< Tsearch_all_result search_all(Tbfwin *bfwin,gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gboolean unescape) {
< 	GList *tmplist;
< 	Tsearch_all_result result_all;
< 
< 	DEBUG_MSG("search_all, started\n");
< 	result_all.start = -1;
< 	result_all.end = -1;
< 	result_all.doc = NULL;
< 	
< 	if (LASTSNR2(bfwin->snr2)->doc) {
< 		tmplist = g_list_find(bfwin->documentlist, LASTSNR2(bfwin->snr2)->doc);
< 	} else {
< 		LASTSNR2(bfwin->snr2)->result.end = 0;
< 		tmplist = g_list_first(bfwin->documentlist);
< 	}
< 	while (tmplist) {
< 		Tsearch_result result;
< 
< 		result = search_doc(bfwin,(Tdocument *)tmplist->data, search_pattern, matchtype, is_case_sens, LASTSNR2(bfwin->snr2)->result.end, unescape);
< 		if (result.end > 0) {
< 			result_all.start = result.start;
< 			result_all.end = result.end;
< 			result_all.doc = tmplist->data;
< 			DEBUG_MSG("search_all, found!! start=%d, end=%d, doc=%p\n", result.start, result.end, tmplist->data);
< 			return result_all;
< 		}
< 		tmplist = g_list_next(tmplist);
< 		if (tmplist) {
< 			LASTSNR2(bfwin->snr2)->result.end = 0;
< 		}
< 	}
< 	DEBUG_MSG("search_all, not found..\n");
< 	return result_all;
< }
< 
< /*****************************************************/
< 
< static gchar *reg_replace(gchar *replace_pattern, gint offset, Tsearch_result result, Tdocument *doc, gboolean standardescape) {
< 	Tconvert_table * tct;
< 	gchar *retval;
< 	gint i, size;
< 	DEBUG_MSG("reg_replace, started for pattern='%s',standardescape=%d\n",replace_pattern,standardescape);
< 	size = (result.nmatch <= 10) ? (result.nmatch == 0 ) ? 0 : result.nmatch -1 : 10;
< 	tct = new_convert_table(size, standardescape);
< 	for (i=0;i<size;i++) {
< 		tct[i].my_int = i+48;
< 		tct[i].my_char = doc_get_chars(doc, offset+result.pmatch[i+1].rm_so, offset+result.pmatch[i+1].rm_eo);
< 	}
< 	retval = expand_string(replace_pattern, '\\', tct);
< 	free_convert_table(tct);
< 	return retval;
< }
< 
< /*
<  * this function will parse the replace string and substitute the \0, \1 etc. with 
<  * the subsearch_pattern matches from regexec()
<  */
< /*static gchar *oldreg_replace(gchar *replace_pattern, gint offset, Tsearch_result result, Tdocument *doc) {
< 	gchar *tmp1, *newstring;
< 	gchar *tmpstr1, *tmpstr2, *tmpstr3;
< 	gboolean escaped=0;
< 	guint from=0, to=0;
< 
< 	newstring = g_strdup("");
< 	tmp1 = replace_pattern;
< 	while (*tmp1 != '\0') {
< 		if (escaped) {
< 			if (*tmp1 == '\\') {
< 				to++;
< 				tmpstr1 = newstring;
< 				tmpstr2 = g_strndup(&replace_pattern[from], to-from);
< 				newstring = g_strconcat(tmpstr1, tmpstr2, NULL);
< 				g_free(tmpstr1);
< 				g_free(tmpstr2);
< 				from = ++to;
< 				DEBUG_MSG("reg_replace, escaped backslash, newstring='%s'\n", newstring);			
< 			} else if ((gint)*tmp1 >= 48 && (gint)*tmp1 <= 57) {
< 				gint num = (gint)*tmp1 - 48;
< 				tmpstr1 = newstring;
< 				tmpstr2 = g_strndup(&replace_pattern[from], to-from);
< 				DEBUG_MSG("reg_replace, from=%d, to=%d, tmpstr2='%s'\n", from, to, tmpstr2);
< 				if (result.nmatch >= num+1) {
< 					DEBUG_MSG("reg_replace, wanted: sub search_pattern %d, offset=%d, so=%d, eo=%d\n", num, offset, result.pmatch[num+1].rm_so, result.pmatch[num+1].rm_eo);
< 					tmpstr3 = doc_get_chars(doc, offset+result.pmatch[num+1].rm_so, offset+result.pmatch[num+1].rm_eo);
< 					DEBUG_MSG("reg_replace, subsearch_pattern %d = '%s'\n", num, tmpstr3);
< 				} else {
< 					DEBUG_MSG("reg_replace, subsearch_pattern %d does not exist, nmatch=%d\n", num, result.nmatch);
< 					tmpstr3 = g_strdup("");
< 				}
< 				newstring = g_strconcat(tmpstr1, tmpstr2, tmpstr3, NULL);
< 				g_free(tmpstr1);
< 				g_free(tmpstr2);
< 				g_free(tmpstr3);
< 				to += 2;
< 				from = to;
< 				DEBUG_MSG("reg_replace, substituted subsearch_pattern, newstring='%s'\n", newstring);
< 			} else {
< 				to += 2;
< 			}
< 			escaped = 0;
< 		} else {
< 			if (*tmp1 == '\\') {
< 				escaped = 1;
< 			} else {
< 				to++;
< 			}
< 		}
< 		tmp1++;
< 	}
< 	tmpstr1 = newstring;
< 	tmpstr2 = g_strndup(&replace_pattern[from], to-from);
< 	newstring = g_strconcat(tmpstr1, tmpstr2, NULL);
< 	g_free(tmpstr1);
< 	g_free(tmpstr2);
< 	DEBUG_MSG("reg_replace, end, newstring='%s'\n", newstring);
< 	return newstring;
< }*/
< 
< /**
<  * replace_backend:
<  * @bfwin: #Tbfwin with the window from this/these documents
<  * @search_pattern: #gchar* to search pattern
<  * @matchtype: See #Tmatch_types
<  * @is_case_sens: #gint
<  * @buf: #ghar* to buffer
<  * @replace_pattern: The replace pattern.
<  * @doc: the #Tdocument
<  * @offset: The difference between the buffer and the text widget because of previous replace actions, so the first char in buf is actually number offset in the text widget.
<  * @replacetype: see #Treplace_types
<  * @replacelen: #gint*, set to -1 to calculate this automatically.
<  * 
<  * This will perform a search and the actual replacement of data in the buffer.
<  * Note that *buf is probably an offset in the documents buffer.
<  * 
<  * Return value: #Tsearch_result
<  **/
< Tsearch_result replace_backend(Tbfwin *bfwin,gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens
< 			, gchar *buf, guint byte_offset, gchar *replace_pattern, Tdocument *doc, gint offset, Treplace_types replacetype
< 			, gint *replacelen, gboolean unescape) {
< /* the offset in this function is the difference between the buffer and the text widget because of previous replace 
< actions, so the first char in buf is actually number offset in the text widget */
< /* replacelen -1 means there is no replacelen known yet, so we have to calculate it */
< 	Tsearch_result result;
< 	gchar *tmpstr=NULL, *realpat;
< 	
< 	if (unescape) {
< 		realpat = unescape_string(search_pattern,FALSE);
< 		DEBUG_MSG("replace_backend, realpat='%s'\n",realpat);
< 	} else {
< 		realpat = search_pattern;
< 	}
< 	result = search_backend(bfwin,realpat, matchtype, is_case_sens, buf, byte_offset, -1, (matchtype != match_normal));
< 	if (unescape) {
< 		DEBUG_MSG("replace_backend, free-ing realpat\n");
< 		g_free(realpat);
< 	}
< 	DEBUG_MSG("replace_backend, offset=%d, result.start=%d, result.end=%d\n", offset, result.start, result.end);
< 	if (result.end > 0) {
< 		gchar *tmp;
< 		switch (replacetype) {
< 		case string:
< 			if (matchtype == match_normal) {
< 				if (unescape) {
< 					DEBUG_MSG("replace_backend, replace_pattern='%s'\n",replace_pattern);
< 					tmpstr = unescape_string(replace_pattern, FALSE);
< 				} else {
< 					tmpstr = g_strdup(replace_pattern);
< 				}
< 			} else {
< 				tmpstr = reg_replace(replace_pattern, offset, result, doc, unescape);
< 			}
< 			DEBUG_MSG("replace_backend, tmpstr='%s'\n", tmpstr);
< 		break;
< 		case uppercase:
< 			tmpstr = g_strndup(&buf[result.bstart], result.bend - result.bstart);
< 			tmp = tmpstr;
< 			tmpstr = g_utf8_strup(tmpstr, -1);
< 			g_free (tmp);
< 		break;
< 		case lowercase:
< 			tmpstr = g_strndup(&buf[result.bstart], result.bend - result.bstart);
< 			tmp = tmpstr;
< 			tmpstr = g_utf8_strdown(tmpstr, -1);
< 			g_free (tmp);
< 		break;
< 		}
< 		DEBUG_MSG("replace_backend, len=%d, offset=%d, start=%d, end=%d, document=%p, tmpstr='%s'\n", result.end - result.start, offset, result.start + offset, result.end + offset, doc,tmpstr);
< 		doc_replace_text_backend(doc, tmpstr, result.start + offset, result.end + offset);
< 		if (*replacelen == -1) {
< 			*replacelen = g_utf8_strlen(tmpstr, -1);
< 		}
< 		g_free(tmpstr);
< 	}
< 	if (matchtype == match_posix) {
< 		g_free(result.pmatch);
< 		result.pmatch = NULL;
< 	}
< 	return result;
< }
< 
< /*****************************************************/
< 
< /**
<  * replace_doc_once:
<  * @search_pattern: #gchar* to search pattern
<  * @matchtype: see #Tmatch_types
<  * @is_case_sens: #gint
<  * @startpos: #gint offset in document.
<  * @endpos: #gint where to stop replacing. Set to -1 to cover the entire buffer.
<  * @replace_pattern: #gchar* to replace pattern
<  * @doc: a #Tdocument* to work on
<  * @replacetype: see #Treplace_types
<  *
<  * Performs a single replace with the selected parameters, by calling replace_backend().
<  * Calls doc_unre_new_group(doc) to make this action undoable.
<  * Updates the internal last_snr2 struct, but the _caller_ is responsible for honouring this data.
<  * 
<  * Return value: #Tsearch_result
<  **/
< Tsearch_result replace_doc_once(Tbfwin *bfwin,gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gint startpos, gint endpos, gchar *replace_pattern, Tdocument *doc, Treplace_types replacetype, gboolean unescape) {
< /* endpos -1 means do till end */
< 	gchar *fulltext;
< 	gint replacelen = 0; /* replacelen -1 means there is no replacelen known yet
< 								, but we don't need one, so we set it to 0 */
< 	Tsearch_result result;
< 
< 	doc_unre_new_group(doc);
< 	utf8_offset_cache_reset();
< 	fulltext = doc_get_chars(doc, startpos, endpos);
< 	result = replace_backend(bfwin,search_pattern, matchtype, is_case_sens, fulltext, 0, replace_pattern, doc, startpos, replacetype, &replacelen, unescape);
< 	if ( result.end > 0) {
< 		LASTSNR2(bfwin->snr2)->result.start = result.start + startpos;
< 		LASTSNR2(bfwin->snr2)->result.end = result.end + startpos;
< 		LASTSNR2(bfwin->snr2)->doc = doc;
< 	} else {
< 		LASTSNR2(bfwin->snr2)->result.start = -1;
< 		LASTSNR2(bfwin->snr2)->result.end = -1;
< 		LASTSNR2(bfwin->snr2)->doc = doc;
< 	}
< 	g_free(fulltext);
< 
< 	doc_unre_new_group(doc);
< 
< 	return result;
< }
<  
< /*****************************************************/
< 
< /**
<  * replace_doc_multiple:
<  * @search_pattern: #gchar* to search pattern
<  * @matchtype: see #Tmatch_types
<  * @is_case_sens: #gint
<  * @endpos: #gint where to stop replacing. Set to -1 to cover the entire buffer.
<  * @replace_pattern: #gchar* to replace pattern
<  * @doc: a #Tdocument* to work on
<  * @replacetype: see #Treplace_types
<  * 
<  * Performs a replace on all occurences of the pattern in the supplied document.
<  * The doc's buffer will be modified.
<  *
<  * last_snr2 is reset with .start = .end = -1, and .doc = doc.
<  * 
<  * Return value: void
<  **/
< void replace_doc_multiple(Tbfwin *bfwin,gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gint startpos, gint endpos, gchar *replace_pattern, Tdocument *doc, Treplace_types replacetype, gboolean unescape) {
< /* endpos -1 means do till end */
< 	gchar *fulltext, *realpats, *realpatr;
< 	gboolean realunesc;
< 	Tsearch_result result;
< 	gint buf_byte_offset=0;
< 	gint buf_text_offset=startpos;
< 	gint replacelen; /* replacelen -1 means there is no replacelen known yet */
< 	doc_unre_new_group(doc);
< 
< 	DEBUG_MSG("replace_doc_multiple, startpos=%d, endpos=%d\n", startpos, endpos);
< 	if (matchtype == match_normal || replacetype != string) {
< 		/* the replace string has a fixed length if it is not regex, or it is not type string
< 		 in this case we can also do the unescaping in this function */
< 		if (unescape) {
< 			realpats = unescape_string(search_pattern, FALSE);
< 			realpatr = unescape_string(replace_pattern, FALSE);
< 			DEBUG_MSG("replace_doc_multiple, unescaped patterns, realpats='%s', realpatr='%s'\n",realpats, realpatr);
< 		} else {
< 			realpats = search_pattern;
< 			realpatr = replace_pattern;
< 		}
< 		replacelen = g_utf8_strlen(realpatr,-1);
< 		realunesc = FALSE;
< 	} else {
< 		replacelen=-1;
< 		realpats = search_pattern;
< 		realpatr = replace_pattern;
< 		realunesc = unescape;
< 	}
< 	fulltext = doc_get_chars(doc, startpos, endpos);
< 	utf8_offset_cache_reset();
< 	result = replace_backend(bfwin,realpats, matchtype, is_case_sens, fulltext, 0, realpatr, doc, buf_text_offset, replacetype, &replacelen, realunesc);
< 	while (result.end > 0) {
< 		if (replacetype == string) {
< 			buf_text_offset += replacelen - (result.end - result.start);
< 		}
< 		if (LASTSNR2(bfwin->snr2)->overlapping_search || result.start == result.end) {
< 			buf_byte_offset = result.bstart + 1;
< 			/* buf_text_offset += result.start + 1; */
< 		} else {
< 			buf_byte_offset = result.bend;
< 			/* buf_text_offset += result.end; */
< 		}
< 		DEBUG_MSG("replace_doc_multiple, after first search, buf_text_offset=%d, buf_byte_offset=%d\n", buf_text_offset, buf_byte_offset);
< 		if (matchtype != match_normal && replacetype == string) {
< 			/* all regex replaces can have different replace lengths, so they have to be re-calculated */
< 			replacelen = -1;
< 		}
< 		result = replace_backend(bfwin,realpats, matchtype, is_case_sens, fulltext, buf_byte_offset, realpatr, doc, buf_text_offset, replacetype, &replacelen, realunesc);
< 
< 		DEBUG_MSG("replace_doc_multiple, 1- buf_text_offset=%d, buf_byte_offset=%d, result.start=%d, result.end=%d\n", buf_text_offset, buf_byte_offset, result.start, result.end);
< 	}
< 	if (unescape && (matchtype == match_normal || replacetype != string)) {
< 		DEBUG_MSG("replace_doc_multiple, free-ing realpats and realpatr\n");
< 		g_free(realpats);
< 		g_free(realpatr);
< 	}
< 
< 	doc_unre_new_group(doc);
< 
< 	LASTSNR2(bfwin->snr2)->result.start = -1;
< 	LASTSNR2(bfwin->snr2)->result.end = -1;
< 	LASTSNR2(bfwin->snr2)->doc = doc;
< 	g_free(fulltext);
< }
< 
< /*****************************************************/
< 
< /**
<  * replace_all:
<  * @bfwin: #Tbfwin* the window with the documents to act upon
<  * @search_pattern: #gchar* to search pattern
<  * @matchtype: see #Tmatch_types
<  * @is_case_sens: #gint
<  * @replace_pattern: #gchar* to replace pattern
<  * @replacetype: see #Treplace_types
<  * 
<  * Perform a replace_doc_multiple() with supplied data on all open documents.
<  * This will replace all occurences of search_pattern in all documents.
<  * 
<  * Return value: void
<  **/
< void replace_all(Tbfwin *bfwin,gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gchar *replace_pattern, Treplace_types replacetype, gboolean unescape) {
< 	GList *tmplist;
< 
< 	tmplist = g_list_first(bfwin->documentlist);
< 	while (tmplist) {
< 		replace_doc_multiple(bfwin,search_pattern, matchtype, is_case_sens, 0, -1, replace_pattern, (Tdocument *)tmplist->data, replacetype, unescape);
< 		tmplist = g_list_next(tmplist);
< 	}
< }
< 
< /*****************************************************/
< /*             Replace prompt callbacks              */
< /*****************************************************/
< 
< /*
<  *
<  * Performs the actual replace-surgery by calls to doc_replace_text_backend() !
<  * Continues the replace cycle by calling snr2_run(), unless this is a single replace.
<  *
<  */
< static void replace_prompt_dialog_ok_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	gchar *tmpstr;
< 	gint sel_start_pos, sel_end_pos;
< 
< 	window_close_by_widget_cb(widget, NULL);
< 	
< 	doc_get_selection(bfwin->current_document, &sel_start_pos, &sel_end_pos);
< 	if ((sel_start_pos == LASTSNR2(bfwin->snr2)->result.start) &&
< 				(sel_end_pos == LASTSNR2(bfwin->snr2)->result.end)) {
< 		gint lenadded;
< 		if (LASTSNR2(bfwin->snr2)->replacetype_option==string) {
< 			tmpstr = g_strdup(LASTSNR2(bfwin->snr2)->replace_pattern);
< 			/* if it was a regex replace we need to do the sub-search_pattern matching */
< 			tmpstr = reg_replace(tmpstr, 0, LASTSNR2(bfwin->snr2)->result, bfwin->current_document, LASTSNR2(bfwin->snr2)->unescape);
< 			
< 		} else if (LASTSNR2(bfwin->snr2)->replacetype_option==uppercase) {
< 			gchar *tmp;
< 			tmpstr = doc_get_chars(bfwin->current_document, LASTSNR2(bfwin->snr2)->result.start ,LASTSNR2(bfwin->snr2)->result.end);
< 			tmp = tmpstr;
< 			tmpstr = g_utf8_strup(tmpstr, -1);
< 			g_free (tmp);
< 		} else {
< 			gchar *tmp;
< 			tmpstr = doc_get_chars(bfwin->current_document, LASTSNR2(bfwin->snr2)->result.start ,LASTSNR2(bfwin->snr2)->result.end);
< 			tmp = tmpstr;
< 			tmpstr = g_utf8_strdown(tmpstr, -1);
< 			g_free (tmp);
< 		}
< 		/* avoid new highlighting at this stage, so call the backend directly instead of the frontend function
< 		this because the highlighting interferes with the selection
< 		the better solution is to have the highlighting handle the selection better, 
< 		the problem starts in document.c in get_positions() because the selection is not saved there
< 		I don't know why the selection is gray, but that's basically the reason why it doesn't save the selection
< 		 */
< 
< 		doc_unre_new_group(bfwin->current_document);
< 		doc_replace_text_backend(bfwin->current_document, tmpstr, LASTSNR2(bfwin->snr2)->result.start,LASTSNR2(bfwin->snr2)->result.end);
< 		doc_unre_new_group(bfwin->current_document);
< 		doc_set_modified(bfwin->current_document, 1);
< 
< 		lenadded = strlen(tmpstr) - (LASTSNR2(bfwin->snr2)->result.end - LASTSNR2(bfwin->snr2)->result.start);
< 		DEBUG_MSG("lenadded=%d (streln=%d, end-start=%d)\n",lenadded,strlen(tmpstr),(LASTSNR2(bfwin->snr2)->result.end - LASTSNR2(bfwin->snr2)->result.start));
< 		g_free(tmpstr);
< 		if (LASTSNR2(bfwin->snr2)->result.pmatch) {
< 			g_free(LASTSNR2(bfwin->snr2)->result.pmatch);
< 			LASTSNR2(bfwin->snr2)->result.pmatch = NULL;
< 		}
< 		if (!LASTSNR2(bfwin->snr2)->replace_once) {
< 			if (!LASTSNR2(bfwin->snr2)->overlapping_search && lenadded > 0) {
< 				LASTSNR2(bfwin->snr2)->result.end += lenadded;
< 			}
< 			snr2_run(bfwin,NULL);
< 		}
< 	}
< #ifdef DEBUG
< 	 else {
< 		g_print("replace_prompt_dialog_ok_lcb, selection != result, not replacing!!\n");
< 	}
< #endif /* DEBUG */
< }
< 
< static void replace_prompt_dialog_skip_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	window_close_by_widget_cb(widget, NULL);
< 	if (LASTSNR2(bfwin->snr2)->result.pmatch) {
< 		g_free(LASTSNR2(bfwin->snr2)->result.pmatch);
< 		LASTSNR2(bfwin->snr2)->result.pmatch = NULL;
< 	}
< 	if (!LASTSNR2(bfwin->snr2)->replace_once) {
< 		snr2_run(bfwin,NULL);
< 	}
< }
< 
< /* Alters last_snr2, setting no-prompt-mode, backtracking one step on the startpoint and .end = .start
<  * continues by running snr2_run(). This will replace all occurrences of the string.. */
< static void replace_prompt_dialog_all_lcb(GtkWidget *widget, Tbfwin *bfwin) {
< 	window_close_by_widget_cb(widget, NULL);
< 	LASTSNR2(bfwin->snr2)->prompt_before_replace = 0;
< 	LASTSNR2(bfwin->snr2)->result.start--;
< 	LASTSNR2(bfwin->snr2)->result.end = LASTSNR2(bfwin->snr2)->result.start;
< 	if (LASTSNR2(bfwin->snr2)->result.pmatch) {
< 		g_free(LASTSNR2(bfwin->snr2)->result.pmatch);
< 		LASTSNR2(bfwin->snr2)->result.pmatch = NULL;
< 	}
< 	snr2_run(bfwin,NULL);
< }
< 
< 
< /**
<  * replace_prompt_dialog:
<  * 
<  * Prompt the user for a replace action. Simply creates and shows GUI.
<  * Used by replace_prompt_doc().
<  * 
<  * Return value: void
<  **/
< void replace_prompt_dialog(Tbfwin *bfwin) {
< 	GtkWidget *win, *vbox, *hbox;
< 	GtkWidget *butok, *butclose, *butall, *butskip;
< 	GtkWidget *image, *label;
< 
< 	DEBUG_MSG("replace_prompt_dialog, start\n");
< 	win = window_full(_("Confirm replace"), GTK_WIN_POS_CENTER, 12, G_CALLBACK(window_close_by_widget_cb), NULL, TRUE);
< 	gtk_window_set_resizable (GTK_WINDOW (win), FALSE);
< 
< 	vbox = gtk_vbox_new (FALSE, 0);
< 	gtk_container_add (GTK_CONTAINER (win), vbox);
< 
< 	hbox = gtk_hbox_new (FALSE, 12);
< 	gtk_box_pack_start (GTK_BOX (vbox), hbox, TRUE, TRUE, 0);
< 
< 	image = gtk_image_new_from_stock ("gtk-dialog-question", GTK_ICON_SIZE_DIALOG);
< 	gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, TRUE, 0);
< 
< 	label = gtk_label_new (_("Replace selected text?"));
< 	gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);
< 	gtk_label_set_justify (GTK_LABEL (label), GTK_JUSTIFY_LEFT);
< 	gtk_label_set_line_wrap (GTK_LABEL (label), TRUE);
< 
< 	gtk_box_pack_start (GTK_BOX (vbox), gtk_hseparator_new (), FALSE, TRUE, 12);
< 
< 	hbox = gtk_hbutton_box_new ();
< 	gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, TRUE, 0);
< 	gtk_button_box_set_layout (GTK_BUTTON_BOX (hbox), GTK_BUTTONBOX_END);
< 	gtk_box_set_spacing (GTK_BOX (hbox), 6);
< 
< 	butclose = bf_gtkstock_button(GTK_STOCK_CLOSE, G_CALLBACK(window_close_by_widget_cb), NULL);
< 	butskip = bf_allbuttons_backend(_("_Skip"), TRUE, 1000, G_CALLBACK(replace_prompt_dialog_skip_lcb), bfwin);
< 	butok = bf_allbuttons_backend(_("_Replace"), TRUE, 1001, G_CALLBACK(replace_prompt_dialog_ok_lcb), bfwin);
< 	butall = bf_generic_mnemonic_button(_("Replace _all"), G_CALLBACK(replace_prompt_dialog_all_lcb), bfwin);
< 	gtk_box_pack_start(GTK_BOX(hbox), butclose, FALSE, FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(hbox), butall, FALSE, FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(hbox), butok, FALSE, FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(hbox), butskip, FALSE, FALSE, 0);
< 	gtk_widget_grab_focus(butskip);
< 	gtk_widget_show_all(win);
< 	DEBUG_MSG("replace_prompt_dialog, end\n");
< }
< 
< /**
<  * replace_prompt_doc:
<  * @search_pattern: #gchar* to search pattern
<  * @matchtype: see #Tmatch_types
<  * @is_case_sens: #gint
<  * @startpos: Start offset in document buffer.
<  * @endpos: End offset of search area. Set to -1 to cover entire buffer.
<  * @replace_pattern: #gchar to replace pattern
<  * @doc: a #Tdocument
<  * 
<  * Finds the next occurence of search_pattern in *doc, shows and selects it in the document,
<  * and finally shows a replace_prompt_dialog to the user.
<  *
<  * last_snr2 is updated if an occurrence of search_pattern is found.
<  * 
<  * Return value: #gint, 1 if a new occurence of the search_pattern was found and a dialog is shown. 0 else.
<  **/
< gint replace_prompt_doc(Tbfwin *bfwin, gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gint startpos, gint endpos, gchar *replace_pattern, Tdocument *doc, gboolean unescape) {
< /* endpos -1 means do till end , returns if the document still had a match*/
< 	gchar *fulltext, *realpat;
< 	Tsearch_result result;
< 
< 	DEBUG_MSG("replace_prompt_doc, doc=%p, startpos=%d, endpos=%d\n",doc,startpos,endpos);
< 	if (LASTSNR2(bfwin->snr2)->result.pmatch) {
< 		g_free(LASTSNR2(bfwin->snr2)->result.pmatch);
< 		LASTSNR2(bfwin->snr2)->result.pmatch = NULL;
< 	}
< 	fulltext = doc_get_chars(doc, startpos, endpos);
< 	utf8_offset_cache_reset();
< 	if (unescape) {
< 		realpat = unescape_string(search_pattern, FALSE);
< 	} else {
< 		realpat = search_pattern;
< 	}
< 	result = search_backend(bfwin,realpat, matchtype, is_case_sens, fulltext, 0, -1, TRUE);
< 	if (unescape) {
< 		g_free(realpat);
< 	}
< 	LASTSNR2(bfwin->snr2)->doc = doc;
< 	g_free(fulltext);
< 	DEBUG_MSG("replace_prompt_doc, doc=%p, result.end=%d\n", doc, result.end);
< 	if (result.end > 0) {
< 		gint i;
< 		LASTSNR2(bfwin->snr2)->result.start = result.start + startpos;
< 		LASTSNR2(bfwin->snr2)->result.end = result.end + startpos;
< 		LASTSNR2(bfwin->snr2)->result.nmatch = result.nmatch;
< 		LASTSNR2(bfwin->snr2)->result.pmatch = result.pmatch;
< 		for (i=0;i<result.nmatch;i++) {
< 			DEBUG_MSG("replace_prompt_doc, adding offset %d to subsearch_pattern %d\n", startpos, i);
< 			LASTSNR2(bfwin->snr2)->result.pmatch[i].rm_so += startpos;
< 			LASTSNR2(bfwin->snr2)->result.pmatch[i].rm_eo += startpos;
< 		}
< 		doc_show_result(doc, result.start + startpos, result.end + startpos);
< 		replace_prompt_dialog(bfwin);
< 		return 1;
< 	} else {
< 		g_free(result.pmatch);
< 		return 0;
< 	}
< }
< 
< /**
<  * replace_prompt_all:
<  * @search_pattern: #gchar* to search pattern
<  * @matchtype: see #Tmatch_types
<  * @is_case_sens: #gint
<  * @replace_pattern: #gchar to replace pattern
<  * 
<  * Performs a replace_prompt_doc for all open documents.
<  * 
<  * Return value: void
<  **/
< void replace_prompt_all(Tbfwin *bfwin,gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gchar *replace_pattern, gboolean unescape) {
< 	GList *tmplist;
< 	gint retvalue;
< 	Tdocument *tmpdoc;
< 
< 	if (LASTSNR2(bfwin->snr2)->doc) {
< 		tmpdoc = LASTSNR2(bfwin->snr2)->doc;
< 	} else {
< 		tmplist = g_list_first(bfwin->documentlist);
< 		tmpdoc = (Tdocument *)tmplist->data;
< 	}
< 	DEBUG_MSG("replace_prompt_all, starting with tmpdoc=%p at position %d\n",tmpdoc,LASTSNR2(bfwin->snr2)->result.end);
< 	retvalue = replace_prompt_doc(bfwin,search_pattern, matchtype, is_case_sens, (LASTSNR2(bfwin->snr2)->result.end < 0)?0:LASTSNR2(bfwin->snr2)->result.end, -1, replace_pattern, tmpdoc, unescape);
< 	while (retvalue == 0) {
< 		tmplist = g_list_find(bfwin->documentlist, LASTSNR2(bfwin->snr2)->doc);
< 		tmplist = g_list_next(tmplist);
< 		if (tmplist) {
< 			DEBUG_MSG("replace_prompt_all, next document is %p\n",tmplist->data);
< 			retvalue = replace_prompt_doc(bfwin,search_pattern, matchtype, is_case_sens, 0, -1, replace_pattern, (Tdocument *)tmplist->data, unescape);
< 		} else {
< 			retvalue = 1;
< 		}
< 	}
< }
< 
< static void search_doc_bookmark_backend(Tbfwin *bfwin,Tdocument *document, gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gint startpos, gint endpos, gboolean unescape) {
< 	gchar *fulltext, *realpat;
<     gint buf_byte_offset = 0;
< 	Tsearch_result result;
< 	fulltext = doc_get_chars(document, 0, -1);
< 	utf8_offset_cache_reset();
< 	if (unescape) {
< 		realpat = unescape_string(search_pattern, FALSE);
< 	} else {
< 		realpat = search_pattern;
< 	}
< 	result = search_backend(bfwin,realpat, matchtype, is_case_sens, fulltext, startpos, endpos, FALSE);
< 	while (result.end > 0) {
< 		gchar *text = doc_get_chars(document, result.start, result.end);
< 		DEBUG_MSG("search_bookmark, adding bookmark '%s' at %d\n", text, result.start);
< 		bmark_add_extern(document, result.start, NULL, text, !main_v->props.bookmarks_default_store);
< 		g_free(text);
< 		if (LASTSNR2(bfwin->snr2)->overlapping_search) {
< 			buf_byte_offset = result.bstart + 1;
< 		} else {
< 			buf_byte_offset = result.bend;
< 		}
< 		result = search_backend(bfwin,realpat, matchtype, is_case_sens, fulltext, buf_byte_offset, endpos, FALSE);
< 	}
< 	if (unescape) {
< 		g_free(realpat);
< 	}
< 	g_free(fulltext);
< }
< 
< /**
<  * search_bookmark:
<  * @bfwin: #Tbfwin *
<  * @startat: #gint
<  *
<  * will search, and bookmark all matches
<  * 
<  */
< static void search_bookmark(Tbfwin *bfwin, gint startpos, gint endpos) {
< 	DEBUG_MSG("search_bookmark, started\n");
< 	if (LASTSNR2(bfwin->snr2)->placetype_option==opened_files) {
< 		GList *tmplist = g_list_first(bfwin->documentlist);
< 		while (tmplist) {
< 			search_doc_bookmark_backend(bfwin,DOCUMENT(tmplist->data), LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, 0, -1, LASTSNR2(bfwin->snr2)->unescape);
< 			tmplist = g_list_next(tmplist);
< 		}
< 	} else {
< 		search_doc_bookmark_backend(bfwin,DOCUMENT(bfwin->current_document), LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, startpos, endpos, LASTSNR2(bfwin->snr2)->unescape);
< 	}
< 	DEBUG_MSG("search_bookmark, done\n");
< }
< 
< /*****************************************************/
< 
< /**
<  * snr2_run:
<  * @bfwin: #Tbfwin*
<  * @doc: a #Tdocument* If set to NULL, use bfwin->current_document
<  *
<  * Continues a search or replace action as specified by the last_snr2 struct.
<  * 
<  * Return value: void
<  **/
< void snr2_run(Tbfwin *bfwin, Tdocument *doc) {
< 	gint startpos, endpos;
< 	Tsearch_result result;
< 	Tsearch_all_result result_all;
< 	Treplace_types replacetype;
< 
< 	if (doc==NULL) {
< 		doc = bfwin->current_document;
< 	}
< 
< 	if (LASTSNR2(bfwin->snr2)->result.pmatch) {
< 		g_free(LASTSNR2(bfwin->snr2)->result.pmatch);
< 		LASTSNR2(bfwin->snr2)->result.pmatch = NULL;
< 	}
< 
< 	/* should be more stuff here */
< 	if (LASTSNR2(bfwin->snr2)->placetype_option==beginning) {
< 		startpos = 0;
< 		endpos = -1;
< 	} else if (LASTSNR2(bfwin->snr2)->placetype_option==cursor) {
< 		startpos = doc_get_cursor_position(doc);
< 		endpos = -1;
< 	} else if (LASTSNR2(bfwin->snr2)->placetype_option==selection) {
< 		if (!doc_get_selection(doc,&startpos,&endpos)) {
< 			/* what to do if there was no selection ?*/
< 			DEBUG_MSG("snr2_run, no selection found, returning\n");
< 			return;
< 		}
< 		DEBUG_MSG("snr2_run, from selection: startpos=%d, endpos=%d\n", startpos, endpos);
< 	}
< 	if (LASTSNR2(bfwin->snr2)->doc == doc) {
< 		if (LASTSNR2(bfwin->snr2)->result.end > 0) {
< 			if (LASTSNR2(bfwin->snr2)->overlapping_search) {
< 				startpos = LASTSNR2(bfwin->snr2)->result.start + 1;
< 			} else {
< 				startpos = LASTSNR2(bfwin->snr2)->result.end;
< 			}
< 		}
< 		DEBUG_MSG("snr2_run, LASTSNR2(bfwin->snr2)->result.end=%d, startpos=%d\n", LASTSNR2(bfwin->snr2)->result.end, startpos);
< 	}
< 	if (LASTSNR2(bfwin->snr2)->replace) {
< 		if (LASTSNR2(bfwin->snr2)->replacetype_option==string) {
< 			replacetype = string;
< 		} else if (LASTSNR2(bfwin->snr2)->replacetype_option==uppercase) {
< 			replacetype = uppercase;
< 		} else {
< 			replacetype = lowercase;
< 		}
< 	
< 		if (LASTSNR2(bfwin->snr2)->prompt_before_replace) {
< 			if (LASTSNR2(bfwin->snr2)->placetype_option==opened_files) {
< 				replace_prompt_all(bfwin,LASTSNR2(bfwin->snr2)->search_pattern,LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, LASTSNR2(bfwin->snr2)->replace_pattern, LASTSNR2(bfwin->snr2)->unescape);
< 			} else {
< 				replace_prompt_doc(bfwin,LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, startpos, endpos, LASTSNR2(bfwin->snr2)->replace_pattern, doc, LASTSNR2(bfwin->snr2)->unescape);
< 			}
< 		} else {
< 			if (LASTSNR2(bfwin->snr2)->placetype_option==opened_files) {
< 				replace_all(bfwin,LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, LASTSNR2(bfwin->snr2)->replace_pattern, replacetype, LASTSNR2(bfwin->snr2)->unescape);
< 			} else if (LASTSNR2(bfwin->snr2)->replace_once) {
< 				replace_doc_once(bfwin,LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, startpos, endpos, LASTSNR2(bfwin->snr2)->replace_pattern, doc, replacetype, LASTSNR2(bfwin->snr2)->unescape);
< 			} else {
< 				replace_doc_multiple(bfwin,LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, startpos, endpos, LASTSNR2(bfwin->snr2)->replace_pattern, doc, replacetype, LASTSNR2(bfwin->snr2)->unescape);
< 			}		
< 		}
< 	} else { /* find, not replace */
< 		if (LASTSNR2(bfwin->snr2)->bookmark_results) {
< 			search_bookmark(bfwin, startpos, endpos);
< 		} else {
< 			if (LASTSNR2(bfwin->snr2)->placetype_option==opened_files) {
< 				DEBUG_MSG("snr2dialog_ok_lcb, search = all\n");
< 				result_all = search_all(bfwin,LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, LASTSNR2(bfwin->snr2)->unescape);
< 				DEBUG_MSG("snr2dialog_ok_lcb, result_all.doc=%p\n",result_all.doc);
< 				if (result_all.end > 0) {
< 					doc_show_result(result_all.doc, result_all.start, result_all.end);
< 				} else {
< 					info_dialog(bfwin->main_window,_("Search: no match found"), NULL);
< 				}
< 			} else {
< 				result = search_doc(bfwin,doc, LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, startpos, LASTSNR2(bfwin->snr2)->unescape);
< 				if (result.end > 0) {
< 					doc_show_result(doc, result.start, result.end);
< 				} else {
< 					info_dialog(bfwin->main_window,_("Search: no match found"), NULL);
< 				}
< 			}
< 		}
< 	}
< 	/* if highlighting is needed for this document do this now !! */
< 	if (doc->need_highlighting && doc->highlightstate) {
< 		doc_highlight_full(doc);
< 	}
< }
< 
< /**
<  * snr2_run_extern_replace:
<  * @doc: a #Tdocument
<  * @search_pattern: #gchar* to search pattern
<  * @region: #gint, 0 = region_from_beginning, 1 = region_from_cursor, 2 = region_selection, 3 = region_all_open_files
<  * @matchtype: #gint, 0 = normal, 1 = posix, 2 = perl
<  * @is_case_sens: #gint
<  * @replace_pattern: #gchar* to replace pattern.
<  * @store_as_last_snr2: Set to FALSE to keep the old last_snr2 after the snr has been completed.
<  * 
<  * Performs the specified replace action on the document by setting
<  * a last_snr2 and calling snr2_run().
<  *
<  * Additional non-configureable arguments passed to snr2_run() via last_snr2:
<  * replace = 1
<  * prompt_before_replace = off
<  * replace_once = off
<  *
<  * Return value: void
<  **/
< void snr2_run_extern_replace(Tdocument *doc, gchar *search_pattern, gint region,
< 							gint matchtype, gint is_case_sens, gchar *replace_pattern,
< 							gboolean store_as_last_snr2) {
< 	Tbfwin *bfwin = BFWIN(doc->bfwin);
< 	gchar *search_pattern_bck, *replace_pattern_bck;
< 	Tlast_snr2 last_snr2_bck;
< 	
< 	search_pattern_bck = LASTSNR2(bfwin->snr2)->search_pattern;
< 	replace_pattern_bck = LASTSNR2(bfwin->snr2)->replace_pattern;
< 	last_snr2_bck = *LASTSNR2(bfwin->snr2);
< 	DEBUG_MSG("snr2..extern..: last_snr2_bck.search_pattern=%p, replace_pattern=%p\n"
< 		,last_snr2_bck.search_pattern, last_snr2_bck.replace_pattern);
< 
< 	if (!search_pattern || !replace_pattern || !strlen(search_pattern)) {
< 		DEBUG_MSG("snr2_run_extern, returning, non-valid arguments\n");
< 		return;
< 	}
< 	DEBUG_MSG("snr2..extern..: doc=%p, search_pattern='%s', region=%d, matchtype=%d, is_case_sens=%d, replace_pattern=%s, store_as_last=%d\n"
< 			,doc,search_pattern,region,matchtype,is_case_sens,replace_pattern,store_as_last_snr2);
< 	LASTSNR2(bfwin->snr2)->search_pattern = g_strdup(search_pattern);
< 	LASTSNR2(bfwin->snr2)->placetype_option = region;
<  	LASTSNR2(bfwin->snr2)->is_case_sens = is_case_sens;
<  	LASTSNR2(bfwin->snr2)->overlapping_search = 0;
< 	LASTSNR2(bfwin->snr2)->replace = 1;
< 	LASTSNR2(bfwin->snr2)->replace_pattern = g_strdup(replace_pattern);
<  	LASTSNR2(bfwin->snr2)->prompt_before_replace = 0;
<  	LASTSNR2(bfwin->snr2)->replace_once = 0;
<  	LASTSNR2(bfwin->snr2)->unescape = 0;
< 	LASTSNR2(bfwin->snr2)->matchtype_option = matchtype;
<  	LASTSNR2(bfwin->snr2)->replacetype_option = string;
<  	LASTSNR2(bfwin->snr2)->bookmark_results = 0;
< 	snr2_run(BFWIN(doc->bfwin),doc);
< 	if (store_as_last_snr2) {
< 		DEBUG_MSG("free-ing old patterns at %p and %p\n",search_pattern_bck,replace_pattern_bck);
< 		g_free(search_pattern_bck);
< 		g_free(replace_pattern_bck);
< 	} else {
< 		g_free(LASTSNR2(bfwin->snr2)->search_pattern);
< 		g_free(LASTSNR2(bfwin->snr2)->replace_pattern);
< 		*LASTSNR2(bfwin->snr2) = last_snr2_bck;
< 	}
< }
< 
< /**
<  * doc_search_run_extern:
<  * @doc: a #Tdocument
<  * @search_pattern: #gchar search pattern
<  * @matchtype: #gint, 0 = normal, 1 = posix, 2 = perl
<  * @is_case_sens: #gint, case sensitive pattern?
<  *
<  * Frontend for search_doc, calling it with supplied arguments and startpos = 0.
<  * 
<  * Return value: #Tsearch_result_doc
<  **/
< Tsearch_result doc_search_run_extern(Tdocument *doc, gchar *search_pattern, gint matchtype, gint is_case_sens) {
< 	return search_doc(BFWIN(doc->bfwin),doc, search_pattern, matchtype, is_case_sens, 0, FALSE);
< } 
< 
< /******************************************************/
< /*        Search and replace dialogs callbacks        */
< /******************************************************/
< 
< static void snr2dialog_destroy_lcb(GtkWidget *widget, gpointer data) {
< 	DEBUG_MSG("snr2dialog_destroy_lcb, started, about to call window_destroy\n");
< 	window_destroy(((Tsnr2_win *)data)->window);
< 	DEBUG_MSG("snr2dialog_destroy_lcb, about to free data %p\n", data);
< 	g_free(data);
< 	DEBUG_MSG("snr2dialog_destroy_lcb, done\n");
< }
< 
< static void snr2dialog_cancel_lcb(GtkWidget *widget, gpointer data) {
< 	snr2dialog_destroy_lcb(NULL, data);
< }
< 
< /*****************************************************/
< 
< /*
<  * Sets the last_snr2 as specified by the user and calls snr2_run(NULL) (aka, run on current document)
<  */
< static void snr2dialog_ok_lcb(GtkWidget *widget, Tsnr2_win *data) {
< 	/*GtkTextIter itstart, itend;
< 	GtkTextBuffer *buf;*/
< 	Tbfwin *bfwin = data->bfwin;
< 	if (LASTSNR2(bfwin->snr2)->search_pattern) {
< 		g_free(LASTSNR2(bfwin->snr2)->search_pattern);
< 		LASTSNR2(bfwin->snr2)->search_pattern = NULL;
< 	}
< 	if (LASTSNR2(bfwin->snr2)->replace_pattern) {
< 		g_free(LASTSNR2(bfwin->snr2)->replace_pattern);
< 		LASTSNR2(bfwin->snr2)->replace_pattern = NULL;
< 	}
< 	/*buf = gtk_text_view_get_buffer(GTK_TEXT_VIEW(data->search_entry));
< 	gtk_text_buffer_get_bounds(buf,&itstart,&itend);
< 	LASTSNR2(bfwin->snr2)->search_pattern = gtk_text_buffer_get_text(buf,&itstart,&itend, FALSE);*/
< 	LASTSNR2(bfwin->snr2)->search_pattern = gtk_editable_get_chars(GTK_EDITABLE(GTK_COMBO(data->search_combo)->entry),0,-1);
< 	
< 	data->bfwin->session->searchlist = add_to_history_stringlist(data->bfwin->session->searchlist,LASTSNR2(bfwin->snr2)->search_pattern,TRUE,TRUE);
< 	
< 	LASTSNR2(bfwin->snr2)->unescape = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->unescape));
<  	LASTSNR2(bfwin->snr2)->is_case_sens = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->is_case_sens));
<  	LASTSNR2(bfwin->snr2)->overlapping_search = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->overlapping_search));
< 	if (data->replace) {
< 		/*GtkTextIter itstart, itend;
< 		GtkTextBuffer *buf = gtk_text_view_get_buffer(GTK_TEXT_VIEW(data->replace_entry));
< 		gtk_text_buffer_get_bounds(buf,&itstart,&itend);
< 		LASTSNR2(bfwin->snr2)->replace_pattern = gtk_text_buffer_get_text(buf,&itstart,&itend, FALSE);*/
< 		LASTSNR2(bfwin->snr2)->replace = 1;
< 		LASTSNR2(bfwin->snr2)->replace_pattern = gtk_editable_get_chars(GTK_EDITABLE(GTK_COMBO(data->replace_combo)->entry),0,-1);
< 		
< 		data->bfwin->session->replacelist = add_to_history_stringlist(data->bfwin->session->replacelist,LASTSNR2(bfwin->snr2)->replace_pattern,TRUE,TRUE);
< 		
< 	 	LASTSNR2(bfwin->snr2)->prompt_before_replace = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->prompt_before_replace));
< 	 	LASTSNR2(bfwin->snr2)->replace_once = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->replace_once));
< 	} else {
< 		LASTSNR2(bfwin->snr2)->replace = 0;
< 		LASTSNR2(bfwin->snr2)->bookmark_results = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->bookmark_results));
< 	}
< 	window_destroy(data->window);
< 	g_free(data);
< 
< 	snr2_run(bfwin,NULL);
< }
< 
< static void placetype_changed_lcb(GtkWidget *widget, Tsnr2_win *snr2win) {
< 	LASTSNR2(snr2win->bfwin->snr2)->placetype_option =  gtk_option_menu_get_history((GtkOptionMenu *) snr2win->placetype_option);
< 	DEBUG_MSG("placetype_changed_lcb, changing option to %d\n", LASTSNR2(snr2win->bfwin->snr2)->placetype_option);
< }	
< 
< static void matchtype_changed_lcb(GtkWidget *widget, Tsnr2_win *snr2win) {
< 	LASTSNR2(snr2win->bfwin->snr2)->matchtype_option =  gtk_option_menu_get_history((GtkOptionMenu *) snr2win->matchtype_option);
< 	if (snr2win->replace) {
< 		if (LASTSNR2(snr2win->bfwin->snr2)->matchtype_option==0) {
< 			gtk_widget_hide(snr2win->subpat_help);
< 		}
< 		else {
< 			gtk_widget_show(snr2win->subpat_help);
< 		}
< 	}
< 	DEBUG_MSG("matchtype_changed_lcb, changing option to %d\n", LASTSNR2(snr2win->bfwin->snr2)->matchtype_option);
< }	
< 
< static void replacetype_changed_lcb(GtkWidget *widget, Tsnr2_win *snr2win) {
< 	LASTSNR2(snr2win->bfwin->snr2)->replacetype_option =  gtk_option_menu_get_history((GtkOptionMenu *) snr2win->replacetype_option);
< 	/*gtk_widget_set_sensitive(snr2win->replace_entry, LASTSNR2(snr2win->bfwin->snr2)->replacetype_option==0);*/
< 	gtk_widget_set_sensitive(snr2win->replace_combo, LASTSNR2(snr2win->bfwin->snr2)->replacetype_option==0);
< 	DEBUG_MSG("replacetype_changed_lcb, changing option to %d\n", LASTSNR2(snr2win->bfwin->snr2)->replacetype_option);
< }
< /*
< static gboolean search_entry_key_press_event_lcb(GtkWidget *widget,GdkEventKey *event,Tsnr2_win *snr2win) {
< 	if ((event->state & GDK_CONTROL_MASK) && (event->keyval == GDK_Return)) {
< 		snr2dialog_ok_lcb(NULL, snr2win);
< 		return TRUE;
< 	}
< 	return FALSE;
< }*/
< 
< static gboolean snr_focus_in_lcb(GtkWidget *widget, GdkEventFocus *event, Tsnr2_win *snr2win)
< {
<     if (snr2win->replace == 0) {
<         if (snr2win->bfwin->current_document->filename) {
<             gtk_widget_set_sensitive (snr2win->bookmark_results, TRUE);
<             if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (snr2win->bookmark_results))) {
<                 LASTSNR2(snr2win->bfwin->snr2)->bookmark_results = TRUE;
<             }
<         } else {
<             LASTSNR2(snr2win->bfwin->snr2)->bookmark_results = FALSE;
<             gtk_widget_set_sensitive (snr2win->bookmark_results, FALSE);
<         }
<     }
< 
<     return FALSE;
< }
< 
< static void snr2dialog(Tbfwin *bfwin, gint is_replace, gint is_new_search) {
< 	Tsnr2_win *snr2win;
< 	GtkWidget *vbox, *hbox, *button, *table;
< 	const gchar *tmptext;
<    gchar *buffer;
<    GtkTextIter start, end;
< 
< 	snr2win = g_malloc(sizeof(Tsnr2_win));
< 	snr2win->bfwin = bfwin;
< 	if (is_replace) {
< 		tmptext = _("Replace");
< 		snr2win->replace = 1;
< 	} else {
< 		tmptext = _("Find");
< 		snr2win->replace = 0;
< 	}
< 	if (is_new_search) {
< 		reset_last_snr2(bfwin);
< 	} else {
< 		LASTSNR2(bfwin->snr2)->result.start = -1;
< 		LASTSNR2(bfwin->snr2)->result.end = -1;
< 		LASTSNR2(bfwin->snr2)->doc = NULL;
< 	}
< 	snr2win->window = window_full(tmptext, GTK_WIN_POS_MOUSE, 12, G_CALLBACK(snr2dialog_destroy_lcb), snr2win, TRUE);
< 	gtk_window_set_role(GTK_WINDOW(snr2win->window), "snr");
< 	g_signal_connect_after(G_OBJECT(snr2win->window), "focus-in-event", G_CALLBACK(snr_focus_in_lcb), snr2win);
< 	vbox = gtk_vbox_new(FALSE, 0);
< 	gtk_container_add(GTK_CONTAINER(snr2win->window), vbox);
< 
< 	if (is_replace) {
< 		table = gtk_table_new (2, 2, FALSE);
< 	}
< 	else {
< 		table = gtk_table_new (1, 2, FALSE);
< 	}
< 	gtk_widget_show (table);
< 	gtk_box_pack_start (GTK_BOX (vbox), table, TRUE, TRUE, 0);
< 	gtk_table_set_row_spacings (GTK_TABLE (table), 12);
< 	gtk_table_set_col_spacings (GTK_TABLE (table), 6);
< 
< 	snr2win->search_label = gtk_label_new_with_mnemonic(_("_Search for: "));
< 	gtk_table_attach (GTK_TABLE (table), snr2win->search_label, 0, 1, 0, 1,
< 					(GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 2, 0);
< 	gtk_label_set_justify (GTK_LABEL (snr2win->search_label), GTK_JUSTIFY_LEFT);
< 	gtk_misc_set_alignment (GTK_MISC (snr2win->search_label), 0, 0.5);
< 	/*snr2win->search_scrollbox = textview_buffer_in_scrolwin(&snr2win->search_entry, 300, 50, LASTSNR2(bfwin->snr2)->search_pattern, GTK_WRAP_NONE);*/
<    gtk_text_buffer_get_selection_bounds(bfwin->current_document->buffer, &start, &end);
<    buffer = gtk_text_buffer_get_text(bfwin->current_document->buffer, &start, &end, FALSE);
<    if (strchr(buffer,'\n')!=NULL) {
<       /* a newline in the selection, we probably don't want this string as search string */
<       g_free(buffer);
<       buffer = NULL;
<    }
<    snr2win->search_combo = combo_with_popdown(buffer ? buffer : "", bfwin->session->searchlist, TRUE);
<    if (buffer) g_free(buffer);
< 	gtk_table_attach (GTK_TABLE (table), snr2win->search_combo, 1, 2, 0, 1,
< 					(GtkAttachOptions) (GTK_EXPAND | GTK_FILL), (GtkAttachOptions) (GTK_FILL), 0, 0);
< 	/*g_signal_connect(G_OBJECT(snr2win->search_entry), "key_press_event", G_CALLBACK(search_entry_key_press_event_lcb), snr2win);*/
< 
< 	if (is_replace) {
< 		snr2win->replace_label = gtk_label_new_with_mnemonic(_("_Replace with: "));
< 		gtk_table_attach (GTK_TABLE (table), snr2win->replace_label, 0, 1, 1, 2,
< 						(GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 2, 0);
< 		gtk_label_set_justify (GTK_LABEL (snr2win->replace_label), GTK_JUSTIFY_LEFT);
< 		gtk_misc_set_alignment (GTK_MISC (snr2win->replace_label), 0, 0.5);
< 		/*snr2win->replace_scrollbox = textview_buffer_in_scrolwin(&snr2win->replace_entry, 300, 50, LASTSNR2(bfwin->snr2)->replace_pattern, GTK_WRAP_NONE);*/
< 		snr2win->replace_combo = combo_with_popdown("", bfwin->session->replacelist, TRUE);
< 		gtk_table_attach (GTK_TABLE (table), snr2win->replace_combo, 1, 2, 1, 2,
< 						(GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (GTK_FILL), 0, 0);
< 		/*g_signal_connect(G_OBJECT(snr2win->replace_entry), "key_press_event", G_CALLBACK(search_entry_key_press_event_lcb), snr2win);*/
< 		snr2win->subpat_help = gtk_label_new(_("\\0 refers to the first subsearch_pattern, \\1 to the second etc."));
< 		gtk_box_pack_start(GTK_BOX(vbox), snr2win->subpat_help, FALSE, TRUE, 6);
< 		gtk_label_set_justify (GTK_LABEL (snr2win->subpat_help), GTK_JUSTIFY_LEFT);
< 		gtk_misc_set_alignment (GTK_MISC (snr2win->subpat_help), 1, 0.5);
< 	}
< 
< 	if (is_replace) {
< 		table = gtk_table_new (3, 2, FALSE);
< 	} else {
< 		table = gtk_table_new (2, 2, FALSE);
< 	}
< 	gtk_box_pack_start (GTK_BOX (vbox), table, TRUE, TRUE, 12);
< 	gtk_table_set_row_spacings (GTK_TABLE (table), 12);
< 	gtk_table_set_col_spacings (GTK_TABLE (table), 6);
< 	{
< 		gchar *placeactions[] = {N_("Beginning of document till end"), N_("Current position till end"),	N_("Beginning of selection till end of selection"), N_("All opened files begin till end"), NULL};
< 		gchar *matchactions[] = {N_("Disabled"), N_("POSIX type"),	N_("PERL type"), NULL};
< 		GtkWidget *matchlabel, *placelabel = gtk_label_new(_("Starts at:"));
< 		DEBUG_MSG("snr2dialog, LASTSNR2(bfwin->snr2)->placetype_option=%d\n", LASTSNR2(bfwin->snr2)->placetype_option);
< 		snr2win->placetype_option = optionmenu_with_value(placeactions, LASTSNR2(bfwin->snr2)->placetype_option);
< 
< 		gtk_table_attach (GTK_TABLE (table), placelabel, 0, 1, 0, 1,
< 						(GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 2, 0);
< 		gtk_label_set_justify (GTK_LABEL (placelabel), GTK_JUSTIFY_LEFT);
< 		gtk_misc_set_alignment (GTK_MISC (placelabel), 0, 0.5);
< 		gtk_table_attach (GTK_TABLE (table), snr2win->placetype_option, 1, 2, 0, 1, 
< 						(GtkAttachOptions) (GTK_EXPAND | GTK_FILL), (GtkAttachOptions) (GTK_FILL), 0, 0);
< 		g_signal_connect(G_OBJECT((GtkWidget *) snr2win->placetype_option), "changed", G_CALLBACK(placetype_changed_lcb), snr2win);
< 		
< 		matchlabel = gtk_label_new(_("Regular expression:"));
< 		DEBUG_MSG("snr2dialog, LASTSNR2(bfwin->snr2)->matchtype_option=%d\n", LASTSNR2(bfwin->snr2)->matchtype_option);
< 		snr2win->matchtype_option = optionmenu_with_value(matchactions, LASTSNR2(bfwin->snr2)->matchtype_option);
< 
< 		gtk_table_attach (GTK_TABLE (table), matchlabel, 0, 1, 1, 2,
< 						(GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 2, 0);
< 		gtk_label_set_justify (GTK_LABEL (matchlabel), GTK_JUSTIFY_LEFT);
< 		gtk_misc_set_alignment (GTK_MISC (matchlabel), 0, 0.5);
< 		gtk_table_attach (GTK_TABLE (table), snr2win->matchtype_option, 1, 2, 1, 2, 
< 						(GtkAttachOptions) (GTK_EXPAND | GTK_FILL), (GtkAttachOptions) (GTK_FILL), 0, 0);
< 		g_signal_connect(G_OBJECT((GtkWidget *) snr2win->matchtype_option), "changed", G_CALLBACK(matchtype_changed_lcb), snr2win);
< 
< 
< 		if (is_replace) {
< 			gchar *replaceactions[] = {N_("Normal"), N_("Uppercase"),	N_("Lowercase"), NULL};
< 			GtkWidget *replacelabel = gtk_label_new(_("Replace type:"));
< 			DEBUG_MSG("snr2dialog, LASTSNR2(bfwin->snr2)->replacetype_option=%d\n", LASTSNR2(bfwin->snr2)->replacetype_option);
< 			snr2win->replacetype_option = optionmenu_with_value(replaceactions, LASTSNR2(bfwin->snr2)->replacetype_option);
< 	
< 			gtk_table_attach (GTK_TABLE (table), replacelabel, 0, 1, 2, 3, 
< 							(GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 2, 0);
< 			gtk_label_set_justify (GTK_LABEL (replacelabel), GTK_JUSTIFY_LEFT);
< 			gtk_misc_set_alignment (GTK_MISC (replacelabel), 0, 0.5);
< 			gtk_table_attach (GTK_TABLE (table), snr2win->replacetype_option, 1, 2, 2, 3, 
< 							(GtkAttachOptions) (GTK_EXPAND | GTK_FILL), (GtkAttachOptions) (GTK_FILL), 0, 0);
< 			g_signal_connect(G_OBJECT((GtkWidget *) snr2win->replacetype_option), "changed", G_CALLBACK(replacetype_changed_lcb), snr2win);
< 		}
< 	}
< 	snr2win->unescape = boxed_checkbut_with_value(_("_Patterns contain backslash escape sequences (\\n, \\t)"), LASTSNR2(bfwin->snr2)->unescape, vbox);
< 	snr2win->is_case_sens = boxed_checkbut_with_value(_("_Match case"), LASTSNR2(bfwin->snr2)->is_case_sens, vbox);
< 	snr2win->overlapping_search = boxed_checkbut_with_value(_("O_verlap searches"), LASTSNR2(bfwin->snr2)->overlapping_search, vbox);
< 	if (is_replace) {
< 		snr2win->prompt_before_replace = boxed_checkbut_with_value(_("Prompt _before replace"), LASTSNR2(bfwin->snr2)->prompt_before_replace, vbox);
< 		snr2win->replace_once = boxed_checkbut_with_value(_("Replace o_nce"), LASTSNR2(bfwin->snr2)->replace_once, vbox);
< 	} else {
< 		snr2win->bookmark_results = boxed_checkbut_with_value(_("_Bookmark results"), LASTSNR2(bfwin->snr2)->bookmark_results, vbox);
< 	}
< 
< 	hbox = gtk_hseparator_new ();
< 	gtk_widget_show (hbox);
< 	gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, TRUE, 12);
< 
< 	hbox = gtk_hbutton_box_new();
< 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
< 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 6);
< 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);
< 
< 	gtk_box_pack_start(GTK_BOX(hbox), bf_stock_cancel_button(G_CALLBACK(snr2dialog_cancel_lcb), snr2win), FALSE, TRUE, 0);
< 	button = bf_stock_ok_button(G_CALLBACK(snr2dialog_ok_lcb), snr2win);
< 	gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);
< 	gtk_window_set_default(GTK_WINDOW(snr2win->window), button);
< 	
< 	gtk_label_set_mnemonic_widget(GTK_LABEL(snr2win->search_label), GTK_COMBO(snr2win->search_combo)->entry);
< 	if(is_replace) {
< 		gtk_label_set_mnemonic_widget(GTK_LABEL(snr2win->replace_label), GTK_COMBO(snr2win->replace_combo)->entry);
< 	}
< 	gtk_widget_grab_focus(snr2win->search_combo);
< 	gtk_widget_show_all(vbox);
< 
< 	gtk_widget_show(snr2win->window);
< /*	{
< 		GtkTextIter itstart, itend;
< 		gtk_text_buffer_get_bounds(gtk_text_view_get_buffer(GTK_TEXT_VIEW(snr2win->search_entry)),&itstart,&itend);
< 		gtk_text_buffer_move_mark_by_name(gtk_text_view_get_buffer(GTK_TEXT_VIEW(snr2win->search_entry)),"insert",&itstart);
< 		gtk_text_buffer_move_mark_by_name(gtk_text_view_get_buffer(GTK_TEXT_VIEW(snr2win->search_entry)),"selection_bound",&itend);
< 	}*/
< 	
< 	if (is_replace) {
< 		matchtype_changed_lcb(NULL, snr2win);
< 		replacetype_changed_lcb(NULL, snr2win);
< 	}
< }
< 
< /*****************************************************/
< 
< void search_from_selection(Tbfwin *bfwin) {
< 	gchar *string;
< 	GtkClipboard* cb;
< 
< 	cb = gtk_clipboard_get(GDK_SELECTION_PRIMARY);
< 	string = gtk_clipboard_wait_for_text(cb);
< 	if (string) {
< 		if (LASTSNR2(bfwin->snr2)->search_pattern) {
< 			g_free(LASTSNR2(bfwin->snr2)->search_pattern);
< 		}
< 		if (LASTSNR2(bfwin->snr2)->replace_pattern) {
< 			g_free(LASTSNR2(bfwin->snr2)->replace_pattern);
< 			LASTSNR2(bfwin->snr2)->replace_pattern = NULL;
< 		}
< 		LASTSNR2(bfwin->snr2)->search_pattern = string;
< 		LASTSNR2(bfwin->snr2)->placetype_option = 0;
<  		LASTSNR2(bfwin->snr2)->is_case_sens = 1;
< 	 	LASTSNR2(bfwin->snr2)->overlapping_search = 0;
< 		LASTSNR2(bfwin->snr2)->replace = 0;
< 		LASTSNR2(bfwin->snr2)->matchtype_option = 0;
< 		snr2_run(bfwin,bfwin->current_document);
< 	}
< }
< 
< /**
<  * search_cb:
<  * @widget: unused #GtkWidget*
<  * @data: unused #gpointer
<  * 
<  * Show the search-dialog.
<  * 
<  * Return value: void
<  **/
< void search_cb(GtkWidget *widget, Tbfwin *bfwin) {
< 	snr2dialog(bfwin, 0, 0);
< }
< 
< /**
<  * search_again_cb:
<  * @widget: unused #GtkWidget*
<  * @data: unused #gpointer
<  * 
<  * Repeat last search, if any.
<  * 
<  * Return value: void
<  **/ 
< void search_again_cb(GtkWidget *widget, Tbfwin *bfwin) {
< 	snr2_run(bfwin,NULL);	
< }
< 
< /**
<  * replace_again_cb:
<  * @widget: unused #GtkWidget*
<  * @data: unused #gpointer
<  * 
<  * Repeat last replace, if any.
<  * 
<  * Return value: void
<  **/ 
< void replace_again_cb(GtkWidget *widget, Tbfwin *bfwin) {
< 	snr2_run(bfwin,NULL);
< }
< 
< /**
<  * replace_cb:
<  * @widget: unused #GtkWidget*
<  * @data: unused #gpointer
<  * 
<  * Show replace dialog.
<  * 
<  * Return value: void
<  **/ 
< void replace_cb(GtkWidget *widget, Tbfwin *bfwin) {
< 	snr2dialog(bfwin, 1, 0);
< }
< 
< /*****************************************************/
< 
< #ifdef NOTPORTEDYET
< 
< static gint do_filename_curfile_replace(gchar *fulltext, Tsearch_result result, gint offset, gchar *olddirname, gchar *newfilename, gint changelen, Tdocument *doc) {
< /* returns the change in the lenght of the buffer compared to the actual document text */
< 	gchar *possible_filename;
< 	gchar *olddirfile;
< 	gint len;
< 	gchar *replacestring;
< 	gint change_lenght = changelen;
< 
< 	possible_filename = g_strndup(&fulltext[offset + result.bstart +1], result.bend - result.bstart -2 );
< 	DEBUG_MSG("do_filename_change_replace, possible_filename=%s\n", possible_filename);
< 	len = strlen(possible_filename) + strlen(olddirname) + 2;
< 	olddirfile = strncat(strncat(strncpy(g_malloc(len), olddirname, len), "/", len), possible_filename, len);
< 
< 	/* code to check if this is a file */
< 	if (file_exists_and_readable(olddirfile)) {
< 		DEBUG_MSG("do_filename_change_replace, olddirfile=%s does exist!!\n", olddirfile);
< 		/* code to create replace_pattern */
< 		olddirfile = most_efficient_filename(olddirfile);
< #ifdef WIN32
< 		/* bf_chrrepl(olddirfile,"/","\\"); */
< #endif
< 		
< 		DEBUG_MSG("do_filename_change_replace, updated olddirfile=%s \n", olddirfile);
< 		replacestring = create_relative_link_to(newfilename, olddirfile);
< 		DEBUG_MSG("do_filename_change_replace, replacestring=%s, newfilename=%s\n", replacestring, newfilename);
< 		/* code to actual replace it */
< 		doc_replace_text(doc, replacestring, result.start + offset + 1 + changelen, result.end + offset + changelen -1);	
< 		change_lenght = strlen(replacestring) - strlen(possible_filename) + changelen;
< 		DEBUG_MSG("do_filename_change_replace, replacestring=%s, possible_filename=%s\n", replacestring, possible_filename);
< 		DEBUG_MSG("do_filename_change_replace, change_lenght=%d\n",change_lenght );		
< 		g_free(replacestring); 
< 	} else {
< 		DEBUG_MSG("do_filename_change_replace, olddirfile=%s does NOT exist\n", olddirfile);  
< 	}
< 	g_free(possible_filename);
< 	g_free(olddirfile);
< 	return change_lenght;
< }
< 
< static gint do_filename_otherfile_replace(gchar *fulltext, Tsearch_result result, gint offset, gchar *oldfilename, gchar *newfilename, gint changelen, Tdocument *doc) {
< 	gchar *possible_filename, *replacestring, *foundstring;
< 	gint change_length = changelen;
< 	gchar *eff_my_filename;
< 
< 	foundstring = g_strndup(&fulltext[offset + result.bstart +1], result.bend - result.bstart -2 );
< 	possible_filename = most_efficient_filename(create_full_path(foundstring, doc->filename));
< #ifdef WIN32
< 		/* bf_chrrepl(possible_filename,"/","\\"); */
< #endif
< 	g_free(foundstring);
< 	DEBUG_MSG("do_filename_otherfile_replace, posname=%s\n", possible_filename);
< 	DEBUG_MSG("do_filename_otherfile_replace, newname=%s\n", oldfilename);
< 	if (strcmp(possible_filename, oldfilename) == 0) {
< 		eff_my_filename = most_efficient_filename(g_strdup(doc->filename));
< #ifdef WIN32
< 		/* bf_chrrepl(eff_my_filename,"/","\\"); */
< #endif
< 		replacestring = create_relative_link_to(eff_my_filename, newfilename);
< 		doc_replace_text(doc, replacestring, result.start + offset + 1 + changelen, result.end + offset + changelen -1);
< 		change_length = strlen(replacestring) - strlen(possible_filename) + changelen;		
< 		g_free(eff_my_filename);
< 		g_free(replacestring);
< 	}
< 	g_free(possible_filename);
< 	return change_length;
< }
< 
< /**
<  * update_filenames_in_file:
<  * @doc: a #Tdocument
<  * @oldfilename: Filename to change from.
<  * @newfilename: Filename to change to.
<  * @doc_has_newfilename: If *doc (blabla?)
<  * 
<  * 
<  *
<  * Return value: void
<  **/
< void update_filenames_in_file(Tdocument *doc, gchar *oldfilename, gchar *newfilename, gint doc_has_newfilename) {
< 	gchar *fulltext;
< 	Tsearch_result result;
< 	gint cur_offset, changelen=0;
< 	gchar *search_pattern;
< 	Tmatch_types matchtype;
< 	gint is_case_sens;
< 	gchar *olddirname=NULL;
< 
< 	if ((oldfilename == NULL)|| (newfilename == NULL)) {
< 		return;
< 	}
< 	search_pattern = "\"[^\"]+\"";
< 	matchtype = match_posix;
<  	is_case_sens = 0;
< 	cur_offset = 0;
< 
< 	if (doc_has_newfilename) {
< 			olddirname = g_path_get_dirname(oldfilename);
< 	}
< 
< 	fulltext = doc_get_chars(doc, 0, -1);
< 	utf8_offset_cache_reset();
< 	result = search_backend(search_pattern, matchtype, is_case_sens, fulltext, -1, FALSE);
< 	while (result.end > 0) {
< 		if (doc_has_newfilename) {
< 			changelen = do_filename_curfile_replace(fulltext, result, cur_offset, olddirname, newfilename, changelen, doc);
< 		} else {
< 			changelen = do_filename_otherfile_replace(fulltext, result, cur_offset, oldfilename, newfilename, changelen, doc);
< 		}
< 		cur_offset += result.bstart +1;
< 		result = search_backend(search_pattern, matchtype, is_case_sens, &fulltext[cur_offset], -1, FALSE);
< 	}
< 	g_free(fulltext);
< 	if (doc_has_newfilename) {
< 		g_free(olddirname);
< 	}
< }
< #endif /* NOTPORTEDYET */
< 
< /**
<  * update_encoding_meta_in_file:
<  * @doc: a #Tdocument*
<  * @encoding: #gchar*, The documents character encoding
<  *
<  * Update the HTML meta encoding tags for the supplied document.
<  *
<  * Return value: void
<  **/
< void update_encoding_meta_in_file(Tdocument *doc, gchar *encoding) {
< 	if (encoding) {
< 		Tbfwin *bfwin = BFWIN(doc->bfwin);
< 		Tlast_snr2 last_snr2_bck = *LASTSNR2(bfwin->snr2);
< 		gchar *last_search_pattern_bck = g_strdup(LASTSNR2(bfwin->snr2)->search_pattern);
< 		gchar *search_pattern, *fulltext;
< 		Tsearch_result result;
< 		/* first find if there is a meta encoding tag already */
< 		search_pattern = "<meta[ \t\n]http-equiv[ \t\n]*=[ \t\n]*\"content-type\"[ \t\n]+content[ \t\n]*=[ \t\n]*\"([^;]*);[ \t\n]*charset=[a-z0-9-]*\"[ \t\n]*(/?)>";
< 		fulltext = doc_get_chars(doc, 0, -1);
< 		utf8_offset_cache_reset();
< 		result = search_backend(bfwin,search_pattern, match_posix, 0, fulltext, 0, -1, TRUE);
< 		if (result.end > 0) {
< 			gchar *replacestring, *type, *xhtmlend;
< 			DEBUG_MSG("update_encoding_meta_in_file, we have a match, nmatch=%d\n",result.nmatch);
< 			if (result.nmatch > 2) {
< 				type = g_strndup(fulltext+result.pmatch[1].rm_so, result.pmatch[1].rm_eo - result.pmatch[1].rm_so);
< 				xhtmlend = g_strndup(fulltext+result.pmatch[2].rm_so, result.pmatch[2].rm_eo - result.pmatch[2].rm_so);
< 				DEBUG_MSG("update_encoding_meta_in_file, type=%s (bstart=%d, bend=%d, so[1]=%d, eo[1]=%d)\n",type,result.bstart,result.bend,result.pmatch[1].rm_so,result.pmatch[1].rm_eo);
< 			} else {
< 				type = g_strdup("text/html");
< 				xhtmlend = g_strdup( main_v->props.xhtml ? "/" : "");
< 			}
< 			replacestring = g_strconcat("<meta http-equiv=\"content-type\" content=\"",type,"; charset=",encoding,"\" ",xhtmlend,">", NULL);
< 			DEBUG_MSG("update_encoding_meta_in_file, 1: we have a match\n");
< 			doc_replace_text(doc, replacestring, result.start, result.end);
< 			g_free(replacestring);
< 			g_free(type);
< 			g_free(xhtmlend);
< 		} else {
< 			DEBUG_MSG("update_encoding_meta_in_file, 1: NO match\n");
< 			/* now search for <head>, we can append it to this tag */
< 			search_pattern = "<head>";
< 			result = search_backend(bfwin,search_pattern, match_posix, 0, fulltext, 0, -1, FALSE);
< 			if (result.end > 0) {
< 				gchar *replacestring = g_strconcat("<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=",encoding,"\">", NULL);
< 				DEBUG_MSG("update_encoding_meta_in_file, 2: we have a match\n");
< 				doc_replace_text(doc, replacestring, result.start, result.end);
< 				g_free(replacestring);
< 			} else {
< 				DEBUG_MSG("update_encoding_meta_in_file, 2: NO match\n");
< 			}
< 		}
< 		g_free(fulltext);
< 		g_free(LASTSNR2(bfwin->snr2)->search_pattern);
< 		*LASTSNR2(bfwin->snr2) = last_snr2_bck;
< 		LASTSNR2(bfwin->snr2)->search_pattern = last_search_pattern_bck;
< 	}
< }
---
> /* Bluefish HTML Editor
>  * snr2.c - rewrite of search 'n replace functions
>  *
>  * Copyright (C) 2000-2006 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> /*
>  * THIS IS THE BACKEND FLOW DIAGRAM
>  *
>  *                              snr2_run
>  *              ________________/ | \  \___________________________
>  *             /      / |         |  \                   \  \      \
>  *  search_bookmark  |  |         |  replace_prompt_all  |   \      \
>  *     |            /   |         |         /           /     \      \
>  *     |   search_all   |   _____replace_prompt_doc    /       \    replace_all
>  *     |     |          |  /          /               /         \     /
>  *     |     \   doc_show_result     /  replace_doc_once   replace_doc_multiple
>  *     |      \                   __/                  \         /
>  *     |  search_doc             /                   replace_backend
>  *      \________ \             /  ___________________________/
>  *               \ \           /  /
>  *                 search_backend
>  */
> /*****************************************************/
> 
> /* #define DEBUG */
> 
> #include <gtk/gtk.h>
> 
> #include "config.h"
> 
> #ifdef HAVE_STRINGS_H
> #include <strings.h>
> #endif /* HAVE_STRINGS_H */
> 
> #include <stdio.h>
> #include <string.h>
> #include <sys/types.h>    /* _before_ regex.h for freeBSD */
> #include <regex.h>        /* regcomp() */
> #include <pcre.h>         /* pcre_compile */
> 
> #ifdef HAVE_PCRE_UTF8
> #ifndef PCRE_UTF8         /* for compatibility with older libpcre's */
> #define PCRE_UTF8 0
> #endif /* PCRE_UTF8 */
> #endif /* HAVE_PCRE_UTF8 */
> 
> #include <gdk/gdkkeysyms.h> /* GDK_Return */
> 
> #include "bluefish.h"
> #include "bookmark.h"    /* bmark_add_extern() */
> #include "bf_lib.h"
> #include "document.h"    /* doc_replace_text() */
> #include "gtk_easy.h"    /* a lot of GUI functions */
> #include "gui.h"         /* switch_to_document_by_pointer() */
> #include "highlight.h"   /* doc_highlight_full() */
> #include "snr2.h"
> #include "stringlist.h"  /* add_to_history_stringlist */
> #include "undo_redo.h"   /* doc_unre_new_group */
> 
> /* Updates, May 2003, by Ruben Dorta */
> 
> typedef enum { string, uppercase, lowercase } Treplace_types;
> typedef enum { match_normal, match_posix, match_perl } Tmatch_types;
> typedef enum { beginning, cursor, selection, opened_files } Tplace_types;
> 
> typedef struct {
> 	gint start;
> 	gint end;
> 	Tdocument *doc;
> } Tsearch_all_result;
> 
> typedef struct {
> 	Tbfwin *bfwin;
> 	Tdocument *doc;
> 	Tsearch_result result;
> 	gint replace;
> 	gchar *search_pattern;
> 	gchar *replace_pattern;
> 	gint unescape;
> 	gint overlapping_search;
> 	gint prompt_before_replace;
> 	gint is_case_sens;
> 	gint replace_once;
> 	gint bookmark_results;
> 	Treplace_types replacetype_option;
> 	Tmatch_types matchtype_option;
> 	Tplace_types placetype_option;
> } Tlast_snr2;
> 
> typedef struct {
> 	gint replace;
> 	Tbfwin *bfwin;
> 	GtkWidget *window;
> 	GtkWidget *search_combo;
> 	/*GtkWidget *search_entry;*/
> 	GtkWidget *search_label;
> 	/*GtkWidget *search_scrollbox;*/
> 	GtkWidget *replace_combo;
> 	/*GtkWidget *replace_entry;*/
> 	GtkWidget *replace_label;
> 	/*GtkWidget *replace_scrollbox;*/
> 	GtkWidget *subpat_help;
> 	GtkWidget *overlapping_search;
> 	GtkWidget *prompt_before_replace;
> 	GtkWidget *is_case_sens;
> 	GtkWidget *replace_once;
> 	GtkWidget *unescape;
> 	GtkWidget *replacetype_option;
> 	GtkWidget *matchtype_option;
> 	GtkWidget *placetype_option;
> 	GtkWidget *bookmark_results;
> } Tsnr2_win;
> #define LASTSNR2(var) ((Tlast_snr2 *)(var))
> /***********************************************************/
> 
> void snr2_run(Tbfwin *bfwin,Tdocument *doc);
> 
> /***********************************************************/
> 
> void snr2_init(Tbfwin *bfwin) {
> 	Tlast_snr2 *lsnr2 = g_new0(Tlast_snr2,1);
> 	lsnr2->bfwin = bfwin;
> 	bfwin->snr2 = lsnr2;
> }
> 
> static void reset_last_snr2(Tbfwin *bfwin) {
> 	if (LASTSNR2(bfwin->snr2)->search_pattern) {
> 		g_free(LASTSNR2(bfwin->snr2)->search_pattern);
> 	}
> 	if (LASTSNR2(bfwin->snr2)->replace_pattern) {
> 		g_free(LASTSNR2(bfwin->snr2)->replace_pattern);
> 	}
> 	memset(LASTSNR2(bfwin->snr2), 0, sizeof(Tlast_snr2));
> }
> 
> /***********************************************************/
> 
> /**
>  * search_backend:
>  * @bfwin: #Tbfwin* 
>  * @search_pattern: #gchar* to search pattern
>  * @matchtype: see #Tmatch_types
>  * @is_case_sens: If the search is case sensitive, #gint
>  * @buf: #gchar* to the document buffer
>  * @byte_offset: #guint where in the buffer the search should start, in bytes, not characters
>  * @endpos: #gint where in buffer the search should end in bytes, -1 to search to end
>  * @want_submatches: #gint
>  * 
>  * Performs an actual search in a supplied buffer (#gchar*, aka string).
>  * NOTE: If want_submatches is set, tsearch_result->pmatch should be free`ed by the calling function!
>  *
>  * Return value: #Tsearch_result, contains both character and byte offsets, for wide-char-compatibility. Note values for start/end are set to -1 on error.
>  **/
> Tsearch_result search_backend(Tbfwin *bfwin, gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gchar *buf, guint byte_offset, gint endpos, gboolean want_submatches) {
> 	Tsearch_result returnvalue;
> 	int (*f) ();
> 	gint buflen, patlen, searchlen, match, i;
> 
> 	returnvalue.start = -1;
> 	returnvalue.end = -1;
> 	returnvalue.bstart = -1;
> 	returnvalue.bend = -1;
> 	returnvalue.pmatch = NULL;
> 	returnvalue.nmatch = 0;
> 	if ((!search_pattern) || (!buf)) {
> 		DEBUG_MSG("search_backend, search_pattern or buf is NULL\n");
> 		return returnvalue;
> 	}
> 	DEBUG_MSG("search_backend, starting for byte_offset=%u\n",byte_offset);
> 	if (matchtype == match_posix) {
> 		/* regex part start */
> 		regex_t reg_pat;
> 		regmatch_t *pmatch;
> 		gint nmatch, retval;
> 
> 		retval = regcomp(&reg_pat, search_pattern, (is_case_sens ? REG_EXTENDED : REG_EXTENDED | REG_ICASE));
> 		DEBUG_MSG("search_backend, regcomp retval=%d\n", retval);
> 		if (retval != 0) {
> #define ERRORSTR_SIZE 300
> 			gchar errorstr[ERRORSTR_SIZE], *errorstr2;
> 			
> 			regerror(retval,  &reg_pat, errorstr, ERRORSTR_SIZE);
> 			errorstr2 = g_strconcat(_("Regular expression error: "), errorstr, NULL);
> 			warning_dialog(bfwin->main_window,_("Search failed"), errorstr2);
> 			g_free(errorstr2);
> 			/* error compiling the search_pattern, returning the default result set,
> 			which is the 'nothing found' set */
> 			return returnvalue;
> 		}
> 		nmatch = (want_submatches) ? reg_pat.re_nsub+1 : 1;
> 		DEBUG_MSG("search_backend, expr. contains %d sub search_patterns\n", reg_pat.re_nsub );
> 		pmatch = g_malloc(nmatch*sizeof(regmatch_t));
> 		retval = regexec(&reg_pat, buf+byte_offset, nmatch, pmatch, 0);
> 		DEBUG_MSG("search_backend, regexec retval=%d\n", retval);
> 		if (retval != 0) {
> 			returnvalue.bstart = -1;
> 			returnvalue.bend = -1;
> 		} else {
> 			returnvalue.bstart = pmatch[0].rm_so + byte_offset;
> 			returnvalue.bend = pmatch[0].rm_eo + byte_offset;
> 		}
> #ifdef DEBUG
> 		{	int i;
> 			for (i=0;i<nmatch;i++) {
> 				DEBUG_MSG("search_backend, sub search_pattern %d so=%d, eo=%d\n", i, pmatch[i].rm_so, pmatch[i].rm_eo);
> 			}
> 		}
> #endif
> 		regfree(&reg_pat);
> 		if (want_submatches) {
> 			returnvalue.pmatch = pmatch;
> 			returnvalue.nmatch = nmatch;
> 			/* if want_submatches is set, pmatch should be 
> 			free`ed by the calling function! */
> 		} else {
> 			g_free(pmatch);
> 		}
> 		/* regex part end */
> 	} else if (matchtype == match_perl) {
> 		pcre *pcre_c;
> 		const char *err=NULL;
> 		int erroffset=0;
> 		int ovector[30];
> 		gint retval;
> 		pcre_c = pcre_compile(search_pattern,  
> #ifdef HAVE_PCRE_UTF8
> 				(is_case_sens ? PCRE_UTF8|PCRE_DOTALL|PCRE_MULTILINE : PCRE_UTF8|PCRE_DOTALL|PCRE_CASELESS|PCRE_MULTILINE),
> #else
> 				(is_case_sens ? PCRE_DOTALL|PCRE_MULTILINE : PCRE_DOTALL|PCRE_CASELESS|PCRE_MULTILINE),
> #endif
> 				&err,&erroffset,NULL);
> 		if (err) {
> 			gchar *errstring;
> 			errstring = g_strdup_printf(_("Regular expression error: %s at offset %d"), err, erroffset);
> 			warning_dialog(bfwin->main_window,_("Search failed"), errstring);
> 			g_free(errstring);
> 			return returnvalue;/* error compiling the search_pattern, returning the default result set,which is the 'nothing found' set */
> 		}
> 		retval = pcre_exec(pcre_c,NULL,buf+byte_offset,strlen(buf+byte_offset),0,0,ovector,30);
> 		if (retval > 0) {
> 			returnvalue.bstart = ovector[0] + byte_offset;
> 			returnvalue.bend = ovector[1] + byte_offset;
> 		} else {
> 			returnvalue.bstart = -1;
> 			returnvalue.bend = -1;
> 		}
> 		if (want_submatches) {
> 			int nmatch,i;
> 			regmatch_t *pmatch;
> 			pcre_fullinfo(pcre_c, NULL, PCRE_INFO_CAPTURECOUNT, &nmatch);
> 			DEBUG_MSG("search_backend, nmatch=%d, retval=%d\n", nmatch, retval);
> 			pmatch = g_malloc((nmatch+1)*sizeof(regmatch_t));
> 			for (i=0;i<=nmatch;i++) { /* nmatch==1 means 1 subsearch_pattern, so 2 search_patterns in total*/
> 				pmatch[i].rm_so = ovector[i*2] + byte_offset;
> 				pmatch[i].rm_eo = ovector[i*2+1] + byte_offset;
> 			}
> 			returnvalue.pmatch = pmatch;
> 			returnvalue.nmatch = retval;
> #ifdef DEBUG
> 			{	int i;
> 				for (i=0;i<returnvalue.nmatch;i++) {
> 					DEBUG_MSG("search_backend, sub search_pattern %d so=%d, eo=%d\n", i, returnvalue.pmatch[i].rm_so, returnvalue.pmatch[i].rm_eo);
> 				}
> 			}
> #endif
> 			/* if want_submatches is set, pmatch should be 
> 			free`ed by the calling function! */
> 		}
> 		pcre_free(pcre_c);
> 	} else {
> 		/* non regex part start */
> 		if (!is_case_sens) {
> 			f = strncasecmp;
> 		} else {
> 			f = strncmp;
> 		}
> 		
> 		patlen = strlen(search_pattern);
> 		if (endpos != -1) {
> 		    buflen = strlen(doc_get_chars(bfwin->current_document, byte_offset, endpos));
> 		    searchlen = (byte_offset + buflen) - patlen;
> 		} else {
> 		    buflen = strlen(buf);
> 		    searchlen = buflen - patlen;
> 		}
> 		
> 		for (i = byte_offset; i <= searchlen; i++) {
> 			match = f(&buf[i], search_pattern, patlen);
> 			if (match == 0) {
> 				returnvalue.bstart = i;
> 				returnvalue.bend = i + patlen;
> 				break;
> 			}
> 		}
> 		/* non regex part end */	
> 	}
> 	
> 	/* if we have a valid result, we now calculate the character offsets for this result */
> 	if (returnvalue.bstart >= 0 && returnvalue.bend >= 0) {
> 		/* utf8_offset_cache_reset(); */
> 		if (returnvalue.bstart >= 0) {
> 			returnvalue.start = utf8_byteoffset_to_charsoffset_cached(buf, returnvalue.bstart);
> 		}
> 		if (returnvalue.bend >= 0) {
> 			returnvalue.end = utf8_byteoffset_to_charsoffset_cached(buf, returnvalue.bend);
> 		}
> 		if (want_submatches) {
> 			int i;
> 			for (i=0;i<returnvalue.nmatch;i++) {
> 				returnvalue.pmatch[i].rm_so = utf8_byteoffset_to_charsoffset_cached(buf, returnvalue.pmatch[i].rm_so);
> 				returnvalue.pmatch[i].rm_eo = utf8_byteoffset_to_charsoffset_cached(buf, returnvalue.pmatch[i].rm_eo);
> 			}
> 		}
> 	} else {
> 		returnvalue.start = -1;
> 		returnvalue.end = -1;
> 		returnvalue.bstart = -1;
> 		returnvalue.bend = -1;
> 	}
> 
> 	DEBUG_MSG("search_backend, returning result.start=%d, result.end=%d, bstart=%d, bend=%d\n", returnvalue.start, returnvalue.end, returnvalue.bstart, returnvalue.bend);
> 	return returnvalue;
> }
> 
> /*****************************************************/
> 
> /**
>  * search_doc:
>  * @bfwin: #Tbfwin*
>  * @document: a #Tdocument to search
>  * @search_pattern: a #gchar* to the search pattern.
>  * @matchtype: see #Tmatch_types
>  * @is_case_sens: #gint
>  * @startpos: #gint offset in document buffer
>  *
>  * Perform search by calling search_backend.
>  * Updates last_snr2-values, but doesn't use them -- that is the callers duty.
>  *
>  * Return value: #Tsearch_result
>  **/
> Tsearch_result search_doc(Tbfwin *bfwin,Tdocument *document, gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gint startpos, gboolean unescape) {
> 	gchar *fulltext, *realpat;
> 	Tsearch_result result;
> 	
> 	DEBUG_MSG("search_doc, started on document %p, startpos=%d\n", document, startpos);
> 	utf8_offset_cache_reset();
> 	fulltext = doc_get_chars(document, startpos, -1);
> 	DEBUG_MSG("search_doc, fulltext=%p, search_pattern=%p\n", fulltext, search_pattern);
> 	if (unescape) {
> 		realpat = unescape_string(search_pattern, FALSE);
> 	} else {
> 		realpat = search_pattern;
> 	}
> 	result = search_backend(bfwin,realpat, matchtype, is_case_sens, fulltext, 0, -1, FALSE);
> 	if (unescape) {
> 		g_free(realpat);
> 	}
> 	g_free(fulltext);
> 	if (result.end > 0) {
> 		DEBUG_MSG("search_doc, received a result (start=%d), adding startpos (%d) to it\n", result.start, startpos);
> 		result.start += startpos;
> 		result.end += startpos;
> 		LASTSNR2(bfwin->snr2)->result.start = result.start;
> 		LASTSNR2(bfwin->snr2)->result.end = result.end;
> 		LASTSNR2(bfwin->snr2)->doc = document;
> 	} else {
> 		LASTSNR2(bfwin->snr2)->result.start = -1;
> 		LASTSNR2(bfwin->snr2)->result.end =  -1;
> 		LASTSNR2(bfwin->snr2)->doc = document;
> 	}
> 	DEBUG_MSG("search_doc, result.start=%d, result.end=%d\n", result.start, result.end);
> 	return result;
> }
> 
> /*****************************************************/
> 
> /**
>  * doc_show_result:
>  * @document: a #Tdocument
>  * @start: Selection start.
>  * @end: Selection end.
>  *
>  * Focus a document and select the supplied range.
>  *
>  * Return value: void
>  **/
> void doc_show_result(Tdocument *document, gint start, gint end) {
> 	DEBUG_MSG("doc_show_result, select from start=%d to end=%d\n",start, end);
> 	if (document != BFWIN(document->bfwin)->current_document) {
> 		switch_to_document_by_pointer(BFWIN(document->bfwin),document);
> 	}
> 	doc_select_region(document, start, end, TRUE);
> }
> 
> /*****************************************************/
> 
> /**
>  * search_all:
>  * @bfwin: #Tbfwin*
>  * @search_pattern: #gchar to search pattern
>  * @matchtype: see #Tmatch_types
>  * is_case_sens: #gint set to 0 or 1.
>  *
>  * Perform a specified search, spanning all open documents.
>  *
>  * When called several times, the search continues from where it left off last time.
>  * The current 'search-position' is stored in the internal last_snr2 structure.
>  *
>  * Return value: #Tsearch_all_result
>  **/
> Tsearch_all_result search_all(Tbfwin *bfwin,gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gboolean unescape) {
> 	GList *tmplist;
> 	Tsearch_all_result result_all;
> 
> 	DEBUG_MSG("search_all, started\n");
> 	result_all.start = -1;
> 	result_all.end = -1;
> 	result_all.doc = NULL;
> 	
> 	if (LASTSNR2(bfwin->snr2)->doc) {
> 		tmplist = g_list_find(bfwin->documentlist, LASTSNR2(bfwin->snr2)->doc);
> 	} else {
> 		LASTSNR2(bfwin->snr2)->result.end = 0;
> 		tmplist = g_list_first(bfwin->documentlist);
> 	}
> 	while (tmplist) {
> 		Tsearch_result result;
> 
> 		result = search_doc(bfwin,(Tdocument *)tmplist->data, search_pattern, matchtype, is_case_sens, LASTSNR2(bfwin->snr2)->result.end, unescape);
> 		if (result.end > 0) {
> 			result_all.start = result.start;
> 			result_all.end = result.end;
> 			result_all.doc = tmplist->data;
> 			DEBUG_MSG("search_all, found!! start=%d, end=%d, doc=%p\n", result.start, result.end, tmplist->data);
> 			return result_all;
> 		}
> 		tmplist = g_list_next(tmplist);
> 		if (tmplist) {
> 			LASTSNR2(bfwin->snr2)->result.end = 0;
> 		}
> 	}
> 	DEBUG_MSG("search_all, not found..\n");
> 	return result_all;
> }
> 
> /*****************************************************/
> 
> static gchar *reg_replace(gchar *replace_pattern, gint offset, Tsearch_result result, Tdocument *doc, gboolean standardescape) {
> 	Tconvert_table * tct;
> 	gchar *retval;
> 	gint i, size;
> 	DEBUG_MSG("reg_replace, started for pattern='%s',standardescape=%d\n",replace_pattern,standardescape);
> 	size = (result.nmatch <= 10) ? (result.nmatch == 0 ) ? 0 : result.nmatch -1 : 10;
> 	tct = new_convert_table(size, standardescape);
> 	for (i=0;i<size;i++) {
> 		tct[i].my_int = i+48;
> 		tct[i].my_char = doc_get_chars(doc, offset+result.pmatch[i+1].rm_so, offset+result.pmatch[i+1].rm_eo);
> 	}
> 	retval = expand_string(replace_pattern, '\\', tct);
> 	free_convert_table(tct);
> 	return retval;
> }
> 
> /*
>  * this function will parse the replace string and substitute the \0, \1 etc. with 
>  * the subsearch_pattern matches from regexec()
>  */
> /*static gchar *oldreg_replace(gchar *replace_pattern, gint offset, Tsearch_result result, Tdocument *doc) {
> 	gchar *tmp1, *newstring;
> 	gchar *tmpstr1, *tmpstr2, *tmpstr3;
> 	gboolean escaped=0;
> 	guint from=0, to=0;
> 
> 	newstring = g_strdup("");
> 	tmp1 = replace_pattern;
> 	while (*tmp1 != '\0') {
> 		if (escaped) {
> 			if (*tmp1 == '\\') {
> 				to++;
> 				tmpstr1 = newstring;
> 				tmpstr2 = g_strndup(&replace_pattern[from], to-from);
> 				newstring = g_strconcat(tmpstr1, tmpstr2, NULL);
> 				g_free(tmpstr1);
> 				g_free(tmpstr2);
> 				from = ++to;
> 				DEBUG_MSG("reg_replace, escaped backslash, newstring='%s'\n", newstring);			
> 			} else if ((gint)*tmp1 >= 48 && (gint)*tmp1 <= 57) {
> 				gint num = (gint)*tmp1 - 48;
> 				tmpstr1 = newstring;
> 				tmpstr2 = g_strndup(&replace_pattern[from], to-from);
> 				DEBUG_MSG("reg_replace, from=%d, to=%d, tmpstr2='%s'\n", from, to, tmpstr2);
> 				if (result.nmatch >= num+1) {
> 					DEBUG_MSG("reg_replace, wanted: sub search_pattern %d, offset=%d, so=%d, eo=%d\n", num, offset, result.pmatch[num+1].rm_so, result.pmatch[num+1].rm_eo);
> 					tmpstr3 = doc_get_chars(doc, offset+result.pmatch[num+1].rm_so, offset+result.pmatch[num+1].rm_eo);
> 					DEBUG_MSG("reg_replace, subsearch_pattern %d = '%s'\n", num, tmpstr3);
> 				} else {
> 					DEBUG_MSG("reg_replace, subsearch_pattern %d does not exist, nmatch=%d\n", num, result.nmatch);
> 					tmpstr3 = g_strdup("");
> 				}
> 				newstring = g_strconcat(tmpstr1, tmpstr2, tmpstr3, NULL);
> 				g_free(tmpstr1);
> 				g_free(tmpstr2);
> 				g_free(tmpstr3);
> 				to += 2;
> 				from = to;
> 				DEBUG_MSG("reg_replace, substituted subsearch_pattern, newstring='%s'\n", newstring);
> 			} else {
> 				to += 2;
> 			}
> 			escaped = 0;
> 		} else {
> 			if (*tmp1 == '\\') {
> 				escaped = 1;
> 			} else {
> 				to++;
> 			}
> 		}
> 		tmp1++;
> 	}
> 	tmpstr1 = newstring;
> 	tmpstr2 = g_strndup(&replace_pattern[from], to-from);
> 	newstring = g_strconcat(tmpstr1, tmpstr2, NULL);
> 	g_free(tmpstr1);
> 	g_free(tmpstr2);
> 	DEBUG_MSG("reg_replace, end, newstring='%s'\n", newstring);
> 	return newstring;
> }*/
> 
> /**
>  * replace_backend:
>  * @bfwin: #Tbfwin with the window from this/these documents
>  * @search_pattern: #gchar* to search pattern
>  * @matchtype: See #Tmatch_types
>  * @is_case_sens: #gint
>  * @buf: #ghar* to buffer
>  * @replace_pattern: The replace pattern.
>  * @doc: the #Tdocument
>  * @offset: The difference between the buffer and the text widget because of previous replace actions, so the first char in buf is actually number offset in the text widget.
>  * @replacetype: see #Treplace_types
>  * @replacelen: #gint*, set to -1 to calculate this automatically.
>  * 
>  * This will perform a search and the actual replacement of data in the buffer.
>  * Note that *buf is probably an offset in the documents buffer.
>  * 
>  * Return value: #Tsearch_result
>  **/
> Tsearch_result replace_backend(Tbfwin *bfwin,gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens
> 			, gchar *buf, guint byte_offset, gchar *replace_pattern, Tdocument *doc, gint offset, Treplace_types replacetype
> 			, gint *replacelen, gboolean unescape) {
> /* the offset in this function is the difference between the buffer and the text widget because of previous replace 
> actions, so the first char in buf is actually number offset in the text widget */
> /* replacelen -1 means there is no replacelen known yet, so we have to calculate it */
> 	Tsearch_result result;
> 	gchar *tmpstr=NULL, *realpat;
> 	
> 	if (unescape) {
> 		realpat = unescape_string(search_pattern,FALSE);
> 		DEBUG_MSG("replace_backend, realpat='%s'\n",realpat);
> 	} else {
> 		realpat = search_pattern;
> 	}
> 	result = search_backend(bfwin,realpat, matchtype, is_case_sens, buf, byte_offset, -1, (matchtype != match_normal));
> 	if (unescape) {
> 		DEBUG_MSG("replace_backend, free-ing realpat\n");
> 		g_free(realpat);
> 	}
> 	DEBUG_MSG("replace_backend, offset=%d, result.start=%d, result.end=%d\n", offset, result.start, result.end);
> 	if (result.end > 0) {
> 		gchar *tmp;
> 		switch (replacetype) {
> 		case string:
> 			if (matchtype == match_normal) {
> 				if (unescape) {
> 					DEBUG_MSG("replace_backend, replace_pattern='%s'\n",replace_pattern);
> 					tmpstr = unescape_string(replace_pattern, FALSE);
> 				} else {
> 					tmpstr = g_strdup(replace_pattern);
> 				}
> 			} else {
> 				tmpstr = reg_replace(replace_pattern, offset, result, doc, unescape);
> 			}
> 			DEBUG_MSG("replace_backend, tmpstr='%s'\n", tmpstr);
> 		break;
> 		case uppercase:
> 			tmpstr = g_strndup(&buf[result.bstart], result.bend - result.bstart);
> 			tmp = tmpstr;
> 			tmpstr = g_utf8_strup(tmpstr, -1);
> 			g_free (tmp);
> 		break;
> 		case lowercase:
> 			tmpstr = g_strndup(&buf[result.bstart], result.bend - result.bstart);
> 			tmp = tmpstr;
> 			tmpstr = g_utf8_strdown(tmpstr, -1);
> 			g_free (tmp);
> 		break;
> 		}
> 		DEBUG_MSG("replace_backend, len=%d, offset=%d, start=%d, end=%d, document=%p, tmpstr='%s'\n", result.end - result.start, offset, result.start + offset, result.end + offset, doc,tmpstr);
> 		doc_replace_text_backend(doc, tmpstr, result.start + offset, result.end + offset);
> 		if (*replacelen == -1) {
> 			*replacelen = g_utf8_strlen(tmpstr, -1);
> 		}
> 		g_free(tmpstr);
> 	}
> 	if (matchtype == match_posix) {
> 		g_free(result.pmatch);
> 		result.pmatch = NULL;
> 	}
> 	return result;
> }
> 
> /*****************************************************/
> 
> /**
>  * replace_doc_once:
>  * @search_pattern: #gchar* to search pattern
>  * @matchtype: see #Tmatch_types
>  * @is_case_sens: #gint
>  * @startpos: #gint offset in document.
>  * @endpos: #gint where to stop replacing. Set to -1 to cover the entire buffer.
>  * @replace_pattern: #gchar* to replace pattern
>  * @doc: a #Tdocument* to work on
>  * @replacetype: see #Treplace_types
>  *
>  * Performs a single replace with the selected parameters, by calling replace_backend().
>  * Calls doc_unre_new_group(doc) to make this action undoable.
>  * Updates the internal last_snr2 struct, but the _caller_ is responsible for honouring this data.
>  * 
>  * Return value: #Tsearch_result
>  **/
> Tsearch_result replace_doc_once(Tbfwin *bfwin,gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gint startpos, gint endpos, gchar *replace_pattern, Tdocument *doc, Treplace_types replacetype, gboolean unescape) {
> /* endpos -1 means do till end */
> 	gchar *fulltext;
> 	gint replacelen = 0; /* replacelen -1 means there is no replacelen known yet
> 								, but we don't need one, so we set it to 0 */
> 	Tsearch_result result;
> 
> 	doc_unre_new_group(doc);
> 	utf8_offset_cache_reset();
> 	fulltext = doc_get_chars(doc, startpos, endpos);
> 	result = replace_backend(bfwin,search_pattern, matchtype, is_case_sens, fulltext, 0, replace_pattern, doc, startpos, replacetype, &replacelen, unescape);
> 	if ( result.end > 0) {
> 		LASTSNR2(bfwin->snr2)->result.start = result.start + startpos;
> 		LASTSNR2(bfwin->snr2)->result.end = result.end + startpos;
> 		LASTSNR2(bfwin->snr2)->doc = doc;
> 	} else {
> 		LASTSNR2(bfwin->snr2)->result.start = -1;
> 		LASTSNR2(bfwin->snr2)->result.end = -1;
> 		LASTSNR2(bfwin->snr2)->doc = doc;
> 	}
> 	g_free(fulltext);
> 
> 	doc_unre_new_group(doc);
> 
> 	return result;
> }
>  
> /*****************************************************/
> 
> /**
>  * replace_doc_multiple:
>  * @search_pattern: #gchar* to search pattern
>  * @matchtype: see #Tmatch_types
>  * @is_case_sens: #gint
>  * @endpos: #gint where to stop replacing. Set to -1 to cover the entire buffer.
>  * @replace_pattern: #gchar* to replace pattern
>  * @doc: a #Tdocument* to work on
>  * @replacetype: see #Treplace_types
>  * 
>  * Performs a replace on all occurences of the pattern in the supplied document.
>  * The doc's buffer will be modified.
>  *
>  * last_snr2 is reset with .start = .end = -1, and .doc = doc.
>  * 
>  * Return value: void
>  **/
> void replace_doc_multiple(Tbfwin *bfwin,gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gint startpos, gint endpos, gchar *replace_pattern, Tdocument *doc, Treplace_types replacetype, gboolean unescape) {
> /* endpos -1 means do till end */
> 	gchar *fulltext, *realpats, *realpatr;
> 	gboolean realunesc;
> 	Tsearch_result result;
> 	gint buf_byte_offset=0;
> 	gint buf_text_offset=startpos;
> 	gint replacelen; /* replacelen -1 means there is no replacelen known yet */
> 	doc_unre_new_group(doc);
> 
> 	DEBUG_MSG("replace_doc_multiple, startpos=%d, endpos=%d\n", startpos, endpos);
> 	if (matchtype == match_normal || replacetype != string) {
> 		/* the replace string has a fixed length if it is not regex, or it is not type string
> 		 in this case we can also do the unescaping in this function */
> 		if (unescape) {
> 			realpats = unescape_string(search_pattern, FALSE);
> 			realpatr = unescape_string(replace_pattern, FALSE);
> 			DEBUG_MSG("replace_doc_multiple, unescaped patterns, realpats='%s', realpatr='%s'\n",realpats, realpatr);
> 		} else {
> 			realpats = search_pattern;
> 			realpatr = replace_pattern;
> 		}
> 		replacelen = g_utf8_strlen(realpatr,-1);
> 		realunesc = FALSE;
> 	} else {
> 		replacelen=-1;
> 		realpats = search_pattern;
> 		realpatr = replace_pattern;
> 		realunesc = unescape;
> 	}
> 	fulltext = doc_get_chars(doc, startpos, endpos);
> 	utf8_offset_cache_reset();
> 	result = replace_backend(bfwin,realpats, matchtype, is_case_sens, fulltext, 0, realpatr, doc, buf_text_offset, replacetype, &replacelen, realunesc);
> 	while (result.end > 0) {
> 		if (replacetype == string) {
> 			buf_text_offset += replacelen - (result.end - result.start);
> 		}
> 		if (LASTSNR2(bfwin->snr2)->overlapping_search || result.start == result.end) {
> 			buf_byte_offset = result.bstart + 1;
> 			/* buf_text_offset += result.start + 1; */
> 		} else {
> 			buf_byte_offset = result.bend;
> 			/* buf_text_offset += result.end; */
> 		}
> 		DEBUG_MSG("replace_doc_multiple, after first search, buf_text_offset=%d, buf_byte_offset=%d\n", buf_text_offset, buf_byte_offset);
> 		if (matchtype != match_normal && replacetype == string) {
> 			/* all regex replaces can have different replace lengths, so they have to be re-calculated */
> 			replacelen = -1;
> 		}
> 		result = replace_backend(bfwin,realpats, matchtype, is_case_sens, fulltext, buf_byte_offset, realpatr, doc, buf_text_offset, replacetype, &replacelen, realunesc);
> 
> 		DEBUG_MSG("replace_doc_multiple, 1- buf_text_offset=%d, buf_byte_offset=%d, result.start=%d, result.end=%d\n", buf_text_offset, buf_byte_offset, result.start, result.end);
> 	}
> 	if (unescape && (matchtype == match_normal || replacetype != string)) {
> 		DEBUG_MSG("replace_doc_multiple, free-ing realpats and realpatr\n");
> 		g_free(realpats);
> 		g_free(realpatr);
> 	}
> 
> 	doc_unre_new_group(doc);
> 
> 	LASTSNR2(bfwin->snr2)->result.start = -1;
> 	LASTSNR2(bfwin->snr2)->result.end = -1;
> 	LASTSNR2(bfwin->snr2)->doc = doc;
> 	g_free(fulltext);
> }
> 
> /*****************************************************/
> 
> /**
>  * replace_all:
>  * @bfwin: #Tbfwin* the window with the documents to act upon
>  * @search_pattern: #gchar* to search pattern
>  * @matchtype: see #Tmatch_types
>  * @is_case_sens: #gint
>  * @replace_pattern: #gchar* to replace pattern
>  * @replacetype: see #Treplace_types
>  * 
>  * Perform a replace_doc_multiple() with supplied data on all open documents.
>  * This will replace all occurences of search_pattern in all documents.
>  * 
>  * Return value: void
>  **/
> void replace_all(Tbfwin *bfwin,gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gchar *replace_pattern, Treplace_types replacetype, gboolean unescape) {
> 	GList *tmplist;
> 
> 	tmplist = g_list_first(bfwin->documentlist);
> 	while (tmplist) {
> 		replace_doc_multiple(bfwin,search_pattern, matchtype, is_case_sens, 0, -1, replace_pattern, (Tdocument *)tmplist->data, replacetype, unescape);
> 		tmplist = g_list_next(tmplist);
> 	}
> }
> 
> /*****************************************************/
> /*             Replace prompt callbacks              */
> /*****************************************************/
> 
> /*
>  *
>  * Performs the actual replace-surgery by calls to doc_replace_text_backend() !
>  * Continues the replace cycle by calling snr2_run(), unless this is a single replace.
>  *
>  */
> static void replace_prompt_dialog_ok_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	gchar *tmpstr;
> 	gint sel_start_pos, sel_end_pos;
> 
> 	window_close_by_widget_cb(widget, NULL);
> 	
> 	doc_get_selection(bfwin->current_document, &sel_start_pos, &sel_end_pos);
> 	if ((sel_start_pos == LASTSNR2(bfwin->snr2)->result.start) &&
> 				(sel_end_pos == LASTSNR2(bfwin->snr2)->result.end)) {
> 		gint lenadded;
> 		if (LASTSNR2(bfwin->snr2)->replacetype_option==string) {
> 			tmpstr = g_strdup(LASTSNR2(bfwin->snr2)->replace_pattern);
> 			/* if it was a regex replace we need to do the sub-search_pattern matching */
> 			tmpstr = reg_replace(tmpstr, 0, LASTSNR2(bfwin->snr2)->result, bfwin->current_document, LASTSNR2(bfwin->snr2)->unescape);
> 			
> 		} else if (LASTSNR2(bfwin->snr2)->replacetype_option==uppercase) {
> 			gchar *tmp;
> 			tmpstr = doc_get_chars(bfwin->current_document, LASTSNR2(bfwin->snr2)->result.start ,LASTSNR2(bfwin->snr2)->result.end);
> 			tmp = tmpstr;
> 			tmpstr = g_utf8_strup(tmpstr, -1);
> 			g_free (tmp);
> 		} else {
> 			gchar *tmp;
> 			tmpstr = doc_get_chars(bfwin->current_document, LASTSNR2(bfwin->snr2)->result.start ,LASTSNR2(bfwin->snr2)->result.end);
> 			tmp = tmpstr;
> 			tmpstr = g_utf8_strdown(tmpstr, -1);
> 			g_free (tmp);
> 		}
> 		/* avoid new highlighting at this stage, so call the backend directly instead of the frontend function
> 		this because the highlighting interferes with the selection
> 		the better solution is to have the highlighting handle the selection better, 
> 		the problem starts in document.c in get_positions() because the selection is not saved there
> 		I don't know why the selection is gray, but that's basically the reason why it doesn't save the selection
> 		 */
> 
> 		doc_unre_new_group(bfwin->current_document);
> 		doc_replace_text_backend(bfwin->current_document, tmpstr, LASTSNR2(bfwin->snr2)->result.start,LASTSNR2(bfwin->snr2)->result.end);
> 		doc_unre_new_group(bfwin->current_document);
> 		doc_set_modified(bfwin->current_document, 1);
> 
> 		lenadded = strlen(tmpstr) - (LASTSNR2(bfwin->snr2)->result.end - LASTSNR2(bfwin->snr2)->result.start);
> 		DEBUG_MSG("lenadded=%d (streln=%d, end-start=%d)\n",lenadded,strlen(tmpstr),(LASTSNR2(bfwin->snr2)->result.end - LASTSNR2(bfwin->snr2)->result.start));
> 		g_free(tmpstr);
> 		if (LASTSNR2(bfwin->snr2)->result.pmatch) {
> 			g_free(LASTSNR2(bfwin->snr2)->result.pmatch);
> 			LASTSNR2(bfwin->snr2)->result.pmatch = NULL;
> 		}
> 		if (!LASTSNR2(bfwin->snr2)->replace_once) {
> 			if (!LASTSNR2(bfwin->snr2)->overlapping_search && lenadded > 0) {
> 				LASTSNR2(bfwin->snr2)->result.end += lenadded;
> 			}
> 			snr2_run(bfwin,NULL);
> 		}
> 	}
> #ifdef DEBUG
> 	 else {
> 		g_print("replace_prompt_dialog_ok_lcb, selection != result, not replacing!!\n");
> 	}
> #endif /* DEBUG */
> }
> 
> static void replace_prompt_dialog_skip_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	window_close_by_widget_cb(widget, NULL);
> 	if (LASTSNR2(bfwin->snr2)->result.pmatch) {
> 		g_free(LASTSNR2(bfwin->snr2)->result.pmatch);
> 		LASTSNR2(bfwin->snr2)->result.pmatch = NULL;
> 	}
> 	if (!LASTSNR2(bfwin->snr2)->replace_once) {
> 		snr2_run(bfwin,NULL);
> 	}
> }
> 
> /* Alters last_snr2, setting no-prompt-mode, backtracking one step on the startpoint and .end = .start
>  * continues by running snr2_run(). This will replace all occurrences of the string.. */
> static void replace_prompt_dialog_all_lcb(GtkWidget *widget, Tbfwin *bfwin) {
> 	window_close_by_widget_cb(widget, NULL);
> 	LASTSNR2(bfwin->snr2)->prompt_before_replace = 0;
> 	LASTSNR2(bfwin->snr2)->result.start--;
> 	LASTSNR2(bfwin->snr2)->result.end = LASTSNR2(bfwin->snr2)->result.start;
> 	if (LASTSNR2(bfwin->snr2)->result.pmatch) {
> 		g_free(LASTSNR2(bfwin->snr2)->result.pmatch);
> 		LASTSNR2(bfwin->snr2)->result.pmatch = NULL;
> 	}
> 	snr2_run(bfwin,NULL);
> }
> 
> 
> /**
>  * replace_prompt_dialog:
>  * 
>  * Prompt the user for a replace action. Simply creates and shows GUI.
>  * Used by replace_prompt_doc().
>  * 
>  * Return value: void
>  **/
> void replace_prompt_dialog(Tbfwin *bfwin) {
> 	GtkWidget *win, *vbox, *hbox;
> 	GtkWidget *butok, *butclose, *butall, *butskip;
> 	GtkWidget *image, *label;
> 
> 	DEBUG_MSG("replace_prompt_dialog, start\n");
> 	win = window_full(_("Confirm replace"), GTK_WIN_POS_CENTER, 12, G_CALLBACK(window_close_by_widget_cb), NULL, TRUE);
> 	gtk_window_set_resizable (GTK_WINDOW (win), FALSE);
> 
> 	vbox = gtk_vbox_new (FALSE, 0);
> 	gtk_container_add (GTK_CONTAINER (win), vbox);
> 
> 	hbox = gtk_hbox_new (FALSE, 12);
> 	gtk_box_pack_start (GTK_BOX (vbox), hbox, TRUE, TRUE, 0);
> 
> 	image = gtk_image_new_from_stock ("gtk-dialog-question", GTK_ICON_SIZE_DIALOG);
> 	gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, TRUE, 0);
> 
> 	label = gtk_label_new (_("Replace selected text?"));
> 	gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);
> 	gtk_label_set_justify (GTK_LABEL (label), GTK_JUSTIFY_LEFT);
> 	gtk_label_set_line_wrap (GTK_LABEL (label), TRUE);
> 
> 	gtk_box_pack_start (GTK_BOX (vbox), gtk_hseparator_new (), FALSE, TRUE, 12);
> 
> 	hbox = gtk_hbutton_box_new ();
> 	gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, TRUE, 0);
> 	gtk_button_box_set_layout (GTK_BUTTON_BOX (hbox), GTK_BUTTONBOX_END);
> 	gtk_box_set_spacing (GTK_BOX (hbox), 6);
> 
> 	butclose = bf_gtkstock_button(GTK_STOCK_CLOSE, G_CALLBACK(window_close_by_widget_cb), NULL);
> 	butskip = bf_allbuttons_backend(_("_Skip"), TRUE, 1000, G_CALLBACK(replace_prompt_dialog_skip_lcb), bfwin);
> 	butok = bf_allbuttons_backend(_("_Replace"), TRUE, 1001, G_CALLBACK(replace_prompt_dialog_ok_lcb), bfwin);
> 	butall = bf_generic_mnemonic_button(_("Replace _all"), G_CALLBACK(replace_prompt_dialog_all_lcb), bfwin);
> 	gtk_box_pack_start(GTK_BOX(hbox), butclose, FALSE, FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(hbox), butall, FALSE, FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(hbox), butok, FALSE, FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(hbox), butskip, FALSE, FALSE, 0);
> 	gtk_widget_grab_focus(butskip);
> 	gtk_widget_show_all(win);
> 	DEBUG_MSG("replace_prompt_dialog, end\n");
> }
> 
> /**
>  * replace_prompt_doc:
>  * @search_pattern: #gchar* to search pattern
>  * @matchtype: see #Tmatch_types
>  * @is_case_sens: #gint
>  * @startpos: Start offset in document buffer.
>  * @endpos: End offset of search area. Set to -1 to cover entire buffer.
>  * @replace_pattern: #gchar to replace pattern
>  * @doc: a #Tdocument
>  * 
>  * Finds the next occurence of search_pattern in *doc, shows and selects it in the document,
>  * and finally shows a replace_prompt_dialog to the user.
>  *
>  * last_snr2 is updated if an occurrence of search_pattern is found.
>  * 
>  * Return value: #gint, 1 if a new occurence of the search_pattern was found and a dialog is shown. 0 else.
>  **/
> gint replace_prompt_doc(Tbfwin *bfwin, gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gint startpos, gint endpos, gchar *replace_pattern, Tdocument *doc, gboolean unescape) {
> /* endpos -1 means do till end , returns if the document still had a match*/
> 	gchar *fulltext, *realpat;
> 	Tsearch_result result;
> 
> 	DEBUG_MSG("replace_prompt_doc, doc=%p, startpos=%d, endpos=%d\n",doc,startpos,endpos);
> 	if (LASTSNR2(bfwin->snr2)->result.pmatch) {
> 		g_free(LASTSNR2(bfwin->snr2)->result.pmatch);
> 		LASTSNR2(bfwin->snr2)->result.pmatch = NULL;
> 	}
> 	fulltext = doc_get_chars(doc, startpos, endpos);
> 	utf8_offset_cache_reset();
> 	if (unescape) {
> 		realpat = unescape_string(search_pattern, FALSE);
> 	} else {
> 		realpat = search_pattern;
> 	}
> 	result = search_backend(bfwin,realpat, matchtype, is_case_sens, fulltext, 0, -1, TRUE);
> 	if (unescape) {
> 		g_free(realpat);
> 	}
> 	LASTSNR2(bfwin->snr2)->doc = doc;
> 	g_free(fulltext);
> 	DEBUG_MSG("replace_prompt_doc, doc=%p, result.end=%d\n", doc, result.end);
> 	if (result.end > 0) {
> 		gint i;
> 		LASTSNR2(bfwin->snr2)->result.start = result.start + startpos;
> 		LASTSNR2(bfwin->snr2)->result.end = result.end + startpos;
> 		LASTSNR2(bfwin->snr2)->result.nmatch = result.nmatch;
> 		LASTSNR2(bfwin->snr2)->result.pmatch = result.pmatch;
> 		for (i=0;i<result.nmatch;i++) {
> 			DEBUG_MSG("replace_prompt_doc, adding offset %d to subsearch_pattern %d\n", startpos, i);
> 			LASTSNR2(bfwin->snr2)->result.pmatch[i].rm_so += startpos;
> 			LASTSNR2(bfwin->snr2)->result.pmatch[i].rm_eo += startpos;
> 		}
> 		doc_show_result(doc, result.start + startpos, result.end + startpos);
> 		replace_prompt_dialog(bfwin);
> 		return 1;
> 	} else {
> 		g_free(result.pmatch);
> 		return 0;
> 	}
> }
> 
> /**
>  * replace_prompt_all:
>  * @search_pattern: #gchar* to search pattern
>  * @matchtype: see #Tmatch_types
>  * @is_case_sens: #gint
>  * @replace_pattern: #gchar to replace pattern
>  * 
>  * Performs a replace_prompt_doc for all open documents.
>  * 
>  * Return value: void
>  **/
> void replace_prompt_all(Tbfwin *bfwin,gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gchar *replace_pattern, gboolean unescape) {
> 	GList *tmplist;
> 	gint retvalue;
> 	Tdocument *tmpdoc;
> 
> 	if (LASTSNR2(bfwin->snr2)->doc) {
> 		tmpdoc = LASTSNR2(bfwin->snr2)->doc;
> 	} else {
> 		tmplist = g_list_first(bfwin->documentlist);
> 		tmpdoc = (Tdocument *)tmplist->data;
> 	}
> 	DEBUG_MSG("replace_prompt_all, starting with tmpdoc=%p at position %d\n",tmpdoc,LASTSNR2(bfwin->snr2)->result.end);
> 	retvalue = replace_prompt_doc(bfwin,search_pattern, matchtype, is_case_sens, (LASTSNR2(bfwin->snr2)->result.end < 0)?0:LASTSNR2(bfwin->snr2)->result.end, -1, replace_pattern, tmpdoc, unescape);
> 	while (retvalue == 0) {
> 		tmplist = g_list_find(bfwin->documentlist, LASTSNR2(bfwin->snr2)->doc);
> 		tmplist = g_list_next(tmplist);
> 		if (tmplist) {
> 			DEBUG_MSG("replace_prompt_all, next document is %p\n",tmplist->data);
> 			retvalue = replace_prompt_doc(bfwin,search_pattern, matchtype, is_case_sens, 0, -1, replace_pattern, (Tdocument *)tmplist->data, unescape);
> 		} else {
> 			retvalue = 1;
> 		}
> 	}
> }
> 
> static void search_doc_bookmark_backend(Tbfwin *bfwin,Tdocument *document, gchar *search_pattern, Tmatch_types matchtype, gint is_case_sens, gint startpos, gint endpos, gboolean unescape) {
> 	gchar *fulltext, *realpat;
>     gint buf_byte_offset = 0;
> 	Tsearch_result result;
> 	fulltext = doc_get_chars(document, 0, -1);
> 	utf8_offset_cache_reset();
> 	if (unescape) {
> 		realpat = unescape_string(search_pattern, FALSE);
> 	} else {
> 		realpat = search_pattern;
> 	}
> 	result = search_backend(bfwin,realpat, matchtype, is_case_sens, fulltext, startpos, endpos, FALSE);
> 	while (result.end > 0) {
> 		gchar *text = doc_get_chars(document, result.start, result.end);
> 		DEBUG_MSG("search_bookmark, adding bookmark '%s' at %d\n", text, result.start);
> 		bmark_add_extern(document, result.start, NULL, text, !main_v->props.bookmarks_default_store);
> 		g_free(text);
> 		if (LASTSNR2(bfwin->snr2)->overlapping_search) {
> 			buf_byte_offset = result.bstart + 1;
> 		} else {
> 			buf_byte_offset = result.bend;
> 		}
> 		result = search_backend(bfwin,realpat, matchtype, is_case_sens, fulltext, buf_byte_offset, endpos, FALSE);
> 	}
> 	if (unescape) {
> 		g_free(realpat);
> 	}
> 	g_free(fulltext);
> }
> 
> /**
>  * search_bookmark:
>  * @bfwin: #Tbfwin *
>  * @startat: #gint
>  *
>  * will search, and bookmark all matches
>  * 
>  */
> static void search_bookmark(Tbfwin *bfwin, gint startpos, gint endpos) {
> 	DEBUG_MSG("search_bookmark, started\n");
> 	if (LASTSNR2(bfwin->snr2)->placetype_option==opened_files) {
> 		GList *tmplist = g_list_first(bfwin->documentlist);
> 		while (tmplist) {
> 			search_doc_bookmark_backend(bfwin,DOCUMENT(tmplist->data), LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, 0, -1, LASTSNR2(bfwin->snr2)->unescape);
> 			tmplist = g_list_next(tmplist);
> 		}
> 	} else {
> 		search_doc_bookmark_backend(bfwin,DOCUMENT(bfwin->current_document), LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, startpos, endpos, LASTSNR2(bfwin->snr2)->unescape);
> 	}
> 	DEBUG_MSG("search_bookmark, done\n");
> }
> 
> /*****************************************************/
> 
> /**
>  * snr2_run:
>  * @bfwin: #Tbfwin*
>  * @doc: a #Tdocument* If set to NULL, use bfwin->current_document
>  *
>  * Continues a search or replace action as specified by the last_snr2 struct.
>  * 
>  * Return value: void
>  **/
> void snr2_run(Tbfwin *bfwin, Tdocument *doc) {
> 	gint startpos, endpos;
> 	Tsearch_result result;
> 	Tsearch_all_result result_all;
> 	Treplace_types replacetype;
> 
> 	if (doc==NULL) {
> 		doc = bfwin->current_document;
> 	}
> 
> 	if (LASTSNR2(bfwin->snr2)->result.pmatch) {
> 		g_free(LASTSNR2(bfwin->snr2)->result.pmatch);
> 		LASTSNR2(bfwin->snr2)->result.pmatch = NULL;
> 	}
> 
> 	/* should be more stuff here */
> 	if (LASTSNR2(bfwin->snr2)->placetype_option==beginning) {
> 		startpos = 0;
> 		endpos = -1;
> 	} else if (LASTSNR2(bfwin->snr2)->placetype_option==cursor) {
> 		startpos = doc_get_cursor_position(doc);
> 		endpos = -1;
> 	} else if (LASTSNR2(bfwin->snr2)->placetype_option==selection) {
> 		if (!doc_get_selection(doc,&startpos,&endpos)) {
> 			/* what to do if there was no selection ?*/
> 			DEBUG_MSG("snr2_run, no selection found, returning\n");
> 			return;
> 		}
> 		DEBUG_MSG("snr2_run, from selection: startpos=%d, endpos=%d\n", startpos, endpos);
> 	}
> 	if (LASTSNR2(bfwin->snr2)->doc == doc) {
> 		if (LASTSNR2(bfwin->snr2)->result.end > 0) {
> 			if (LASTSNR2(bfwin->snr2)->overlapping_search) {
> 				startpos = LASTSNR2(bfwin->snr2)->result.start + 1;
> 			} else {
> 				startpos = LASTSNR2(bfwin->snr2)->result.end;
> 			}
> 		}
> 		DEBUG_MSG("snr2_run, LASTSNR2(bfwin->snr2)->result.end=%d, startpos=%d\n", LASTSNR2(bfwin->snr2)->result.end, startpos);
> 	}
> 	if (LASTSNR2(bfwin->snr2)->replace) {
> 		if (LASTSNR2(bfwin->snr2)->replacetype_option==string) {
> 			replacetype = string;
> 		} else if (LASTSNR2(bfwin->snr2)->replacetype_option==uppercase) {
> 			replacetype = uppercase;
> 		} else {
> 			replacetype = lowercase;
> 		}
> 	
> 		if (LASTSNR2(bfwin->snr2)->prompt_before_replace) {
> 			if (LASTSNR2(bfwin->snr2)->placetype_option==opened_files) {
> 				replace_prompt_all(bfwin,LASTSNR2(bfwin->snr2)->search_pattern,LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, LASTSNR2(bfwin->snr2)->replace_pattern, LASTSNR2(bfwin->snr2)->unescape);
> 			} else {
> 				replace_prompt_doc(bfwin,LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, startpos, endpos, LASTSNR2(bfwin->snr2)->replace_pattern, doc, LASTSNR2(bfwin->snr2)->unescape);
> 			}
> 		} else {
> 			if (LASTSNR2(bfwin->snr2)->placetype_option==opened_files) {
> 				replace_all(bfwin,LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, LASTSNR2(bfwin->snr2)->replace_pattern, replacetype, LASTSNR2(bfwin->snr2)->unescape);
> 			} else if (LASTSNR2(bfwin->snr2)->replace_once) {
> 				replace_doc_once(bfwin,LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, startpos, endpos, LASTSNR2(bfwin->snr2)->replace_pattern, doc, replacetype, LASTSNR2(bfwin->snr2)->unescape);
> 			} else {
> 				replace_doc_multiple(bfwin,LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, startpos, endpos, LASTSNR2(bfwin->snr2)->replace_pattern, doc, replacetype, LASTSNR2(bfwin->snr2)->unescape);
> 			}		
> 		}
> 	} else { /* find, not replace */
> 		if (LASTSNR2(bfwin->snr2)->bookmark_results) {
> 			search_bookmark(bfwin, startpos, endpos);
> 		} else {
> 			if (LASTSNR2(bfwin->snr2)->placetype_option==opened_files) {
> 				DEBUG_MSG("snr2dialog_ok_lcb, search = all\n");
> 				result_all = search_all(bfwin,LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, LASTSNR2(bfwin->snr2)->unescape);
> 				DEBUG_MSG("snr2dialog_ok_lcb, result_all.doc=%p\n",result_all.doc);
> 				if (result_all.end > 0) {
> 					doc_show_result(result_all.doc, result_all.start, result_all.end);
> 				} else {
> 					info_dialog(bfwin->main_window,_("Search: no match found"), NULL);
> 				}
> 			} else {
> 				result = search_doc(bfwin,doc, LASTSNR2(bfwin->snr2)->search_pattern, LASTSNR2(bfwin->snr2)->matchtype_option, LASTSNR2(bfwin->snr2)->is_case_sens, startpos, LASTSNR2(bfwin->snr2)->unescape);
> 				if (result.end > 0) {
> 					doc_show_result(doc, result.start, result.end);
> 				} else {
> 					info_dialog(bfwin->main_window,_("Search: no match found"), NULL);
> 				}
> 			}
> 		}
> 	}
> 	/* if highlighting is needed for this document do this now !! */
> 	if (doc->need_highlighting && doc->highlightstate) {
> 		doc_highlight_full(doc);
> 	}
> }
> 
> /**
>  * snr2_run_extern_replace:
>  * @doc: a #Tdocument
>  * @search_pattern: #gchar* to search pattern
>  * @region: #gint, 0 = region_from_beginning, 1 = region_from_cursor, 2 = region_selection, 3 = region_all_open_files
>  * @matchtype: #gint, 0 = normal, 1 = posix, 2 = perl
>  * @is_case_sens: #gint
>  * @replace_pattern: #gchar* to replace pattern.
>  * @store_as_last_snr2: Set to FALSE to keep the old last_snr2 after the snr has been completed.
>  * 
>  * Performs the specified replace action on the document by setting
>  * a last_snr2 and calling snr2_run().
>  *
>  * Additional non-configureable arguments passed to snr2_run() via last_snr2:
>  * replace = 1
>  * prompt_before_replace = off
>  * replace_once = off
>  *
>  * Return value: void
>  **/
> void snr2_run_extern_replace(Tdocument *doc, gchar *search_pattern, gint region,
> 							gint matchtype, gint is_case_sens, gchar *replace_pattern,
> 							gboolean store_as_last_snr2) {
> 	Tbfwin *bfwin = BFWIN(doc->bfwin);
> 	gchar *search_pattern_bck, *replace_pattern_bck;
> 	Tlast_snr2 last_snr2_bck;
> 	
> 	search_pattern_bck = LASTSNR2(bfwin->snr2)->search_pattern;
> 	replace_pattern_bck = LASTSNR2(bfwin->snr2)->replace_pattern;
> 	last_snr2_bck = *LASTSNR2(bfwin->snr2);
> 	DEBUG_MSG("snr2..extern..: last_snr2_bck.search_pattern=%p, replace_pattern=%p\n"
> 		,last_snr2_bck.search_pattern, last_snr2_bck.replace_pattern);
> 
> 	if (!search_pattern || !replace_pattern || !strlen(search_pattern)) {
> 		DEBUG_MSG("snr2_run_extern, returning, non-valid arguments\n");
> 		return;
> 	}
> 	DEBUG_MSG("snr2..extern..: doc=%p, search_pattern='%s', region=%d, matchtype=%d, is_case_sens=%d, replace_pattern=%s, store_as_last=%d\n"
> 			,doc,search_pattern,region,matchtype,is_case_sens,replace_pattern,store_as_last_snr2);
> 	LASTSNR2(bfwin->snr2)->search_pattern = g_strdup(search_pattern);
> 	LASTSNR2(bfwin->snr2)->placetype_option = region;
>  	LASTSNR2(bfwin->snr2)->is_case_sens = is_case_sens;
>  	LASTSNR2(bfwin->snr2)->overlapping_search = 0;
> 	LASTSNR2(bfwin->snr2)->replace = 1;
> 	LASTSNR2(bfwin->snr2)->replace_pattern = g_strdup(replace_pattern);
>  	LASTSNR2(bfwin->snr2)->prompt_before_replace = 0;
>  	LASTSNR2(bfwin->snr2)->replace_once = 0;
>  	LASTSNR2(bfwin->snr2)->unescape = 0;
> 	LASTSNR2(bfwin->snr2)->matchtype_option = matchtype;
>  	LASTSNR2(bfwin->snr2)->replacetype_option = string;
>  	LASTSNR2(bfwin->snr2)->bookmark_results = 0;
> 	snr2_run(BFWIN(doc->bfwin),doc);
> 	if (store_as_last_snr2) {
> 		DEBUG_MSG("free-ing old patterns at %p and %p\n",search_pattern_bck,replace_pattern_bck);
> 		g_free(search_pattern_bck);
> 		g_free(replace_pattern_bck);
> 	} else {
> 		g_free(LASTSNR2(bfwin->snr2)->search_pattern);
> 		g_free(LASTSNR2(bfwin->snr2)->replace_pattern);
> 		*LASTSNR2(bfwin->snr2) = last_snr2_bck;
> 	}
> }
> 
> /**
>  * doc_search_run_extern:
>  * @doc: a #Tdocument
>  * @search_pattern: #gchar search pattern
>  * @matchtype: #gint, 0 = normal, 1 = posix, 2 = perl
>  * @is_case_sens: #gint, case sensitive pattern?
>  *
>  * Frontend for search_doc, calling it with supplied arguments and startpos = 0.
>  * 
>  * Return value: #Tsearch_result_doc
>  **/
> Tsearch_result doc_search_run_extern(Tdocument *doc, gchar *search_pattern, gint matchtype, gint is_case_sens) {
> 	return search_doc(BFWIN(doc->bfwin),doc, search_pattern, matchtype, is_case_sens, 0, FALSE);
> } 
> 
> /******************************************************/
> /*        Search and replace dialogs callbacks        */
> /******************************************************/
> 
> static void snr2dialog_destroy_lcb(GtkWidget *widget, gpointer data) {
> 	DEBUG_MSG("snr2dialog_destroy_lcb, started, about to call window_destroy\n");
> 	window_destroy(((Tsnr2_win *)data)->window);
> 	DEBUG_MSG("snr2dialog_destroy_lcb, about to free data %p\n", data);
> 	g_free(data);
> 	DEBUG_MSG("snr2dialog_destroy_lcb, done\n");
> }
> 
> static void snr2dialog_cancel_lcb(GtkWidget *widget, gpointer data) {
> 	snr2dialog_destroy_lcb(NULL, data);
> }
> 
> /*****************************************************/
> 
> /*
>  * Sets the last_snr2 as specified by the user and calls snr2_run(NULL) (aka, run on current document)
>  */
> static void snr2dialog_ok_lcb(GtkWidget *widget, Tsnr2_win *data) {
> 	/*GtkTextIter itstart, itend;
> 	GtkTextBuffer *buf;*/
> 	Tbfwin *bfwin = data->bfwin;
> 	if (LASTSNR2(bfwin->snr2)->search_pattern) {
> 		g_free(LASTSNR2(bfwin->snr2)->search_pattern);
> 		LASTSNR2(bfwin->snr2)->search_pattern = NULL;
> 	}
> 	if (LASTSNR2(bfwin->snr2)->replace_pattern) {
> 		g_free(LASTSNR2(bfwin->snr2)->replace_pattern);
> 		LASTSNR2(bfwin->snr2)->replace_pattern = NULL;
> 	}
> 	/*buf = gtk_text_view_get_buffer(GTK_TEXT_VIEW(data->search_entry));
> 	gtk_text_buffer_get_bounds(buf,&itstart,&itend);
> 	LASTSNR2(bfwin->snr2)->search_pattern = gtk_text_buffer_get_text(buf,&itstart,&itend, FALSE);*/
> 	LASTSNR2(bfwin->snr2)->search_pattern = gtk_editable_get_chars(GTK_EDITABLE(GTK_COMBO(data->search_combo)->entry),0,-1);
> 	
> 	data->bfwin->session->searchlist = add_to_history_stringlist(data->bfwin->session->searchlist,LASTSNR2(bfwin->snr2)->search_pattern,TRUE,TRUE);
> 	
> 	LASTSNR2(bfwin->snr2)->unescape = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->unescape));
>  	LASTSNR2(bfwin->snr2)->is_case_sens = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->is_case_sens));
>  	LASTSNR2(bfwin->snr2)->overlapping_search = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->overlapping_search));
> 	if (data->replace) {
> 		/*GtkTextIter itstart, itend;
> 		GtkTextBuffer *buf = gtk_text_view_get_buffer(GTK_TEXT_VIEW(data->replace_entry));
> 		gtk_text_buffer_get_bounds(buf,&itstart,&itend);
> 		LASTSNR2(bfwin->snr2)->replace_pattern = gtk_text_buffer_get_text(buf,&itstart,&itend, FALSE);*/
> 		LASTSNR2(bfwin->snr2)->replace = 1;
> 		LASTSNR2(bfwin->snr2)->replace_pattern = gtk_editable_get_chars(GTK_EDITABLE(GTK_COMBO(data->replace_combo)->entry),0,-1);
> 		
> 		data->bfwin->session->replacelist = add_to_history_stringlist(data->bfwin->session->replacelist,LASTSNR2(bfwin->snr2)->replace_pattern,TRUE,TRUE);
> 		
> 	 	LASTSNR2(bfwin->snr2)->prompt_before_replace = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->prompt_before_replace));
> 	 	LASTSNR2(bfwin->snr2)->replace_once = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->replace_once));
> 	} else {
> 		LASTSNR2(bfwin->snr2)->replace = 0;
> 		LASTSNR2(bfwin->snr2)->bookmark_results = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data->bookmark_results));
> 	}
> 	window_destroy(data->window);
> 	g_free(data);
> 
> 	snr2_run(bfwin,NULL);
> }
> 
> static void placetype_changed_lcb(GtkWidget *widget, Tsnr2_win *snr2win) {
> 	LASTSNR2(snr2win->bfwin->snr2)->placetype_option =  gtk_option_menu_get_history((GtkOptionMenu *) snr2win->placetype_option);
> 	DEBUG_MSG("placetype_changed_lcb, changing option to %d\n", LASTSNR2(snr2win->bfwin->snr2)->placetype_option);
> }	
> 
> static void matchtype_changed_lcb(GtkWidget *widget, Tsnr2_win *snr2win) {
> 	LASTSNR2(snr2win->bfwin->snr2)->matchtype_option =  gtk_option_menu_get_history((GtkOptionMenu *) snr2win->matchtype_option);
> 	if (snr2win->replace) {
> 		if (LASTSNR2(snr2win->bfwin->snr2)->matchtype_option==0) {
> 			gtk_widget_hide(snr2win->subpat_help);
> 		}
> 		else {
> 			gtk_widget_show(snr2win->subpat_help);
> 		}
> 	}
> 	DEBUG_MSG("matchtype_changed_lcb, changing option to %d\n", LASTSNR2(snr2win->bfwin->snr2)->matchtype_option);
> }	
> 
> static void replacetype_changed_lcb(GtkWidget *widget, Tsnr2_win *snr2win) {
> 	LASTSNR2(snr2win->bfwin->snr2)->replacetype_option =  gtk_option_menu_get_history((GtkOptionMenu *) snr2win->replacetype_option);
> 	/*gtk_widget_set_sensitive(snr2win->replace_entry, LASTSNR2(snr2win->bfwin->snr2)->replacetype_option==0);*/
> 	gtk_widget_set_sensitive(snr2win->replace_combo, LASTSNR2(snr2win->bfwin->snr2)->replacetype_option==0);
> 	DEBUG_MSG("replacetype_changed_lcb, changing option to %d\n", LASTSNR2(snr2win->bfwin->snr2)->replacetype_option);
> }
> /*
> static gboolean search_entry_key_press_event_lcb(GtkWidget *widget,GdkEventKey *event,Tsnr2_win *snr2win) {
> 	if ((event->state & GDK_CONTROL_MASK) && (event->keyval == GDK_Return)) {
> 		snr2dialog_ok_lcb(NULL, snr2win);
> 		return TRUE;
> 	}
> 	return FALSE;
> }*/
> 
> static gboolean snr_focus_in_lcb(GtkWidget *widget, GdkEventFocus *event, Tsnr2_win *snr2win)
> {
>     if (snr2win->replace == 0) {
>         if (snr2win->bfwin->current_document->filename) {
>             gtk_widget_set_sensitive (snr2win->bookmark_results, TRUE);
>             if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (snr2win->bookmark_results))) {
>                 LASTSNR2(snr2win->bfwin->snr2)->bookmark_results = TRUE;
>             }
>         } else {
>             LASTSNR2(snr2win->bfwin->snr2)->bookmark_results = FALSE;
>             gtk_widget_set_sensitive (snr2win->bookmark_results, FALSE);
>         }
>     }
> 
>     return FALSE;
> }
> 
> static void snr2dialog(Tbfwin *bfwin, gint is_replace, gint is_new_search) {
> 	Tsnr2_win *snr2win;
> 	GtkWidget *vbox, *hbox, *button, *table;
> 	const gchar *tmptext;
>    gchar *buffer;
>    GtkTextIter start, end;
> 
> 	snr2win = g_malloc(sizeof(Tsnr2_win));
> 	snr2win->bfwin = bfwin;
> 	if (is_replace) {
> 		tmptext = _("Replace");
> 		snr2win->replace = 1;
> 	} else {
> 		tmptext = _("Find");
> 		snr2win->replace = 0;
> 	}
> 	if (is_new_search) {
> 		reset_last_snr2(bfwin);
> 	} else {
> 		LASTSNR2(bfwin->snr2)->result.start = -1;
> 		LASTSNR2(bfwin->snr2)->result.end = -1;
> 		LASTSNR2(bfwin->snr2)->doc = NULL;
> 	}
> 	snr2win->window = window_full(tmptext, GTK_WIN_POS_MOUSE, 12, G_CALLBACK(snr2dialog_destroy_lcb), snr2win, TRUE);
> 	gtk_window_set_role(GTK_WINDOW(snr2win->window), "snr");
> 	g_signal_connect_after(G_OBJECT(snr2win->window), "focus-in-event", G_CALLBACK(snr_focus_in_lcb), snr2win);
> 	vbox = gtk_vbox_new(FALSE, 0);
> 	gtk_container_add(GTK_CONTAINER(snr2win->window), vbox);
> 
> 	if (is_replace) {
> 		table = gtk_table_new (2, 2, FALSE);
> 	}
> 	else {
> 		table = gtk_table_new (1, 2, FALSE);
> 	}
> 	gtk_widget_show (table);
> 	gtk_box_pack_start (GTK_BOX (vbox), table, TRUE, TRUE, 0);
> 	gtk_table_set_row_spacings (GTK_TABLE (table), 12);
> 	gtk_table_set_col_spacings (GTK_TABLE (table), 6);
> 
> 	snr2win->search_label = gtk_label_new_with_mnemonic(_("_Search for: "));
> 	gtk_table_attach (GTK_TABLE (table), snr2win->search_label, 0, 1, 0, 1,
> 					(GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 2, 0);
> 	gtk_label_set_justify (GTK_LABEL (snr2win->search_label), GTK_JUSTIFY_LEFT);
> 	gtk_misc_set_alignment (GTK_MISC (snr2win->search_label), 0, 0.5);
> 	/*snr2win->search_scrollbox = textview_buffer_in_scrolwin(&snr2win->search_entry, 300, 50, LASTSNR2(bfwin->snr2)->search_pattern, GTK_WRAP_NONE);*/
>    gtk_text_buffer_get_selection_bounds(bfwin->current_document->buffer, &start, &end);
>    buffer = gtk_text_buffer_get_text(bfwin->current_document->buffer, &start, &end, FALSE);
>    if (strchr(buffer,'\n')!=NULL) {
>       /* a newline in the selection, we probably don't want this string as search string */
>       g_free(buffer);
>       buffer = NULL;
>    }
>    snr2win->search_combo = combo_with_popdown(buffer ? buffer : "", bfwin->session->searchlist, TRUE);
>    if (buffer) g_free(buffer);
> 	gtk_table_attach (GTK_TABLE (table), snr2win->search_combo, 1, 2, 0, 1,
> 					(GtkAttachOptions) (GTK_EXPAND | GTK_FILL), (GtkAttachOptions) (GTK_FILL), 0, 0);
> 	/*g_signal_connect(G_OBJECT(snr2win->search_entry), "key_press_event", G_CALLBACK(search_entry_key_press_event_lcb), snr2win);*/
> 
> 	if (is_replace) {
> 		snr2win->replace_label = gtk_label_new_with_mnemonic(_("_Replace with: "));
> 		gtk_table_attach (GTK_TABLE (table), snr2win->replace_label, 0, 1, 1, 2,
> 						(GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 2, 0);
> 		gtk_label_set_justify (GTK_LABEL (snr2win->replace_label), GTK_JUSTIFY_LEFT);
> 		gtk_misc_set_alignment (GTK_MISC (snr2win->replace_label), 0, 0.5);
> 		/*snr2win->replace_scrollbox = textview_buffer_in_scrolwin(&snr2win->replace_entry, 300, 50, LASTSNR2(bfwin->snr2)->replace_pattern, GTK_WRAP_NONE);*/
> 		snr2win->replace_combo = combo_with_popdown("", bfwin->session->replacelist, TRUE);
> 		gtk_table_attach (GTK_TABLE (table), snr2win->replace_combo, 1, 2, 1, 2,
> 						(GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (GTK_FILL), 0, 0);
> 		/*g_signal_connect(G_OBJECT(snr2win->replace_entry), "key_press_event", G_CALLBACK(search_entry_key_press_event_lcb), snr2win);*/
> 		snr2win->subpat_help = gtk_label_new(_("\\0 refers to the first subsearch_pattern, \\1 to the second etc."));
> 		gtk_box_pack_start(GTK_BOX(vbox), snr2win->subpat_help, FALSE, TRUE, 6);
> 		gtk_label_set_justify (GTK_LABEL (snr2win->subpat_help), GTK_JUSTIFY_LEFT);
> 		gtk_misc_set_alignment (GTK_MISC (snr2win->subpat_help), 1, 0.5);
> 	}
> 
> 	if (is_replace) {
> 		table = gtk_table_new (3, 2, FALSE);
> 	} else {
> 		table = gtk_table_new (2, 2, FALSE);
> 	}
> 	gtk_box_pack_start (GTK_BOX (vbox), table, TRUE, TRUE, 12);
> 	gtk_table_set_row_spacings (GTK_TABLE (table), 12);
> 	gtk_table_set_col_spacings (GTK_TABLE (table), 6);
> 	{
> 		gchar *placeactions[] = {N_("Beginning of document till end"), N_("Current position till end"),	N_("Beginning of selection till end of selection"), N_("All opened files begin till end"), NULL};
> 		gchar *matchactions[] = {N_("Disabled"), N_("POSIX type"),	N_("PERL type"), NULL};
> 		GtkWidget *matchlabel, *placelabel = gtk_label_new(_("Starts at:"));
> 		DEBUG_MSG("snr2dialog, LASTSNR2(bfwin->snr2)->placetype_option=%d\n", LASTSNR2(bfwin->snr2)->placetype_option);
> 		snr2win->placetype_option = optionmenu_with_value(placeactions, LASTSNR2(bfwin->snr2)->placetype_option);
> 
> 		gtk_table_attach (GTK_TABLE (table), placelabel, 0, 1, 0, 1,
> 						(GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 2, 0);
> 		gtk_label_set_justify (GTK_LABEL (placelabel), GTK_JUSTIFY_LEFT);
> 		gtk_misc_set_alignment (GTK_MISC (placelabel), 0, 0.5);
> 		gtk_table_attach (GTK_TABLE (table), snr2win->placetype_option, 1, 2, 0, 1, 
> 						(GtkAttachOptions) (GTK_EXPAND | GTK_FILL), (GtkAttachOptions) (GTK_FILL), 0, 0);
> 		g_signal_connect(G_OBJECT((GtkWidget *) snr2win->placetype_option), "changed", G_CALLBACK(placetype_changed_lcb), snr2win);
> 		
> 		matchlabel = gtk_label_new(_("Regular expression:"));
> 		DEBUG_MSG("snr2dialog, LASTSNR2(bfwin->snr2)->matchtype_option=%d\n", LASTSNR2(bfwin->snr2)->matchtype_option);
> 		snr2win->matchtype_option = optionmenu_with_value(matchactions, LASTSNR2(bfwin->snr2)->matchtype_option);
> 
> 		gtk_table_attach (GTK_TABLE (table), matchlabel, 0, 1, 1, 2,
> 						(GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 2, 0);
> 		gtk_label_set_justify (GTK_LABEL (matchlabel), GTK_JUSTIFY_LEFT);
> 		gtk_misc_set_alignment (GTK_MISC (matchlabel), 0, 0.5);
> 		gtk_table_attach (GTK_TABLE (table), snr2win->matchtype_option, 1, 2, 1, 2, 
> 						(GtkAttachOptions) (GTK_EXPAND | GTK_FILL), (GtkAttachOptions) (GTK_FILL), 0, 0);
> 		g_signal_connect(G_OBJECT((GtkWidget *) snr2win->matchtype_option), "changed", G_CALLBACK(matchtype_changed_lcb), snr2win);
> 
> 
> 		if (is_replace) {
> 			gchar *replaceactions[] = {N_("Normal"), N_("Uppercase"),	N_("Lowercase"), NULL};
> 			GtkWidget *replacelabel = gtk_label_new(_("Replace type:"));
> 			DEBUG_MSG("snr2dialog, LASTSNR2(bfwin->snr2)->replacetype_option=%d\n", LASTSNR2(bfwin->snr2)->replacetype_option);
> 			snr2win->replacetype_option = optionmenu_with_value(replaceactions, LASTSNR2(bfwin->snr2)->replacetype_option);
> 	
> 			gtk_table_attach (GTK_TABLE (table), replacelabel, 0, 1, 2, 3, 
> 							(GtkAttachOptions) (GTK_FILL), (GtkAttachOptions) (0), 2, 0);
> 			gtk_label_set_justify (GTK_LABEL (replacelabel), GTK_JUSTIFY_LEFT);
> 			gtk_misc_set_alignment (GTK_MISC (replacelabel), 0, 0.5);
> 			gtk_table_attach (GTK_TABLE (table), snr2win->replacetype_option, 1, 2, 2, 3, 
> 							(GtkAttachOptions) (GTK_EXPAND | GTK_FILL), (GtkAttachOptions) (GTK_FILL), 0, 0);
> 			g_signal_connect(G_OBJECT((GtkWidget *) snr2win->replacetype_option), "changed", G_CALLBACK(replacetype_changed_lcb), snr2win);
> 		}
> 	}
> 	snr2win->unescape = boxed_checkbut_with_value(_("_Patterns contain backslash escape sequences (\\n, \\t)"), LASTSNR2(bfwin->snr2)->unescape, vbox);
> 	snr2win->is_case_sens = boxed_checkbut_with_value(_("_Match case"), LASTSNR2(bfwin->snr2)->is_case_sens, vbox);
> 	snr2win->overlapping_search = boxed_checkbut_with_value(_("O_verlap searches"), LASTSNR2(bfwin->snr2)->overlapping_search, vbox);
> 	if (is_replace) {
> 		snr2win->prompt_before_replace = boxed_checkbut_with_value(_("Prompt _before replace"), LASTSNR2(bfwin->snr2)->prompt_before_replace, vbox);
> 		snr2win->replace_once = boxed_checkbut_with_value(_("Replace o_nce"), LASTSNR2(bfwin->snr2)->replace_once, vbox);
> 	} else {
> 		snr2win->bookmark_results = boxed_checkbut_with_value(_("_Bookmark results"), LASTSNR2(bfwin->snr2)->bookmark_results, vbox);
> 	}
> 
> 	hbox = gtk_hseparator_new ();
> 	gtk_widget_show (hbox);
> 	gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, TRUE, 12);
> 
> 	hbox = gtk_hbutton_box_new();
> 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
> 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 6);
> 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);
> 
> 	gtk_box_pack_start(GTK_BOX(hbox), bf_stock_cancel_button(G_CALLBACK(snr2dialog_cancel_lcb), snr2win), FALSE, TRUE, 0);
> 	button = bf_stock_ok_button(G_CALLBACK(snr2dialog_ok_lcb), snr2win);
> 	gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);
> 	gtk_window_set_default(GTK_WINDOW(snr2win->window), button);
> 	
> 	gtk_label_set_mnemonic_widget(GTK_LABEL(snr2win->search_label), GTK_COMBO(snr2win->search_combo)->entry);
> 	if(is_replace) {
> 		gtk_label_set_mnemonic_widget(GTK_LABEL(snr2win->replace_label), GTK_COMBO(snr2win->replace_combo)->entry);
> 	}
> 	gtk_widget_grab_focus(snr2win->search_combo);
> 	gtk_widget_show_all(vbox);
> 
> 	gtk_widget_show(snr2win->window);
> /*	{
> 		GtkTextIter itstart, itend;
> 		gtk_text_buffer_get_bounds(gtk_text_view_get_buffer(GTK_TEXT_VIEW(snr2win->search_entry)),&itstart,&itend);
> 		gtk_text_buffer_move_mark_by_name(gtk_text_view_get_buffer(GTK_TEXT_VIEW(snr2win->search_entry)),"insert",&itstart);
> 		gtk_text_buffer_move_mark_by_name(gtk_text_view_get_buffer(GTK_TEXT_VIEW(snr2win->search_entry)),"selection_bound",&itend);
> 	}*/
> 	
> 	if (is_replace) {
> 		matchtype_changed_lcb(NULL, snr2win);
> 		replacetype_changed_lcb(NULL, snr2win);
> 	}
> }
> 
> /*****************************************************/
> 
> void search_from_selection(Tbfwin *bfwin) {
> 	gchar *string;
> 	GtkClipboard* cb;
> 
> 	cb = gtk_clipboard_get(GDK_SELECTION_PRIMARY);
> 	string = gtk_clipboard_wait_for_text(cb);
> 	if (string) {
> 		if (LASTSNR2(bfwin->snr2)->search_pattern) {
> 			g_free(LASTSNR2(bfwin->snr2)->search_pattern);
> 		}
> 		if (LASTSNR2(bfwin->snr2)->replace_pattern) {
> 			g_free(LASTSNR2(bfwin->snr2)->replace_pattern);
> 			LASTSNR2(bfwin->snr2)->replace_pattern = NULL;
> 		}
> 		LASTSNR2(bfwin->snr2)->search_pattern = string;
> 		LASTSNR2(bfwin->snr2)->placetype_option = 0;
>  		LASTSNR2(bfwin->snr2)->is_case_sens = 1;
> 	 	LASTSNR2(bfwin->snr2)->overlapping_search = 0;
> 		LASTSNR2(bfwin->snr2)->replace = 0;
> 		LASTSNR2(bfwin->snr2)->matchtype_option = 0;
> 		snr2_run(bfwin,bfwin->current_document);
> 	}
> }
> 
> /**
>  * search_cb:
>  * @widget: unused #GtkWidget*
>  * @data: unused #gpointer
>  * 
>  * Show the search-dialog.
>  * 
>  * Return value: void
>  **/
> void search_cb(GtkWidget *widget, Tbfwin *bfwin) {
> 	snr2dialog(bfwin, 0, 0);
> }
> 
> /**
>  * search_again_cb:
>  * @widget: unused #GtkWidget*
>  * @data: unused #gpointer
>  * 
>  * Repeat last search, if any.
>  * 
>  * Return value: void
>  **/ 
> void search_again_cb(GtkWidget *widget, Tbfwin *bfwin) {
> 	snr2_run(bfwin,NULL);	
> }
> 
> /**
>  * replace_again_cb:
>  * @widget: unused #GtkWidget*
>  * @data: unused #gpointer
>  * 
>  * Repeat last replace, if any.
>  * 
>  * Return value: void
>  **/ 
> void replace_again_cb(GtkWidget *widget, Tbfwin *bfwin) {
> 	snr2_run(bfwin,NULL);
> }
> 
> /**
>  * replace_cb:
>  * @widget: unused #GtkWidget*
>  * @data: unused #gpointer
>  * 
>  * Show replace dialog.
>  * 
>  * Return value: void
>  **/ 
> void replace_cb(GtkWidget *widget, Tbfwin *bfwin) {
> 	snr2dialog(bfwin, 1, 0);
> }
> 
> /*****************************************************/
> 
> #ifdef NOTPORTEDYET
> 
> static gint do_filename_curfile_replace(gchar *fulltext, Tsearch_result result, gint offset, gchar *olddirname, gchar *newfilename, gint changelen, Tdocument *doc) {
> /* returns the change in the lenght of the buffer compared to the actual document text */
> 	gchar *possible_filename;
> 	gchar *olddirfile;
> 	gint len;
> 	gchar *replacestring;
> 	gint change_lenght = changelen;
> 
> 	possible_filename = g_strndup(&fulltext[offset + result.bstart +1], result.bend - result.bstart -2 );
> 	DEBUG_MSG("do_filename_change_replace, possible_filename=%s\n", possible_filename);
> 	len = strlen(possible_filename) + strlen(olddirname) + 2;
> 	olddirfile = strncat(strncat(strncpy(g_malloc(len), olddirname, len), "/", len), possible_filename, len);
> 
> 	/* code to check if this is a file */
> 	if (file_exists_and_readable(olddirfile)) {
> 		DEBUG_MSG("do_filename_change_replace, olddirfile=%s does exist!!\n", olddirfile);
> 		/* code to create replace_pattern */
> 		olddirfile = most_efficient_filename(olddirfile);
> 		DEBUG_MSG("do_filename_change_replace, updated olddirfile=%s \n", olddirfile);
> 		replacestring = create_relative_link_to(newfilename, olddirfile);
> 		DEBUG_MSG("do_filename_change_replace, replacestring=%s, newfilename=%s\n", replacestring, newfilename);
> 		/* code to actual replace it */
> 		doc_replace_text(doc, replacestring, result.start + offset + 1 + changelen, result.end + offset + changelen -1);	
> 		change_lenght = strlen(replacestring) - strlen(possible_filename) + changelen;
> 		DEBUG_MSG("do_filename_change_replace, replacestring=%s, possible_filename=%s\n", replacestring, possible_filename);
> 		DEBUG_MSG("do_filename_change_replace, change_lenght=%d\n",change_lenght );		
> 		g_free(replacestring); 
> 	} else {
> 		DEBUG_MSG("do_filename_change_replace, olddirfile=%s does NOT exist\n", olddirfile);  
> 	}
> 	g_free(possible_filename);
> 	g_free(olddirfile);
> 	return change_lenght;
> }
> 
> static gint do_filename_otherfile_replace(gchar *fulltext, Tsearch_result result, gint offset, gchar *oldfilename, gchar *newfilename, gint changelen, Tdocument *doc) {
> 	gchar *possible_filename, *replacestring, *foundstring;
> 	gint change_length = changelen;
> 	gchar *eff_my_filename;
> 
> 	foundstring = g_strndup(&fulltext[offset + result.bstart +1], result.bend - result.bstart -2 );
> 	possible_filename = most_efficient_filename(create_full_path(foundstring, doc->filename));
> 	g_free(foundstring);
> 	DEBUG_MSG("do_filename_otherfile_replace, posname=%s\n", possible_filename);
> 	DEBUG_MSG("do_filename_otherfile_replace, newname=%s\n", oldfilename);
> 	if (strcmp(possible_filename, oldfilename) == 0) {
> 		eff_my_filename = most_efficient_filename(g_strdup(doc->filename));
> 		replacestring = create_relative_link_to(eff_my_filename, newfilename);
> 		doc_replace_text(doc, replacestring, result.start + offset + 1 + changelen, result.end + offset + changelen -1);
> 		change_length = strlen(replacestring) - strlen(possible_filename) + changelen;		
> 		g_free(eff_my_filename);
> 		g_free(replacestring);
> 	}
> 	g_free(possible_filename);
> 	return change_length;
> }
> 
> /**
>  * update_filenames_in_file:
>  * @doc: a #Tdocument
>  * @oldfilename: Filename to change from.
>  * @newfilename: Filename to change to.
>  * @doc_has_newfilename: If *doc (blabla?)
>  * 
>  * 
>  *
>  * Return value: void
>  **/
> void update_filenames_in_file(Tdocument *doc, gchar *oldfilename, gchar *newfilename, gint doc_has_newfilename) {
> 	gchar *fulltext;
> 	Tsearch_result result;
> 	gint cur_offset, changelen=0;
> 	gchar *search_pattern;
> 	Tmatch_types matchtype;
> 	gint is_case_sens;
> 	gchar *olddirname=NULL;
> 
> 	if ((oldfilename == NULL)|| (newfilename == NULL)) {
> 		return;
> 	}
> 	search_pattern = "\"[^\"]+\"";
> 	matchtype = match_posix;
>  	is_case_sens = 0;
> 	cur_offset = 0;
> 
> 	if (doc_has_newfilename) {
> 			olddirname = g_path_get_dirname(oldfilename);
> 	}
> 
> 	fulltext = doc_get_chars(doc, 0, -1);
> 	utf8_offset_cache_reset();
> 	result = search_backend(search_pattern, matchtype, is_case_sens, fulltext, -1, FALSE);
> 	while (result.end > 0) {
> 		if (doc_has_newfilename) {
> 			changelen = do_filename_curfile_replace(fulltext, result, cur_offset, olddirname, newfilename, changelen, doc);
> 		} else {
> 			changelen = do_filename_otherfile_replace(fulltext, result, cur_offset, oldfilename, newfilename, changelen, doc);
> 		}
> 		cur_offset += result.bstart +1;
> 		result = search_backend(search_pattern, matchtype, is_case_sens, &fulltext[cur_offset], -1, FALSE);
> 	}
> 	g_free(fulltext);
> 	if (doc_has_newfilename) {
> 		g_free(olddirname);
> 	}
> }
> #endif /* NOTPORTEDYET */
> 
> /**
>  * update_encoding_meta_in_file:
>  * @doc: a #Tdocument*
>  * @encoding: #gchar*, The documents character encoding
>  *
>  * Update the HTML meta encoding tags for the supplied document.
>  *
>  * Return value: void
>  **/
> void update_encoding_meta_in_file(Tdocument *doc, gchar *encoding) {
> 	if (encoding) {
> 		Tbfwin *bfwin = BFWIN(doc->bfwin);
> 		Tlast_snr2 last_snr2_bck = *LASTSNR2(bfwin->snr2);
> 		gchar *last_search_pattern_bck = g_strdup(LASTSNR2(bfwin->snr2)->search_pattern);
> 		gchar *search_pattern, *fulltext;
> 		Tsearch_result result;
> 		/* first find if there is a meta encoding tag already */
> 		search_pattern = "<meta[ \t\n]http-equiv[ \t\n]*=[ \t\n]*\"content-type\"[ \t\n]+content[ \t\n]*=[ \t\n]*\"([^;]*);[ \t\n]*charset=[a-z0-9-]*\"[ \t\n]*(/?)>";
> 		fulltext = doc_get_chars(doc, 0, -1);
> 		utf8_offset_cache_reset();
> 		result = search_backend(bfwin,search_pattern, match_posix, 0, fulltext, 0, -1, TRUE);
> 		if (result.end > 0) {
> 			gchar *replacestring, *type, *xhtmlend;
> 			DEBUG_MSG("update_encoding_meta_in_file, we have a match, nmatch=%d\n",result.nmatch);
> 			if (result.nmatch > 2) {
> 				type = g_strndup(fulltext+result.pmatch[1].rm_so, result.pmatch[1].rm_eo - result.pmatch[1].rm_so);
> 				xhtmlend = g_strndup(fulltext+result.pmatch[2].rm_so, result.pmatch[2].rm_eo - result.pmatch[2].rm_so);
> 				DEBUG_MSG("update_encoding_meta_in_file, type=%s (bstart=%d, bend=%d, so[1]=%d, eo[1]=%d)\n",type,result.bstart,result.bend,result.pmatch[1].rm_so,result.pmatch[1].rm_eo);
> 			} else {
> 				type = g_strdup("text/html");
> 				xhtmlend = g_strdup( main_v->props.xhtml ? "/" : "");
> 			}
> 			replacestring = g_strconcat("<meta http-equiv=\"content-type\" content=\"",type,"; charset=",encoding,"\" ",xhtmlend,">", NULL);
> 			DEBUG_MSG("update_encoding_meta_in_file, 1: we have a match\n");
> 			doc_replace_text(doc, replacestring, result.start, result.end);
> 			g_free(replacestring);
> 			g_free(type);
> 			g_free(xhtmlend);
> 		} else {
> 			DEBUG_MSG("update_encoding_meta_in_file, 1: NO match\n");
> 			/* now search for <head>, we can append it to this tag */
> 			search_pattern = "<head>";
> 			result = search_backend(bfwin,search_pattern, match_posix, 0, fulltext, 0, -1, FALSE);
> 			if (result.end > 0) {
> 				gchar *replacestring = g_strconcat("<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=",encoding,"\">", NULL);
> 				DEBUG_MSG("update_encoding_meta_in_file, 2: we have a match\n");
> 				doc_replace_text(doc, replacestring, result.start, result.end);
> 				g_free(replacestring);
> 			} else {
> 				DEBUG_MSG("update_encoding_meta_in_file, 2: NO match\n");
> 			}
> 		}
> 		g_free(fulltext);
> 		g_free(LASTSNR2(bfwin->snr2)->search_pattern);
> 		*LASTSNR2(bfwin->snr2) = last_snr2_bck;
> 		LASTSNR2(bfwin->snr2)->search_pattern = last_search_pattern_bck;
> 	}
> }
1,1182c1,1160
< /* Bluefish HTML Editor
<  * stringlist.c - functions that deal with stringlists
<  *
<  * Copyright (C) 1999-2002 Olivier Sessink
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License as published by
<  * the Free Software Foundation; either version 2 of the License, or
<  * (at your option) any later version.
<  * 
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  * 
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
<  */
< 
< /*#define DEBUG*/
< 
< /*
<  * This module deals with the GUI dialog used in bluefish to manage
<  * GLists in which each element is composed of several strings,
<  * like the lists of syntax highlighting, external filters, external commands,
<  * and lately doctypes. For example, the list of doctypes contains a string
<  * for the DOCTYPE and a string for the FILENAME of that doctype.
<  *
<  * When the stringlist is edited, the old one is deleted and a new one is created,
<  * so the order can be different from the original.
<  */
< 
< #include <gtk/gtk.h>
< #include <stdio.h>
< #include <string.h>  	/* strspn() */
< #include <strings.h>  	/* strcasecmp() */
< #include "bluefish.h"
< #include "bf_lib.h"
< 
< /*#include "coloursel.h"  color_but_new() */
< #include "stringlist.h"
< #include "gtk_easy.h"
< 
< #define STRING_MAX_SIZE 4096
< #define MAX_ARRAY_LENGTH 20
< 
< 
< /************************************************************************/
< 
< 
< /************************************************************************/
< #ifdef USE_ESTRL_DIALOG
< typedef struct {
< 	GtkWidget *win;
< 	GtkWidget *ins_upd_entry[MAX_ARRAY_LENGTH];
< 	GtkWidget *clist;
< 	gint num_columns;
< 	gint last_row;
< 	GList **the_list;
< 	void (*function)();
< } Testrl;
< 
< 
< /******************************************************************************
<  * Check if the strings we want to add, already exist in the list
<  */
< static int is_duplicated(gchar **new_values, Testrl *estrl) {
<     guint i, duplicated=0;
<     gchar **tmparray, *tmpstring;
<     gint row=0, retval=1;
< 
<     DEBUG_MSG("stringlist:is_duplicated(%p, %p)\n", new_values, estrl);
<     retval = gtk_clist_get_text(GTK_CLIST(estrl->clist), row, 0, &tmpstring);
<     while (retval == 1 && !duplicated) {
<       tmparray = g_malloc(((estrl->num_columns ? estrl->num_columns : 1)+2)*sizeof(char *));
< 		for (i = 0; i < (estrl->num_columns ? estrl->num_columns  : 1); i++) {
< 			gtk_clist_get_text(GTK_CLIST(estrl->clist), row, i, &tmpstring);
< 			tmparray[i] = g_strdup(tmpstring);
< 		}
<       tmparray[i] = NULL;
< 
<       duplicated = 1;
< 		if (estrl->num_columns == 0) {
< 			if (strcmp((gchar *) tmparray[0], new_values[0]) != 0) {
< 				duplicated = 0;
< 			}
< 		} else {
< 			for (i = 0; i < estrl->num_columns; i++) {
< 				DEBUG_MSG("old_values[%d]='%s'\n", i, tmparray[i]);
< 				DEBUG_MSG("new_values[%d]='%s'\n", i, new_values[i]);
< 				if (strcmp(tmparray[i], new_values[i]) != 0) {
< 					duplicated = 0;
< 				}
< 			}
< 		}
<       row++;
<       retval = gtk_clist_get_text(GTK_CLIST(estrl->clist), row, 0, &tmpstring);
<     }
<     DEBUG_MSG("duplicated=%d\n", duplicated);
<     return duplicated;
< }
< 
< 
< static void estrl_destroy_lcb(GtkWidget * widget, GdkEvent *event, Testrl *estrl) {
< 	window_destroy(estrl->win);
< 	g_free(estrl);
< }
< 
< static void estrl_cancel_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
< 	estrl_destroy_lcb(NULL, NULL, estrl);
< }
< 
< /***************************************************************************
<  * ok button clicked
<  *
<  * Creates a new list with the elements of the dialog and replaces the old list
<  * with the new one
<  * At the end calls the post_func passed to the creator of the dialog and
<  * destroys the dialog
< */
< static void estrl_ok_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
< 
< 	guint i;
< 	gchar *tmpstring;
< 	gchar **tmparray;
< 	gint row=0, retval=1;
< 	GList *the_list=NULL, *orig_list;
< 
< 	retval = gtk_clist_get_text(GTK_CLIST(estrl->clist), row, 0, &tmpstring);
< 	while (retval == 1) {
< 		tmparray = g_malloc(((estrl->num_columns ? estrl->num_columns : 1)+2)*sizeof(char *));
< 		for (i = 0; i < (estrl->num_columns ? estrl->num_columns  : 1); i++) {
< 			gtk_clist_get_text(GTK_CLIST(estrl->clist), row, i, &tmpstring);
< 			tmparray[i] = g_strdup(tmpstring);
< 		}
< 		tmparray[i] = NULL;
< 		if (estrl->num_columns == 0) {
< 			the_list = g_list_append(the_list, tmparray[0]);
< 			g_free(tmparray);
< 		} else {
< 			the_list = g_list_append(the_list, tmparray);
< 		}
< 		row++;
< 		retval = gtk_clist_get_text(GTK_CLIST(estrl->clist), row, 0, &tmpstring);
< 	}
< 	DEBUG_MSG("estrl_ok_clicked_lcb, going to add %p to the list\n", the_list);
< 	orig_list = *estrl->the_list;
< 	*estrl->the_list = the_list;
< 
< 	if (estrl->num_columns) {
< 	        free_arraylist(orig_list);
< 	} else {
< 		free_stringlist(orig_list);
< 	}
< 
< 	if (estrl->function)
< 		estrl->function();
< 
< 	estrl_destroy_lcb(NULL, NULL, estrl);
< }
< 
< static void estrl_select_row_lcb(GtkWidget * widget, gint row, gint column, GdkEventButton * event, Testrl *estrl){
< 	gchar *text;
< 	guint i;
< 
< 	for (i = 0; i < ( estrl->num_columns ? estrl->num_columns : 1); i++) {
< 		gtk_clist_get_text(GTK_CLIST(estrl->clist), row, i, &text);
< 		gtk_entry_set_text(GTK_ENTRY(estrl->ins_upd_entry[i]), text);
< 	}
< 	estrl->last_row = row;
< }
< 
< static void estrl_unselect_row_lcb(GtkWidget * widget, gint row, gint column, GdkEventButton * event, Testrl *estrl) {
< 	estrl->last_row = -1;
< }
< 
< static void estrl_up_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
< 	if (estrl->last_row >= 1) {
< 		gtk_clist_swap_rows(GTK_CLIST(estrl->clist), estrl->last_row, estrl->last_row - 1);
< 		estrl->last_row--;
< 	}
< }
< 
< static void estrl_down_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
< 	if (estrl->last_row < GTK_CLIST(estrl->clist)->rows - 1) {
< 		gtk_clist_swap_rows(GTK_CLIST(estrl->clist), estrl->last_row, estrl->last_row + 1);
< 		estrl->last_row++;
< 	}
< }
< 
< /******************************************************************************
<  * Avoid adding an empty element to the stringlist
<  * Avoid adding a duplicated element to the stringlist
<  */
< static void estrl_add_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
<    gchar **tmplistentry;
< 	guint i, len;
< 
<     tmplistentry = g_malloc(((estrl->num_columns ? estrl->num_columns : 1)+2)*sizeof(char *));
<     for (len = i = 0; i < (estrl->num_columns ? estrl->num_columns  : 1); i++) {
< 		tmplistentry[i] = gtk_editable_get_chars(GTK_EDITABLE(estrl->ins_upd_entry[i]),0,-1);
< 		len += strlen(tmplistentry[i]);
< 		DEBUG_MSG("tmplistentry[%d]='%s'\n", i, tmplistentry[i]);
<     }
<     tmplistentry[i]=NULL;
<     if(len) {
< 		if(!is_duplicated(tmplistentry, estrl)) {
< 			gtk_clist_append(GTK_CLIST(estrl->clist), tmplistentry);
< 			/* does this introduce a memory leak?
< 			I'm not going to look at it since we need to get rid of the clist anyway 
< 			(gtk deprecated)
< 			*/
< 		} else {
< 			g_free(tmplistentry);
< 		}
< 	} else {
< 		g_free(tmplistentry);
< 	}
< }
< 
< static void estrl_update_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
< 	guint i;
< 
< 	for (i = 0; i < (estrl->num_columns ? estrl->num_columns  : 1); i++) {
< 		gtk_clist_set_text(GTK_CLIST(estrl->clist)
< 					   , estrl->last_row, i, gtk_entry_get_text(GTK_ENTRY(estrl->ins_upd_entry[i])));
< 	}
< }
< 
< static void estrl_delete_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
< 	gtk_clist_remove(GTK_CLIST(estrl->clist), estrl->last_row);
< }
< 
< static void estrl_sort_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
< 	gtk_clist_set_auto_sort(GTK_CLIST(estrl->clist), 1);
< }
< 
< /****************************************************************************
<  * Creates the dialog to edit a stringlist
<  *
<  * Parameters:
<  *  which_list      .- the stringlist which we want to edit
<  *  title           .- the title of the dialog
<  *  what_list       .- a bit more of information about the kind of strings
<  *  column_num      .- number of strings in each element of the stringlist
<  *                     equals to the number of columns in the dialog
<  *                     if column_num=0, it is assumed column_num=1
<  *  column_titles   .- title of the columns in the dialog
<  *  post_dialog_func.- function to call after editing to process the modified
<  *                     stringlist
< */
< 
< void estrl_dialog(GList **which_list, gchar *title, gint what_list
< 				, gint column_num, gchar **column_titles, void (*post_dialog_func)()) {
< 	Testrl *estrl;
< 	GList *tmplist;
< 	GtkWidget *but_var=NULL, *hbox, *scrolwin, *vbox2, *vbox;
< 	GtkWidget *table2, *but;
< 	gint i;
< 	gchar *tmplistentry[1];
< 
< 
< 	estrl = g_malloc(sizeof(Testrl));
<         if( column_num > MAX_ARRAY_LENGTH )
<               column_num = MAX_ARRAY_LENGTH;
< 	estrl->num_columns = column_num;
< 	estrl->the_list = which_list;
< 	estrl->function = post_dialog_func;
< 	estrl->win = window_full(title, GTK_WIN_POS_MOUSE, 5, G_CALLBACK(estrl_destroy_lcb), estrl, TRUE);
< 
< 	vbox = gtk_vbox_new(FALSE, 1);
< 	gtk_container_add(GTK_CONTAINER(estrl->win), vbox);
< 	gtk_widget_realize(estrl->win);
< 
< 	table2 = gtk_table_new(column_num ? column_num : 1, 3, 0);
< 	for (i = 0; i < (column_num ? column_num : 1); i++) {
< 		estrl->ins_upd_entry[i] = gtk_entry_new_with_max_length(950/(column_num ? column_num : 1));
< 		if (column_titles) {
< 			gtk_table_attach_defaults(GTK_TABLE(table2), gtk_label_new(column_titles[i]), 0, 1, i, i+1);
< 		}
< 		gtk_table_attach_defaults(GTK_TABLE(table2), estrl->ins_upd_entry[i], 1, 2, i, i+1);
< 	}
< 	gtk_box_pack_start(GTK_BOX(vbox), table2, FALSE, FALSE, 0);
< 
< 	switch (what_list) {
< 	case 1:
< 		/* files */
< 		but_var = file_but_new(estrl->ins_upd_entry[0], estrl->win, 1);
< 		break;
< 	case 2:
< 		/* color */
< #ifdef NOTYET
< 		but_var = color_but_new(estrl->ins_upd_entry[0], estrl->win);
< #endif
< 		break;
< 	case 4:
< 		/* url */
< 		but_var = file_but_new(estrl->ins_upd_entry[0], estrl->win, 0);
< 		break;
< 	case 7:
< 		/* external filters and commands */
< 
< 		break;
< 	case 8:
< 		/* syntax highlighting patterns */
< #ifdef NOTYET
< 		but_var = color_but_new(estrl->ins_upd_entry[0], estrl->win);
< #endif
< 		break;
< 
< #ifdef PARSEDTD
< 	case 9:
<                 /* doctypes */
< 		but_var = file_but_new(estrl->ins_upd_entry[1], estrl->win, 0);
< 		break;
< #endif
< 
< 	default:
< 		/* targets(5), fonts(3) meta_cb (6) */
< 		break;
< 	}
< 	if (but_var) {
< 		gtk_table_attach_defaults(GTK_TABLE(table2), but_var, 2, 3, 0, 1);
< 		GTK_WIDGET_SET_FLAGS(but_var, GTK_CAN_DEFAULT);
< 	}
< 
< 	hbox = gtk_hbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(vbox), hbox, TRUE, TRUE, 0);
< 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
< 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
< 	gtk_box_pack_start(GTK_BOX(hbox), scrolwin, TRUE, TRUE, 0);
< 	vbox2 = gtk_vbox_new(FALSE, 0);
< 	gtk_box_pack_start(GTK_BOX(hbox), vbox2, FALSE, FALSE, 0);
< 
< 	if (column_num == 0) {
< 		estrl->clist = gtk_clist_new(1);
< 	} else {
< 		if (column_titles != NULL) {
< 			estrl->clist = gtk_clist_new_with_titles(column_num, column_titles);
< 		} else {
< 			estrl->clist = gtk_clist_new(column_num);
< 		}
< 	}
< 
< 	gtk_signal_connect(GTK_OBJECT(estrl->clist), "select_row", GTK_SIGNAL_FUNC(estrl_select_row_lcb), estrl);
< 	gtk_signal_connect(GTK_OBJECT(estrl->clist), "unselect_row", GTK_SIGNAL_FUNC(estrl_unselect_row_lcb), estrl);
< 	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolwin), estrl->clist);
< 	gtk_clist_set_reorderable(GTK_CLIST(estrl->clist), TRUE);
< 	gtk_clist_freeze(GTK_CLIST(estrl->clist));
< 
< 	tmplist = g_list_first(*which_list);
< 	if (column_num == 0) {
< 		while (tmplist != NULL) {
< 			tmplistentry[0] = (gchar *) tmplist->data;
< 			gtk_clist_append(GTK_CLIST(estrl->clist), tmplistentry);
< 			tmplist = g_list_next(tmplist);
< 		}
< 	} else {
< 		while (tmplist != NULL) {
< 			gtk_clist_append(GTK_CLIST(estrl->clist), (gchar **) tmplist->data);
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	gtk_clist_thaw(GTK_CLIST(estrl->clist));
< 
< 	but = bf_generic_mnemonic_button(_(" Add "), G_CALLBACK(estrl_add_clicked_lcb), estrl);
< 	gtk_box_pack_start(GTK_BOX(vbox2),but , TRUE, TRUE, 0);
< 	but = bf_generic_mnemonic_button(_(" Update "), G_CALLBACK(estrl_update_clicked_lcb), estrl);
< 	gtk_box_pack_start(GTK_BOX(vbox2),but , TRUE, TRUE, 0);
< 	but = bf_generic_mnemonic_button(_(" Delete "), G_CALLBACK(estrl_delete_clicked_lcb), estrl);
< 	gtk_box_pack_start(GTK_BOX(vbox2),but , TRUE, TRUE, 0);
< 	but = bf_generic_mnemonic_button(_(" Up "), G_CALLBACK(estrl_up_clicked_lcb), estrl);
< 	gtk_box_pack_start(GTK_BOX(vbox2),but , TRUE, TRUE, 0);
< 	but = bf_generic_mnemonic_button(_(" Down "), G_CALLBACK(estrl_down_clicked_lcb), estrl);
< 	gtk_box_pack_start(GTK_BOX(vbox2),but , TRUE, TRUE, 0);
< 	but = bf_generic_mnemonic_button(_(" Sort "), G_CALLBACK(estrl_sort_clicked_lcb), estrl);
< 	gtk_box_pack_start(GTK_BOX(vbox2),but , TRUE, TRUE, 0);
< 
< 	hbox = gtk_hbutton_box_new();
< 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
< 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 1);
< 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
< 
< 	but = bf_stock_ok_button(G_CALLBACK(estrl_ok_clicked_lcb), estrl);
< 	gtk_box_pack_start(GTK_BOX(hbox), but, TRUE, TRUE, 0);
< 	gtk_window_set_default(GTK_WINDOW(estrl->win), but);
< 
< 	but = bf_stock_cancel_button(G_CALLBACK(estrl_cancel_clicked_lcb), estrl);
< 	gtk_box_pack_start(GTK_BOX(hbox), but, TRUE, TRUE, 0);
< 
< 	/* Adjust the size and position of the dialog */
< 	{
< 	  int wx=100, optx;
< 	  optx = gtk_clist_optimal_column_width(GTK_CLIST(estrl->clist),0);
< 	  if( optx < 100 )
< 	    optx = 100;
< 	  wx += optx + gtk_clist_optimal_column_width(GTK_CLIST(estrl->clist), 1);
< 	  if( wx < gdk_screen_width() ) {
< 	    gtk_clist_set_column_width(GTK_CLIST(estrl->clist), 0, optx );
< 	    gtk_widget_set_size_request(GTK_WIDGET(estrl->win), wx, 400);
< 	    gtk_widget_set_uposition(estrl->win, 
< 				     (gdk_screen_width()-wx)/2,
< 				     (gdk_screen_height() - 400)/2);
< 	  }
< 	}
< 	gtk_widget_show_all(estrl->win);
< }
< #endif /* USE_ESTRL_DIALOG */
< 
< 
< /************************************************************************/
< 
< #ifdef DEBUG
< void debug_array(gchar **array) {
< 	gint count=0;
< 	gchar **tmpchar=array;
< 	
< 	if (!tmpchar) {
< 		DEBUG_MSG("debug_array, no array!?!?\n");
< 	}
< 
< 	while (*tmpchar != NULL) {
< 		count++;
< 		DEBUG_MSG("debug_array, tmpchar(%p), count=%d, contains(%p) %s\n", tmpchar, count, *tmpchar, *tmpchar);
< 		tmpchar++;
< 	}
< }
< #endif
< 
< /**
<  * count_array:
<  * @array: #gchar** with the NULL terminated array to count
<  *
<  * counts the number of entries in a NULL terminated array
<  *
<  * Return value: #gint with number of entries
<  */
< gint count_array(gchar **array) {
< 	gint count=0;
< 	gchar **tmpchar=array;
< 	
< 	if (!tmpchar) {
< 		DEBUG_MSG("count_array, no array!?!?\n");
< 		return 0;
< 	}
< 
< 	while (*tmpchar != NULL) {
< 		count++;
< 		tmpchar++;
< 	}
< 	return count;
< }
< 
< /**
<  * array_to_string:
<  * @array: #gchar** with NULL terminated array
<  * @delimiter: #gchar with the delimiter character
<  *
<  * Converts a NULL terminated array to a string with a delimiter
<  * between the entries, and some characters backslash escaped
<  * like \t, \n, \\ and the delimiter. In Bluefish the : is the most 
<  * used delimiter
<  *
<  * Return value: #gchar* newly allocated string
<  */
< gchar *array_to_string(gchar **array) {
< 	if (array) {
< 		gchar **tmp, *escaped1, *finalstring;
< 		gint newsize=1;
< 		DEBUG_MSG("array_to_string, started\n");
< 		finalstring = g_malloc0(newsize);
< 		tmp = array;
< 		while(*tmp) {
< 			DEBUG_MSG("array_to_string, *tmp = %s\n", *tmp);
< 			escaped1 = escape_string(*tmp, TRUE);
< 			newsize += strlen(escaped1)+1;
< 			finalstring = g_realloc(finalstring, newsize);
< 			strcat(finalstring, escaped1);
< 			finalstring[newsize-2] = ':';
< 			finalstring[newsize-1] = '\0';
< 			g_free(escaped1);
< 			tmp++;
< 		}	
< 		DEBUG_MSG("array_to_string, finalstring = %s\n", finalstring);
< 		return finalstring;
< 	} else {
< #ifdef DEBUG
< 		g_print("array_to_string, array=NULL !!!\n");
< 		exit(135);
< #else
< 		return g_strdup("");
< #endif
< 	}
< }
< 
< #define ARRAYBLOCKSIZE 6
< #define BUFBLOCKSIZE 60
< /**
<  * string_to_array:
<  * @string: #gchar* with the string to convert
<  * @delimiter: #gchar with the delimiter character
<  *
<  * breaks the string apart into a NULL terminated array
<  * using the delimiter character. \t, \\ and \n are also unescaped
<  * to their original characters
<  *
<  * Return value: #gchar** newly allocated NULL terminated array
<  */
< gchar **string_to_array(gchar *string) {
< 	gchar **array;
< 	gchar *tmpchar, *tmpchar2;
< 	gchar *newstring;
< 	gint count=0;
< 	gint newstringsize;
< 	gint arraycount=0, arraysize;
< 
< 	newstringsize = BUFBLOCKSIZE;
< 	newstring = g_malloc(newstringsize * sizeof(char));
< 	
< 	arraysize = ARRAYBLOCKSIZE;
< 	array = g_malloc(arraysize * sizeof(char *));
< 	DEBUG_MSG("string_to_array, started, array=%p\n", array);	
< 	
< 	tmpchar = string;
< 	while (*tmpchar != '\0') {
< 		DEBUG_MSG("string_to_array, count=%d, newstring(%p)\n", count, newstring);
< 		if (*tmpchar == '\\') {
< 			tmpchar2 = tmpchar+1;
< 			switch (*tmpchar2) {
< 			case '\0':
< 				newstring[count] = '\\';
< 			break;
< 			case '\\':
< 				newstring[count] = '\\';
< 				tmpchar++;
< 			break;
< 			case 'n':
< 				newstring[count] = '\n';
< 				tmpchar++;
< 			break;
< 			case 't':
< 				newstring[count] = '\t';
< 				tmpchar++;
< 			break;
< 			case ':':
< 				newstring[count] = ':';
< 				tmpchar++;
< 			break;
< 			default:
< 				DEBUG_MSG("string_to_array, weird, an unescaped backslash ?\n");
< 				newstring[count] = '\\';
< 			break;
< 			}
< 		} else if (*tmpchar == ':') {
< 			newstring[count] = '\0';  /* end of the current newstring */
< 			DEBUG_MSG("string_to_array, newstring(%p)=%s\n", newstring, newstring);
< 			array[arraycount] = g_strdup(newstring);
< 			DEBUG_MSG("string_to_array, found delimiter, arraycount=%d, result(%p)=%s\n",arraycount, array[arraycount], array[arraycount]);
< 			arraycount++;
< 			if (arraycount == arraysize-2) { /* we need 1 spare entry in the array */
< 				arraysize += ARRAYBLOCKSIZE;  /* and arraysize starts at 1, arraycount at 0 */
< 				DEBUG_MSG("string_to_array, arraycount=%d, about to increase arraysize to %d, sizeof(array(%p))=%d\n", arraycount, arraysize, array, sizeof(&array));
< 				array = g_realloc(array, arraysize * sizeof(char *));
< 				DEBUG_MSG("string_to_array, arraysize=%d, array(%p), sizeof(array)=%d\n", arraysize, array, sizeof(&array));
< 			}
< 			count = -1;
< 		} else {
< 			newstring[count] = *tmpchar;
< 		}
< 		tmpchar++;
< 		count++;
< 		if (count == newstringsize-2) {
< 			newstringsize += BUFBLOCKSIZE;
< 			DEBUG_MSG("string_to_array, about to increase newstring(%p) to %d bytes\n", newstring, newstringsize);
< 			newstring = g_realloc(newstring, newstringsize * sizeof(char));
< 			DEBUG_MSG("string_to_array, newstringsize=%d, sizeof(newstring(%p))=%d\n", newstringsize, newstring, sizeof(newstring));
< 		}
< 	}
< 	
< 	if (count > 0) {
< 		newstring[count] = '\0';
< 		array[arraycount] = g_strdup(newstring);
< 		DEBUG_MSG("string_to_array, last array entry, arraycount=%d, result(%p)=%s\n",arraycount, array[arraycount],array[arraycount]);
< 	} else {
< 		array[arraycount] = NULL;
< 	}
< 	array[arraycount+1] = NULL; /* since we have 1 spare entry in the array this is safe to do*/
< 	DEBUG_MSG("string_to_array, returning %p\n", array);
< 	g_free(newstring);
< 	return array;
< }		
< 
< /**
<  * array_from_arglist:
<  * @...: #gchar* with the first string, NULL terminated
<  *
<  * builds a NULL terminated array from the argumentlist to this function
<  *
<  * Return value: #gchar** with the array
<  */
< gchar **array_from_arglist(const gchar *string1, ...) {
< 	gint numargs=1;
< 	va_list args;
< 	gchar *s;
< 	gchar **retval, **index;
< 
< 	va_start (args, string1);
< 	s = va_arg (args, gchar*);
< 	while (s) {
< 		numargs++;
< 		s = va_arg (args, gchar*);
< 	}
< 	va_end (args);
< 	DEBUG_MSG("array_from_arglist, numargs=%d\n", numargs);
< 
< 	index = retval = g_new(gchar *, numargs + 1);
< 	*index = g_strdup(string1);
< 
< 	va_start (args, string1);
< 	s = va_arg (args, gchar*);
< 	while (s) {
< 		index++;
< 		*index = g_strdup(s);
< 		s = va_arg (args, gchar*);
< 	}
< 	va_end (args);
< 	index++;
< 	*index = NULL;
< 	return retval;
< }
< /**
<  * array_from_arglist:
<  * @allocate_strings: #gboolean if the strings should be newly allocated
<  * @...: #gchar* with the first string, NULL terminated
<  *
<  * builds a GList with strings (a stringlist), copied by reference or by content
<  *
<  * Return value: GList *
<  */
< GList *list_from_arglist(gboolean allocate_strings, ...) {
< 	GList *retval=NULL;
< 	va_list args;
< 	gchar *s;
< 	va_start(args, allocate_strings);
< 	s = va_arg(args, gchar*);
< 	while (s) {
< 		retval = g_list_append(retval, s);
< 		s = va_arg (args, gchar*);
< 	}
< 	va_end (args);
< 	return retval;
< }
< 
< GList *duplicate_stringlist(GList *list, gint dup_data) {
< 	GList *retlist=NULL;
< 	if (list) {
< 		GList *tmplist;
< 		tmplist = g_list_first(list);
< 		while (tmplist) {
< 			if (tmplist->data) {
< 				gchar *data;
< 				if (dup_data) {
< 					data = g_strdup((gchar *)tmplist->data);
< 				} else {
< 					data = (gchar *)tmplist->data;
< 				}
< 				retlist = g_list_append(retlist, data);
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	return retlist;
< }
< 
< gint free_stringlist(GList * which_list)
< {
< 	GList *tmplist;
< 
< 	DEBUG_MSG("free_stringlist, started\n");
< 
< 	tmplist = g_list_first(which_list);
< 	while (tmplist != NULL) {
< 		DEBUG_MSG("free_stringlist, tmplist->data(%p)\n", tmplist->data);
< 		g_free(tmplist->data);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	DEBUG_MSG("free_stringlist, strings free-ed, about to free list itself\n");
< 	g_list_free(which_list);
< 	which_list = NULL;
< 	return 1;
< }
< 
< gint free_arraylist(GList * which_list)
< {
< 	GList *tmplist;
< #ifdef DEBUGGING
< 	gchar **tmpchar;
< #endif
< 	DEBUG_MSG("free_arraylist, started\n");
< 
< 	tmplist = g_list_first(which_list);
< 	while (tmplist != NULL) {
< 
< #ifdef DEBUGGING
< 		DEBUG_MSG("free_arraylist, starting list %p with data %p\n", tmplist, tmplist->data);
< 		tmpchar = (gchar **)tmplist->data;
< 		while (*tmpchar) {
< 			DEBUG_MSG("free_arraylist, freeing %p\n", *tmpchar);
< 			DEBUG_MSG("free_arraylist, containing %s\n", *tmpchar);
< 			g_free(*tmpchar);
< 			tmpchar++;
< 		}
< 		DEBUG_MSG("free_arraylist, content freed\n");
< 		g_free((gchar **)tmplist->data);
< 		DEBUG_MSG("free_arraylist, array freed\n");
< #else
< 		g_strfreev((gchar **)tmplist->data);
< #endif
< 		tmplist = g_list_next(tmplist);
< 	}
< 	g_list_free(which_list);
< 	which_list = NULL;
< 	return 1;
< }
< 
< gchar **duplicate_stringarray(gchar **array) {
< 	gchar **newchar;
< 	gint i;
< 
< 	newchar = g_malloc0((count_array(array)+1)*sizeof(gchar *));
< 	for (i=0; array[i] != NULL ; i++) {
< 		newchar[i] = g_strdup(array[i]);
< 	}
< 	return newchar;
< }
< 
< GList *duplicate_arraylist(GList *arraylist) {
< 	GList *tmplist;
< 	GList *newlist=NULL;
< 
< 	tmplist = g_list_first(arraylist);
< 	while (tmplist != NULL) {
< 		newlist = g_list_append(newlist, duplicate_stringarray((gchar **)tmplist->data));
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return newlist;
< }
< 
< 
< /*****************************************************************************
<  * gets a stringlist from a file
<  */
< GList *get_list(const gchar * filename, GList * which_list, gboolean is_arraylist) {
< 	DEBUG_MSG("get_stringlist, started with filename=%s\n", filename);
< 	if (filename == NULL) {
< 		return NULL;
< 	}
< 
< #ifdef WIN32
< 	if (filename[0] == '/') { filename++;}
< #endif /* WIN32 */
< 	
< 	if (file_exists_and_readable(filename)) {
< 		FILE *fd;
< 		gchar *tmpbuf;
< 		DEBUG_MSG("get_stringlist, opening %s\n", filename);
< 		fd = fopen(filename, "r");
< 		if (fd == NULL) {
< 			return NULL;
< 		}
< 		tmpbuf = g_malloc(STRING_MAX_SIZE);
< 		while (fgets(tmpbuf, STRING_MAX_SIZE, fd) != NULL) {
< 			gchar *tempstr= NULL;
< 			tmpbuf = trunc_on_char(tmpbuf, '\n');
< #ifdef WIN32	
< 			if (tmpbuf[0] == '/'){
< 				tempstr = g_strdup(tempstr+1);
< 			DEBUG_MSG("Adjusted tempstr\n");
< 			}else{
< 			tempstr = g_strdup(tmpbuf);
< 		}
< #else  
< 		tempstr = g_strdup(tmpbuf);
< #endif /* WIN32 */
< 			if (is_arraylist) {
< 				gchar **temparr = string_to_array(tempstr);
< 				which_list = g_list_append(which_list, temparr);
< 				g_free(tempstr);
< 			} else {
< 				DEBUG_MSG("get_list, adding string \"%s\" to the stringlist=%p\n", tempstr, which_list);
< 				which_list = g_list_append(which_list, tempstr);
< 			}
< 		}
< 		fclose(fd);
< 		g_free(tmpbuf);
< 	}
< 	return which_list;
< }
< #ifdef __GNUC__
< __inline__ 
< #endif
< GList *get_stringlist(const gchar * filename, GList * which_list) {
< 	return get_list(filename,which_list,FALSE);
< }
< 
< /**
<  * put_stringlist_limited:
<  * @filename: #gchar* with the filename to store the list
<  * @which_list: #GList* with the list to store
<  * @maxentries: #gint only the LAST maxentries of the list will be stored
<  *
<  * stores the LAST maxentries entries of list which_list in file filename
<  * if maxentries is 0 all entries will be stored
<  *
<  * Return value: #gboolean TRUE on success, FALSE on failure
<  */
< gboolean put_stringlist_limited(gchar * filename, GList * which_list, gint maxentries) {
< 	FILE *fd;
< 	GList *tmplist;
< 
< 	DEBUG_MSG("put_stringlist_limited, started with filename=%s\n", filename);
< 	{
< 		gchar *backupfilename = g_strconcat(filename, main_v->props.backup_filestring,NULL);
< 		file_copy(filename, backupfilename);
< 		g_free(backupfilename);
< 	}
< 
< 	DEBUG_MSG("put_stringlist_limited, opening %s for saving list(%p)\n", filename, which_list);
< 	fd = fopen(filename, "w");
< 	if (fd == NULL) {
< 		return FALSE;
< 	}
< 	if (maxentries > 0) {
< 		gint count;
< 		count = g_list_length(which_list) - maxentries;
< 		tmplist = g_list_nth(which_list, (count<0) ? 0 : count);
< 	} else {
< 		tmplist = g_list_first(which_list);
< 	}
< 	while (tmplist) {
< 		gchar *tmpstr = g_strndup((char *) tmplist->data, STRING_MAX_SIZE - 1);
< 		DEBUG_MSG("put_stringlist_limited, tmplist(%p), adding string(%p)=%s (strlen=%d)the file\n", tmplist, tmpstr, tmpstr, strlen(tmpstr));
< #ifdef WIN32
< 		if (tmpstr[0] == '/') {tmpstr++;}
< 		fputs(tmpstr, fd);
< 		tmpstr--;
< #else
< 		fputs(tmpstr,fd);
< #endif /* WIN32 */
< 		g_free(tmpstr);
< 		fputs("\n", fd);
< 		tmplist = g_list_next(tmplist);
< 	}
< 	fclose(fd);
< 	DEBUG_MSG("put_stringlist_limited, finished, filedescriptor closed\n");
< 	return TRUE;
< }
< 
< gboolean put_stringlist(gchar * filename, GList * which_list) {
< 	return put_stringlist_limited(filename,which_list, -1);
< }
< 
< GList *remove_from_stringlist(GList *which_list, const gchar * string) {
< 	if (string && strlen(string) ) {
< 		GList *tmplist = g_list_first(which_list);
< 		while (tmplist) {
< 			if (strcmp((gchar *) tmplist->data, string) == 0) {
< 				DEBUG_MSG("remove_from_stringlist, removing '%s' (%p)\n", (gchar *)tmplist->data, tmplist->data);
< 				g_free(tmplist->data);
< 				return g_list_remove(which_list, tmplist->data);
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 	}
< 	return which_list;
< }
< 
< static void unlink_before(GList *tmplist) {
< 	GList *prev = tmplist->prev;
< 	if (prev) {
< 		prev->next = NULL;
< 	}
< 	tmplist->prev = NULL;
< }
< 
< GList *limit_stringlist(GList *which_list, gint num_entries, gboolean keep_end) {
< 	GList *retlist, *freelist;
< 	if (keep_end) {
< 		gint len;
< 		freelist = g_list_first(which_list);
< 		len = g_list_length(freelist);
< 		if (len <= num_entries) return which_list;
< 		retlist = g_list_nth(freelist, len - num_entries);
< 		unlink_before(retlist);
< 	} else {
< 		retlist = g_list_first(which_list);
< 		freelist = g_list_nth(retlist, num_entries);
< 		if (freelist) unlink_before(freelist);
< 	}
< 	if (freelist) free_stringlist(freelist);
< 	return retlist;
< }
< 
< /**
<  * add_to_history_stringlist:
<  * @which_list: #GList* the list to add to
<  * @string: #const gchar* with the string to add
<  * @recent_on_top: #gboolean, TRUE if the most recent entry is the one on top
<  * @move_if_exists: #gboolean, if TRUE do move existing entries to the most recent part
<  *
<  * adds string to the stringlist which_list
<  *
<  * if string exists in this list already and move_if_exists is TRUE, 
<  * it will be moved to the most recent part of the list (which is the 
<  * end or the beginning based on the value of recent_on_top
<  *
<  * Return value: GList* with the modified list
<  */
< GList *add_to_history_stringlist(GList *which_list, const gchar *string, gboolean recent_on_top, gboolean move_if_exists) {
< 	if (string && strlen(string) ) {
< 		GList *tmplist = g_list_first(which_list);
< 		while (tmplist) {
< 			if (strcmp((gchar *) tmplist->data, string) == 0) {
< 				/* move this entry to the end */
< 				if (move_if_exists) {
< 					DEBUG_MSG("add_to_history_stringlist, entry %s exists, moving!\n", string);
< 					which_list = g_list_remove_link(which_list, tmplist);
< 					if (recent_on_top) {
< 						return g_list_concat(tmplist, which_list);
< 					} else {
< 						return g_list_concat(which_list, tmplist);
< 					}
< 				} else {
< 					return which_list;
< 				}
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		/* if we arrive here the string was not yet in the list */
< 		DEBUG_MSG("add_to_history_stringlist, adding new entry %s\n",string);
< 		if (recent_on_top) {
< 			which_list = g_list_prepend(which_list, g_strdup(string));
< 		} else {
< 			which_list = g_list_append(which_list, g_strdup(string));
< 		}
< 	}
< 	return which_list;
< }
< 
< /**
<  * add_to_stringlist:
<  * @which_list: a #GList * to add to
<  * @string: a #const gchar * item you want to add to the list
<  * 
<  * this function will check if a string with same content exists already
<  * and if not it will add it to the list, it returns the new list pointer
<  * 
<  * Return value: the new GList *
<  **/
< GList *add_to_stringlist(GList * which_list, const gchar * string) {
< 	if (string && strlen(string) ) {
< 		GList *tmplist = g_list_first(which_list);
< 		while (tmplist) {
< 			if (strcmp((gchar *) tmplist->data, string) == 0) {
< 				DEBUG_MSG("add_to_stringlist, strings are the same, don't add!!\n");
< 				return which_list;
< 			}
< 			tmplist = g_list_next(tmplist);
< 		}
< 		/* if we arrive here the string was not yet in the list */
< 		which_list = g_list_append(which_list, g_strdup(string));
< 	}
< 	return which_list;
< }
< /**
<  * stringlist_to_string:
<  * @stringlist: a #GList * to convert
<  * @delimiter: a #const gchar * item with the delimiter
<  * 
<  * this function will convert a stringlist (GList that contains 
<  * only \0 terminated gchar* elements) to a string, putting the 
<  * delimiter inbetween all elements;
<  * 
<  * Return value: the gchar *
<  **/
< gchar *stringlist_to_string(GList *stringlist, gchar *delimiter) {
< 	gchar *string, *tmp;
< 	GList *tmplist;
< 	string = g_strdup("");
< 	tmp = string;
< 	tmplist = g_list_first(stringlist);
< 	while (tmplist) {
< 		string = g_strconcat(tmp, (gchar *) tmplist->data, delimiter, NULL);
< 		g_free(tmp);
< 		tmp = string;
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return string;
< }
< /**
<  * array_n_strings_identical:
<  * @array1: #gchar**
<  * @array2: #gchar**
<  * @case_sensitive: #gboolean 
<  * @testlevel: #gint
<  *
<  * tests the first testlevel strings in the arrays if they are identical
<  * returns the first strcmp() value that is not 0, or 0 if all
<  * strings up to testlevel are identical.
<  *
<  * if BOTH array end before testlevel is reached, 0 is returned
<  * if ONE array ends before the other, -1 or 1 is returned
<  *
<  * Return value: #gint
<  */
< gint array_n_strings_identical(gchar **array1, gchar **array2, gboolean case_sensitive, gint testlevel) {
< 	gint i=0, res=0;
< 	while (i<testlevel && res==0) {
< 		/*  array1[i]==array2[i] will only happen when they are both NULL	*/
< 		if (array1[i] == NULL || array2[i] == NULL) {
< 			/* NULL - NULL = 0
< 			 * NULL - ptr = negative
< 			 * ptr - NULL = positive */
< 			return (gint)(array1[i] - array2[i]);
< 		} else if (case_sensitive) {
< 			res = strcmp(array1[i],array2[i]);
< 		} else /*if (!case_sensitive)*/ {
< 			res = strcasecmp(array1[i],array2[i]);
< 		}
< 		if (res !=0) return res;
< 		i++;
< 	}
< 	return res;
< }
< /**
<  * arraylist_delete_identical:
<  * @thelist: #GList*
<  * @compare: #gchar**
<  * @testlevel: #gint
<  * @case_sensitive: #gboolean
<  *
<  * Deletes all arrays from 'arraylist' that are, up to testlevel, identical to array 'compare'
<  *
<  * Return value: the new list
<  */
< GList *arraylist_delete_identical(GList *thelist, gchar **compare, gint testlevel, gboolean case_sensitive) {
< 	GList *tmplist = g_list_first(thelist);
< 	while (tmplist) {
< 		GList *nextlist = g_list_next(tmplist);
< 		gchar **tmparr = tmplist->data;
< 		if (array_n_strings_identical(compare, tmparr, case_sensitive, testlevel)==0) {
< 			DEBUG_MSG("arraylist_delete_identical, %s and %s are identical, will delete %p from list\n",tmparr[0],compare[0], tmplist);
< 			thelist = g_list_delete_link(thelist, tmplist);
< 			DEBUG_MSG("arraylist_delete_identical, free array %p (%s)\n",tmparr,tmparr[0]);
< 			g_strfreev(tmparr);
< 		}
< 		tmplist = nextlist;
< 	}
< 	return thelist;
< }
< 
< /**
<  * arraylist_append_identical_from_list:
<  * @thelist: #GList*
<  * @source: #GList*
<  * @compare: #gchar**
<  * @testlevel: #gint
<  * @case_sensitive: #gboolean
<  *
<  * compares every array in 'source' with 'compare', and if it is identical up to 'testlevel', it will
<  * add the array to 'thelist'
<  *
<  * Return value: the new arraylist
<  */
< GList *arraylist_append_identical_from_list(GList *thelist, GList *source, gchar **compare, gint testlevel, gboolean case_sensitive) {
< 	GList *tmplist = g_list_first(source);
< 	while (tmplist) {
< 		gchar **tmparr = tmplist->data;
< 		if (array_n_strings_identical(compare, tmparr, case_sensitive, testlevel)==0) {
< 			thelist = g_list_append(thelist, duplicate_stringarray(tmparr));
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return thelist;
< }
< 
< /**
<  * arraylist_append_identical_from_file:
<  * @thelist: #GList*
<  * @sourcefilename: #const gchar*
<  * @compare: #gchar**
<  * @testlevel: #gint
<  * @case_sensitive: #gboolean
<  *
<  * compares every array read from 'sourcefilename' with 'compare', and if it is identical up to 'testlevel', it will
<  * add the array to 'thelist'
<  *
<  * Return value: the new arraylist
<  */
< GList *arraylist_append_identical_from_file(GList *thelist, const gchar *sourcefilename, gchar **compare, gint testlevel, gboolean case_sensitive) {
< 	GList *sourcelist = get_list(sourcefilename,NULL,TRUE);
< 	DEBUG_MSG("arraylist_append_identical_from_file: back from get_list\n");
< 	thelist = arraylist_append_identical_from_list(thelist, sourcelist, compare, testlevel, case_sensitive);
< 	free_arraylist(sourcelist);
< 	return thelist;
< }
< 
< /**
<  * arraylist_value_exists:
<  * @arraylist: #GList*
<  * @value: #gchar**
<  * @testlevel: #gint
<  * @case_sensitive: #gboolean whether the test should be case sensitive
<  *
<  * tests for the occurence of an array with identical content as value
<  * in arraylist. It will only test the first testlevel strings in the array
<  * so if you want the test to check for a 100% identical array that number 
<  * should be high (9999 or so)
<  *
<  * Return value: #gboolean 
<  */
< gboolean arraylist_value_exists(GList *arraylist, gchar **value, gint testlevel, gboolean case_sensitive) {
< 	GList *tmplist = g_list_first(arraylist);
< 	while (tmplist) {
< 		gchar **tmparr = tmplist->data;
< 		if (array_n_strings_identical(value, tmparr, case_sensitive, testlevel)==0) {
< 			return TRUE;
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return FALSE;
< }
< /**
<  * arraylist_load_new_identifiers_from_list:
<  * @mylist: #GList*
<  * @fromlist: #GList*
<  * @uniquelevel: #gint
<  *
<  * compares every entry in fromlist 
<  * with all entries in list mylist. Comparision is done uniquelevel deep
<  * by function arraylist_value_exists()
<  * those arrays that do _not_ match are appended to mylist which is returned
<  * at the end of the function
<  *
<  * Return value: #GList*
<  */
< GList *arraylist_load_new_identifiers_from_list(GList *mylist, GList *deflist, gint uniquelevel) {
< 	GList *tmplist = g_list_first(deflist);
< 	while (tmplist) {
< 		gchar **tmparr = tmplist->data;
< 		if (count_array(tmparr) >= uniquelevel) {
< 			if (!arraylist_value_exists(mylist, tmparr, uniquelevel, TRUE)) {
< 				DEBUG_MSG("arraylist_load_new_identifiers, adding %s to thelist\n",tmparr[0]);
< 				mylist = g_list_append(mylist, duplicate_stringarray(tmparr));
< 			}
< 		}
< 		tmplist = g_list_next(tmplist);
< 	}
< 	return mylist;
< }
< /**
<  * arraylist_load_new_identifiers_from_file:
<  * @mylist: #GList*
<  * @fromfilename: #gchar*
<  * @uniquelevel: #gint
<  *
<  * loads an arraylist from fromfilename and compares every entry 
<  * with all entries in list mylist. Comparision is done uniquelevel deep
<  * by function arraylist_value_exists()
<  * those arrays that do _not_ match are appended to mylist which is returned
<  * at the end of the function
<  *
<  * Return value: #GList*
<  */
< GList *arraylist_load_new_identifiers_from_file(GList *mylist, const gchar *fromfilename, gint uniquelevel) {
< 	GList *deflist = get_list(fromfilename,NULL,TRUE);
< 	DEBUG_MSG("arraylist_load_new_identifiers_from_file: back from get_list\n");
< 	mylist = arraylist_load_new_identifiers_from_list(mylist, deflist, uniquelevel);
< 	free_arraylist(deflist);
< 	return mylist;	
< }
---
> /* Bluefish HTML Editor
>  * stringlist.c - functions that deal with stringlists
>  *
>  * Copyright (C) 1999-2002 Olivier Sessink
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License as published by
>  * the Free Software Foundation; either version 2 of the License, or
>  * (at your option) any later version.
>  * 
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  * 
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
>  */
> 
> /*#define DEBUG*/
> 
> /*
>  * This module deals with the GUI dialog used in bluefish to manage
>  * GLists in which each element is composed of several strings,
>  * like the lists of syntax highlighting, external filters, external commands,
>  * and lately doctypes. For example, the list of doctypes contains a string
>  * for the DOCTYPE and a string for the FILENAME of that doctype.
>  *
>  * When the stringlist is edited, the old one is deleted and a new one is created,
>  * so the order can be different from the original.
>  */
> 
> #include <gtk/gtk.h>
> #include <stdio.h>
> #include <string.h>  	/* strspn() */
> #include <strings.h>  	/* strcasecmp() */
> #include "bluefish.h"
> #include "bf_lib.h"
> 
> /*#include "coloursel.h"  color_but_new() */
> #include "stringlist.h"
> #include "gtk_easy.h"
> 
> #define STRING_MAX_SIZE 4096
> #define MAX_ARRAY_LENGTH 20
> 
> 
> /************************************************************************/
> 
> 
> /************************************************************************/
> #ifdef USE_ESTRL_DIALOG
> typedef struct {
> 	GtkWidget *win;
> 	GtkWidget *ins_upd_entry[MAX_ARRAY_LENGTH];
> 	GtkWidget *clist;
> 	gint num_columns;
> 	gint last_row;
> 	GList **the_list;
> 	void (*function)();
> } Testrl;
> 
> 
> /******************************************************************************
>  * Check if the strings we want to add, already exist in the list
>  */
> static int is_duplicated(gchar **new_values, Testrl *estrl) {
>     guint i, duplicated=0;
>     gchar **tmparray, *tmpstring;
>     gint row=0, retval=1;
> 
>     DEBUG_MSG("stringlist:is_duplicated(%p, %p)\n", new_values, estrl);
>     retval = gtk_clist_get_text(GTK_CLIST(estrl->clist), row, 0, &tmpstring);
>     while (retval == 1 && !duplicated) {
>       tmparray = g_malloc(((estrl->num_columns ? estrl->num_columns : 1)+2)*sizeof(char *));
> 		for (i = 0; i < (estrl->num_columns ? estrl->num_columns  : 1); i++) {
> 			gtk_clist_get_text(GTK_CLIST(estrl->clist), row, i, &tmpstring);
> 			tmparray[i] = g_strdup(tmpstring);
> 		}
>       tmparray[i] = NULL;
> 
>       duplicated = 1;
> 		if (estrl->num_columns == 0) {
> 			if (strcmp((gchar *) tmparray[0], new_values[0]) != 0) {
> 				duplicated = 0;
> 			}
> 		} else {
> 			for (i = 0; i < estrl->num_columns; i++) {
> 				DEBUG_MSG("old_values[%d]='%s'\n", i, tmparray[i]);
> 				DEBUG_MSG("new_values[%d]='%s'\n", i, new_values[i]);
> 				if (strcmp(tmparray[i], new_values[i]) != 0) {
> 					duplicated = 0;
> 				}
> 			}
> 		}
>       row++;
>       retval = gtk_clist_get_text(GTK_CLIST(estrl->clist), row, 0, &tmpstring);
>     }
>     DEBUG_MSG("duplicated=%d\n", duplicated);
>     return duplicated;
> }
> 
> 
> static void estrl_destroy_lcb(GtkWidget * widget, GdkEvent *event, Testrl *estrl) {
> 	window_destroy(estrl->win);
> 	g_free(estrl);
> }
> 
> static void estrl_cancel_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
> 	estrl_destroy_lcb(NULL, NULL, estrl);
> }
> 
> /***************************************************************************
>  * ok button clicked
>  *
>  * Creates a new list with the elements of the dialog and replaces the old list
>  * with the new one
>  * At the end calls the post_func passed to the creator of the dialog and
>  * destroys the dialog
> */
> static void estrl_ok_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
> 
> 	guint i;
> 	gchar *tmpstring;
> 	gchar **tmparray;
> 	gint row=0, retval=1;
> 	GList *the_list=NULL, *orig_list;
> 
> 	retval = gtk_clist_get_text(GTK_CLIST(estrl->clist), row, 0, &tmpstring);
> 	while (retval == 1) {
> 		tmparray = g_malloc(((estrl->num_columns ? estrl->num_columns : 1)+2)*sizeof(char *));
> 		for (i = 0; i < (estrl->num_columns ? estrl->num_columns  : 1); i++) {
> 			gtk_clist_get_text(GTK_CLIST(estrl->clist), row, i, &tmpstring);
> 			tmparray[i] = g_strdup(tmpstring);
> 		}
> 		tmparray[i] = NULL;
> 		if (estrl->num_columns == 0) {
> 			the_list = g_list_append(the_list, tmparray[0]);
> 			g_free(tmparray);
> 		} else {
> 			the_list = g_list_append(the_list, tmparray);
> 		}
> 		row++;
> 		retval = gtk_clist_get_text(GTK_CLIST(estrl->clist), row, 0, &tmpstring);
> 	}
> 	DEBUG_MSG("estrl_ok_clicked_lcb, going to add %p to the list\n", the_list);
> 	orig_list = *estrl->the_list;
> 	*estrl->the_list = the_list;
> 
> 	if (estrl->num_columns) {
> 	        free_arraylist(orig_list);
> 	} else {
> 		free_stringlist(orig_list);
> 	}
> 
> 	if (estrl->function)
> 		estrl->function();
> 
> 	estrl_destroy_lcb(NULL, NULL, estrl);
> }
> 
> static void estrl_select_row_lcb(GtkWidget * widget, gint row, gint column, GdkEventButton * event, Testrl *estrl){
> 	gchar *text;
> 	guint i;
> 
> 	for (i = 0; i < ( estrl->num_columns ? estrl->num_columns : 1); i++) {
> 		gtk_clist_get_text(GTK_CLIST(estrl->clist), row, i, &text);
> 		gtk_entry_set_text(GTK_ENTRY(estrl->ins_upd_entry[i]), text);
> 	}
> 	estrl->last_row = row;
> }
> 
> static void estrl_unselect_row_lcb(GtkWidget * widget, gint row, gint column, GdkEventButton * event, Testrl *estrl) {
> 	estrl->last_row = -1;
> }
> 
> static void estrl_up_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
> 	if (estrl->last_row >= 1) {
> 		gtk_clist_swap_rows(GTK_CLIST(estrl->clist), estrl->last_row, estrl->last_row - 1);
> 		estrl->last_row--;
> 	}
> }
> 
> static void estrl_down_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
> 	if (estrl->last_row < GTK_CLIST(estrl->clist)->rows - 1) {
> 		gtk_clist_swap_rows(GTK_CLIST(estrl->clist), estrl->last_row, estrl->last_row + 1);
> 		estrl->last_row++;
> 	}
> }
> 
> /******************************************************************************
>  * Avoid adding an empty element to the stringlist
>  * Avoid adding a duplicated element to the stringlist
>  */
> static void estrl_add_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
>    gchar **tmplistentry;
> 	guint i, len;
> 
>     tmplistentry = g_malloc(((estrl->num_columns ? estrl->num_columns : 1)+2)*sizeof(char *));
>     for (len = i = 0; i < (estrl->num_columns ? estrl->num_columns  : 1); i++) {
> 		tmplistentry[i] = gtk_editable_get_chars(GTK_EDITABLE(estrl->ins_upd_entry[i]),0,-1);
> 		len += strlen(tmplistentry[i]);
> 		DEBUG_MSG("tmplistentry[%d]='%s'\n", i, tmplistentry[i]);
>     }
>     tmplistentry[i]=NULL;
>     if(len) {
> 		if(!is_duplicated(tmplistentry, estrl)) {
> 			gtk_clist_append(GTK_CLIST(estrl->clist), tmplistentry);
> 			/* does this introduce a memory leak?
> 			I'm not going to look at it since we need to get rid of the clist anyway 
> 			(gtk deprecated)
> 			*/
> 		} else {
> 			g_free(tmplistentry);
> 		}
> 	} else {
> 		g_free(tmplistentry);
> 	}
> }
> 
> static void estrl_update_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
> 	guint i;
> 
> 	for (i = 0; i < (estrl->num_columns ? estrl->num_columns  : 1); i++) {
> 		gtk_clist_set_text(GTK_CLIST(estrl->clist)
> 					   , estrl->last_row, i, gtk_entry_get_text(GTK_ENTRY(estrl->ins_upd_entry[i])));
> 	}
> }
> 
> static void estrl_delete_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
> 	gtk_clist_remove(GTK_CLIST(estrl->clist), estrl->last_row);
> }
> 
> static void estrl_sort_clicked_lcb(GtkWidget * widget, Testrl *estrl) {
> 	gtk_clist_set_auto_sort(GTK_CLIST(estrl->clist), 1);
> }
> 
> /****************************************************************************
>  * Creates the dialog to edit a stringlist
>  *
>  * Parameters:
>  *  which_list      .- the stringlist which we want to edit
>  *  title           .- the title of the dialog
>  *  what_list       .- a bit more of information about the kind of strings
>  *  column_num      .- number of strings in each element of the stringlist
>  *                     equals to the number of columns in the dialog
>  *                     if column_num=0, it is assumed column_num=1
>  *  column_titles   .- title of the columns in the dialog
>  *  post_dialog_func.- function to call after editing to process the modified
>  *                     stringlist
> */
> 
> void estrl_dialog(GList **which_list, gchar *title, gint what_list
> 				, gint column_num, gchar **column_titles, void (*post_dialog_func)()) {
> 	Testrl *estrl;
> 	GList *tmplist;
> 	GtkWidget *but_var=NULL, *hbox, *scrolwin, *vbox2, *vbox;
> 	GtkWidget *table2, *but;
> 	gint i;
> 	gchar *tmplistentry[1];
> 
> 
> 	estrl = g_malloc(sizeof(Testrl));
>         if( column_num > MAX_ARRAY_LENGTH )
>               column_num = MAX_ARRAY_LENGTH;
> 	estrl->num_columns = column_num;
> 	estrl->the_list = which_list;
> 	estrl->function = post_dialog_func;
> 	estrl->win = window_full(title, GTK_WIN_POS_MOUSE, 5, G_CALLBACK(estrl_destroy_lcb), estrl, TRUE);
> 
> 	vbox = gtk_vbox_new(FALSE, 1);
> 	gtk_container_add(GTK_CONTAINER(estrl->win), vbox);
> 	gtk_widget_realize(estrl->win);
> 
> 	table2 = gtk_table_new(column_num ? column_num : 1, 3, 0);
> 	for (i = 0; i < (column_num ? column_num : 1); i++) {
> 		estrl->ins_upd_entry[i] = gtk_entry_new_with_max_length(950/(column_num ? column_num : 1));
> 		if (column_titles) {
> 			gtk_table_attach_defaults(GTK_TABLE(table2), gtk_label_new(column_titles[i]), 0, 1, i, i+1);
> 		}
> 		gtk_table_attach_defaults(GTK_TABLE(table2), estrl->ins_upd_entry[i], 1, 2, i, i+1);
> 	}
> 	gtk_box_pack_start(GTK_BOX(vbox), table2, FALSE, FALSE, 0);
> 
> 	switch (what_list) {
> 	case 1:
> 		/* files */
> 		but_var = file_but_new(estrl->ins_upd_entry[0], estrl->win, 1);
> 		break;
> 	case 2:
> 		/* color */
> #ifdef NOTYET
> 		but_var = color_but_new(estrl->ins_upd_entry[0], estrl->win);
> #endif
> 		break;
> 	case 4:
> 		/* url */
> 		but_var = file_but_new(estrl->ins_upd_entry[0], estrl->win, 0);
> 		break;
> 	case 7:
> 		/* external filters and commands */
> 
> 		break;
> 	case 8:
> 		/* syntax highlighting patterns */
> #ifdef NOTYET
> 		but_var = color_but_new(estrl->ins_upd_entry[0], estrl->win);
> #endif
> 		break;
> 
> #ifdef PARSEDTD
> 	case 9:
>                 /* doctypes */
> 		but_var = file_but_new(estrl->ins_upd_entry[1], estrl->win, 0);
> 		break;
> #endif
> 
> 	default:
> 		/* targets(5), fonts(3) meta_cb (6) */
> 		break;
> 	}
> 	if (but_var) {
> 		gtk_table_attach_defaults(GTK_TABLE(table2), but_var, 2, 3, 0, 1);
> 		GTK_WIDGET_SET_FLAGS(but_var, GTK_CAN_DEFAULT);
> 	}
> 
> 	hbox = gtk_hbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(vbox), hbox, TRUE, TRUE, 0);
> 	scrolwin = gtk_scrolled_window_new(NULL, NULL);
> 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolwin), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
> 	gtk_box_pack_start(GTK_BOX(hbox), scrolwin, TRUE, TRUE, 0);
> 	vbox2 = gtk_vbox_new(FALSE, 0);
> 	gtk_box_pack_start(GTK_BOX(hbox), vbox2, FALSE, FALSE, 0);
> 
> 	if (column_num == 0) {
> 		estrl->clist = gtk_clist_new(1);
> 	} else {
> 		if (column_titles != NULL) {
> 			estrl->clist = gtk_clist_new_with_titles(column_num, column_titles);
> 		} else {
> 			estrl->clist = gtk_clist_new(column_num);
> 		}
> 	}
> 
> 	gtk_signal_connect(GTK_OBJECT(estrl->clist), "select_row", GTK_SIGNAL_FUNC(estrl_select_row_lcb), estrl);
> 	gtk_signal_connect(GTK_OBJECT(estrl->clist), "unselect_row", GTK_SIGNAL_FUNC(estrl_unselect_row_lcb), estrl);
> 	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolwin), estrl->clist);
> 	gtk_clist_set_reorderable(GTK_CLIST(estrl->clist), TRUE);
> 	gtk_clist_freeze(GTK_CLIST(estrl->clist));
> 
> 	tmplist = g_list_first(*which_list);
> 	if (column_num == 0) {
> 		while (tmplist != NULL) {
> 			tmplistentry[0] = (gchar *) tmplist->data;
> 			gtk_clist_append(GTK_CLIST(estrl->clist), tmplistentry);
> 			tmplist = g_list_next(tmplist);
> 		}
> 	} else {
> 		while (tmplist != NULL) {
> 			gtk_clist_append(GTK_CLIST(estrl->clist), (gchar **) tmplist->data);
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	gtk_clist_thaw(GTK_CLIST(estrl->clist));
> 
> 	but = bf_generic_mnemonic_button(_(" Add "), G_CALLBACK(estrl_add_clicked_lcb), estrl);
> 	gtk_box_pack_start(GTK_BOX(vbox2),but , TRUE, TRUE, 0);
> 	but = bf_generic_mnemonic_button(_(" Update "), G_CALLBACK(estrl_update_clicked_lcb), estrl);
> 	gtk_box_pack_start(GTK_BOX(vbox2),but , TRUE, TRUE, 0);
> 	but = bf_generic_mnemonic_button(_(" Delete "), G_CALLBACK(estrl_delete_clicked_lcb), estrl);
> 	gtk_box_pack_start(GTK_BOX(vbox2),but , TRUE, TRUE, 0);
> 	but = bf_generic_mnemonic_button(_(" Up "), G_CALLBACK(estrl_up_clicked_lcb), estrl);
> 	gtk_box_pack_start(GTK_BOX(vbox2),but , TRUE, TRUE, 0);
> 	but = bf_generic_mnemonic_button(_(" Down "), G_CALLBACK(estrl_down_clicked_lcb), estrl);
> 	gtk_box_pack_start(GTK_BOX(vbox2),but , TRUE, TRUE, 0);
> 	but = bf_generic_mnemonic_button(_(" Sort "), G_CALLBACK(estrl_sort_clicked_lcb), estrl);
> 	gtk_box_pack_start(GTK_BOX(vbox2),but , TRUE, TRUE, 0);
> 
> 	hbox = gtk_hbutton_box_new();
> 	gtk_hbutton_box_set_layout_default(GTK_BUTTONBOX_END);
> 	gtk_button_box_set_spacing(GTK_BUTTON_BOX(hbox), 1);
> 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
> 
> 	but = bf_stock_ok_button(G_CALLBACK(estrl_ok_clicked_lcb), estrl);
> 	gtk_box_pack_start(GTK_BOX(hbox), but, TRUE, TRUE, 0);
> 	gtk_window_set_default(GTK_WINDOW(estrl->win), but);
> 
> 	but = bf_stock_cancel_button(G_CALLBACK(estrl_cancel_clicked_lcb), estrl);
> 	gtk_box_pack_start(GTK_BOX(hbox), but, TRUE, TRUE, 0);
> 
> 	/* Adjust the size and position of the dialog */
> 	{
> 	  int wx=100, optx;
> 	  optx = gtk_clist_optimal_column_width(GTK_CLIST(estrl->clist),0);
> 	  if( optx < 100 )
> 	    optx = 100;
> 	  wx += optx + gtk_clist_optimal_column_width(GTK_CLIST(estrl->clist), 1);
> 	  if( wx < gdk_screen_width() ) {
> 	    gtk_clist_set_column_width(GTK_CLIST(estrl->clist), 0, optx );
> 	    gtk_widget_set_size_request(GTK_WIDGET(estrl->win), wx, 400);
> 	    gtk_widget_set_uposition(estrl->win, 
> 				     (gdk_screen_width()-wx)/2,
> 				     (gdk_screen_height() - 400)/2);
> 	  }
> 	}
> 	gtk_widget_show_all(estrl->win);
> }
> #endif /* USE_ESTRL_DIALOG */
> 
> 
> /************************************************************************/
> 
> #ifdef DEBUG
> void debug_array(gchar **array) {
> 	gint count=0;
> 	gchar **tmpchar=array;
> 	
> 	if (!tmpchar) {
> 		DEBUG_MSG("debug_array, no array!?!?\n");
> 	}
> 
> 	while (*tmpchar != NULL) {
> 		count++;
> 		DEBUG_MSG("debug_array, tmpchar(%p), count=%d, contains(%p) %s\n", tmpchar, count, *tmpchar, *tmpchar);
> 		tmpchar++;
> 	}
> }
> #endif
> 
> /**
>  * count_array:
>  * @array: #gchar** with the NULL terminated array to count
>  *
>  * counts the number of entries in a NULL terminated array
>  *
>  * Return value: #gint with number of entries
>  */
> gint count_array(gchar **array) {
> 	gint count=0;
> 	gchar **tmpchar=array;
> 	
> 	if (!tmpchar) {
> 		DEBUG_MSG("count_array, no array!?!?\n");
> 		return 0;
> 	}
> 
> 	while (*tmpchar != NULL) {
> 		count++;
> 		tmpchar++;
> 	}
> 	return count;
> }
> 
> /**
>  * array_to_string:
>  * @array: #gchar** with NULL terminated array
>  * @delimiter: #gchar with the delimiter character
>  *
>  * Converts a NULL terminated array to a string with a delimiter
>  * between the entries, and some characters backslash escaped
>  * like \t, \n, \\ and the delimiter. In Bluefish the : is the most 
>  * used delimiter
>  *
>  * Return value: #gchar* newly allocated string
>  */
> gchar *array_to_string(gchar **array) {
> 	if (array) {
> 		gchar **tmp, *escaped1, *finalstring;
> 		gint newsize=1;
> 		DEBUG_MSG("array_to_string, started\n");
> 		finalstring = g_malloc0(newsize);
> 		tmp = array;
> 		while(*tmp) {
> 			DEBUG_MSG("array_to_string, *tmp = %s\n", *tmp);
> 			escaped1 = escape_string(*tmp, TRUE);
> 			newsize += strlen(escaped1)+1;
> 			finalstring = g_realloc(finalstring, newsize);
> 			strcat(finalstring, escaped1);
> 			finalstring[newsize-2] = ':';
> 			finalstring[newsize-1] = '\0';
> 			g_free(escaped1);
> 			tmp++;
> 		}	
> 		DEBUG_MSG("array_to_string, finalstring = %s\n", finalstring);
> 		return finalstring;
> 	} else {
> #ifdef DEBUG
> 		g_print("array_to_string, array=NULL !!!\n");
> 		exit(135);
> #else
> 		return g_strdup("");
> #endif
> 	}
> }
> 
> #define ARRAYBLOCKSIZE 6
> #define BUFBLOCKSIZE 60
> /**
>  * string_to_array:
>  * @string: #gchar* with the string to convert
>  * @delimiter: #gchar with the delimiter character
>  *
>  * breaks the string apart into a NULL terminated array
>  * using the delimiter character. \t, \\ and \n are also unescaped
>  * to their original characters
>  *
>  * Return value: #gchar** newly allocated NULL terminated array
>  */
> gchar **string_to_array(gchar *string) {
> 	gchar **array;
> 	gchar *tmpchar, *tmpchar2;
> 	gchar *newstring;
> 	gint count=0;
> 	gint newstringsize;
> 	gint arraycount=0, arraysize;
> 
> 	newstringsize = BUFBLOCKSIZE;
> 	newstring = g_malloc(newstringsize * sizeof(char));
> 	
> 	arraysize = ARRAYBLOCKSIZE;
> 	array = g_malloc(arraysize * sizeof(char *));
> 	DEBUG_MSG("string_to_array, started, array=%p\n", array);	
> 	
> 	tmpchar = string;
> 	while (*tmpchar != '\0') {
> 		DEBUG_MSG("string_to_array, count=%d, newstring(%p)\n", count, newstring);
> 		if (*tmpchar == '\\') {
> 			tmpchar2 = tmpchar+1;
> 			switch (*tmpchar2) {
> 			case '\0':
> 				newstring[count] = '\\';
> 			break;
> 			case '\\':
> 				newstring[count] = '\\';
> 				tmpchar++;
> 			break;
> 			case 'n':
> 				newstring[count] = '\n';
> 				tmpchar++;
> 			break;
> 			case 't':
> 				newstring[count] = '\t';
> 				tmpchar++;
> 			break;
> 			case ':':
> 				newstring[count] = ':';
> 				tmpchar++;
> 			break;
> 			default:
> 				DEBUG_MSG("string_to_array, weird, an unescaped backslash ?\n");
> 				newstring[count] = '\\';
> 			break;
> 			}
> 		} else if (*tmpchar == ':') {
> 			newstring[count] = '\0';  /* end of the current newstring */
> 			DEBUG_MSG("string_to_array, newstring(%p)=%s\n", newstring, newstring);
> 			array[arraycount] = g_strdup(newstring);
> 			DEBUG_MSG("string_to_array, found delimiter, arraycount=%d, result(%p)=%s\n",arraycount, array[arraycount], array[arraycount]);
> 			arraycount++;
> 			if (arraycount == arraysize-2) { /* we need 1 spare entry in the array */
> 				arraysize += ARRAYBLOCKSIZE;  /* and arraysize starts at 1, arraycount at 0 */
> 				DEBUG_MSG("string_to_array, arraycount=%d, about to increase arraysize to %d, sizeof(array(%p))=%d\n", arraycount, arraysize, array, sizeof(&array));
> 				array = g_realloc(array, arraysize * sizeof(char *));
> 				DEBUG_MSG("string_to_array, arraysize=%d, array(%p), sizeof(array)=%d\n", arraysize, array, sizeof(&array));
> 			}
> 			count = -1;
> 		} else {
> 			newstring[count] = *tmpchar;
> 		}
> 		tmpchar++;
> 		count++;
> 		if (count == newstringsize-2) {
> 			newstringsize += BUFBLOCKSIZE;
> 			DEBUG_MSG("string_to_array, about to increase newstring(%p) to %d bytes\n", newstring, newstringsize);
> 			newstring = g_realloc(newstring, newstringsize * sizeof(char));
> 			DEBUG_MSG("string_to_array, newstringsize=%d, sizeof(newstring(%p))=%d\n", newstringsize, newstring, sizeof(newstring));
> 		}
> 	}
> 	
> 	if (count > 0) {
> 		newstring[count] = '\0';
> 		array[arraycount] = g_strdup(newstring);
> 		DEBUG_MSG("string_to_array, last array entry, arraycount=%d, result(%p)=%s\n",arraycount, array[arraycount],array[arraycount]);
> 	} else {
> 		array[arraycount] = NULL;
> 	}
> 	array[arraycount+1] = NULL; /* since we have 1 spare entry in the array this is safe to do*/
> 	DEBUG_MSG("string_to_array, returning %p\n", array);
> 	g_free(newstring);
> 	return array;
> }		
> 
> /**
>  * array_from_arglist:
>  * @...: #gchar* with the first string, NULL terminated
>  *
>  * builds a NULL terminated array from the argumentlist to this function
>  *
>  * Return value: #gchar** with the array
>  */
> gchar **array_from_arglist(const gchar *string1, ...) {
> 	gint numargs=1;
> 	va_list args;
> 	gchar *s;
> 	gchar **retval, **index;
> 
> 	va_start (args, string1);
> 	s = va_arg (args, gchar*);
> 	while (s) {
> 		numargs++;
> 		s = va_arg (args, gchar*);
> 	}
> 	va_end (args);
> 	DEBUG_MSG("array_from_arglist, numargs=%d\n", numargs);
> 
> 	index = retval = g_new(gchar *, numargs + 1);
> 	*index = g_strdup(string1);
> 
> 	va_start (args, string1);
> 	s = va_arg (args, gchar*);
> 	while (s) {
> 		index++;
> 		*index = g_strdup(s);
> 		s = va_arg (args, gchar*);
> 	}
> 	va_end (args);
> 	index++;
> 	*index = NULL;
> 	return retval;
> }
> /**
>  * array_from_arglist:
>  * @allocate_strings: #gboolean if the strings should be newly allocated
>  * @...: #gchar* with the first string, NULL terminated
>  *
>  * builds a GList with strings (a stringlist), copied by reference or by content
>  *
>  * Return value: GList *
>  */
> GList *list_from_arglist(gboolean allocate_strings, ...) {
> 	GList *retval=NULL;
> 	va_list args;
> 	gchar *s;
> 	va_start(args, allocate_strings);
> 	s = va_arg(args, gchar*);
> 	while (s) {
> 		retval = g_list_append(retval, s);
> 		s = va_arg (args, gchar*);
> 	}
> 	va_end (args);
> 	return retval;
> }
> 
> GList *duplicate_stringlist(GList *list, gint dup_data) {
> 	GList *retlist=NULL;
> 	if (list) {
> 		GList *tmplist;
> 		tmplist = g_list_first(list);
> 		while (tmplist) {
> 			if (tmplist->data) {
> 				gchar *data;
> 				if (dup_data) {
> 					data = g_strdup((gchar *)tmplist->data);
> 				} else {
> 					data = (gchar *)tmplist->data;
> 				}
> 				retlist = g_list_append(retlist, data);
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	return retlist;
> }
> 
> gint free_stringlist(GList * which_list)
> {
> 	GList *tmplist;
> 
> 	DEBUG_MSG("free_stringlist, started\n");
> 
> 	tmplist = g_list_first(which_list);
> 	while (tmplist != NULL) {
> 		DEBUG_MSG("free_stringlist, tmplist->data(%p)\n", tmplist->data);
> 		g_free(tmplist->data);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	DEBUG_MSG("free_stringlist, strings free-ed, about to free list itself\n");
> 	g_list_free(which_list);
> 	which_list = NULL;
> 	return 1;
> }
> 
> gint free_arraylist(GList * which_list)
> {
> 	GList *tmplist;
> #ifdef DEBUGGING
> 	gchar **tmpchar;
> #endif
> 	DEBUG_MSG("free_arraylist, started\n");
> 
> 	tmplist = g_list_first(which_list);
> 	while (tmplist != NULL) {
> 
> #ifdef DEBUGGING
> 		DEBUG_MSG("free_arraylist, starting list %p with data %p\n", tmplist, tmplist->data);
> 		tmpchar = (gchar **)tmplist->data;
> 		while (*tmpchar) {
> 			DEBUG_MSG("free_arraylist, freeing %p\n", *tmpchar);
> 			DEBUG_MSG("free_arraylist, containing %s\n", *tmpchar);
> 			g_free(*tmpchar);
> 			tmpchar++;
> 		}
> 		DEBUG_MSG("free_arraylist, content freed\n");
> 		g_free((gchar **)tmplist->data);
> 		DEBUG_MSG("free_arraylist, array freed\n");
> #else
> 		g_strfreev((gchar **)tmplist->data);
> #endif
> 		tmplist = g_list_next(tmplist);
> 	}
> 	g_list_free(which_list);
> 	which_list = NULL;
> 	return 1;
> }
> 
> gchar **duplicate_stringarray(gchar **array) {
> 	gchar **newchar;
> 	gint i;
> 
> 	newchar = g_malloc0((count_array(array)+1)*sizeof(gchar *));
> 	for (i=0; array[i] != NULL ; i++) {
> 		newchar[i] = g_strdup(array[i]);
> 	}
> 	return newchar;
> }
> 
> GList *duplicate_arraylist(GList *arraylist) {
> 	GList *tmplist;
> 	GList *newlist=NULL;
> 
> 	tmplist = g_list_first(arraylist);
> 	while (tmplist != NULL) {
> 		newlist = g_list_append(newlist, duplicate_stringarray((gchar **)tmplist->data));
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return newlist;
> }
> 
> 
> /*****************************************************************************
>  * gets a stringlist from a file
>  */
> GList *get_list(const gchar * filename, GList * which_list, gboolean is_arraylist) {
> 	DEBUG_MSG("get_stringlist, started with filename=%s\n", filename);
> 	if (filename == NULL) {
> 		return NULL;
> 	}
> 	if (file_exists_and_readable(filename)) {
> 		FILE *fd;
> 		gchar *tmpbuf;
> 		DEBUG_MSG("get_stringlist, opening %s\n", filename);
> 		fd = fopen(filename, "r");
> 		if (fd == NULL) {
> 			return NULL;
> 		}
> 		tmpbuf = g_malloc(STRING_MAX_SIZE);
> 		while (fgets(tmpbuf, STRING_MAX_SIZE, fd) != NULL) {
> 			gchar *tempstr;
> 			tmpbuf = trunc_on_char(tmpbuf, '\n');
> 			tempstr = g_strdup(tmpbuf);
> 			if (is_arraylist) {
> 				gchar **temparr = string_to_array(tempstr);
> 				which_list = g_list_append(which_list, temparr);
> 				g_free(tempstr);
> 			} else {
> 				DEBUG_MSG("get_list, adding string \"%s\" to the stringlist=%p\n", tempstr, which_list);
> 				which_list = g_list_append(which_list, tempstr);
> 			}
> 		}
> 		fclose(fd);
> 		g_free(tmpbuf);
> 	}
> 	return which_list;
> }
> #ifdef __GNUC__
> __inline__ 
> #endif
> GList *get_stringlist(const gchar * filename, GList * which_list) {
> 	return get_list(filename,which_list,FALSE);
> }
> 
> /**
>  * put_stringlist_limited:
>  * @filename: #gchar* with the filename to store the list
>  * @which_list: #GList* with the list to store
>  * @maxentries: #gint only the LAST maxentries of the list will be stored
>  *
>  * stores the LAST maxentries entries of list which_list in file filename
>  * if maxentries is 0 all entries will be stored
>  *
>  * Return value: #gboolean TRUE on success, FALSE on failure
>  */
> gboolean put_stringlist_limited(gchar * filename, GList * which_list, gint maxentries) {
> 	FILE *fd;
> 	GList *tmplist;
> 
> 	DEBUG_MSG("put_stringlist_limited, started with filename=%s\n", filename);
> 	{
> 		gchar *backupfilename = g_strconcat(filename, main_v->props.backup_filestring,NULL);
> 		file_copy(filename, backupfilename);
> 		g_free(backupfilename);
> 	}
> 
> 	DEBUG_MSG("put_stringlist_limited, opening %s for saving list(%p)\n", filename, which_list);
> 	fd = fopen(filename, "w");
> 	if (fd == NULL) {
> 		return FALSE;
> 	}
> 	if (maxentries > 0) {
> 		gint count;
> 		count = g_list_length(which_list) - maxentries;
> 		tmplist = g_list_nth(which_list, (count<0) ? 0 : count);
> 	} else {
> 		tmplist = g_list_first(which_list);
> 	}
> 	while (tmplist) {
> 		gchar *tmpstr = g_strndup((char *) tmplist->data, STRING_MAX_SIZE - 1);
> 		DEBUG_MSG("put_stringlist_limited, tmplist(%p), adding string(%p)=%s (strlen=%d)the file\n", tmplist, tmpstr, tmpstr, strlen(tmpstr));
> 		fputs(tmpstr, fd);
> 		g_free(tmpstr);
> 		fputs("\n", fd);
> 		tmplist = g_list_next(tmplist);
> 	}
> 	fclose(fd);
> 	DEBUG_MSG("put_stringlist_limited, finished, filedescriptor closed\n");
> 	return TRUE;
> }
> 
> gboolean put_stringlist(gchar * filename, GList * which_list) {
> 	return put_stringlist_limited(filename,which_list, -1);
> }
> 
> GList *remove_from_stringlist(GList *which_list, const gchar * string) {
> 	if (string && strlen(string) ) {
> 		GList *tmplist = g_list_first(which_list);
> 		while (tmplist) {
> 			if (strcmp((gchar *) tmplist->data, string) == 0) {
> 				DEBUG_MSG("remove_from_stringlist, removing '%s' (%p)\n", (gchar *)tmplist->data, tmplist->data);
> 				g_free(tmplist->data);
> 				return g_list_remove(which_list, tmplist->data);
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 	}
> 	return which_list;
> }
> 
> static void unlink_before(GList *tmplist) {
> 	GList *prev = tmplist->prev;
> 	if (prev) {
> 		prev->next = NULL;
> 	}
> 	tmplist->prev = NULL;
> }
> 
> GList *limit_stringlist(GList *which_list, gint num_entries, gboolean keep_end) {
> 	GList *retlist, *freelist;
> 	if (keep_end) {
> 		gint len;
> 		freelist = g_list_first(which_list);
> 		len = g_list_length(freelist);
> 		if (len <= num_entries) return which_list;
> 		retlist = g_list_nth(freelist, len - num_entries);
> 		unlink_before(retlist);
> 	} else {
> 		retlist = g_list_first(which_list);
> 		freelist = g_list_nth(retlist, num_entries);
> 		if (freelist) unlink_before(freelist);
> 	}
> 	if (freelist) free_stringlist(freelist);
> 	return retlist;
> }
> 
> /**
>  * add_to_history_stringlist:
>  * @which_list: #GList* the list to add to
>  * @string: #const gchar* with the string to add
>  * @recent_on_top: #gboolean, TRUE if the most recent entry is the one on top
>  * @move_if_exists: #gboolean, if TRUE do move existing entries to the most recent part
>  *
>  * adds string to the stringlist which_list
>  *
>  * if string exists in this list already and move_if_exists is TRUE, 
>  * it will be moved to the most recent part of the list (which is the 
>  * end or the beginning based on the value of recent_on_top
>  *
>  * Return value: GList* with the modified list
>  */
> GList *add_to_history_stringlist(GList *which_list, const gchar *string, gboolean recent_on_top, gboolean move_if_exists) {
> 	if (string && strlen(string) ) {
> 		GList *tmplist = g_list_first(which_list);
> 		while (tmplist) {
> 			if (strcmp((gchar *) tmplist->data, string) == 0) {
> 				/* move this entry to the end */
> 				if (move_if_exists) {
> 					DEBUG_MSG("add_to_history_stringlist, entry %s exists, moving!\n", string);
> 					which_list = g_list_remove_link(which_list, tmplist);
> 					if (recent_on_top) {
> 						return g_list_concat(tmplist, which_list);
> 					} else {
> 						return g_list_concat(which_list, tmplist);
> 					}
> 				} else {
> 					return which_list;
> 				}
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		/* if we arrive here the string was not yet in the list */
> 		DEBUG_MSG("add_to_history_stringlist, adding new entry %s\n",string);
> 		if (recent_on_top) {
> 			which_list = g_list_prepend(which_list, g_strdup(string));
> 		} else {
> 			which_list = g_list_append(which_list, g_strdup(string));
> 		}
> 	}
> 	return which_list;
> }
> 
> /**
>  * add_to_stringlist:
>  * @which_list: a #GList * to add to
>  * @string: a #const gchar * item you want to add to the list
>  * 
>  * this function will check if a string with same content exists already
>  * and if not it will add it to the list, it returns the new list pointer
>  * 
>  * Return value: the new GList *
>  **/
> GList *add_to_stringlist(GList * which_list, const gchar * string) {
> 	if (string && strlen(string) ) {
> 		GList *tmplist = g_list_first(which_list);
> 		while (tmplist) {
> 			if (strcmp((gchar *) tmplist->data, string) == 0) {
> 				DEBUG_MSG("add_to_stringlist, strings are the same, don't add!!\n");
> 				return which_list;
> 			}
> 			tmplist = g_list_next(tmplist);
> 		}
> 		/* if we arrive here the string was not yet in the list */
> 		which_list = g_list_append(which_list, g_strdup(string));
> 	}
> 	return which_list;
> }
> /**
>  * stringlist_to_string:
>  * @stringlist: a #GList * to convert
>  * @delimiter: a #const gchar * item with the delimiter
>  * 
>  * this function will convert a stringlist (GList that contains 
>  * only \0 terminated gchar* elements) to a string, putting the 
>  * delimiter inbetween all elements;
>  * 
>  * Return value: the gchar *
>  **/
> gchar *stringlist_to_string(GList *stringlist, gchar *delimiter) {
> 	gchar *string, *tmp;
> 	GList *tmplist;
> 	string = g_strdup("");
> 	tmp = string;
> 	tmplist = g_list_first(stringlist);
> 	while (tmplist) {
> 		string = g_strconcat(tmp, (gchar *) tmplist->data, delimiter, NULL);
> 		g_free(tmp);
> 		tmp = string;
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return string;
> }
> /**
>  * array_n_strings_identical:
>  * @array1: #gchar**
>  * @array2: #gchar**
>  * @case_sensitive: #gboolean 
>  * @testlevel: #gint
>  *
>  * tests the first testlevel strings in the arrays if they are identical
>  * returns the first strcmp() value that is not 0, or 0 if all
>  * strings up to testlevel are identical.
>  *
>  * if BOTH array end before testlevel is reached, 0 is returned
>  * if ONE array ends before the other, -1 or 1 is returned
>  *
>  * Return value: #gint
>  */
> gint array_n_strings_identical(gchar **array1, gchar **array2, gboolean case_sensitive, gint testlevel) {
> 	gint i=0, res=0;
> 	while (i<testlevel && res==0) {
> 		/*  array1[i]==array2[i] will only happen when they are both NULL	*/
> 		if (array1[i] == NULL || array2[i] == NULL) {
> 			/* NULL - NULL = 0
> 			 * NULL - ptr = negative
> 			 * ptr - NULL = positive */
> 			return (gint)(array1[i] - array2[i]);
> 		} else if (case_sensitive) {
> 			res = strcmp(array1[i],array2[i]);
> 		} else /*if (!case_sensitive)*/ {
> 			res = strcasecmp(array1[i],array2[i]);
> 		}
> 		if (res !=0) return res;
> 		i++;
> 	}
> 	return res;
> }
> /**
>  * arraylist_delete_identical:
>  * @thelist: #GList*
>  * @compare: #gchar**
>  * @testlevel: #gint
>  * @case_sensitive: #gboolean
>  *
>  * Deletes all arrays from 'arraylist' that are, up to testlevel, identical to array 'compare'
>  *
>  * Return value: the new list
>  */
> GList *arraylist_delete_identical(GList *thelist, gchar **compare, gint testlevel, gboolean case_sensitive) {
> 	GList *tmplist = g_list_first(thelist);
> 	while (tmplist) {
> 		GList *nextlist = g_list_next(tmplist);
> 		gchar **tmparr = tmplist->data;
> 		if (array_n_strings_identical(compare, tmparr, case_sensitive, testlevel)==0) {
> 			DEBUG_MSG("arraylist_delete_identical, %s and %s are identical, will delete %p from list\n",tmparr[0],compare[0], tmplist);
> 			thelist = g_list_delete_link(thelist, tmplist);
> 			DEBUG_MSG("arraylist_delete_identical, free array %p (%s)\n",tmparr,tmparr[0]);
> 			g_strfreev(tmparr);
> 		}
> 		tmplist = nextlist;
> 	}
> 	return thelist;
> }
> 
> /**
>  * arraylist_append_identical_from_list:
>  * @thelist: #GList*
>  * @source: #GList*
>  * @compare: #gchar**
>  * @testlevel: #gint
>  * @case_sensitive: #gboolean
>  *
>  * compares every array in 'source' with 'compare', and if it is identical up to 'testlevel', it will
>  * add the array to 'thelist'
>  *
>  * Return value: the new arraylist
>  */
> GList *arraylist_append_identical_from_list(GList *thelist, GList *source, gchar **compare, gint testlevel, gboolean case_sensitive) {
> 	GList *tmplist = g_list_first(source);
> 	while (tmplist) {
> 		gchar **tmparr = tmplist->data;
> 		if (array_n_strings_identical(compare, tmparr, case_sensitive, testlevel)==0) {
> 			thelist = g_list_append(thelist, duplicate_stringarray(tmparr));
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return thelist;
> }
> 
> /**
>  * arraylist_append_identical_from_file:
>  * @thelist: #GList*
>  * @sourcefilename: #const gchar*
>  * @compare: #gchar**
>  * @testlevel: #gint
>  * @case_sensitive: #gboolean
>  *
>  * compares every array read from 'sourcefilename' with 'compare', and if it is identical up to 'testlevel', it will
>  * add the array to 'thelist'
>  *
>  * Return value: the new arraylist
>  */
> GList *arraylist_append_identical_from_file(GList *thelist, const gchar *sourcefilename, gchar **compare, gint testlevel, gboolean case_sensitive) {
> 	GList *sourcelist = get_list(sourcefilename,NULL,TRUE);
> 	thelist = arraylist_append_identical_from_list(thelist, sourcelist, compare, testlevel, case_sensitive);
> 	free_arraylist(sourcelist);
> 	return thelist;
> }
> 
> /**
>  * arraylist_value_exists:
>  * @arraylist: #GList*
>  * @value: #gchar**
>  * @testlevel: #gint
>  * @case_sensitive: #gboolean whether the test should be case sensitive
>  *
>  * tests for the occurence of an array with identical content as value
>  * in arraylist. It will only test the first testlevel strings in the array
>  * so if you want the test to check for a 100% identical array that number 
>  * should be high (9999 or so)
>  *
>  * Return value: #gboolean 
>  */
> gboolean arraylist_value_exists(GList *arraylist, gchar **value, gint testlevel, gboolean case_sensitive) {
> 	GList *tmplist = g_list_first(arraylist);
> 	while (tmplist) {
> 		gchar **tmparr = tmplist->data;
> 		if (array_n_strings_identical(value, tmparr, case_sensitive, testlevel)==0) {
> 			return TRUE;
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return FALSE;
> }
> /**
>  * arraylist_load_new_identifiers_from_list:
>  * @mylist: #GList*
>  * @fromlist: #GList*
>  * @uniquelevel: #gint
>  *
>  * compares every entry in fromlist 
>  * with all entries in list mylist. Comparision is done uniquelevel deep
>  * by function arraylist_value_exists()
>  * those arrays that do _not_ match are appended to mylist which is returned
>  * at the end of the function
>  *
>  * Return value: #GList*
>  */
> GList *arraylist_load_new_identifiers_from_list(GList *mylist, GList *deflist, gint uniquelevel) {
> 	GList *tmplist = g_list_first(deflist);
> 	while (tmplist) {
> 		gchar **tmparr = tmplist->data;
> 		if (count_array(tmparr) >= uniquelevel) {
> 			if (!arraylist_value_exists(mylist, tmparr, uniquelevel, TRUE)) {
> 				DEBUG_MSG("arraylist_load_new_identifiers, adding %s to thelist\n",tmparr[0]);
> 				mylist = g_list_append(mylist, duplicate_stringarray(tmparr));
> 			}
> 		}
> 		tmplist = g_list_next(tmplist);
> 	}
> 	return mylist;
> }
> /**
>  * arraylist_load_new_identifiers_from_file:
>  * @mylist: #GList*
>  * @fromfilename: #gchar*
>  * @uniquelevel: #gint
>  *
>  * loads an arraylist from fromfilename and compares every entry 
>  * with all entries in list mylist. Comparision is done uniquelevel deep
>  * by function arraylist_value_exists()
>  * those arrays that do _not_ match are appended to mylist which is returned
>  * at the end of the function
>  *
>  * Return value: #GList*
>  */
> GList *arraylist_load_new_identifiers_from_file(GList *mylist, const gchar *fromfilename, gint uniquelevel) {
> 	GList *deflist = get_list(fromfilename,NULL,TRUE);
> 	mylist = arraylist_load_new_identifiers_from_list(mylist, deflist, uniquelevel);
> 	free_arraylist(deflist);
> 	return mylist;	
> }
